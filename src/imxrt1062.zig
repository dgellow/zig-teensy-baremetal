// dgellow: file generated by microzig/tools/regz:
//  ./zig-out/bin/regz ../../../MIMXRT1062.svd --format svd --output_path ../../../src/imxrt1062.zig

// dgellow: added to workaround the microzig reference
const microzig = @import("_microzig.zig");
// dgellow: added to workaround the mmio import
const mmio = @import("_mmio.zig");

pub const Interrupt = struct {
    name: [:0]const u8,
    index: i16,
    description: ?[:0]const u8,
};

pub const devices = struct {
    /// MIMXRT1062DVL6A
    pub const MIMXRT1062 = struct {
        pub const properties = struct {
            pub const @"cpu.endian" = "little";
            pub const @"cpu.fpuPresent" = "true";
            pub const @"cpu.mpuPresent" = "true";
            pub const @"cpu.name" = "CM7";
            pub const @"cpu.nvicPrioBits" = "4";
            pub const @"cpu.revision" = "r0p1";
            pub const @"cpu.vendorSystickConfig" = "false";
            pub const @"cpu.vtorPresent" = "true";
            pub const license =
                \\
                \\Copyright 2016-2019 NXP
                \\All rights reserved.
                \\
                \\SPDX-License-Identifier: BSD-3-Clause
                \\
            ;
        };

        pub const interrupts: []const Interrupt = &.{
            .{ .name = "NMI", .index = -14, .description = null },
            .{ .name = "HardFault", .index = -13, .description = null },
            .{ .name = "MemManageFault", .index = -12, .description = null },
            .{ .name = "BusFault", .index = -11, .description = null },
            .{ .name = "UsageFault", .index = -10, .description = null },
            .{ .name = "SVCall", .index = -5, .description = null },
            .{ .name = "PendSV", .index = -2, .description = null },
            .{ .name = "SysTick", .index = -1, .description = null },
            .{ .name = "DMA0_DMA16", .index = 0, .description = null },
            .{ .name = "DMA1_DMA17", .index = 1, .description = null },
            .{ .name = "DMA2_DMA18", .index = 2, .description = null },
            .{ .name = "DMA3_DMA19", .index = 3, .description = null },
            .{ .name = "DMA4_DMA20", .index = 4, .description = null },
            .{ .name = "DMA5_DMA21", .index = 5, .description = null },
            .{ .name = "DMA6_DMA22", .index = 6, .description = null },
            .{ .name = "DMA7_DMA23", .index = 7, .description = null },
            .{ .name = "DMA8_DMA24", .index = 8, .description = null },
            .{ .name = "DMA9_DMA25", .index = 9, .description = null },
            .{ .name = "DMA10_DMA26", .index = 10, .description = null },
            .{ .name = "DMA11_DMA27", .index = 11, .description = null },
            .{ .name = "DMA12_DMA28", .index = 12, .description = null },
            .{ .name = "DMA13_DMA29", .index = 13, .description = null },
            .{ .name = "DMA14_DMA30", .index = 14, .description = null },
            .{ .name = "DMA15_DMA31", .index = 15, .description = null },
            .{ .name = "DMA_ERROR", .index = 16, .description = null },
            .{ .name = "CTI0_ERROR", .index = 17, .description = null },
            .{ .name = "CTI1_ERROR", .index = 18, .description = null },
            .{ .name = "CORE", .index = 19, .description = null },
            .{ .name = "LPUART1", .index = 20, .description = null },
            .{ .name = "LPUART2", .index = 21, .description = null },
            .{ .name = "LPUART3", .index = 22, .description = null },
            .{ .name = "LPUART4", .index = 23, .description = null },
            .{ .name = "LPUART5", .index = 24, .description = null },
            .{ .name = "LPUART6", .index = 25, .description = null },
            .{ .name = "LPUART7", .index = 26, .description = null },
            .{ .name = "LPUART8", .index = 27, .description = null },
            .{ .name = "LPI2C1", .index = 28, .description = null },
            .{ .name = "LPI2C2", .index = 29, .description = null },
            .{ .name = "LPI2C3", .index = 30, .description = null },
            .{ .name = "LPI2C4", .index = 31, .description = null },
            .{ .name = "LPSPI1", .index = 32, .description = null },
            .{ .name = "LPSPI2", .index = 33, .description = null },
            .{ .name = "LPSPI3", .index = 34, .description = null },
            .{ .name = "LPSPI4", .index = 35, .description = null },
            .{ .name = "CAN1", .index = 36, .description = null },
            .{ .name = "CAN2", .index = 37, .description = null },
            .{ .name = "FLEXRAM", .index = 38, .description = null },
            .{ .name = "KPP", .index = 39, .description = null },
            .{ .name = "TSC_DIG", .index = 40, .description = null },
            .{ .name = "GPR_IRQ", .index = 41, .description = null },
            .{ .name = "LCDIF", .index = 42, .description = null },
            .{ .name = "CSI", .index = 43, .description = null },
            .{ .name = "PXP", .index = 44, .description = null },
            .{ .name = "WDOG2", .index = 45, .description = null },
            .{ .name = "SNVS_HP_WRAPPER", .index = 46, .description = null },
            .{ .name = "SNVS_HP_WRAPPER_TZ", .index = 47, .description = null },
            .{ .name = "SNVS_LP_WRAPPER", .index = 48, .description = null },
            .{ .name = "CSU", .index = 49, .description = null },
            .{ .name = "DCP", .index = 50, .description = null },
            .{ .name = "DCP_VMI", .index = 51, .description = null },
            .{ .name = "Reserved68", .index = 52, .description = null },
            .{ .name = "TRNG", .index = 53, .description = null },
            .{ .name = "SJC", .index = 54, .description = null },
            .{ .name = "BEE", .index = 55, .description = null },
            .{ .name = "SAI1", .index = 56, .description = null },
            .{ .name = "SAI2", .index = 57, .description = null },
            .{ .name = "SAI3_RX", .index = 58, .description = null },
            .{ .name = "SAI3_TX", .index = 59, .description = null },
            .{ .name = "SPDIF", .index = 60, .description = null },
            .{ .name = "PMU_EVENT", .index = 61, .description = null },
            .{ .name = "Reserved78", .index = 62, .description = null },
            .{ .name = "TEMP_LOW_HIGH", .index = 63, .description = null },
            .{ .name = "TEMP_PANIC", .index = 64, .description = null },
            .{ .name = "USB_PHY1", .index = 65, .description = null },
            .{ .name = "USB_PHY2", .index = 66, .description = null },
            .{ .name = "ADC1", .index = 67, .description = null },
            .{ .name = "ADC2", .index = 68, .description = null },
            .{ .name = "DCDC", .index = 69, .description = null },
            .{ .name = "Reserved86", .index = 70, .description = null },
            .{ .name = "Reserved87", .index = 71, .description = null },
            .{ .name = "GPIO1_INT0", .index = 72, .description = null },
            .{ .name = "GPIO1_INT1", .index = 73, .description = null },
            .{ .name = "GPIO1_INT2", .index = 74, .description = null },
            .{ .name = "GPIO1_INT3", .index = 75, .description = null },
            .{ .name = "GPIO1_INT4", .index = 76, .description = null },
            .{ .name = "GPIO1_INT5", .index = 77, .description = null },
            .{ .name = "GPIO1_INT6", .index = 78, .description = null },
            .{ .name = "GPIO1_INT7", .index = 79, .description = null },
            .{ .name = "GPIO1_Combined_0_15", .index = 80, .description = null },
            .{ .name = "GPIO1_Combined_16_31", .index = 81, .description = null },
            .{ .name = "GPIO2_Combined_0_15", .index = 82, .description = null },
            .{ .name = "GPIO2_Combined_16_31", .index = 83, .description = null },
            .{ .name = "GPIO3_Combined_0_15", .index = 84, .description = null },
            .{ .name = "GPIO3_Combined_16_31", .index = 85, .description = null },
            .{ .name = "GPIO4_Combined_0_15", .index = 86, .description = null },
            .{ .name = "GPIO4_Combined_16_31", .index = 87, .description = null },
            .{ .name = "GPIO5_Combined_0_15", .index = 88, .description = null },
            .{ .name = "GPIO5_Combined_16_31", .index = 89, .description = null },
            .{ .name = "FLEXIO1", .index = 90, .description = null },
            .{ .name = "FLEXIO2", .index = 91, .description = null },
            .{ .name = "WDOG1", .index = 92, .description = null },
            .{ .name = "RTWDOG", .index = 93, .description = null },
            .{ .name = "EWM", .index = 94, .description = null },
            .{ .name = "CCM_1", .index = 95, .description = null },
            .{ .name = "CCM_2", .index = 96, .description = null },
            .{ .name = "GPC", .index = 97, .description = null },
            .{ .name = "SRC", .index = 98, .description = null },
            .{ .name = "Reserved115", .index = 99, .description = null },
            .{ .name = "GPT1", .index = 100, .description = null },
            .{ .name = "GPT2", .index = 101, .description = null },
            .{ .name = "PWM1_0", .index = 102, .description = null },
            .{ .name = "PWM1_1", .index = 103, .description = null },
            .{ .name = "PWM1_2", .index = 104, .description = null },
            .{ .name = "PWM1_3", .index = 105, .description = null },
            .{ .name = "PWM1_FAULT", .index = 106, .description = null },
            .{ .name = "FLEXSPI2", .index = 107, .description = null },
            .{ .name = "FLEXSPI", .index = 108, .description = null },
            .{ .name = "SEMC", .index = 109, .description = null },
            .{ .name = "USDHC1", .index = 110, .description = null },
            .{ .name = "USDHC2", .index = 111, .description = null },
            .{ .name = "USB_OTG2", .index = 112, .description = null },
            .{ .name = "USB_OTG1", .index = 113, .description = null },
            .{ .name = "ENET", .index = 114, .description = null },
            .{ .name = "ENET_1588_Timer", .index = 115, .description = null },
            .{ .name = "XBAR1_IRQ_0_1", .index = 116, .description = null },
            .{ .name = "XBAR1_IRQ_2_3", .index = 117, .description = null },
            .{ .name = "ADC_ETC_IRQ0", .index = 118, .description = null },
            .{ .name = "ADC_ETC_IRQ1", .index = 119, .description = null },
            .{ .name = "ADC_ETC_IRQ2", .index = 120, .description = null },
            .{ .name = "ADC_ETC_ERROR_IRQ", .index = 121, .description = null },
            .{ .name = "PIT", .index = 122, .description = null },
            .{ .name = "ACMP1", .index = 123, .description = null },
            .{ .name = "ACMP2", .index = 124, .description = null },
            .{ .name = "ACMP3", .index = 125, .description = null },
            .{ .name = "ACMP4", .index = 126, .description = null },
            .{ .name = "Reserved143", .index = 127, .description = null },
            .{ .name = "Reserved144", .index = 128, .description = null },
            .{ .name = "ENC1", .index = 129, .description = null },
            .{ .name = "ENC2", .index = 130, .description = null },
            .{ .name = "ENC3", .index = 131, .description = null },
            .{ .name = "ENC4", .index = 132, .description = null },
            .{ .name = "TMR1", .index = 133, .description = null },
            .{ .name = "TMR2", .index = 134, .description = null },
            .{ .name = "TMR3", .index = 135, .description = null },
            .{ .name = "TMR4", .index = 136, .description = null },
            .{ .name = "PWM2_0", .index = 137, .description = null },
            .{ .name = "PWM2_1", .index = 138, .description = null },
            .{ .name = "PWM2_2", .index = 139, .description = null },
            .{ .name = "PWM2_3", .index = 140, .description = null },
            .{ .name = "PWM2_FAULT", .index = 141, .description = null },
            .{ .name = "PWM3_0", .index = 142, .description = null },
            .{ .name = "PWM3_1", .index = 143, .description = null },
            .{ .name = "PWM3_2", .index = 144, .description = null },
            .{ .name = "PWM3_3", .index = 145, .description = null },
            .{ .name = "PWM3_FAULT", .index = 146, .description = null },
            .{ .name = "PWM4_0", .index = 147, .description = null },
            .{ .name = "PWM4_1", .index = 148, .description = null },
            .{ .name = "PWM4_2", .index = 149, .description = null },
            .{ .name = "PWM4_3", .index = 150, .description = null },
            .{ .name = "PWM4_FAULT", .index = 151, .description = null },
            .{ .name = "ENET2", .index = 152, .description = null },
            .{ .name = "ENET2_1588_Timer", .index = 153, .description = null },
            .{ .name = "CAN3", .index = 154, .description = null },
            .{ .name = "Reserved171", .index = 155, .description = null },
            .{ .name = "FLEXIO3", .index = 156, .description = null },
            .{ .name = "GPIO6_7_8_9", .index = 157, .description = null },
        };

        pub const VectorTable = extern struct {
            const Handler = microzig.interrupt.Handler;
            const unhandled = microzig.interrupt.unhandled;

            initial_stack_pointer: u32,
            Reset: Handler,
            NMI: Handler = unhandled,
            HardFault: Handler = unhandled,
            MemManageFault: Handler = unhandled,
            BusFault: Handler = unhandled,
            UsageFault: Handler = unhandled,
            reserved5: [4]u32 = undefined,
            SVCall: Handler = unhandled,
            reserved10: [2]u32 = undefined,
            PendSV: Handler = unhandled,
            SysTick: Handler = unhandled,
            DMA0_DMA16: Handler = unhandled,
            DMA1_DMA17: Handler = unhandled,
            DMA2_DMA18: Handler = unhandled,
            DMA3_DMA19: Handler = unhandled,
            DMA4_DMA20: Handler = unhandled,
            DMA5_DMA21: Handler = unhandled,
            DMA6_DMA22: Handler = unhandled,
            DMA7_DMA23: Handler = unhandled,
            DMA8_DMA24: Handler = unhandled,
            DMA9_DMA25: Handler = unhandled,
            DMA10_DMA26: Handler = unhandled,
            DMA11_DMA27: Handler = unhandled,
            DMA12_DMA28: Handler = unhandled,
            DMA13_DMA29: Handler = unhandled,
            DMA14_DMA30: Handler = unhandled,
            DMA15_DMA31: Handler = unhandled,
            DMA_ERROR: Handler = unhandled,
            CTI0_ERROR: Handler = unhandled,
            CTI1_ERROR: Handler = unhandled,
            CORE: Handler = unhandled,
            LPUART1: Handler = unhandled,
            LPUART2: Handler = unhandled,
            LPUART3: Handler = unhandled,
            LPUART4: Handler = unhandled,
            LPUART5: Handler = unhandled,
            LPUART6: Handler = unhandled,
            LPUART7: Handler = unhandled,
            LPUART8: Handler = unhandled,
            LPI2C1: Handler = unhandled,
            LPI2C2: Handler = unhandled,
            LPI2C3: Handler = unhandled,
            LPI2C4: Handler = unhandled,
            LPSPI1: Handler = unhandled,
            LPSPI2: Handler = unhandled,
            LPSPI3: Handler = unhandled,
            LPSPI4: Handler = unhandled,
            CAN1: Handler = unhandled,
            CAN2: Handler = unhandled,
            FLEXRAM: Handler = unhandled,
            KPP: Handler = unhandled,
            TSC_DIG: Handler = unhandled,
            GPR_IRQ: Handler = unhandled,
            LCDIF: Handler = unhandled,
            CSI: Handler = unhandled,
            PXP: Handler = unhandled,
            WDOG2: Handler = unhandled,
            SNVS_HP_WRAPPER: Handler = unhandled,
            SNVS_HP_WRAPPER_TZ: Handler = unhandled,
            SNVS_LP_WRAPPER: Handler = unhandled,
            CSU: Handler = unhandled,
            DCP: Handler = unhandled,
            DCP_VMI: Handler = unhandled,
            Reserved68: Handler = unhandled,
            TRNG: Handler = unhandled,
            SJC: Handler = unhandled,
            BEE: Handler = unhandled,
            SAI1: Handler = unhandled,
            SAI2: Handler = unhandled,
            SAI3_RX: Handler = unhandled,
            SAI3_TX: Handler = unhandled,
            SPDIF: Handler = unhandled,
            PMU_EVENT: Handler = unhandled,
            Reserved78: Handler = unhandled,
            TEMP_LOW_HIGH: Handler = unhandled,
            TEMP_PANIC: Handler = unhandled,
            USB_PHY1: Handler = unhandled,
            USB_PHY2: Handler = unhandled,
            ADC1: Handler = unhandled,
            ADC2: Handler = unhandled,
            DCDC: Handler = unhandled,
            Reserved86: Handler = unhandled,
            Reserved87: Handler = unhandled,
            GPIO1_INT0: Handler = unhandled,
            GPIO1_INT1: Handler = unhandled,
            GPIO1_INT2: Handler = unhandled,
            GPIO1_INT3: Handler = unhandled,
            GPIO1_INT4: Handler = unhandled,
            GPIO1_INT5: Handler = unhandled,
            GPIO1_INT6: Handler = unhandled,
            GPIO1_INT7: Handler = unhandled,
            GPIO1_Combined_0_15: Handler = unhandled,
            GPIO1_Combined_16_31: Handler = unhandled,
            GPIO2_Combined_0_15: Handler = unhandled,
            GPIO2_Combined_16_31: Handler = unhandled,
            GPIO3_Combined_0_15: Handler = unhandled,
            GPIO3_Combined_16_31: Handler = unhandled,
            GPIO4_Combined_0_15: Handler = unhandled,
            GPIO4_Combined_16_31: Handler = unhandled,
            GPIO5_Combined_0_15: Handler = unhandled,
            GPIO5_Combined_16_31: Handler = unhandled,
            FLEXIO1: Handler = unhandled,
            FLEXIO2: Handler = unhandled,
            WDOG1: Handler = unhandled,
            RTWDOG: Handler = unhandled,
            EWM: Handler = unhandled,
            CCM_1: Handler = unhandled,
            CCM_2: Handler = unhandled,
            GPC: Handler = unhandled,
            SRC: Handler = unhandled,
            Reserved115: Handler = unhandled,
            GPT1: Handler = unhandled,
            GPT2: Handler = unhandled,
            PWM1_0: Handler = unhandled,
            PWM1_1: Handler = unhandled,
            PWM1_2: Handler = unhandled,
            PWM1_3: Handler = unhandled,
            PWM1_FAULT: Handler = unhandled,
            FLEXSPI2: Handler = unhandled,
            FLEXSPI: Handler = unhandled,
            SEMC: Handler = unhandled,
            USDHC1: Handler = unhandled,
            USDHC2: Handler = unhandled,
            USB_OTG2: Handler = unhandled,
            USB_OTG1: Handler = unhandled,
            ENET: Handler = unhandled,
            ENET_1588_Timer: Handler = unhandled,
            XBAR1_IRQ_0_1: Handler = unhandled,
            XBAR1_IRQ_2_3: Handler = unhandled,
            ADC_ETC_IRQ0: Handler = unhandled,
            ADC_ETC_IRQ1: Handler = unhandled,
            ADC_ETC_IRQ2: Handler = unhandled,
            ADC_ETC_ERROR_IRQ: Handler = unhandled,
            PIT: Handler = unhandled,
            ACMP1: Handler = unhandled,
            ACMP2: Handler = unhandled,
            ACMP3: Handler = unhandled,
            ACMP4: Handler = unhandled,
            Reserved143: Handler = unhandled,
            Reserved144: Handler = unhandled,
            ENC1: Handler = unhandled,
            ENC2: Handler = unhandled,
            ENC3: Handler = unhandled,
            ENC4: Handler = unhandled,
            TMR1: Handler = unhandled,
            TMR2: Handler = unhandled,
            TMR3: Handler = unhandled,
            TMR4: Handler = unhandled,
            PWM2_0: Handler = unhandled,
            PWM2_1: Handler = unhandled,
            PWM2_2: Handler = unhandled,
            PWM2_3: Handler = unhandled,
            PWM2_FAULT: Handler = unhandled,
            PWM3_0: Handler = unhandled,
            PWM3_1: Handler = unhandled,
            PWM3_2: Handler = unhandled,
            PWM3_3: Handler = unhandled,
            PWM3_FAULT: Handler = unhandled,
            PWM4_0: Handler = unhandled,
            PWM4_1: Handler = unhandled,
            PWM4_2: Handler = unhandled,
            PWM4_3: Handler = unhandled,
            PWM4_FAULT: Handler = unhandled,
            ENET2: Handler = unhandled,
            ENET2_1588_Timer: Handler = unhandled,
            CAN3: Handler = unhandled,
            Reserved171: Handler = unhandled,
            FLEXIO3: Handler = unhandled,
            GPIO6_7_8_9: Handler = unhandled,
        };

        pub const peripherals = struct {
            /// AIPSTZ Control Registers
            pub const AIPSTZ1: *volatile types.peripherals.AIPSTZ1 = @ptrFromInt(0x4007c000);
            /// DCDC
            pub const DCDC: *volatile types.peripherals.DCDC = @ptrFromInt(0x40080000);
            /// PIT
            pub const PIT: *volatile types.peripherals.PIT = @ptrFromInt(0x40084000);
            /// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
            pub const CMP1: *volatile types.peripherals.CMP1 = @ptrFromInt(0x40094000);
            /// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
            pub const CMP2: *volatile types.peripherals.CMP1 = @ptrFromInt(0x40094008);
            /// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
            pub const CMP3: *volatile types.peripherals.CMP1 = @ptrFromInt(0x40094010);
            /// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
            pub const CMP4: *volatile types.peripherals.CMP1 = @ptrFromInt(0x40094018);
            /// IOMUXC
            pub const IOMUXC_SNVS_GPR: *volatile types.peripherals.IOMUXC_SNVS_GPR = @ptrFromInt(0x400a4000);
            /// IOMUXC_SNVS
            pub const IOMUXC_SNVS: *volatile types.peripherals.IOMUXC_SNVS = @ptrFromInt(0x400a8000);
            /// IOMUXC_GPR
            pub const IOMUXC_GPR: *volatile types.peripherals.IOMUXC_GPR = @ptrFromInt(0x400ac000);
            /// FLEXRAM
            pub const FLEXRAM: *volatile types.peripherals.FLEXRAM = @ptrFromInt(0x400b0000);
            /// EWM
            pub const EWM: *volatile types.peripherals.EWM = @ptrFromInt(0x400b4000);
            /// WDOG
            pub const WDOG1: *volatile types.peripherals.WDOG1 = @ptrFromInt(0x400b8000);
            /// WDOG
            pub const RTWDOG: *volatile types.peripherals.RTWDOG = @ptrFromInt(0x400bc000);
            /// GPIO
            pub const GPIO5: *volatile types.peripherals.GPIO1 = @ptrFromInt(0x400c0000);
            /// Analog-to-Digital Converter
            pub const ADC1: *volatile types.peripherals.ADC1 = @ptrFromInt(0x400c4000);
            /// Analog-to-Digital Converter
            pub const ADC2: *volatile types.peripherals.ADC1 = @ptrFromInt(0x400c8000);
            /// TRNG
            pub const TRNG: *volatile types.peripherals.TRNG = @ptrFromInt(0x400cc000);
            /// WDOG
            pub const WDOG2: *volatile types.peripherals.WDOG1 = @ptrFromInt(0x400d0000);
            /// SNVS
            pub const SNVS: *volatile types.peripherals.SNVS = @ptrFromInt(0x400d4000);
            /// CCM_ANALOG
            pub const CCM_ANALOG: *volatile types.peripherals.CCM_ANALOG = @ptrFromInt(0x400d8000);
            /// PMU
            pub const PMU: *volatile types.peripherals.PMU = @ptrFromInt(0x400d8000);
            /// Temperature Monitor
            pub const TEMPMON: *volatile types.peripherals.TEMPMON = @ptrFromInt(0x400d8000);
            /// USB Analog
            pub const USB_ANALOG: *volatile types.peripherals.USB_ANALOG = @ptrFromInt(0x400d8000);
            /// XTALOSC24M
            pub const XTALOSC24M: *volatile types.peripherals.XTALOSC24M = @ptrFromInt(0x400d8000);
            /// USBPHY Register Reference Index
            pub const USBPHY1: *volatile types.peripherals.USBPHY1 = @ptrFromInt(0x400d9000);
            /// USBPHY Register Reference Index
            pub const USBPHY2: *volatile types.peripherals.USBPHY1 = @ptrFromInt(0x400da000);
            /// CSU registers
            pub const CSU: *volatile types.peripherals.CSU = @ptrFromInt(0x400dc000);
            /// Touch Screen Controller
            pub const TSC: *volatile types.peripherals.TSC = @ptrFromInt(0x400e0000);
            /// DMA
            pub const DMA0: *volatile types.peripherals.DMA0 = @ptrFromInt(0x400e8000);
            /// DMA_CH_MUX
            pub const DMAMUX: *volatile types.peripherals.DMAMUX = @ptrFromInt(0x400ec000);
            /// GPC
            pub const GPC: *volatile types.peripherals.GPC = @ptrFromInt(0x400f4000);
            /// PGC
            pub const PGC: *volatile types.peripherals.PGC = @ptrFromInt(0x400f4000);
            /// SRC
            pub const SRC: *volatile types.peripherals.SRC = @ptrFromInt(0x400f8000);
            /// CCM
            pub const CCM: *volatile types.peripherals.CCM = @ptrFromInt(0x400fc000);
            /// AIPSTZ Control Registers
            pub const AIPSTZ2: *volatile types.peripherals.AIPSTZ1 = @ptrFromInt(0x4017c000);
            /// ROMC
            pub const ROMC: *volatile types.peripherals.ROMC = @ptrFromInt(0x40180000);
            /// LPUART
            pub const LPUART1: *volatile types.peripherals.LPUART1 = @ptrFromInt(0x40184000);
            /// LPUART
            pub const LPUART2: *volatile types.peripherals.LPUART1 = @ptrFromInt(0x40188000);
            /// LPUART
            pub const LPUART3: *volatile types.peripherals.LPUART1 = @ptrFromInt(0x4018c000);
            /// LPUART
            pub const LPUART4: *volatile types.peripherals.LPUART1 = @ptrFromInt(0x40190000);
            /// LPUART
            pub const LPUART5: *volatile types.peripherals.LPUART1 = @ptrFromInt(0x40194000);
            /// LPUART
            pub const LPUART6: *volatile types.peripherals.LPUART1 = @ptrFromInt(0x40198000);
            /// LPUART
            pub const LPUART7: *volatile types.peripherals.LPUART1 = @ptrFromInt(0x4019c000);
            /// LPUART
            pub const LPUART8: *volatile types.peripherals.LPUART1 = @ptrFromInt(0x401a0000);
            /// FLEXIO
            pub const FLEXIO1: *volatile types.peripherals.FLEXIO1 = @ptrFromInt(0x401ac000);
            /// FLEXIO
            pub const FLEXIO2: *volatile types.peripherals.FLEXIO1 = @ptrFromInt(0x401b0000);
            /// GPIO
            pub const GPIO1: *volatile types.peripherals.GPIO1 = @ptrFromInt(0x401b8000);
            /// GPIO
            pub const GPIO2: *volatile types.peripherals.GPIO1 = @ptrFromInt(0x401bc000);
            /// GPIO
            pub const GPIO3: *volatile types.peripherals.GPIO1 = @ptrFromInt(0x401c0000);
            /// GPIO
            pub const GPIO4: *volatile types.peripherals.GPIO1 = @ptrFromInt(0x401c4000);
            /// FLEXCAN
            pub const CAN1: *volatile types.peripherals.CAN1 = @ptrFromInt(0x401d0000);
            /// FLEXCAN
            pub const CAN2: *volatile types.peripherals.CAN1 = @ptrFromInt(0x401d4000);
            /// CAN
            pub const CAN3: *volatile types.peripherals.CAN3 = @ptrFromInt(0x401d8000);
            /// Quad Timer
            pub const TMR1: *volatile types.peripherals.TMR1 = @ptrFromInt(0x401dc000);
            /// Quad Timer
            pub const TMR2: *volatile types.peripherals.TMR1 = @ptrFromInt(0x401e0000);
            /// Quad Timer
            pub const TMR3: *volatile types.peripherals.TMR1 = @ptrFromInt(0x401e4000);
            /// Quad Timer
            pub const TMR4: *volatile types.peripherals.TMR1 = @ptrFromInt(0x401e8000);
            /// GPT
            pub const GPT1: *volatile types.peripherals.GPT1 = @ptrFromInt(0x401ec000);
            /// GPT
            pub const GPT2: *volatile types.peripherals.GPT1 = @ptrFromInt(0x401f0000);
            /// OCOTP
            pub const OCOTP: *volatile types.peripherals.OCOTP = @ptrFromInt(0x401f4000);
            /// IOMUXC
            pub const IOMUXC: *volatile types.peripherals.IOMUXC = @ptrFromInt(0x401f8000);
            /// KPP Registers
            pub const KPP: *volatile types.peripherals.KPP = @ptrFromInt(0x401fc000);
            /// AIPSTZ Control Registers
            pub const AIPSTZ3: *volatile types.peripherals.AIPSTZ1 = @ptrFromInt(0x4027c000);
            /// FlexSPI
            pub const FLEXSPI2: *volatile types.peripherals.FLEXSPI = @ptrFromInt(0x402a4000);
            /// FlexSPI
            pub const FLEXSPI: *volatile types.peripherals.FLEXSPI = @ptrFromInt(0x402a8000);
            /// PXP v2.0 Register Reference Index
            pub const PXP: *volatile types.peripherals.PXP = @ptrFromInt(0x402b4000);
            /// LCDIF Register Reference Index
            pub const LCDIF: *volatile types.peripherals.LCDIF = @ptrFromInt(0x402b8000);
            /// CSI
            pub const CSI: *volatile types.peripherals.CSI = @ptrFromInt(0x402bc000);
            /// uSDHC
            pub const USDHC1: *volatile types.peripherals.USDHC1 = @ptrFromInt(0x402c0000);
            /// uSDHC
            pub const USDHC2: *volatile types.peripherals.USDHC1 = @ptrFromInt(0x402c4000);
            /// Ethernet MAC-NET Core
            pub const ENET2: *volatile types.peripherals.ENET = @ptrFromInt(0x402d4000);
            /// Ethernet MAC-NET Core
            pub const ENET: *volatile types.peripherals.ENET = @ptrFromInt(0x402d8000);
            /// USB
            pub const USB1: *volatile types.peripherals.USB1 = @ptrFromInt(0x402e0000);
            /// USB
            pub const USBNC1: *volatile types.peripherals.USBNC1 = @ptrFromInt(0x402e0000);
            /// USB
            pub const USBNC2: *volatile types.peripherals.USBNC1 = @ptrFromInt(0x402e0004);
            /// USB
            pub const USB2: *volatile types.peripherals.USB1 = @ptrFromInt(0x402e0200);
            /// SEMC
            pub const SEMC: *volatile types.peripherals.SEMC = @ptrFromInt(0x402f0000);
            /// DCP register reference index
            pub const DCP: *volatile types.peripherals.DCP = @ptrFromInt(0x402fc000);
            /// AIPSTZ Control Registers
            pub const AIPSTZ4: *volatile types.peripherals.AIPSTZ1 = @ptrFromInt(0x4037c000);
            /// SPDIF
            pub const SPDIF: *volatile types.peripherals.SPDIF = @ptrFromInt(0x40380000);
            /// I2S
            pub const SAI1: *volatile types.peripherals.SAI1 = @ptrFromInt(0x40384000);
            /// I2S
            pub const SAI2: *volatile types.peripherals.SAI1 = @ptrFromInt(0x40388000);
            /// I2S
            pub const SAI3: *volatile types.peripherals.SAI1 = @ptrFromInt(0x4038c000);
            /// LPSPI
            pub const LPSPI1: *volatile types.peripherals.LPSPI1 = @ptrFromInt(0x40394000);
            /// LPSPI
            pub const LPSPI2: *volatile types.peripherals.LPSPI1 = @ptrFromInt(0x40398000);
            /// LPSPI
            pub const LPSPI3: *volatile types.peripherals.LPSPI1 = @ptrFromInt(0x4039c000);
            /// LPSPI
            pub const LPSPI4: *volatile types.peripherals.LPSPI1 = @ptrFromInt(0x403a0000);
            /// ADC_ETC
            pub const ADC_ETC: *volatile types.peripherals.ADC_ETC = @ptrFromInt(0x403b0000);
            /// AND/OR/INVERT module
            pub const AOI1: *volatile types.peripherals.AOI1 = @ptrFromInt(0x403b4000);
            /// AND/OR/INVERT module
            pub const AOI2: *volatile types.peripherals.AOI1 = @ptrFromInt(0x403b8000);
            /// Crossbar Switch
            pub const XBARA1: *volatile types.peripherals.XBARA1 = @ptrFromInt(0x403bc000);
            /// Crossbar Switch
            pub const XBARB2: *volatile types.peripherals.XBARB2 = @ptrFromInt(0x403c0000);
            /// Crossbar Switch
            pub const XBARB3: *volatile types.peripherals.XBARB2 = @ptrFromInt(0x403c4000);
            /// Quadrature Decoder
            pub const ENC1: *volatile types.peripherals.ENC1 = @ptrFromInt(0x403c8000);
            /// Quadrature Decoder
            pub const ENC2: *volatile types.peripherals.ENC1 = @ptrFromInt(0x403cc000);
            /// Quadrature Decoder
            pub const ENC3: *volatile types.peripherals.ENC1 = @ptrFromInt(0x403d0000);
            /// Quadrature Decoder
            pub const ENC4: *volatile types.peripherals.ENC1 = @ptrFromInt(0x403d4000);
            /// PWM
            pub const PWM1: *volatile types.peripherals.PWM1 = @ptrFromInt(0x403dc000);
            /// PWM
            pub const PWM2: *volatile types.peripherals.PWM1 = @ptrFromInt(0x403e0000);
            /// PWM
            pub const PWM3: *volatile types.peripherals.PWM1 = @ptrFromInt(0x403e4000);
            /// PWM
            pub const PWM4: *volatile types.peripherals.PWM1 = @ptrFromInt(0x403e8000);
            /// Bus Encryption Engine
            pub const BEE: *volatile types.peripherals.BEE = @ptrFromInt(0x403ec000);
            /// LPI2C
            pub const LPI2C1: *volatile types.peripherals.LPI2C1 = @ptrFromInt(0x403f0000);
            /// LPI2C
            pub const LPI2C2: *volatile types.peripherals.LPI2C1 = @ptrFromInt(0x403f4000);
            /// LPI2C
            pub const LPI2C3: *volatile types.peripherals.LPI2C1 = @ptrFromInt(0x403f8000);
            /// LPI2C
            pub const LPI2C4: *volatile types.peripherals.LPI2C1 = @ptrFromInt(0x403fc000);
            /// GPIO
            pub const GPIO6: *volatile types.peripherals.GPIO1 = @ptrFromInt(0x42000000);
            /// GPIO
            pub const GPIO7: *volatile types.peripherals.GPIO1 = @ptrFromInt(0x42004000);
            /// GPIO
            pub const GPIO8: *volatile types.peripherals.GPIO1 = @ptrFromInt(0x42008000);
            /// GPIO
            pub const GPIO9: *volatile types.peripherals.GPIO1 = @ptrFromInt(0x4200c000);
            /// FLEXIO
            pub const FLEXIO3: *volatile types.peripherals.FLEXIO1 = @ptrFromInt(0x42020000);
            /// System Control Block
            pub const SystemControl: *volatile types.peripherals.SystemControl = @ptrFromInt(0xe000e000);
            /// Nested Vectored Interrupt Controller
            pub const NVIC: *volatile types.peripherals.NVIC = @ptrFromInt(0xe000e100);
        };
    };
};

pub const types = struct {
    pub const peripherals = struct {
        /// Analog-to-Digital Converter
        pub const ADC1 = extern struct {
            /// Control register for hardware triggers
            HC0: mmio.Mmio(packed struct(u32) {
                /// Input Channel Select
                ADCH: enum(u5) {
                    /// External channel selection from ADC_ETC
                    ADCH_16 = 0x10,
                    /// VREFSH = internal channel, for ADC self-test, hard connected to VRH internally
                    ADCH_25 = 0x19,
                    /// Conversion Disabled. Hardware Triggers will not initiate any conversion.
                    ADCH_31 = 0x1f,
                    _,
                },
                reserved7: u2 = 0,
                /// Conversion Complete Interrupt Enable/Disable Control
                AIEN: enum(u1) {
                    /// Conversion complete interrupt disabled
                    AIEN_0 = 0x0,
                    /// Conversion complete interrupt enabled
                    AIEN_1 = 0x1,
                },
                padding: u24 = 0,
            }),
            reserved32: [28]u8,
            /// Status register for HW triggers
            HS: mmio.Mmio(packed struct(u32) {
                /// Conversion Complete Flag
                COCO0: u1,
                padding: u31 = 0,
            }),
            /// Data result register for HW triggers
            R0: mmio.Mmio(packed struct(u32) {
                /// Data (result of an ADC conversion)
                CDATA: u12,
                padding: u20 = 0,
            }),
            reserved68: [28]u8,
            /// Configuration register
            CFG: mmio.Mmio(packed struct(u32) {
                /// Input Clock Select
                ADICLK: enum(u2) {
                    /// IPG clock
                    ADICLK_0 = 0x0,
                    /// IPG clock divided by 2
                    ADICLK_1 = 0x1,
                    /// Asynchronous clock (ADACK)
                    ADICLK_3 = 0x3,
                    _,
                },
                /// Conversion Mode Selection
                MODE: enum(u2) {
                    /// 8-bit conversion
                    MODE_0 = 0x0,
                    /// 10-bit conversion
                    MODE_1 = 0x1,
                    /// 12-bit conversion
                    MODE_2 = 0x2,
                    _,
                },
                /// Long Sample Time Configuration
                ADLSMP: enum(u1) {
                    /// Short sample mode.
                    ADLSMP_0 = 0x0,
                    /// Long sample mode.
                    ADLSMP_1 = 0x1,
                },
                /// Clock Divide Select
                ADIV: enum(u2) {
                    /// Input clock
                    ADIV_0 = 0x0,
                    /// Input clock / 2
                    ADIV_1 = 0x1,
                    /// Input clock / 4
                    ADIV_2 = 0x2,
                    /// Input clock / 8
                    ADIV_3 = 0x3,
                },
                /// Low-Power Configuration
                ADLPC: enum(u1) {
                    /// ADC hard block not in low power mode.
                    ADLPC_0 = 0x0,
                    /// ADC hard block in low power mode.
                    ADLPC_1 = 0x1,
                },
                /// Defines the sample time duration
                ADSTS: enum(u2) {
                    /// Sample period (ADC clocks) = 2 if ADLSMP=0b Sample period (ADC clocks) = 12 if ADLSMP=1b
                    ADSTS_0 = 0x0,
                    /// Sample period (ADC clocks) = 4 if ADLSMP=0b Sample period (ADC clocks) = 16 if ADLSMP=1b
                    ADSTS_1 = 0x1,
                    /// Sample period (ADC clocks) = 6 if ADLSMP=0b Sample period (ADC clocks) = 20 if ADLSMP=1b
                    ADSTS_2 = 0x2,
                    /// Sample period (ADC clocks) = 8 if ADLSMP=0b Sample period (ADC clocks) = 24 if ADLSMP=1b
                    ADSTS_3 = 0x3,
                },
                /// High Speed Configuration
                ADHSC: enum(u1) {
                    /// Normal conversion selected.
                    ADHSC_0 = 0x0,
                    /// High speed conversion selected.
                    ADHSC_1 = 0x1,
                },
                /// Voltage Reference Selection
                REFSEL: enum(u2) {
                    /// Selects VREFH/VREFL as reference voltage.
                    REFSEL_0 = 0x0,
                    _,
                },
                /// Conversion Trigger Select
                ADTRG: enum(u1) {
                    /// Software trigger selected
                    ADTRG_0 = 0x0,
                    /// Hardware trigger selected
                    ADTRG_1 = 0x1,
                },
                /// Hardware Average select
                AVGS: enum(u2) {
                    /// 4 samples averaged
                    AVGS_0 = 0x0,
                    /// 8 samples averaged
                    AVGS_1 = 0x1,
                    /// 16 samples averaged
                    AVGS_2 = 0x2,
                    /// 32 samples averaged
                    AVGS_3 = 0x3,
                },
                /// Data Overwrite Enable
                OVWREN: enum(u1) {
                    /// Disable the overwriting. Existing Data in Data result register will not be overwritten by subsequent converted data.
                    OVWREN_0 = 0x0,
                    /// Enable the overwriting.
                    OVWREN_1 = 0x1,
                },
                padding: u15 = 0,
            }),
            /// General control register
            GC: mmio.Mmio(packed struct(u32) {
                /// Asynchronous clock output enable
                ADACKEN: enum(u1) {
                    /// Asynchronous clock output disabled; Asynchronous clock only enabled if selected by ADICLK and a conversion is active.
                    ADACKEN_0 = 0x0,
                    /// Asynchronous clock and clock output enabled regardless of the state of the ADC
                    ADACKEN_1 = 0x1,
                },
                /// DMA Enable
                DMAEN: enum(u1) {
                    /// DMA disabled (default)
                    DMAEN_0 = 0x0,
                    /// DMA enabled
                    DMAEN_1 = 0x1,
                },
                /// Compare Function Range Enable
                ACREN: enum(u1) {
                    /// Range function disabled. Only the compare value 1 of ADC_CV register (CV1) is compared.
                    ACREN_0 = 0x0,
                    /// Range function enabled. Both compare values of ADC_CV registers (CV1 and CV2) are compared.
                    ACREN_1 = 0x1,
                },
                /// Compare Function Greater Than Enable
                ACFGT: enum(u1) {
                    /// Configures "Less Than Threshold, Outside Range Not Inclusive and Inside Range Not Inclusive" functionality based on the values placed in the ADC_CV register.
                    ACFGT_0 = 0x0,
                    /// Configures "Greater Than Or Equal To Threshold, Outside Range Inclusive and Inside Range Inclusive" functionality based on the values placed in the ADC_CV registers.
                    ACFGT_1 = 0x1,
                },
                /// Compare Function Enable
                ACFE: enum(u1) {
                    /// Compare function disabled
                    ACFE_0 = 0x0,
                    /// Compare function enabled
                    ACFE_1 = 0x1,
                },
                /// Hardware average enable
                AVGE: enum(u1) {
                    /// Hardware average function disabled
                    AVGE_0 = 0x0,
                    /// Hardware average function enabled
                    AVGE_1 = 0x1,
                },
                /// Continuous Conversion Enable
                ADCO: enum(u1) {
                    /// One conversion or one set of conversions if the hardware average function is enabled (AVGE=1) after initiating a conversion.
                    ADCO_0 = 0x0,
                    /// Continuous conversions or sets of conversions if the hardware average function is enabled (AVGE=1) after initiating a conversion.
                    ADCO_1 = 0x1,
                },
                /// Calibration
                CAL: u1,
                padding: u24 = 0,
            }),
            /// General status register
            GS: mmio.Mmio(packed struct(u32) {
                /// Conversion Active
                ADACT: enum(u1) {
                    /// Conversion not in progress.
                    ADACT_0 = 0x0,
                    /// Conversion in progress.
                    ADACT_1 = 0x1,
                },
                /// Calibration Failed Flag
                CALF: enum(u1) {
                    /// Calibration completed normally.
                    CALF_0 = 0x0,
                    /// Calibration failed. ADC accuracy specifications are not guaranteed.
                    CALF_1 = 0x1,
                },
                /// Asynchronous wakeup interrupt status
                AWKST: enum(u1) {
                    /// No asynchronous interrupt.
                    AWKST_0 = 0x0,
                    /// Asynchronous wake up interrupt occurred in stop mode.
                    AWKST_1 = 0x1,
                },
                padding: u29 = 0,
            }),
            /// Compare value register
            CV: mmio.Mmio(packed struct(u32) {
                /// Compare Value 1
                CV1: u12,
                reserved16: u4 = 0,
                /// Compare Value 2
                CV2: u12,
                padding: u4 = 0,
            }),
            /// Offset correction value register
            OFS: mmio.Mmio(packed struct(u32) {
                /// Offset value
                OFS: u12,
                /// Sign bit
                SIGN: enum(u1) {
                    /// The offset value is added with the raw result
                    SIGN_0 = 0x0,
                    /// The offset value is subtracted from the raw converted value
                    SIGN_1 = 0x1,
                },
                padding: u19 = 0,
            }),
            /// Calibration value register
            CAL: mmio.Mmio(packed struct(u32) {
                /// Calibration Result Value
                CAL_CODE: u4,
                padding: u28 = 0,
            }),
        };

        /// ADC_ETC
        pub const ADC_ETC = extern struct {
            /// ADC_ETC Global Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                /// TRIG enable register
                TRIG_ENABLE: u8,
                /// TSC0 TRIG enable register. 1'b1: enable external TSC0 trigger. 1'b0: disable external TSC0 trigger.
                EXT0_TRIG_ENABLE: u1,
                /// External TSC0 trigger priority, 7 is Highest, 0 is lowest .
                EXT0_TRIG_PRIORITY: u3,
                /// TSC1 TRIG enable register. 1'b1: enable external TSC1 trigger. 1'b0: disable external TSC1 trigger.
                EXT1_TRIG_ENABLE: u1,
                /// External TSC1 trigger priority, 7 is Highest, 0 is lowest .
                EXT1_TRIG_PRIORITY: u3,
                /// Pre-divider for trig delay and interval .
                PRE_DIVIDER: u8,
                reserved29: u5 = 0,
                /// 1'b0: Trig DMA_REQ with latched signal, REQ will be cleared when ACK and source request cleared
                DMA_MODE_SEL: u1,
                /// 1'b1: TSC is bypassed to ADC2. 1'b0: TSC not bypassed. To use ADC2, this bit should be cleared.
                TSC_BYPASS: u1,
                /// Software reset, high active. When write 1 ,all logical will be reset.
                SOFTRST: u1,
            }),
            /// ETC DONE0 and DONE1 IRQ State Register
            DONE0_1_IRQ: mmio.Mmio(packed struct(u32) {
                /// TRIG0 done0 interrupt detection
                TRIG0_DONE0: u1,
                /// TRIG1 done0 interrupt detection
                TRIG1_DONE0: u1,
                /// TRIG2 done0 interrupt detection
                TRIG2_DONE0: u1,
                /// TRIG3 done0 interrupt detection
                TRIG3_DONE0: u1,
                /// TRIG4 done0 interrupt detection
                TRIG4_DONE0: u1,
                /// TRIG5 done0 interrupt detection
                TRIG5_DONE0: u1,
                /// TRIG6 done0 interrupt detection
                TRIG6_DONE0: u1,
                /// TRIG7 done0 interrupt detection
                TRIG7_DONE0: u1,
                reserved16: u8 = 0,
                /// TRIG0 done1 interrupt detection
                TRIG0_DONE1: u1,
                /// TRIG1 done1 interrupt detection
                TRIG1_DONE1: u1,
                /// TRIG2 done1 interrupt detection
                TRIG2_DONE1: u1,
                /// TRIG3 done1 interrupt detection
                TRIG3_DONE1: u1,
                /// TRIG4 done1 interrupt detection
                TRIG4_DONE1: u1,
                /// TRIG5 done1 interrupt detection
                TRIG5_DONE1: u1,
                /// TRIG6 done1 interrupt detection
                TRIG6_DONE1: u1,
                /// TRIG7 done1 interrupt detection
                TRIG7_DONE1: u1,
                padding: u8 = 0,
            }),
            /// ETC DONE_2 and DONE_ERR IRQ State Register
            DONE2_ERR_IRQ: mmio.Mmio(packed struct(u32) {
                /// TRIG0 done2 interrupt detection
                TRIG0_DONE2: u1,
                /// TRIG1 done2 interrupt detection
                TRIG1_DONE2: u1,
                /// TRIG2 done2 interrupt detection
                TRIG2_DONE2: u1,
                /// TRIG3 done2 interrupt detection
                TRIG3_DONE2: u1,
                /// TRIG4 done2 interrupt detection
                TRIG4_DONE2: u1,
                /// TRIG5 done2 interrupt detection
                TRIG5_DONE2: u1,
                /// TRIG6 done2 interrupt detection
                TRIG6_DONE2: u1,
                /// TRIG7 done2 interrupt detection
                TRIG7_DONE2: u1,
                reserved16: u8 = 0,
                /// TRIG0 error interrupt detection
                TRIG0_ERR: u1,
                /// TRIG1 error interrupt detection
                TRIG1_ERR: u1,
                /// TRIG2 error interrupt detection
                TRIG2_ERR: u1,
                /// TRIG3 error interrupt detection
                TRIG3_ERR: u1,
                /// TRIG4 error interrupt detection
                TRIG4_ERR: u1,
                /// TRIG5 error interrupt detection
                TRIG5_ERR: u1,
                /// TRIG6 error interrupt detection
                TRIG6_ERR: u1,
                /// TRIG7 error interrupt detection
                TRIG7_ERR: u1,
                padding: u8 = 0,
            }),
            /// ETC DMA control Register
            DMA_CTRL: mmio.Mmio(packed struct(u32) {
                /// When TRIG0 done enable DMA request
                TRIG0_ENABLE: u1,
                /// When TRIG1 done enable DMA request
                TRIG1_ENABLE: u1,
                /// When TRIG2 done enable DMA request
                TRIG2_ENABLE: u1,
                /// When TRIG3 done enable DMA request
                TRIG3_ENABLE: u1,
                /// When TRIG4 done enable DMA request
                TRIG4_ENABLE: u1,
                /// When TRIG5 done enable DMA request
                TRIG5_ENABLE: u1,
                /// When TRIG6 done enable DMA request
                TRIG6_ENABLE: u1,
                /// When TRIG7 done enable DMA request
                TRIG7_ENABLE: u1,
                reserved16: u8 = 0,
                /// When TRIG0 done DMA request detection
                TRIG0_REQ: u1,
                /// When TRIG1 done DMA request detection
                TRIG1_REQ: u1,
                /// When TRIG2 done DMA request detection
                TRIG2_REQ: u1,
                /// When TRIG3 done DMA request detection
                TRIG3_REQ: u1,
                /// When TRIG4 done DMA request detection
                TRIG4_REQ: u1,
                /// When TRIG5 done DMA request detection
                TRIG5_REQ: u1,
                /// When TRIG6 done DMA request detection
                TRIG6_REQ: u1,
                /// When TRIG7 done DMA request detection
                TRIG7_REQ: u1,
                padding: u8 = 0,
            }),
            /// ETC_TRIG0 Control Register
            TRIG0_CTRL: mmio.Mmio(packed struct(u32) {
                /// Software write 1 as the TRIGGER. This register is self-clearing.
                SW_TRIG: u1,
                reserved4: u3 = 0,
                /// TRIG mode register. 1'b0: hardware trigger. 1'b1: software trigger.
                TRIG_MODE: u1,
                reserved8: u3 = 0,
                /// TRIG chain length to the ADC. 0: Trig length is 1; ... 7: Trig length is 8;
                TRIG_CHAIN: u3,
                reserved12: u1 = 0,
                /// External trigger priority, 7 is highest, 0 is lowest .
                TRIG_PRIORITY: u3,
                reserved16: u1 = 0,
                /// TRIG mode control . 1'b0: Disable sync mode; 1'b1: Enable sync mode
                SYNC_MODE: u1,
                padding: u15 = 0,
            }),
            /// ETC_TRIG0 Counter Register
            TRIG0_COUNTER: mmio.Mmio(packed struct(u32) {
                /// TRIGGER initial delay counter
                INIT_DELAY: u16,
                /// TRIGGER sampling interval counter
                SAMPLE_INTERVAL: u16,
            }),
            /// ETC_TRIG Chain 0/1 Register
            TRIG0_CHAIN_1_0: mmio.Mmio(packed struct(u32) {
                /// CHAIN0 CSEL ADC channel selection
                CSEL0: u4,
                /// CHAIN0 HWTS ADC hardware trigger selection. For more information, see the ADC chapter.
                HWTS0: u8,
                /// CHAIN0 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
                B2B0: u1,
                /// CHAIN0 IE 2'b00: No interrupt when finished 2'b01: Finished Interrupt on Done0 2'b10: Finished Interrupt on Done1 2'b11: Finished Interrupt on Done2
                IE0: u2,
                reserved16: u1 = 0,
                /// CHAIN1 CSEL ADC channel selection
                CSEL1: u4,
                /// CHAIN1 HWTS ADC hardware trigger selection. For more information, see the ADC chapter.
                HWTS1: u8,
                /// CHAIN1 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
                B2B1: u1,
                /// CHAIN1 IE 2'b00: No interrupt when finished 2'b01: Finished Interrupt on Done0 2'b10: Finished Interrupt on Done1 2'b11: Finished Interrupt on Done2
                IE1: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 2/3 Register
            TRIG0_CHAIN_3_2: mmio.Mmio(packed struct(u32) {
                /// CHAIN2 CSEL
                CSEL2: u4,
                /// CHAIN2 HWTS
                HWTS2: u8,
                /// CHAIN2 B2B
                B2B2: u1,
                /// CHAIN2 IE
                IE2: u2,
                reserved16: u1 = 0,
                /// CHAIN3 CSEL
                CSEL3: u4,
                /// CHAIN3 HWTS
                HWTS3: u8,
                /// CHAIN3 B2B
                B2B3: u1,
                /// CHAIN3 IE
                IE3: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 4/5 Register
            TRIG0_CHAIN_5_4: mmio.Mmio(packed struct(u32) {
                /// CHAIN4 CSEL
                CSEL4: u4,
                /// CHAIN4 HWTS
                HWTS4: u8,
                /// CHAIN4 B2B
                B2B4: u1,
                /// CHAIN4 IE
                IE4: u2,
                reserved16: u1 = 0,
                /// CHAIN5 CSEL
                CSEL5: u4,
                /// CHAIN5 HWTS
                HWTS5: u8,
                /// CHAIN5 B2B
                B2B5: u1,
                /// CHAIN5 IE
                IE5: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 6/7 Register
            TRIG0_CHAIN_7_6: mmio.Mmio(packed struct(u32) {
                /// CHAIN6 CSEL
                CSEL6: u4,
                /// CHAIN6 HWTS
                HWTS6: u8,
                /// CHAIN6 B2B
                B2B6: u1,
                /// CHAIN6 IE
                IE6: u2,
                reserved16: u1 = 0,
                /// CHAIN7 CSEL
                CSEL7: u4,
                /// CHAIN7 HWTS
                HWTS7: u8,
                /// CHAIN7 B2B
                B2B7: u1,
                /// CHAIN7 IE
                IE7: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Result Data 1/0 Register
            TRIG0_RESULT_1_0: mmio.Mmio(packed struct(u32) {
                /// Result DATA0
                DATA0: u12,
                reserved16: u4 = 0,
                /// Result DATA1
                DATA1: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 3/2 Register
            TRIG0_RESULT_3_2: mmio.Mmio(packed struct(u32) {
                /// Result DATA2
                DATA2: u12,
                reserved16: u4 = 0,
                /// Result DATA3
                DATA3: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 5/4 Register
            TRIG0_RESULT_5_4: mmio.Mmio(packed struct(u32) {
                /// Result DATA4
                DATA4: u12,
                reserved16: u4 = 0,
                /// Result DATA5
                DATA5: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 7/6 Register
            TRIG0_RESULT_7_6: mmio.Mmio(packed struct(u32) {
                /// Result DATA6
                DATA6: u12,
                reserved16: u4 = 0,
                /// Result DATA7
                DATA7: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG1 Control Register
            TRIG1_CTRL: mmio.Mmio(packed struct(u32) {
                /// Software write 1 as the TRIGGER. This register is self-clearing.
                SW_TRIG: u1,
                reserved4: u3 = 0,
                /// TRIG mode register. 1'b0: hardware trigger. 1'b1: software trigger.
                TRIG_MODE: u1,
                reserved8: u3 = 0,
                /// TRIG chain length to the ADC. 0: Trig length is 1; ... 7: Trig length is 8;
                TRIG_CHAIN: u3,
                reserved12: u1 = 0,
                /// External trigger priority, 7 is highest, 0 is lowest .
                TRIG_PRIORITY: u3,
                reserved16: u1 = 0,
                /// TRIG mode control . 1'b0: Disable sync mode; 1'b1: Enable sync mode
                SYNC_MODE: u1,
                padding: u15 = 0,
            }),
            /// ETC_TRIG1 Counter Register
            TRIG1_COUNTER: mmio.Mmio(packed struct(u32) {
                /// TRIGGER initial delay counter
                INIT_DELAY: u16,
                /// TRIGGER sampling interval counter
                SAMPLE_INTERVAL: u16,
            }),
            /// ETC_TRIG Chain 0/1 Register
            TRIG1_CHAIN_1_0: mmio.Mmio(packed struct(u32) {
                /// CHAIN0 CSEL ADC channel selection
                CSEL0: u4,
                /// CHAIN0 HWTS ADC hardware trigger selection
                HWTS0: u8,
                /// CHAIN0 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
                B2B0: u1,
                /// CHAIN0 IE 2'b00: No interrupt when finished 2'b01: Finished Interrupt on Done0 2'b10: Finished Interrupt on Done1 2'b11: Finished Interrupt on Done2
                IE0: u2,
                reserved16: u1 = 0,
                /// CHAIN1 CSEL ADC channel selection
                CSEL1: u4,
                /// CHAIN1 HWTS ADC hardware trigger selection
                HWTS1: u8,
                /// CHAIN1 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
                B2B1: u1,
                /// CHAIN1 IE 2'b00: No interrupt when finished 2'b01: Finished Interrupt on Done0 2'b10: Finished Interrupt on Done1 2'b11: Finished Interrupt on Done2
                IE1: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 2/3 Register
            TRIG1_CHAIN_3_2: mmio.Mmio(packed struct(u32) {
                /// CHAIN2 CSEL
                CSEL2: u4,
                /// CHAIN2 HWTS
                HWTS2: u8,
                /// CHAIN2 B2B
                B2B2: u1,
                /// CHAIN2 IE
                IE2: u2,
                reserved16: u1 = 0,
                /// CHAIN3 CSEL
                CSEL3: u4,
                /// CHAIN3 HWTS
                HWTS3: u8,
                /// CHAIN3 B2B
                B2B3: u1,
                /// CHAIN3 IE
                IE3: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 4/5 Register
            TRIG1_CHAIN_5_4: mmio.Mmio(packed struct(u32) {
                /// CHAIN4 CSEL
                CSEL4: u4,
                /// CHAIN4 HWTS
                HWTS4: u8,
                /// CHAIN4 B2B
                B2B4: u1,
                /// CHAIN4 IE
                IE4: u2,
                reserved16: u1 = 0,
                /// CHAIN5 CSEL
                CSEL5: u4,
                /// CHAIN5 HWTS
                HWTS5: u8,
                /// CHAIN5 B2B
                B2B5: u1,
                /// CHAIN5 IE
                IE5: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 6/7 Register
            TRIG1_CHAIN_7_6: mmio.Mmio(packed struct(u32) {
                /// CHAIN6 CSEL
                CSEL6: u4,
                /// CHAIN6 HWTS
                HWTS6: u8,
                /// CHAIN6 B2B
                B2B6: u1,
                /// CHAIN6 IE
                IE6: u2,
                reserved16: u1 = 0,
                /// CHAIN7 CSEL
                CSEL7: u4,
                /// CHAIN7 HWTS
                HWTS7: u8,
                /// CHAIN7 B2B
                B2B7: u1,
                /// CHAIN7 IE
                IE7: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Result Data 1/0 Register
            TRIG1_RESULT_1_0: mmio.Mmio(packed struct(u32) {
                /// Result DATA0
                DATA0: u12,
                reserved16: u4 = 0,
                /// Result DATA1
                DATA1: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 3/2 Register
            TRIG1_RESULT_3_2: mmio.Mmio(packed struct(u32) {
                /// Result DATA2
                DATA2: u12,
                reserved16: u4 = 0,
                /// Result DATA3
                DATA3: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 5/4 Register
            TRIG1_RESULT_5_4: mmio.Mmio(packed struct(u32) {
                /// Result DATA4
                DATA4: u12,
                reserved16: u4 = 0,
                /// Result DATA5
                DATA5: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 7/6 Register
            TRIG1_RESULT_7_6: mmio.Mmio(packed struct(u32) {
                /// Result DATA6
                DATA6: u12,
                reserved16: u4 = 0,
                /// Result DATA7
                DATA7: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG2 Control Register
            TRIG2_CTRL: mmio.Mmio(packed struct(u32) {
                /// Software write 1 as the TRIGGER. This register is self-clearing.
                SW_TRIG: u1,
                reserved4: u3 = 0,
                /// TRIG mode register. 1'b0: hardware trigger. 1'b1: software trigger.
                TRIG_MODE: u1,
                reserved8: u3 = 0,
                /// TRIG chain length to the ADC. 0: Trig length is 1; ... 7: Trig length is 8;
                TRIG_CHAIN: u3,
                reserved12: u1 = 0,
                /// External trigger priority, 7 is highest, 0 is lowest .
                TRIG_PRIORITY: u3,
                reserved16: u1 = 0,
                /// TRIG mode control . 1'b0: Disable sync mode; 1'b1: Enable sync mode
                SYNC_MODE: u1,
                padding: u15 = 0,
            }),
            /// ETC_TRIG2 Counter Register
            TRIG2_COUNTER: mmio.Mmio(packed struct(u32) {
                /// TRIGGER initial delay counter
                INIT_DELAY: u16,
                /// TRIGGER sampling interval counter
                SAMPLE_INTERVAL: u16,
            }),
            /// ETC_TRIG Chain 0/1 Register
            TRIG2_CHAIN_1_0: mmio.Mmio(packed struct(u32) {
                /// CHAIN0 CSEL ADC channel selection
                CSEL0: u4,
                /// CHAIN0 HWTS ADC hardware trigger selection
                HWTS0: u8,
                /// CHAIN0 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
                B2B0: u1,
                /// CHAIN0 IE 2'b00: No interrupt when finished 2'b01: Finished Interrupt on Done0 2'b10: Finished Interrupt on Done1 2'b11: Finished Interrupt on Done2
                IE0: u2,
                reserved16: u1 = 0,
                /// CHAIN1 CSEL ADC channel selection
                CSEL1: u4,
                /// CHAIN1 HWTS ADC hardware trigger selection
                HWTS1: u8,
                /// CHAIN1 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
                B2B1: u1,
                /// CHAIN1 IE 2'b00: No interrupt when finished 2'b01: Finished Interrupt on Done0 2'b10: Finished Interrupt on Done1 2'b11: Finished Interrupt on Done2
                IE1: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 2/3 Register
            TRIG2_CHAIN_3_2: mmio.Mmio(packed struct(u32) {
                /// CHAIN2 CSEL
                CSEL2: u4,
                /// CHAIN2 HWTS
                HWTS2: u8,
                /// CHAIN2 B2B
                B2B2: u1,
                /// CHAIN2 IE
                IE2: u2,
                reserved16: u1 = 0,
                /// CHAIN3 CSEL
                CSEL3: u4,
                /// CHAIN3 HWTS
                HWTS3: u8,
                /// CHAIN3 B2B
                B2B3: u1,
                /// CHAIN3 IE
                IE3: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 4/5 Register
            TRIG2_CHAIN_5_4: mmio.Mmio(packed struct(u32) {
                /// CHAIN4 CSEL
                CSEL4: u4,
                /// CHAIN4 HWTS
                HWTS4: u8,
                /// CHAIN4 B2B
                B2B4: u1,
                /// CHAIN4 IE
                IE4: u2,
                reserved16: u1 = 0,
                /// CHAIN5 CSEL
                CSEL5: u4,
                /// CHAIN5 HWTS
                HWTS5: u8,
                /// CHAIN5 B2B
                B2B5: u1,
                /// CHAIN5 IE
                IE5: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 6/7 Register
            TRIG2_CHAIN_7_6: mmio.Mmio(packed struct(u32) {
                /// CHAIN6 CSEL
                CSEL6: u4,
                /// CHAIN6 HWTS
                HWTS6: u8,
                /// CHAIN6 B2B
                B2B6: u1,
                /// CHAIN6 IE
                IE6: u2,
                reserved16: u1 = 0,
                /// CHAIN7 CSEL
                CSEL7: u4,
                /// CHAIN7 HWTS
                HWTS7: u8,
                /// CHAIN7 B2B
                B2B7: u1,
                /// CHAIN7 IE
                IE7: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Result Data 1/0 Register
            TRIG2_RESULT_1_0: mmio.Mmio(packed struct(u32) {
                /// Result DATA0
                DATA0: u12,
                reserved16: u4 = 0,
                /// Result DATA1
                DATA1: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 3/2 Register
            TRIG2_RESULT_3_2: mmio.Mmio(packed struct(u32) {
                /// Result DATA2
                DATA2: u12,
                reserved16: u4 = 0,
                /// Result DATA3
                DATA3: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 5/4 Register
            TRIG2_RESULT_5_4: mmio.Mmio(packed struct(u32) {
                /// Result DATA4
                DATA4: u12,
                reserved16: u4 = 0,
                /// Result DATA5
                DATA5: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 7/6 Register
            TRIG2_RESULT_7_6: mmio.Mmio(packed struct(u32) {
                /// Result DATA6
                DATA6: u12,
                reserved16: u4 = 0,
                /// Result DATA7
                DATA7: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG3 Control Register
            TRIG3_CTRL: mmio.Mmio(packed struct(u32) {
                /// Software write 1 as the TRIGGER. This register is self-clearing.
                SW_TRIG: u1,
                reserved4: u3 = 0,
                /// TRIG mode register. 1'b0: hardware trigger. 1'b1: software trigger.
                TRIG_MODE: u1,
                reserved8: u3 = 0,
                /// TRIG chain length to the ADC. 0: Trig length is 1; ... 7: Trig length is 8;
                TRIG_CHAIN: u3,
                reserved12: u1 = 0,
                /// External trigger priority, 7 is highest, 0 is lowest .
                TRIG_PRIORITY: u3,
                reserved16: u1 = 0,
                /// TRIG mode control . 1'b0: Disable sync mode; 1'b1: Enable sync mode
                SYNC_MODE: u1,
                padding: u15 = 0,
            }),
            /// ETC_TRIG3 Counter Register
            TRIG3_COUNTER: mmio.Mmio(packed struct(u32) {
                /// TRIGGER initial delay counter
                INIT_DELAY: u16,
                /// TRIGGER sampling interval counter
                SAMPLE_INTERVAL: u16,
            }),
            /// ETC_TRIG Chain 0/1 Register
            TRIG3_CHAIN_1_0: mmio.Mmio(packed struct(u32) {
                /// CHAIN0 CSEL ADC channel selection
                CSEL0: u4,
                /// CHAIN0 HWTS ADC hardware trigger selection
                HWTS0: u8,
                /// CHAIN0 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
                B2B0: u1,
                /// CHAIN0 IE 2'b00: No interrupt when finished 2'b01: Finished Interrupt on Done0 2'b10: Finished Interrupt on Done1 2'b11: Finished Interrupt on Done2
                IE0: u2,
                reserved16: u1 = 0,
                /// CHAIN1 CSEL ADC channel selection
                CSEL1: u4,
                /// CHAIN1 HWTS ADC hardware trigger selection
                HWTS1: u8,
                /// CHAIN1 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
                B2B1: u1,
                /// CHAIN1 IE 2'b00: No interrupt when finished 2'b01: Finished Interrupt on Done0 2'b10: Finished Interrupt on Done1 2'b11: Finished Interrupt on Done2
                IE1: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 2/3 Register
            TRIG3_CHAIN_3_2: mmio.Mmio(packed struct(u32) {
                /// CHAIN2 CSEL
                CSEL2: u4,
                /// CHAIN2 HWTS
                HWTS2: u8,
                /// CHAIN2 B2B
                B2B2: u1,
                /// CHAIN2 IE
                IE2: u2,
                reserved16: u1 = 0,
                /// CHAIN3 CSEL
                CSEL3: u4,
                /// CHAIN3 HWTS
                HWTS3: u8,
                /// CHAIN3 B2B
                B2B3: u1,
                /// CHAIN3 IE
                IE3: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 4/5 Register
            TRIG3_CHAIN_5_4: mmio.Mmio(packed struct(u32) {
                /// CHAIN4 CSEL
                CSEL4: u4,
                /// CHAIN4 HWTS
                HWTS4: u8,
                /// CHAIN4 B2B
                B2B4: u1,
                /// CHAIN4 IE
                IE4: u2,
                reserved16: u1 = 0,
                /// CHAIN5 CSEL
                CSEL5: u4,
                /// CHAIN5 HWTS
                HWTS5: u8,
                /// CHAIN5 B2B
                B2B5: u1,
                /// CHAIN5 IE
                IE5: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 6/7 Register
            TRIG3_CHAIN_7_6: mmio.Mmio(packed struct(u32) {
                /// CHAIN6 CSEL
                CSEL6: u4,
                /// CHAIN6 HWTS
                HWTS6: u8,
                /// CHAIN6 B2B
                B2B6: u1,
                /// CHAIN6 IE
                IE6: u2,
                reserved16: u1 = 0,
                /// CHAIN7 CSEL
                CSEL7: u4,
                /// CHAIN7 HWTS
                HWTS7: u8,
                /// CHAIN7 B2B
                B2B7: u1,
                /// CHAIN7 IE
                IE7: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Result Data 1/0 Register
            TRIG3_RESULT_1_0: mmio.Mmio(packed struct(u32) {
                /// Result DATA0
                DATA0: u12,
                reserved16: u4 = 0,
                /// Result DATA1
                DATA1: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 3/2 Register
            TRIG3_RESULT_3_2: mmio.Mmio(packed struct(u32) {
                /// Result DATA2
                DATA2: u12,
                reserved16: u4 = 0,
                /// Result DATA3
                DATA3: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 5/4 Register
            TRIG3_RESULT_5_4: mmio.Mmio(packed struct(u32) {
                /// Result DATA4
                DATA4: u12,
                reserved16: u4 = 0,
                /// Result DATA5
                DATA5: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 7/6 Register
            TRIG3_RESULT_7_6: mmio.Mmio(packed struct(u32) {
                /// Result DATA6
                DATA6: u12,
                reserved16: u4 = 0,
                /// Result DATA7
                DATA7: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG4 Control Register
            TRIG4_CTRL: mmio.Mmio(packed struct(u32) {
                /// Software write 1 as the TRIGGER. This register is self-clearing.
                SW_TRIG: u1,
                reserved4: u3 = 0,
                /// TRIG mode register. 1'b0: hardware trigger. 1'b1: software trigger.
                TRIG_MODE: u1,
                reserved8: u3 = 0,
                /// TRIG chain length to the ADC. 0: Trig length is 1; ... 7: Trig length is 8;
                TRIG_CHAIN: u3,
                reserved12: u1 = 0,
                /// External trigger priority, 7 is highest, 0 is lowest .
                TRIG_PRIORITY: u3,
                reserved16: u1 = 0,
                /// TRIG mode control . 1'b0: Disable sync mode; 1'b1: Enable sync mode
                SYNC_MODE: u1,
                padding: u15 = 0,
            }),
            /// ETC_TRIG4 Counter Register
            TRIG4_COUNTER: mmio.Mmio(packed struct(u32) {
                /// TRIGGER initial delay counter
                INIT_DELAY: u16,
                /// TRIGGER sampling interval counter
                SAMPLE_INTERVAL: u16,
            }),
            /// ETC_TRIG Chain 0/1 Register
            TRIG4_CHAIN_1_0: mmio.Mmio(packed struct(u32) {
                /// CHAIN0 CSEL ADC channel selection
                CSEL0: u4,
                /// CHAIN0 HWTS ADC hardware trigger selection
                HWTS0: u8,
                /// CHAIN0 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
                B2B0: u1,
                /// CHAIN0 IE 2'b00: No interrupt when finished 2'b01: Finished Interrupt on Done0 2'b10: Finished Interrupt on Done1 2'b11: Finished Interrupt on Done2
                IE0: u2,
                reserved16: u1 = 0,
                /// CHAIN1 CSEL ADC channel selection
                CSEL1: u4,
                /// CHAIN1 HWTS ADC hardware trigger selection
                HWTS1: u8,
                /// CHAIN1 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
                B2B1: u1,
                /// CHAIN1 IE 2'b00: No interrupt when finished 2'b01: Finished Interrupt on Done0 2'b10: Finished Interrupt on Done1 2'b11: Finished Interrupt on Done2
                IE1: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 2/3 Register
            TRIG4_CHAIN_3_2: mmio.Mmio(packed struct(u32) {
                /// CHAIN2 CSEL
                CSEL2: u4,
                /// CHAIN2 HWTS
                HWTS2: u8,
                /// CHAIN2 B2B
                B2B2: u1,
                /// CHAIN2 IE
                IE2: u2,
                reserved16: u1 = 0,
                /// CHAIN3 CSEL
                CSEL3: u4,
                /// CHAIN3 HWTS
                HWTS3: u8,
                /// CHAIN3 B2B
                B2B3: u1,
                /// CHAIN3 IE
                IE3: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 4/5 Register
            TRIG4_CHAIN_5_4: mmio.Mmio(packed struct(u32) {
                /// CHAIN4 CSEL
                CSEL4: u4,
                /// CHAIN4 HWTS
                HWTS4: u8,
                /// CHAIN4 B2B
                B2B4: u1,
                /// CHAIN4 IE
                IE4: u2,
                reserved16: u1 = 0,
                /// CHAIN5 CSEL
                CSEL5: u4,
                /// CHAIN5 HWTS
                HWTS5: u8,
                /// CHAIN5 B2B
                B2B5: u1,
                /// CHAIN5 IE
                IE5: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 6/7 Register
            TRIG4_CHAIN_7_6: mmio.Mmio(packed struct(u32) {
                /// CHAIN6 CSEL
                CSEL6: u4,
                /// CHAIN6 HWTS
                HWTS6: u8,
                /// CHAIN6 B2B
                B2B6: u1,
                /// CHAIN6 IE
                IE6: u2,
                reserved16: u1 = 0,
                /// CHAIN7 CSEL
                CSEL7: u4,
                /// CHAIN7 HWTS
                HWTS7: u8,
                /// CHAIN7 B2B
                B2B7: u1,
                /// CHAIN7 IE
                IE7: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Result Data 1/0 Register
            TRIG4_RESULT_1_0: mmio.Mmio(packed struct(u32) {
                /// Result DATA0
                DATA0: u12,
                reserved16: u4 = 0,
                /// Result DATA1
                DATA1: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 3/2 Register
            TRIG4_RESULT_3_2: mmio.Mmio(packed struct(u32) {
                /// Result DATA2
                DATA2: u12,
                reserved16: u4 = 0,
                /// Result DATA3
                DATA3: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 5/4 Register
            TRIG4_RESULT_5_4: mmio.Mmio(packed struct(u32) {
                /// Result DATA4
                DATA4: u12,
                reserved16: u4 = 0,
                /// Result DATA5
                DATA5: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 7/6 Register
            TRIG4_RESULT_7_6: mmio.Mmio(packed struct(u32) {
                /// Result DATA6
                DATA6: u12,
                reserved16: u4 = 0,
                /// Result DATA7
                DATA7: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG5 Control Register
            TRIG5_CTRL: mmio.Mmio(packed struct(u32) {
                /// Software write 1 as the TRIGGER
                SW_TRIG: u1,
                reserved4: u3 = 0,
                /// TRIG mode register. 1'b0: hardware trigger. 1'b1: software trigger.
                TRIG_MODE: u1,
                reserved8: u3 = 0,
                /// TRIG chain length to the ADC. 0: Trig length is 1; ... 7: Trig length is 8;
                TRIG_CHAIN: u3,
                reserved12: u1 = 0,
                /// External trigger priority, 7 is highest, 0 is lowest .
                TRIG_PRIORITY: u3,
                reserved16: u1 = 0,
                /// TRIG mode control . 1'b0: Disable sync mode; 1'b1: Enable sync mode
                SYNC_MODE: u1,
                padding: u15 = 0,
            }),
            /// ETC_TRIG5 Counter Register
            TRIG5_COUNTER: mmio.Mmio(packed struct(u32) {
                /// TRIGGER initial delay counter
                INIT_DELAY: u16,
                /// TRIGGER sampling interval counter
                SAMPLE_INTERVAL: u16,
            }),
            /// ETC_TRIG Chain 0/1 Register
            TRIG5_CHAIN_1_0: mmio.Mmio(packed struct(u32) {
                /// CHAIN0 CSEL ADC channel selection
                CSEL0: u4,
                /// CHAIN0 HWTS ADC hardware trigger selection
                HWTS0: u8,
                /// CHAIN0 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
                B2B0: u1,
                /// CHAIN0 IE 2'b00: No interrupt when finished 2'b01: Finished Interrupt on Done0 2'b10: Finished Interrupt on Done1 2'b11: Finished Interrupt on Done2
                IE0: u2,
                reserved16: u1 = 0,
                /// CHAIN1 CSEL ADC channel selection
                CSEL1: u4,
                /// CHAIN1 HWTS ADC hardware trigger selection
                HWTS1: u8,
                /// CHAIN1 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
                B2B1: u1,
                /// CHAIN1 IE 2'b00: No interrupt when finished 2'b01: Finished Interrupt on Done0 2'b10: Finished Interrupt on Done1 2'b11: Finished Interrupt on Done2
                IE1: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 2/3 Register
            TRIG5_CHAIN_3_2: mmio.Mmio(packed struct(u32) {
                /// CHAIN2 CSEL
                CSEL2: u4,
                /// CHAIN2 HWTS
                HWTS2: u8,
                /// CHAIN2 B2B
                B2B2: u1,
                /// CHAIN2 IE
                IE2: u2,
                reserved16: u1 = 0,
                /// CHAIN3 CSEL
                CSEL3: u4,
                /// CHAIN3 HWTS
                HWTS3: u8,
                /// CHAIN3 B2B
                B2B3: u1,
                /// CHAIN3 IE
                IE3: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 4/5 Register
            TRIG5_CHAIN_5_4: mmio.Mmio(packed struct(u32) {
                /// CHAIN4 CSEL
                CSEL4: u4,
                /// CHAIN4 HWTS
                HWTS4: u8,
                /// CHAIN4 B2B
                B2B4: u1,
                /// CHAIN4 IE
                IE4: u2,
                reserved16: u1 = 0,
                /// CHAIN5 CSEL
                CSEL5: u4,
                /// CHAIN5 HWTS
                HWTS5: u8,
                /// CHAIN5 B2B
                B2B5: u1,
                /// CHAIN5 IE
                IE5: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 6/7 Register
            TRIG5_CHAIN_7_6: mmio.Mmio(packed struct(u32) {
                /// CHAIN6 CSEL
                CSEL6: u4,
                /// CHAIN6 HWTS
                HWTS6: u8,
                /// CHAIN6 B2B
                B2B6: u1,
                /// CHAIN6 IE
                IE6: u2,
                reserved16: u1 = 0,
                /// CHAIN7 CSEL
                CSEL7: u4,
                /// CHAIN7 HWTS
                HWTS7: u8,
                /// CHAIN7 B2B
                B2B7: u1,
                /// CHAIN7 IE
                IE7: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Result Data 1/0 Register
            TRIG5_RESULT_1_0: mmio.Mmio(packed struct(u32) {
                /// Result DATA0
                DATA0: u12,
                reserved16: u4 = 0,
                /// Result DATA1
                DATA1: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 3/2 Register
            TRIG5_RESULT_3_2: mmio.Mmio(packed struct(u32) {
                /// Result DATA2
                DATA2: u12,
                reserved16: u4 = 0,
                /// Result DATA3
                DATA3: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 5/4 Register
            TRIG5_RESULT_5_4: mmio.Mmio(packed struct(u32) {
                /// Result DATA4
                DATA4: u12,
                reserved16: u4 = 0,
                /// Result DATA5
                DATA5: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 7/6 Register
            TRIG5_RESULT_7_6: mmio.Mmio(packed struct(u32) {
                /// Result DATA6
                DATA6: u12,
                reserved16: u4 = 0,
                /// Result DATA7
                DATA7: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG6 Control Register
            TRIG6_CTRL: mmio.Mmio(packed struct(u32) {
                /// Software write 1 as the TRIGGER. This register is self-clearing.
                SW_TRIG: u1,
                reserved4: u3 = 0,
                /// TRIG mode register. 1'b0: hardware trigger. 1'b1: software trigger.
                TRIG_MODE: u1,
                reserved8: u3 = 0,
                /// TRIG chain length to the ADC. 0: Trig length is 1; ... 7: Trig length is 8;
                TRIG_CHAIN: u3,
                reserved12: u1 = 0,
                /// External trigger priority, 7 is highest, 0 is lowest .
                TRIG_PRIORITY: u3,
                reserved16: u1 = 0,
                /// TRIG mode control . 1'b0: Disable sync mode; 1'b1: Enable sync mode
                SYNC_MODE: u1,
                padding: u15 = 0,
            }),
            /// ETC_TRIG6 Counter Register
            TRIG6_COUNTER: mmio.Mmio(packed struct(u32) {
                /// TRIGGER initial delay counter
                INIT_DELAY: u16,
                /// TRIGGER sampling interval counter
                SAMPLE_INTERVAL: u16,
            }),
            /// ETC_TRIG Chain 0/1 Register
            TRIG6_CHAIN_1_0: mmio.Mmio(packed struct(u32) {
                /// CHAIN0 CSEL ADC channel selection
                CSEL0: u4,
                /// CHAIN0 HWTS ADC hardware trigger selection
                HWTS0: u8,
                /// CHAIN0 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
                B2B0: u1,
                /// CHAIN0 IE 2'b00: No interrupt when finished 2'b01: Finished Interrupt on Done0 2'b10: Finished Interrupt on Done1 2'b11: Finished Interrupt on Done2
                IE0: u2,
                reserved16: u1 = 0,
                /// CHAIN1 CSEL ADC channel selection
                CSEL1: u4,
                /// CHAIN1 HWTS ADC hardware trigger selection
                HWTS1: u8,
                /// CHAIN1 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
                B2B1: u1,
                /// CHAIN1 IE 2'b00: No interrupt when finished 2'b01: Finished Interrupt on Done0 2'b10: Finished Interrupt on Done1 2'b11: Finished Interrupt on Done2
                IE1: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 2/3 Register
            TRIG6_CHAIN_3_2: mmio.Mmio(packed struct(u32) {
                /// CHAIN2 CSEL
                CSEL2: u4,
                /// CHAIN2 HWTS
                HWTS2: u8,
                /// CHAIN2 B2B
                B2B2: u1,
                /// CHAIN2 IE
                IE2: u2,
                reserved16: u1 = 0,
                /// CHAIN3 CSEL
                CSEL3: u4,
                /// CHAIN3 HWTS
                HWTS3: u8,
                /// CHAIN3 B2B
                B2B3: u1,
                /// CHAIN3 IE
                IE3: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 4/5 Register
            TRIG6_CHAIN_5_4: mmio.Mmio(packed struct(u32) {
                /// CHAIN4 CSEL
                CSEL4: u4,
                /// CHAIN4 HWTS
                HWTS4: u8,
                /// CHAIN4 B2B
                B2B4: u1,
                /// CHAIN4 IE
                IE4: u2,
                reserved16: u1 = 0,
                /// CHAIN5 CSEL
                CSEL5: u4,
                /// CHAIN5 HWTS
                HWTS5: u8,
                /// CHAIN5 B2B
                B2B5: u1,
                /// CHAIN5 IE
                IE5: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 6/7 Register
            TRIG6_CHAIN_7_6: mmio.Mmio(packed struct(u32) {
                /// CHAIN6 CSEL
                CSEL6: u4,
                /// CHAIN6 HWTS
                HWTS6: u8,
                /// CHAIN6 B2B
                B2B6: u1,
                /// CHAIN6 IE
                IE6: u2,
                reserved16: u1 = 0,
                /// CHAIN7 CSEL
                CSEL7: u4,
                /// CHAIN7 HWTS
                HWTS7: u8,
                /// CHAIN7 B2B
                B2B7: u1,
                /// CHAIN7 IE
                IE7: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Result Data 1/0 Register
            TRIG6_RESULT_1_0: mmio.Mmio(packed struct(u32) {
                /// Result DATA0
                DATA0: u12,
                reserved16: u4 = 0,
                /// Result DATA1
                DATA1: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 3/2 Register
            TRIG6_RESULT_3_2: mmio.Mmio(packed struct(u32) {
                /// Result DATA2
                DATA2: u12,
                reserved16: u4 = 0,
                /// Result DATA3
                DATA3: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 5/4 Register
            TRIG6_RESULT_5_4: mmio.Mmio(packed struct(u32) {
                /// Result DATA4
                DATA4: u12,
                reserved16: u4 = 0,
                /// Result DATA5
                DATA5: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 7/6 Register
            TRIG6_RESULT_7_6: mmio.Mmio(packed struct(u32) {
                /// Result DATA6
                DATA6: u12,
                reserved16: u4 = 0,
                /// Result DATA7
                DATA7: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG7 Control Register
            TRIG7_CTRL: mmio.Mmio(packed struct(u32) {
                /// Software write 1 as the TRIGGER. This register is self-clearing.
                SW_TRIG: u1,
                reserved4: u3 = 0,
                /// TRIG mode register. 1'b0: hardware trigger. 1'b1: software trigger.
                TRIG_MODE: u1,
                reserved8: u3 = 0,
                /// TRIG chain length to the ADC. 0: Trig length is 1; ... 7: Trig length is 8;
                TRIG_CHAIN: u3,
                reserved12: u1 = 0,
                /// External trigger priority, 7 is highest, 0 is lowest .
                TRIG_PRIORITY: u3,
                reserved16: u1 = 0,
                /// TRIG mode control . 1'b0: Disable sync mode; 1'b1: Enable sync mode
                SYNC_MODE: u1,
                padding: u15 = 0,
            }),
            /// ETC_TRIG7 Counter Register
            TRIG7_COUNTER: mmio.Mmio(packed struct(u32) {
                /// TRIGGER initial delay counter
                INIT_DELAY: u16,
                /// TRIGGER sampling interval counter
                SAMPLE_INTERVAL: u16,
            }),
            /// ETC_TRIG Chain 0/1 Register
            TRIG7_CHAIN_1_0: mmio.Mmio(packed struct(u32) {
                /// CHAIN0 CSEL ADC channel selection
                CSEL0: u4,
                /// CHAIN0 HWTS ADC hardware trigger selection
                HWTS0: u8,
                /// CHAIN0 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
                B2B0: u1,
                /// CHAIN0 IE 2'b00: No interrupt when finished 2'b01: Finished Interrupt on Done0 2'b10: Finished Interrupt on Done1 2'b11: Finished Interrupt on Done2
                IE0: u2,
                reserved16: u1 = 0,
                /// CHAIN1 CSEL ADC channel selection
                CSEL1: u4,
                /// CHAIN1 HWTS ADC hardware trigger selection
                HWTS1: u8,
                /// CHAIN1 B2B 1'b0: Disable B2B, wait until interval is reached 1'b1: Enable B2B, back to back ADC trigger
                B2B1: u1,
                /// CHAIN1 IE 2'b00: No interrupt when finished 2'b01: Finished Interrupt on Done0 2'b10: Finished Interrupt on Done1 2'b11: Finished Interrupt on Done2
                IE1: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 2/3 Register
            TRIG7_CHAIN_3_2: mmio.Mmio(packed struct(u32) {
                /// CHAIN2 CSEL
                CSEL2: u4,
                /// CHAIN2 HWTS
                HWTS2: u8,
                /// CHAIN2 B2B
                B2B2: u1,
                /// CHAIN2 IE
                IE2: u2,
                reserved16: u1 = 0,
                /// CHAIN3 CSEL
                CSEL3: u4,
                /// CHAIN3 HWTS
                HWTS3: u8,
                /// CHAIN3 B2B
                B2B3: u1,
                /// CHAIN3 IE
                IE3: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 4/5 Register
            TRIG7_CHAIN_5_4: mmio.Mmio(packed struct(u32) {
                /// CHAIN4 CSEL
                CSEL4: u4,
                /// CHAIN4 HWTS
                HWTS4: u8,
                /// CHAIN4 B2B
                B2B4: u1,
                /// CHAIN4 IE
                IE4: u2,
                reserved16: u1 = 0,
                /// CHAIN5 CSEL
                CSEL5: u4,
                /// CHAIN5 HWTS
                HWTS5: u8,
                /// CHAIN5 B2B
                B2B5: u1,
                /// CHAIN5 IE
                IE5: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Chain 6/7 Register
            TRIG7_CHAIN_7_6: mmio.Mmio(packed struct(u32) {
                /// CHAIN6 CSEL
                CSEL6: u4,
                /// CHAIN6 HWTS
                HWTS6: u8,
                /// CHAIN6 B2B
                B2B6: u1,
                /// CHAIN6 IE
                IE6: u2,
                reserved16: u1 = 0,
                /// CHAIN7 CSEL
                CSEL7: u4,
                /// CHAIN7 HWTS
                HWTS7: u8,
                /// CHAIN7 B2B
                B2B7: u1,
                /// CHAIN7 IE
                IE7: u2,
                padding: u1 = 0,
            }),
            /// ETC_TRIG Result Data 1/0 Register
            TRIG7_RESULT_1_0: mmio.Mmio(packed struct(u32) {
                /// Result DATA0
                DATA0: u12,
                reserved16: u4 = 0,
                /// Result DATA1
                DATA1: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 3/2 Register
            TRIG7_RESULT_3_2: mmio.Mmio(packed struct(u32) {
                /// Result DATA2
                DATA2: u12,
                reserved16: u4 = 0,
                /// Result DATA3
                DATA3: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 5/4 Register
            TRIG7_RESULT_5_4: mmio.Mmio(packed struct(u32) {
                /// Result DATA4
                DATA4: u12,
                reserved16: u4 = 0,
                /// Result DATA5
                DATA5: u12,
                padding: u4 = 0,
            }),
            /// ETC_TRIG Result Data 7/6 Register
            TRIG7_RESULT_7_6: mmio.Mmio(packed struct(u32) {
                /// Result DATA6
                DATA6: u12,
                reserved16: u4 = 0,
                /// Result DATA7
                DATA7: u12,
                padding: u4 = 0,
            }),
        };

        /// AIPSTZ Control Registers
        pub const AIPSTZ1 = extern struct {
            /// Master Priviledge Registers
            MPR: u32,
            reserved64: [60]u8,
            /// Off-Platform Peripheral Access Control Registers
            OPACR: u32,
            /// Off-Platform Peripheral Access Control Registers
            OPACR1: u32,
            /// Off-Platform Peripheral Access Control Registers
            OPACR2: u32,
            /// Off-Platform Peripheral Access Control Registers
            OPACR3: u32,
            /// Off-Platform Peripheral Access Control Registers
            OPACR4: u32,
        };

        /// AND/OR/INVERT module
        pub const AOI1 = struct {};

        /// Bus Encryption Engine
        pub const BEE = extern struct {
            /// BEE Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                /// BEE enable bit
                BEE_ENABLE: enum(u1) {
                    /// Disable BEE
                    BEE_ENABLE_0 = 0x0,
                    /// Enable BEE
                    BEE_ENABLE_1 = 0x1,
                },
                /// Clock enable input, low inactive
                CTRL_CLK_EN: u1,
                /// Soft reset input, low active
                CTRL_SFTRST_N: u1,
                reserved4: u1 = 0,
                /// AES-128 key is ready
                KEY_VALID: u1,
                /// AES key region select
                KEY_REGION_SEL: enum(u1) {
                    /// Load AES key for region0
                    KEY_REGION_SEL_0 = 0x0,
                    /// Load AES key for region1
                    KEY_REGION_SEL_1 = 0x1,
                },
                /// Enable access permission control When AC_PROT_EN is asserted, all encrypted regions are limited to be ARM core access only
                AC_PROT_EN: u1,
                /// Endian swap control for the 16 bytes input and output data of AES core.
                LITTLE_ENDIAN: enum(u1) {
                    /// The input and output data of the AES core is swapped as below: {B15,B14,B13,B12,B11,B10,B9,B8, B7,B6,B5,B4,B3,B2,B1,B0} swap to {B0,B1,B2,B3,B4,B5,B6,B7, B8,B9,B10,B11,B12,B13,B14,B15}, where B0~B15 refers to Byte0 to Byte15.
                    LITTLE_ENDIAN_0 = 0x0,
                    /// The input and output data of AES core is not swapped.
                    LITTLE_ENDIAN_1 = 0x1,
                },
                /// Security level of the allowed access for memory region0
                SECURITY_LEVEL_R0: u2,
                /// AES mode of region0
                CTRL_AES_MODE_R0: enum(u1) {
                    /// ECB
                    CTRL_AES_MODE_R0_0 = 0x0,
                    /// CTR
                    CTRL_AES_MODE_R0_1 = 0x1,
                },
                reserved12: u1 = 0,
                /// Security level of the allowed access for memory region1
                SECURITY_LEVEL_R1: u2,
                /// AES mode of region1
                CTRL_AES_MODE_R1: enum(u1) {
                    /// ECB
                    CTRL_AES_MODE_R1_0 = 0x0,
                    /// CTR
                    CTRL_AES_MODE_R1_1 = 0x1,
                },
                reserved16: u1 = 0,
                /// Lock bit for bee_enable
                BEE_ENABLE_LOCK: u1,
                /// Lock bit for ctrl_clk_en
                CTRL_CLK_EN_LOCK: u1,
                /// Lock bit for ctrl_sftrst
                CTRL_SFTRST_N_LOCK: u1,
                /// Lock bit for region1 address boundary
                REGION1_ADDR_LOCK: u1,
                /// Lock bit for key_valid
                KEY_VALID_LOCK: u1,
                /// Lock bit for key_region_sel
                KEY_REGION_SEL_LOCK: u1,
                /// Lock bit for ac_prot
                AC_PROT_EN_LOCK: u1,
                /// Lock bit for little_endian
                LITTLE_ENDIAN_LOCK: u1,
                /// Lock bits for security_level_r0
                SECURITY_LEVEL_R0_LOCK: u2,
                /// Lock bit for region0 ctrl_aes_mode
                CTRL_AES_MODE_R0_LOCK: u1,
                /// Lock bit for region0 AES key
                REGION0_KEY_LOCK: u1,
                /// Lock bits for security_level_r1
                SECURITY_LEVEL_R1_LOCK: u2,
                /// Lock bit for region1 ctrl_aes_mode
                CTRL_AES_MODE_R1_LOCK: u1,
                /// Lock bit for region1 AES key
                REGION1_KEY_LOCK: u1,
            }),
            /// no description available
            ADDR_OFFSET0: mmio.Mmio(packed struct(u32) {
                /// Signed offset for BEE region 0
                ADDR_OFFSET0: u16,
                /// Lock bits for addr_offset0
                ADDR_OFFSET0_LOCK: u16,
            }),
            /// no description available
            ADDR_OFFSET1: mmio.Mmio(packed struct(u32) {
                /// Signed offset for BEE region 1
                ADDR_OFFSET1: u16,
                /// Lock bits for addr_offset1
                ADDR_OFFSET1_LOCK: u16,
            }),
            /// no description available
            AES_KEY0_W0: mmio.Mmio(packed struct(u32) {
                /// AES 128 key from software
                KEY0: u32,
            }),
            /// no description available
            AES_KEY0_W1: mmio.Mmio(packed struct(u32) {
                /// AES 128 key from software
                KEY1: u32,
            }),
            /// no description available
            AES_KEY0_W2: mmio.Mmio(packed struct(u32) {
                /// AES 128 key from software
                KEY2: u32,
            }),
            /// no description available
            AES_KEY0_W3: mmio.Mmio(packed struct(u32) {
                /// AES 128 key from software
                KEY3: u32,
            }),
            /// no description available
            STATUS: mmio.Mmio(packed struct(u32) {
                /// bit 7: Protected region-3 access violation bit 6: Protected region-2 access violation bit 5: Protected region-1 access violation bit 4: Protected region-0 access violation bit 3: Region-1 read channel security violation bit 2: Read channel illegal access detected bit 1: Region-0 read channel security violation bit 0: Disable abort
                IRQ_VEC: u8,
                /// 1'b1: BEE is idle; 1'b0: BEE is active
                BEE_IDLE: u1,
                padding: u23 = 0,
            }),
            /// no description available
            CTR_NONCE0_W0: mmio.Mmio(packed struct(u32) {
                /// Nonce0 from software for CTR, for region0. Nonce0={Nonce03,Nonce02,Nonce01,Nonce00}
                NONCE00: u32,
            }),
            /// no description available
            CTR_NONCE0_W1: mmio.Mmio(packed struct(u32) {
                /// Nonce0 from software for CTR, for region0. Nonce0={Nonce03,Nonce02,Nonce01,Nonce00}
                NONCE01: u32,
            }),
            /// no description available
            CTR_NONCE0_W2: mmio.Mmio(packed struct(u32) {
                /// Nonce0 from software for CTR, for region0. Nonce0={Nonce03,Nonce02,Nonce01,Nonce00}
                NONCE02: u32,
            }),
            /// no description available
            CTR_NONCE0_W3: mmio.Mmio(packed struct(u32) {
                /// Nonce0 from software for CTR, for region0. Nonce0={Nonce03,Nonce02,Nonce01,Nonce00}
                NONCE03: u32,
            }),
            /// no description available
            CTR_NONCE1_W0: mmio.Mmio(packed struct(u32) {
                /// Nonce1 from software for CTR, for region1. Nonce1={Nonce13,Nonce12,Nonce11,Nonce10}
                NONCE10: u32,
            }),
            /// no description available
            CTR_NONCE1_W1: mmio.Mmio(packed struct(u32) {
                /// Nonce1 from software for CTR, for region1. Nonce1={Nonce13,Nonce12,Nonce11,Nonce10}
                NONCE11: u32,
            }),
            /// no description available
            CTR_NONCE1_W2: mmio.Mmio(packed struct(u32) {
                /// Nonce1 from software for CTR, for region1. Nonce1={Nonce13,Nonce12,Nonce11,Nonce10}
                NONCE12: u32,
            }),
            /// no description available
            CTR_NONCE1_W3: mmio.Mmio(packed struct(u32) {
                /// Nonce1 from software for CTR, for region1. Nonce1={Nonce13,Nonce12,Nonce11,Nonce10}
                NONCE13: u32,
            }),
            /// no description available
            REGION1_TOP: mmio.Mmio(packed struct(u32) {
                /// Address upper limit of region1
                REGION1_TOP: u32,
            }),
            /// no description available
            REGION1_BOT: mmio.Mmio(packed struct(u32) {
                /// Address lower limit of region1
                REGION1_BOT: u32,
            }),
        };

        /// FLEXCAN
        pub const CAN1 = extern struct {
            /// Module Configuration Register
            MCR: mmio.Mmio(packed struct(u32) {
                /// This 7-bit field defines the number of the last Message Buffers that will take part in the matching and arbitration processes
                MAXMB: u7,
                reserved8: u1 = 0,
                /// This 2-bit field identifies the format of the elements of the Rx FIFO filter table, as shown below
                IDAM: enum(u2) {
                    /// Format A One full ID (standard or extended) per ID filter Table element.
                    IDAM_0 = 0x0,
                    /// Format B Two full standard IDs or two partial 14-bit extended IDs per ID filter Table element.
                    IDAM_1 = 0x1,
                    /// Format C Four partial 8-bit IDs (standard or extended) per ID filter Table element.
                    IDAM_2 = 0x2,
                    /// Format D All frames rejected.
                    IDAM_3 = 0x3,
                },
                reserved12: u2 = 0,
                /// This bit is supplied for backwards compatibility reasons
                AEN: enum(u1) {
                    /// Abort disabled
                    AEN_0 = 0x0,
                    /// Abort enabled
                    AEN_1 = 0x1,
                },
                /// This bit is provided for backwards compatibility reasons
                LPRIOEN: enum(u1) {
                    /// Local Priority disabled
                    LPRIOEN_0 = 0x0,
                    /// Local Priority enabled
                    LPRIOEN_1 = 0x1,
                },
                reserved16: u2 = 0,
                /// This bit indicates whether Rx matching process will be based either on individual masking and queue or on masking scheme with RXMGMASK, RX14MASK and RX15MASK, RXFGMASK
                IRMQ: enum(u1) {
                    /// Individual Rx masking and queue feature are disabled.For backward compatibility, the reading of C/S word locks the MB even if it is EMPTY.
                    IRMQ_0 = 0x0,
                    /// Individual Rx masking and queue feature are enabled.
                    IRMQ_1 = 0x1,
                },
                /// This bit defines whether FlexCAN is allowed to receive frames transmitted by itself
                SRXDIS: enum(u1) {
                    /// Self reception enabled
                    SRXDIS_0 = 0x0,
                    /// Self reception disabled
                    SRXDIS_1 = 0x1,
                },
                reserved19: u1 = 0,
                /// This bit defines whether the integrated low-pass filter is applied to protect the FLEXCAN_RX input from spurious wake up
                WAKSRC: enum(u1) {
                    /// FLEXCAN uses the unfiltered FLEXCAN_RX input to detect recessive to dominant edges on the CAN bus.
                    WAKSRC_0 = 0x0,
                    /// FLEXCAN uses the filtered FLEXCAN_RX input to detect recessive to dominant edges on the CAN bus
                    WAKSRC_1 = 0x1,
                },
                /// This read-only bit indicates that FLEXCAN is either in Disable Mode or Stop Mode
                LPMACK: enum(u1) {
                    /// FLEXCAN not in any of the low power modes
                    LPMACK_0 = 0x0,
                    /// FLEXCAN is either in Disable Mode, or Stop mode
                    LPMACK_1 = 0x1,
                },
                /// When asserted, this bit enables the generation of the TWRN_INT and RWRN_INT flags in the Error and Status Register
                WRNEN: enum(u1) {
                    /// TWRN_INT and RWRN_INT bits are zero, independent of the values in the error counters.
                    WRNEN_0 = 0x0,
                    /// TWRN_INT and RWRN_INT bits are set when the respective error counter transition from <96 to >= 96.
                    WRNEN_1 = 0x1,
                },
                /// This bit enables the Self Wake Up feature when FLEXCAN is in Stop Mode
                SLFWAK: enum(u1) {
                    /// FLEXCAN Self Wake Up feature is disabled
                    SLFWAK_0 = 0x0,
                    /// FLEXCAN Self Wake Up feature is enabled
                    SLFWAK_1 = 0x1,
                },
                /// This bit configures some of the FLEXCAN registers to be either in Supervisor or User Mode
                SUPV: enum(u1) {
                    /// FlexCAN is in User Mode. Affected registers allow both Supervisor and Unrestricted accesses
                    SUPV_0 = 0x0,
                    /// FlexCAN is in Supervisor Mode. Affected registers allow only Supervisor access. Unrestricted access behaves as though the access was done to an unimplemented register location
                    SUPV_1 = 0x1,
                },
                /// This read-only bit indicates that FLEXCAN is in Freeze Mode and its prescaler is stopped
                FRZACK: enum(u1) {
                    /// FLEXCAN not in Freeze Mode, prescaler running
                    FRZACK_0 = 0x0,
                    /// FLEXCAN in Freeze Mode, prescaler stopped
                    FRZACK_1 = 0x1,
                },
                /// When this bit is asserted, FlexCAN resets its internal state machines and some of the memory mapped registers
                SOFTRST: enum(u1) {
                    /// No reset request
                    SOFTRST_0 = 0x0,
                    /// Reset the registers
                    SOFTRST_1 = 0x1,
                },
                /// This bit enables the Wake Up Interrupt generation.
                WAKMSK: enum(u1) {
                    /// Wake Up Interrupt is disabled
                    WAKMSK_0 = 0x0,
                    /// Wake Up Interrupt is enabled
                    WAKMSK_1 = 0x1,
                },
                /// This read-only bit indicates that FLEXCAN is either in Disable Mode, Stop Mode or Freeze Mode
                NOTRDY: enum(u1) {
                    /// FLEXCAN module is either in Normal Mode, Listen-Only Mode or Loop-Back Mode
                    NOTRDY_0 = 0x0,
                    /// FLEXCAN module is either in Disable Mode, Stop Mode or Freeze Mode
                    NOTRDY_1 = 0x1,
                },
                /// Assertion of this bit puts the FLEXCAN module into Freeze Mode
                HALT: enum(u1) {
                    /// No Freeze Mode request.
                    HALT_0 = 0x0,
                    /// Enters Freeze Mode if the FRZ bit is asserted.
                    HALT_1 = 0x1,
                },
                /// This bit controls whether the Rx FIFO feature is enabled or not
                RFEN: enum(u1) {
                    /// FIFO not enabled
                    RFEN_0 = 0x0,
                    /// FIFO enabled
                    RFEN_1 = 0x1,
                },
                /// The FRZ bit specifies the FLEXCAN behavior when the HALT bit in the MCR Register is set or when Debug Mode is requested at Arm level
                FRZ: enum(u1) {
                    /// Not enabled to enter Freeze Mode
                    FRZ_0 = 0x0,
                    /// Enabled to enter Freeze Mode
                    FRZ_1 = 0x1,
                },
                /// This bit controls whether FLEXCAN is enabled or not
                MDIS: enum(u1) {
                    /// Enable the FLEXCAN module
                    MDIS_0 = 0x0,
                    /// Disable the FLEXCAN module
                    MDIS_1 = 0x1,
                },
            }),
            /// Control 1 Register
            CTRL1: mmio.Mmio(packed struct(u32) {
                /// This 3-bit field defines the length of the Propagation Segment in the bit time
                PROPSEG: u3,
                /// This bit configures FLEXCAN to operate in Listen Only Mode
                LOM: enum(u1) {
                    /// Listen Only Mode is deactivated
                    LOM_0 = 0x0,
                    /// FLEXCAN module operates in Listen Only Mode
                    LOM_1 = 0x1,
                },
                /// This bit defines the ordering mechanism for Message Buffer transmission
                LBUF: enum(u1) {
                    /// Buffer with highest priority is transmitted first
                    LBUF_0 = 0x0,
                    /// Lowest number buffer is transmitted first
                    LBUF_1 = 0x1,
                },
                /// This bit enables a mechanism that resets the free-running timer each time a message is received in Message Buffer 0
                TSYN: enum(u1) {
                    /// Timer Sync feature disabled
                    TSYN_0 = 0x0,
                    /// Timer Sync feature enabled
                    TSYN_1 = 0x1,
                },
                /// This bit defines how FLEXCAN recovers from Bus Off state
                BOFFREC: enum(u1) {
                    /// Automatic recovering from Bus Off state enabled, according to CAN Spec 2.0 part B
                    BOFFREC_0 = 0x0,
                    /// Automatic recovering from Bus Off state disabled
                    BOFFREC_1 = 0x1,
                },
                /// This bit defines the sampling mode of CAN bits at the FLEXCAN_RX
                SMP: enum(u1) {
                    /// Just one sample is used to determine the bit value
                    SMP_0 = 0x0,
                    /// Three samples are used to determine the value of the received bit: the regular one (sample point) and 2 preceding samples, a majority rule is used
                    SMP_1 = 0x1,
                },
                reserved10: u2 = 0,
                /// This bit provides a mask for the Rx Warning Interrupt associated with the RWRN_INT flag in the Error and Status Register
                RWRNMSK: enum(u1) {
                    /// Rx Warning Interrupt disabled
                    RWRNMSK_0 = 0x0,
                    /// Rx Warning Interrupt enabled
                    RWRNMSK_1 = 0x1,
                },
                /// This bit provides a mask for the Tx Warning Interrupt associated with the TWRN_INT flag in the Error and Status Register
                TWRNMSK: enum(u1) {
                    /// Tx Warning Interrupt disabled
                    TWRNMSK_0 = 0x0,
                    /// Tx Warning Interrupt enabled
                    TWRNMSK_1 = 0x1,
                },
                /// This bit configures FlexCAN to operate in Loop-Back Mode
                LPB: enum(u1) {
                    /// Loop Back disabled
                    LPB_0 = 0x0,
                    /// Loop Back enabled
                    LPB_1 = 0x1,
                },
                reserved14: u1 = 0,
                /// This bit provides a mask for the Error Interrupt.
                ERRMSK: enum(u1) {
                    /// Error interrupt disabled
                    ERRMSK_0 = 0x0,
                    /// Error interrupt enabled
                    ERRMSK_1 = 0x1,
                },
                /// This bit provides a mask for the Bus Off Interrupt.
                BOFFMSK: enum(u1) {
                    /// Bus Off interrupt disabled
                    BOFFMSK_0 = 0x0,
                    /// Bus Off interrupt enabled
                    BOFFMSK_1 = 0x1,
                },
                /// This 3-bit field defines the length of Phase Buffer Segment 2 in the bit time
                PSEG2: u3,
                /// This 3-bit field defines the length of Phase Buffer Segment 1 in the bit time
                PSEG1: u3,
                /// This 2-bit field defines the maximum number of time quanta One time quantum is equal to the Sclock period
                RJW: u2,
                /// This 8-bit field defines the ratio between the PE clock frequency and the Serial Clock (Sclock) frequency
                PRESDIV: u8,
            }),
            /// Free Running Timer Register
            TIMER: mmio.Mmio(packed struct(u32) {
                /// TIMER
                TIMER: u16,
                padding: u16 = 0,
            }),
            reserved16: [4]u8,
            /// Rx Mailboxes Global Mask Register
            RXMGMASK: mmio.Mmio(packed struct(u32) {
                /// These bits mask the Mailbox filter bits as shown in the figure above
                MG: enum(u32) {
                    /// the corresponding bit in the filter is "don't care"
                    MG_0 = 0x0,
                    /// The corresponding bit in the filter is checked against the one received
                    MG_1 = 0x1,
                    _,
                },
            }),
            /// Rx Buffer 14 Mask Register
            RX14MASK: mmio.Mmio(packed struct(u32) {
                /// These bits mask Mailbox 14 filter bits in the same fashion as RXMGMASK masks other Mailboxes filters (see RXMGMASKRx Mailboxes Global Mask Register )
                RX14M: enum(u32) {
                    /// the corresponding bit in the filter is "don't care"
                    RX14M_0 = 0x0,
                    /// The corresponding bit in the filter is checked
                    RX14M_1 = 0x1,
                    _,
                },
            }),
            /// Rx Buffer 15 Mask Register
            RX15MASK: mmio.Mmio(packed struct(u32) {
                /// These bits mask Mailbox 15 filter bits in the same fashion as RXMGMASK masks other Mailboxes filters (see RXMGMASKRx Mailboxes Global Mask Register )
                RX15M: enum(u32) {
                    /// the corresponding bit in the filter is "don't care"
                    RX15M_0 = 0x0,
                    /// The corresponding bit in the filter is checked
                    RX15M_1 = 0x1,
                    _,
                },
            }),
            /// Error Counter Register
            ECR: mmio.Mmio(packed struct(u32) {
                /// Tx_Err_Counter
                TX_ERR_COUNTER: u8,
                /// Rx_Err_Counter
                RX_ERR_COUNTER: u8,
                padding: u16 = 0,
            }),
            /// Error and Status 1 Register
            ESR1: mmio.Mmio(packed struct(u32) {
                /// When FLEXCAN is Stop Mode and a recessive to dominant transition is detected on the CAN bus and if the WAK_MSK bit in the MCR Register is set, an interrupt is generated to the Arm
                WAKINT: enum(u1) {
                    /// No such occurrence
                    WAKINT_0 = 0x0,
                    /// Indicates a recessive to dominant transition received on the CAN bus when the FLEXCAN module is in Stop Mode
                    WAKINT_1 = 0x1,
                },
                /// This bit indicates that at least one of the Error Bits (bits 15-10) is set
                ERRINT: enum(u1) {
                    /// No such occurrence
                    ERRINT_0 = 0x0,
                    /// Indicates setting of any Error Bit in the Error and Status Register
                    ERRINT_1 = 0x1,
                },
                /// This bit is set when FLEXCAN enters 'Bus Off' state
                BOFFINT: enum(u1) {
                    /// No such occurrence
                    BOFFINT_0 = 0x0,
                    /// FLEXCAN module entered 'Bus Off' state
                    BOFFINT_1 = 0x1,
                },
                /// This bit indicates if FlexCAN is receiving a message. Refer to .
                RX: enum(u1) {
                    /// FLEXCAN is receiving a message
                    RX_0 = 0x0,
                    /// FLEXCAN is transmitting a message
                    RX_1 = 0x1,
                },
                reserved6: u2 = 0,
                /// This bit indicates if FLEXCAN is transmitting a message.Refer to .
                TX: enum(u1) {
                    /// FLEXCAN is receiving a message
                    TX_0 = 0x0,
                    /// FLEXCAN is transmitting a message
                    TX_1 = 0x1,
                },
                /// This bit indicates when CAN bus is in IDLE state.Refer to .
                IDLE: enum(u1) {
                    /// No such occurrence
                    IDLE_0 = 0x0,
                    /// CAN bus is now IDLE
                    IDLE_1 = 0x1,
                },
                /// This bit indicates when repetitive errors are occurring during message reception.
                RXWRN: enum(u1) {
                    /// No such occurrence
                    RXWRN_0 = 0x0,
                    /// Rx_Err_Counter >= 96
                    RXWRN_1 = 0x1,
                },
                /// This bit indicates when repetitive errors are occurring during message transmission.
                TXWRN: enum(u1) {
                    /// No such occurrence
                    TXWRN_0 = 0x0,
                    /// TX_Err_Counter >= 96
                    TXWRN_1 = 0x1,
                },
                /// This bit indicates that a Stuffing Error has been detected.
                STFERR: enum(u1) {
                    /// No such occurrence.
                    STFERR_0 = 0x0,
                    /// A Stuffing Error occurred since last read of this register.
                    STFERR_1 = 0x1,
                },
                /// This bit indicates that a Form Error has been detected by the receiver node, i
                FRMERR: enum(u1) {
                    /// No such occurrence
                    FRMERR_0 = 0x0,
                    /// A Form Error occurred since last read of this register
                    FRMERR_1 = 0x1,
                },
                /// This bit indicates that a CRC Error has been detected by the receiver node, i
                CRCERR: enum(u1) {
                    /// No such occurrence
                    CRCERR_0 = 0x0,
                    /// A CRC error occurred since last read of this register.
                    CRCERR_1 = 0x1,
                },
                /// This bit indicates that an Acknowledge Error has been detected by the transmitter node, i
                ACKERR: enum(u1) {
                    /// No such occurrence
                    ACKERR_0 = 0x0,
                    /// An ACK error occurred since last read of this register
                    ACKERR_1 = 0x1,
                },
                /// This bit indicates when an inconsistency occurs between the transmitted and the received bit in a message
                BIT0ERR: enum(u1) {
                    /// No such occurrence
                    BIT0ERR_0 = 0x0,
                    /// At least one bit sent as dominant is received as recessive
                    BIT0ERR_1 = 0x1,
                },
                /// This bit indicates when an inconsistency occurs between the transmitted and the received bit in a message
                BIT1ERR: enum(u1) {
                    /// No such occurrence
                    BIT1ERR_0 = 0x0,
                    /// At least one bit sent as recessive is received as dominant
                    BIT1ERR_1 = 0x1,
                },
                /// If the WRN_EN bit in MCR is asserted, the RWRN_INT bit is set when the RX_WRN flag transition from '0' to '1', meaning that the Rx error counters reached 96
                RWRNINT: enum(u1) {
                    /// No such occurrence
                    RWRNINT_0 = 0x0,
                    /// The Rx error counter transition from < 96 to >= 96
                    RWRNINT_1 = 0x1,
                },
                /// If the WRN_EN bit in MCR is asserted, the TWRN_INT bit is set when the TX_WRN flag transition from '0' to '1', meaning that the Tx error counter reached 96
                TWRNINT: enum(u1) {
                    /// No such occurrence
                    TWRNINT_0 = 0x0,
                    /// The Tx error counter transition from < 96 to >= 96
                    TWRNINT_1 = 0x1,
                },
                /// This read-only flag indicates whether the FlexCAN is synchronized to the CAN bus and able to participate in the communication process
                SYNCH: enum(u1) {
                    /// FlexCAN is not synchronized to the CAN bus
                    SYNCH_0 = 0x0,
                    /// FlexCAN is synchronized to the CAN bus
                    SYNCH_1 = 0x1,
                },
                padding: u13 = 0,
            }),
            /// Interrupt Masks 2 Register
            IMASK2: mmio.Mmio(packed struct(u32) {
                /// Each bit enables or disables the respective FLEXCAN Message Buffer (MB32 to MB63) Interrupt
                BUFHM: enum(u32) {
                    /// The corresponding buffer Interrupt is disabled
                    BUFHM_0 = 0x0,
                    /// The corresponding buffer Interrupt is enabled
                    BUFHM_1 = 0x1,
                    _,
                },
            }),
            /// Interrupt Masks 1 Register
            IMASK1: mmio.Mmio(packed struct(u32) {
                /// Each bit enables or disables the respective FLEXCAN Message Buffer (MB0 to MB31) Interrupt
                BUFLM: enum(u32) {
                    /// The corresponding buffer Interrupt is disabled
                    BUFLM_0 = 0x0,
                    /// The corresponding buffer Interrupt is enabled
                    BUFLM_1 = 0x1,
                    _,
                },
            }),
            /// Interrupt Flags 2 Register
            IFLAG2: mmio.Mmio(packed struct(u32) {
                /// Each bit flags the respective FLEXCAN Message Buffer (MB32 to MB63) interrupt.
                BUFHI: enum(u32) {
                    /// No such occurrence
                    BUFHI_0 = 0x0,
                    /// The corresponding buffer has successfully completed transmission or reception
                    BUFHI_1 = 0x1,
                    _,
                },
            }),
            /// Interrupt Flags 1 Register
            IFLAG1: mmio.Mmio(packed struct(u32) {
                /// If the Rx FIFO is not enabled, these bits flag the interrupts for MB0 to MB4
                BUF4TO0I: enum(u5) {
                    /// No such occurrence
                    BUF4TO0I_0 = 0x0,
                    /// Corresponding MB completed transmission/reception
                    BUF4TO0I_1 = 0x1,
                    _,
                },
                /// If the Rx FIFO is not enabled, this bit flags the interrupt for MB5
                BUF5I: enum(u1) {
                    /// No such occurrence
                    BUF5I_0 = 0x0,
                    /// MB5 completed transmission/reception or frames available in the FIFO
                    BUF5I_1 = 0x1,
                },
                /// If the Rx FIFO is not enabled, this bit flags the interrupt for MB6
                BUF6I: enum(u1) {
                    /// No such occurrence
                    BUF6I_0 = 0x0,
                    /// MB6 completed transmission/reception or FIFO almost full
                    BUF6I_1 = 0x1,
                },
                /// If the Rx FIFO is not enabled, this bit flags the interrupt for MB7
                BUF7I: enum(u1) {
                    /// No such occurrence
                    BUF7I_0 = 0x0,
                    /// MB7 completed transmission/reception or FIFO overflow
                    BUF7I_1 = 0x1,
                },
                /// Each bit flags the respective FLEXCAN Message Buffer (MB8 to MB31) interrupt.
                BUF31TO8I: enum(u24) {
                    /// No such occurrence
                    BUF31TO8I_0 = 0x0,
                    /// The corresponding MB has successfully completed transmission or reception
                    BUF31TO8I_1 = 0x1,
                    _,
                },
            }),
            /// Control 2 Register
            CTRL2: mmio.Mmio(packed struct(u32) {
                reserved16: u16 = 0,
                /// This bit controls the comparison of IDE and RTR bits within Rx Mailboxes filters with their corresponding bits in the incoming frame by the matching process
                EACEN: enum(u1) {
                    /// Rx Mailbox filter's IDE bit is always compared and RTR is never compared despite mask bits.
                    EACEN_0 = 0x0,
                    /// Enables the comparison of both Rx Mailbox filter's IDE and RTR bit with their corresponding bits within the incoming frame. Mask bits do apply.
                    EACEN_1 = 0x1,
                },
                /// If this bit is asserted Remote Request Frame is submitted to a matching process and stored in the corresponding Message Buffer in the same fashion of a Data Frame
                RRS: enum(u1) {
                    /// Remote Response Frame is generated
                    RRS_0 = 0x0,
                    /// Remote Request Frame is stored
                    RRS_1 = 0x1,
                },
                /// If this bit is set the matching process starts from the Mailboxes and if no match occurs the matching continues on the Rx FIFO
                MRP: enum(u1) {
                    /// Matching starts from Rx FIFO and continues on Mailboxes
                    MRP_0 = 0x0,
                    /// Matching starts from Mailboxes and continues on Rx FIFO
                    MRP_1 = 0x1,
                },
                /// This 5-bit field indicates how many CAN bits the Tx arbitration process start point can be delayed from the first bit of CRC field on CAN bus
                TASD: u5,
                /// This 4-bit field defines the number of Rx FIFO filters according to
                RFFN: u4,
                /// Enable unrestricted write access to FlexCAN memory in Freeze mode
                WRMFRZ: enum(u1) {
                    /// Keep the write access restricted in some regions of FlexCAN memory
                    WRMFRZ_0 = 0x0,
                    /// Enable unrestricted write access to FlexCAN memory
                    WRMFRZ_1 = 0x1,
                },
                padding: u3 = 0,
            }),
            /// Error and Status 2 Register
            ESR2: mmio.Mmio(packed struct(u32) {
                reserved13: u13 = 0,
                /// If ESR2[VPS] is asserted, this bit indicates whether there is any inactive Mailbox (CODE field is either 0b1000 or 0b0000)
                IMB: enum(u1) {
                    /// If ESR2[VPS] is asserted, the ESR2[LPTM] is not an inactive Mailbox.
                    IMB_0 = 0x0,
                    /// If ESR2[VPS] is asserted, there is at least one inactive Mailbox. LPTM content is the number of the first one.
                    IMB_1 = 0x1,
                },
                /// This bit indicates whether IMB and LPTM contents are currently valid or not
                VPS: enum(u1) {
                    /// Contents of IMB and LPTM are invalid
                    VPS_0 = 0x0,
                    /// Contents of IMB and LPTM are valid
                    VPS_1 = 0x1,
                },
                reserved16: u1 = 0,
                /// If ESR2[VPS] is asserted, his 7-bit field indicates the lowest number inactive Mailbox (refer to IMB bit description)
                LPTM: u7,
                padding: u9 = 0,
            }),
            reserved68: [8]u8,
            /// CRC Register
            CRCR: mmio.Mmio(packed struct(u32) {
                /// This field indicates the CRC value of the last message transmitted
                TXCRC: u15,
                reserved16: u1 = 0,
                /// This field indicates the number of the Mailbox corresponding to the value in TXCRC field.
                MBCRC: u7,
                padding: u9 = 0,
            }),
            /// Rx FIFO Global Mask Register
            RXFGMASK: mmio.Mmio(packed struct(u32) {
                /// These bits mask the ID Filter Table elements bits in a perfect alignment
                FGM: enum(u32) {
                    /// The corresponding bit in the filter is "don't care"
                    FGM_0 = 0x0,
                    /// The corresponding bit in the filter is checked
                    FGM_1 = 0x1,
                    _,
                },
            }),
            /// Rx FIFO Information Register
            RXFIR: mmio.Mmio(packed struct(u32) {
                /// This 9-bit field indicates which Identifier Acceptance Filter (see Rx FIFO Structure) was hit by the received message that is in the output of the Rx FIFO
                IDHIT: u9,
                padding: u23 = 0,
            }),
            reserved88: [8]u8,
            /// Debug 1 register
            DBG1: mmio.Mmio(packed struct(u32) {
                /// CAN Finite State Machine
                CFSM: u6,
                reserved24: u18 = 0,
                /// CAN Bit Number
                CBN: u5,
                padding: u3 = 0,
            }),
            /// Debug 2 register
            DBG2: mmio.Mmio(packed struct(u32) {
                /// Rx Matching Pointer
                RMP: u7,
                /// Matching Process in Progress
                MPP: enum(u1) {
                    /// No matching process ongoing.
                    MPP_0 = 0x0,
                    /// Matching process is in progress.
                    MPP_1 = 0x1,
                },
                /// Tx Arbitration Pointer
                TAP: u7,
                /// Arbitration Process in Progress
                APP: enum(u1) {
                    /// No matching process ongoing.
                    APP_0 = 0x0,
                    /// Matching process is in progress.
                    APP_1 = 0x1,
                },
                padding: u16 = 0,
            }),
            reserved2528: [2432]u8,
            /// Glitch Filter Width Registers
            GFWR: mmio.Mmio(packed struct(u32) {
                /// It determines the Glitch Filter Width
                GFWR: u8,
                padding: u24 = 0,
            }),
        };

        /// CAN
        pub const CAN3 = extern struct {
            /// Module Configuration Register
            MCR: mmio.Mmio(packed struct(u32) {
                /// Number Of The Last Message Buffer
                MAXMB: u7,
                reserved8: u1 = 0,
                /// ID Acceptance Mode
                IDAM: enum(u2) {
                    /// Format A: One full ID (standard and extended) per ID Filter Table element.
                    IDAM_0 = 0x0,
                    /// Format B: Two full standard IDs or two partial 14-bit (standard and extended) IDs per ID Filter Table element.
                    IDAM_1 = 0x1,
                    /// Format C: Four partial 8-bit Standard IDs per ID Filter Table element.
                    IDAM_2 = 0x2,
                    /// Format D: All frames rejected.
                    IDAM_3 = 0x3,
                },
                reserved11: u1 = 0,
                /// CAN FD operation enable
                FDEN: enum(u1) {
                    /// CAN FD is disabled. FlexCAN is able to receive and transmit messages in CAN 2.0 format.
                    FDEN_0 = 0x0,
                    /// CAN FD is enabled. FlexCAN is able to receive and transmit messages in both CAN FD and CAN 2.0 formats.
                    FDEN_1 = 0x1,
                },
                /// Abort Enable
                AEN: enum(u1) {
                    /// Abort disabled.
                    AEN_0 = 0x0,
                    /// Abort enabled.
                    AEN_1 = 0x1,
                },
                /// Local Priority Enable
                LPRIOEN: enum(u1) {
                    /// Local Priority disabled.
                    LPRIOEN_0 = 0x0,
                    /// Local Priority enabled.
                    LPRIOEN_1 = 0x1,
                },
                reserved15: u1 = 0,
                /// DMA Enable
                DMA: enum(u1) {
                    /// DMA feature for Legacy RX FIFO or Enhanced Rx FIFO are disabled.
                    DMA_0 = 0x0,
                    /// DMA feature for Legacy RX FIFO or Enhanced Rx FIFO are enabled.
                    DMA_1 = 0x1,
                },
                /// Individual Rx Masking And Queue Enable
                IRMQ: enum(u1) {
                    /// Individual Rx masking and queue feature are disabled. For backward compatibility with legacy applications, the reading of C/S word locks the MB even if it is EMPTY.
                    IRMQ_0 = 0x0,
                    /// Individual Rx masking and queue feature are enabled.
                    IRMQ_1 = 0x1,
                },
                /// Self Reception Disable
                SRXDIS: enum(u1) {
                    /// Self reception enabled.
                    SRXDIS_0 = 0x0,
                    /// Self reception disabled.
                    SRXDIS_1 = 0x1,
                },
                /// Doze Mode Enable
                DOZE: enum(u1) {
                    /// FlexCAN is not enabled to enter low-power mode when Doze mode is requested.
                    DOZE_0 = 0x0,
                    /// FlexCAN is enabled to enter low-power mode when Doze mode is requested.
                    DOZE_1 = 0x1,
                },
                /// Wake Up Source
                WAKSRC: enum(u1) {
                    /// FlexCAN uses the unfiltered Rx input to detect recessive to dominant edges on the CAN bus.
                    WAKSRC_0 = 0x0,
                    /// FlexCAN uses the filtered Rx input to detect recessive to dominant edges on the CAN bus.
                    WAKSRC_1 = 0x1,
                },
                /// Low-Power Mode Acknowledge
                LPMACK: enum(u1) {
                    /// FlexCAN is not in a low-power mode.
                    LPMACK_0 = 0x0,
                    /// FlexCAN is in a low-power mode.
                    LPMACK_1 = 0x1,
                },
                /// Warning Interrupt Enable
                WRNEN: enum(u1) {
                    /// TWRNINT and RWRNINT bits are zero, independent of the values in the error counters.
                    WRNEN_0 = 0x0,
                    /// TWRNINT and RWRNINT bits are set when the respective error counter transitions from less than 96 to greater than or equal to 96.
                    WRNEN_1 = 0x1,
                },
                /// Self Wake Up
                SLFWAK: enum(u1) {
                    /// FlexCAN Self Wake Up feature is disabled.
                    SLFWAK_0 = 0x0,
                    /// FlexCAN Self Wake Up feature is enabled.
                    SLFWAK_1 = 0x1,
                },
                /// Supervisor Mode
                SUPV: enum(u1) {
                    /// FlexCAN is in User mode. Affected registers allow both Supervisor and Unrestricted accesses.
                    SUPV_0 = 0x0,
                    /// FlexCAN is in Supervisor mode. Affected registers allow only Supervisor access. Unrestricted access behaves as though the access was done to an unimplemented register location.
                    SUPV_1 = 0x1,
                },
                /// Freeze Mode Acknowledge
                FRZACK: enum(u1) {
                    /// FlexCAN not in Freeze mode, prescaler running.
                    FRZACK_0 = 0x0,
                    /// FlexCAN in Freeze mode, prescaler stopped.
                    FRZACK_1 = 0x1,
                },
                /// Soft Reset
                SOFTRST: enum(u1) {
                    /// No reset request.
                    SOFTRST_0 = 0x0,
                    /// Resets the registers affected by soft reset.
                    SOFTRST_1 = 0x1,
                },
                /// Wake Up Interrupt Mask
                WAKMSK: enum(u1) {
                    /// Wake Up Interrupt is disabled.
                    WAKMSK_0 = 0x0,
                    /// Wake Up Interrupt is enabled.
                    WAKMSK_1 = 0x1,
                },
                /// FlexCAN Not Ready
                NOTRDY: enum(u1) {
                    /// FlexCAN module is either in Normal mode, Listen-Only mode or Loop-Back mode.
                    NOTRDY_0 = 0x0,
                    /// FlexCAN module is either in Disable mode, Doze mode , Stop mode or Freeze mode.
                    NOTRDY_1 = 0x1,
                },
                /// Halt FlexCAN
                HALT: enum(u1) {
                    /// No Freeze mode request.
                    HALT_0 = 0x0,
                    /// Enters Freeze mode if the FRZ bit is asserted.
                    HALT_1 = 0x1,
                },
                /// Legacy Rx FIFO Enable
                RFEN: enum(u1) {
                    /// Legacy Rx FIFO not enabled.
                    RFEN_0 = 0x0,
                    /// Legacy Rx FIFO enabled.
                    RFEN_1 = 0x1,
                },
                /// Freeze Enable
                FRZ: enum(u1) {
                    /// Not enabled to enter Freeze mode.
                    FRZ_0 = 0x0,
                    /// Enabled to enter Freeze mode.
                    FRZ_1 = 0x1,
                },
                /// Module Disable
                MDIS: enum(u1) {
                    /// Enable the FlexCAN module.
                    MDIS_0 = 0x0,
                    /// Disable the FlexCAN module.
                    MDIS_1 = 0x1,
                },
            }),
            /// Control 1 register
            CTRL1: mmio.Mmio(packed struct(u32) {
                /// Propagation Segment
                PROPSEG: u3,
                /// Listen-Only Mode
                LOM: enum(u1) {
                    /// Listen-Only mode is deactivated.
                    LOM_0 = 0x0,
                    /// FlexCAN module operates in Listen-Only mode.
                    LOM_1 = 0x1,
                },
                /// Lowest Buffer Transmitted First
                LBUF: enum(u1) {
                    /// Buffer with highest priority is transmitted first.
                    LBUF_0 = 0x0,
                    /// Lowest number buffer is transmitted first.
                    LBUF_1 = 0x1,
                },
                /// Timer Sync
                TSYN: enum(u1) {
                    /// Timer Sync feature disabled
                    TSYN_0 = 0x0,
                    /// Timer Sync feature enabled
                    TSYN_1 = 0x1,
                },
                /// Bus Off Recovery
                BOFFREC: enum(u1) {
                    /// Automatic recovering from Bus Off state enabled.
                    BOFFREC_0 = 0x0,
                    /// Automatic recovering from Bus Off state disabled.
                    BOFFREC_1 = 0x1,
                },
                /// CAN Bit Sampling
                SMP: enum(u1) {
                    /// Just one sample is used to determine the bit value.
                    SMP_0 = 0x0,
                    /// Three samples are used to determine the value of the received bit: the regular one (sample point) and 2 preceding samples; a majority rule is used.
                    SMP_1 = 0x1,
                },
                reserved10: u2 = 0,
                /// Rx Warning Interrupt Mask
                RWRNMSK: enum(u1) {
                    /// Rx Warning Interrupt disabled.
                    RWRNMSK_0 = 0x0,
                    /// Rx Warning Interrupt enabled.
                    RWRNMSK_1 = 0x1,
                },
                /// Tx Warning Interrupt Mask
                TWRNMSK: enum(u1) {
                    /// Tx Warning Interrupt disabled.
                    TWRNMSK_0 = 0x0,
                    /// Tx Warning Interrupt enabled.
                    TWRNMSK_1 = 0x1,
                },
                /// Loop Back Mode
                LPB: enum(u1) {
                    /// Loop Back disabled.
                    LPB_0 = 0x0,
                    /// Loop Back enabled.
                    LPB_1 = 0x1,
                },
                /// CAN Engine Clock Source
                CLKSRC: enum(u1) {
                    /// The CAN engine clock source is the oscillator clock. Under this condition, the oscillator clock frequency must be lower than the bus clock.
                    CLKSRC_0 = 0x0,
                    /// The CAN engine clock source is the peripheral clock.
                    CLKSRC_1 = 0x1,
                },
                /// Error Interrupt Mask
                ERRMSK: enum(u1) {
                    /// Error interrupt disabled.
                    ERRMSK_0 = 0x0,
                    /// Error interrupt enabled.
                    ERRMSK_1 = 0x1,
                },
                /// Bus Off Interrupt Mask
                BOFFMSK: enum(u1) {
                    /// Bus Off interrupt disabled.
                    BOFFMSK_0 = 0x0,
                    /// Bus Off interrupt enabled.
                    BOFFMSK_1 = 0x1,
                },
                /// Phase Segment 2
                PSEG2: u3,
                /// Phase Segment 1
                PSEG1: u3,
                /// Resync Jump Width
                RJW: u2,
                /// Prescaler Division Factor
                PRESDIV: u8,
            }),
            /// Free Running Timer
            TIMER: mmio.Mmio(packed struct(u32) {
                /// Timer Value
                TIMER: u16,
                padding: u16 = 0,
            }),
            reserved16: [4]u8,
            /// Rx Mailboxes Global Mask Register
            RXMGMASK: mmio.Mmio(packed struct(u32) {
                /// Rx Mailboxes Global Mask Bits
                MG: u32,
            }),
            /// Rx 14 Mask register
            RX14MASK: mmio.Mmio(packed struct(u32) {
                /// Rx Buffer 14 Mask Bits
                RX14M: u32,
            }),
            /// Rx 15 Mask register
            RX15MASK: mmio.Mmio(packed struct(u32) {
                /// Rx Buffer 15 Mask Bits
                RX15M: u32,
            }),
            /// Error Counter
            ECR: mmio.Mmio(packed struct(u32) {
                /// Transmit Error Counter
                TXERRCNT: u8,
                /// Receive Error Counter
                RXERRCNT: u8,
                /// Transmit Error Counter for fast bits
                TXERRCNT_FAST: u8,
                /// Receive Error Counter for fast bits
                RXERRCNT_FAST: u8,
            }),
            /// Error and Status 1 register
            ESR1: mmio.Mmio(packed struct(u32) {
                /// Wake-Up Interrupt
                WAKINT: enum(u1) {
                    /// No such occurrence.
                    WAKINT_0 = 0x0,
                    /// Indicates a recessive to dominant transition was received on the CAN bus.
                    WAKINT_1 = 0x1,
                },
                /// Error Interrupt
                ERRINT: enum(u1) {
                    /// No such occurrence.
                    ERRINT_0 = 0x0,
                    /// Indicates setting of any Error Bit in the Error and Status Register.
                    ERRINT_1 = 0x1,
                },
                /// Bus Off Interrupt
                BOFFINT: enum(u1) {
                    /// No such occurrence.
                    BOFFINT_0 = 0x0,
                    /// FlexCAN module entered Bus Off state.
                    BOFFINT_1 = 0x1,
                },
                /// FlexCAN In Reception
                RX: enum(u1) {
                    /// FlexCAN is not receiving a message.
                    RX_0 = 0x0,
                    /// FlexCAN is receiving a message.
                    RX_1 = 0x1,
                },
                reserved6: u2 = 0,
                /// FlexCAN In Transmission
                TX: enum(u1) {
                    /// FlexCAN is not transmitting a message.
                    TX_0 = 0x0,
                    /// FlexCAN is transmitting a message.
                    TX_1 = 0x1,
                },
                /// IDLE
                IDLE: enum(u1) {
                    /// No such occurrence.
                    IDLE_0 = 0x0,
                    /// CAN bus is now IDLE.
                    IDLE_1 = 0x1,
                },
                /// Rx Error Warning
                RXWRN: enum(u1) {
                    /// No such occurrence.
                    RXWRN_0 = 0x0,
                    /// RXERRCNT is greater than or equal to 96.
                    RXWRN_1 = 0x1,
                },
                /// TX Error Warning
                TXWRN: enum(u1) {
                    /// No such occurrence.
                    TXWRN_0 = 0x0,
                    /// TXERRCNT is greater than or equal to 96.
                    TXWRN_1 = 0x1,
                },
                /// Stuffing Error
                STFERR: enum(u1) {
                    /// No such occurrence.
                    STFERR_0 = 0x0,
                    /// A Stuffing Error occurred since last read of this register.
                    STFERR_1 = 0x1,
                },
                /// Form Error
                FRMERR: enum(u1) {
                    /// No such occurrence.
                    FRMERR_0 = 0x0,
                    /// A Form Error occurred since last read of this register.
                    FRMERR_1 = 0x1,
                },
                /// Cyclic Redundancy Check Error
                CRCERR: enum(u1) {
                    /// No such occurrence.
                    CRCERR_0 = 0x0,
                    /// A CRC error occurred since last read of this register.
                    CRCERR_1 = 0x1,
                },
                /// Acknowledge Error
                ACKERR: enum(u1) {
                    /// No such occurrence.
                    ACKERR_0 = 0x0,
                    /// An ACK error occurred since last read of this register.
                    ACKERR_1 = 0x1,
                },
                /// Bit0 Error
                BIT0ERR: enum(u1) {
                    /// No such occurrence.
                    BIT0ERR_0 = 0x0,
                    /// At least one bit sent as dominant is received as recessive.
                    BIT0ERR_1 = 0x1,
                },
                /// Bit1 Error
                BIT1ERR: enum(u1) {
                    /// No such occurrence.
                    BIT1ERR_0 = 0x0,
                    /// At least one bit sent as recessive is received as dominant.
                    BIT1ERR_1 = 0x1,
                },
                /// Rx Warning Interrupt Flag
                RWRNINT: enum(u1) {
                    /// No such occurrence.
                    RWRNINT_0 = 0x0,
                    /// The Rx error counter transitioned from less than 96 to greater than or equal to 96.
                    RWRNINT_1 = 0x1,
                },
                /// Tx Warning Interrupt Flag
                TWRNINT: enum(u1) {
                    /// No such occurrence.
                    TWRNINT_0 = 0x0,
                    /// The Tx error counter transitioned from less than 96 to greater than or equal to 96.
                    TWRNINT_1 = 0x1,
                },
                /// CAN Synchronization Status
                SYNCH: enum(u1) {
                    /// FlexCAN is not synchronized to the CAN bus.
                    SYNCH_0 = 0x0,
                    /// FlexCAN is synchronized to the CAN bus.
                    SYNCH_1 = 0x1,
                },
                /// Bus Off Done Interrupt
                BOFFDONEINT: enum(u1) {
                    /// No such occurrence.
                    BOFFDONEINT_0 = 0x0,
                    /// FlexCAN module has completed Bus Off process.
                    BOFFDONEINT_1 = 0x1,
                },
                /// Error Interrupt for errors detected in the Data Phase of CAN FD frames with the BRS bit set
                ERRINT_FAST: enum(u1) {
                    /// No such occurrence.
                    ERRINT_FAST_0 = 0x0,
                    /// Indicates setting of any Error Bit detected in the Data Phase of CAN FD frames with the BRS bit set.
                    ERRINT_FAST_1 = 0x1,
                },
                /// Error Overrun bit
                ERROVR: enum(u1) {
                    /// Overrun has not occurred.
                    ERROVR_0 = 0x0,
                    /// Overrun has occurred.
                    ERROVR_1 = 0x1,
                },
                reserved26: u4 = 0,
                /// Stuffing Error in the Data Phase of CAN FD frames with the BRS bit set
                STFERR_FAST: enum(u1) {
                    /// No such occurrence.
                    STFERR_FAST_0 = 0x0,
                    /// A Stuffing Error occurred since last read of this register.
                    STFERR_FAST_1 = 0x1,
                },
                /// Form Error in the Data Phase of CAN FD frames with the BRS bit set
                FRMERR_FAST: enum(u1) {
                    /// No such occurrence.
                    FRMERR_FAST_0 = 0x0,
                    /// A Form Error occurred since last read of this register.
                    FRMERR_FAST_1 = 0x1,
                },
                /// Cyclic Redundancy Check Error in the CRC field of CAN FD frames with the BRS bit set
                CRCERR_FAST: enum(u1) {
                    /// No such occurrence.
                    CRCERR_FAST_0 = 0x0,
                    /// A CRC error occurred since last read of this register.
                    CRCERR_FAST_1 = 0x1,
                },
                reserved30: u1 = 0,
                /// Bit0 Error in the Data Phase of CAN FD frames with the BRS bit set
                BIT0ERR_FAST: enum(u1) {
                    /// No such occurrence.
                    BIT0ERR_FAST_0 = 0x0,
                    /// At least one bit sent as dominant is received as recessive.
                    BIT0ERR_FAST_1 = 0x1,
                },
                /// Bit1 Error in the Data Phase of CAN FD frames with the BRS bit set
                BIT1ERR_FAST: enum(u1) {
                    /// No such occurrence.
                    BIT1ERR_FAST_0 = 0x0,
                    /// At least one bit sent as recessive is received as dominant.
                    BIT1ERR_FAST_1 = 0x1,
                },
            }),
            /// Interrupt Masks 2 register
            IMASK2: mmio.Mmio(packed struct(u32) {
                /// Buffer MB i Mask
                BUF63TO32M: u32,
            }),
            /// Interrupt Masks 1 register
            IMASK1: mmio.Mmio(packed struct(u32) {
                /// Buffer MB i Mask
                BUF31TO0M: u32,
            }),
            /// Interrupt Flags 2 register
            IFLAG2: mmio.Mmio(packed struct(u32) {
                /// Buffer MB i Interrupt
                BUF63TO32I: u32,
            }),
            /// Interrupt Flags 1 register
            IFLAG1: mmio.Mmio(packed struct(u32) {
                /// Buffer MB0 Interrupt Or Clear Legacy FIFO bit
                BUF0I: enum(u1) {
                    /// The corresponding buffer has no occurrence of successfully completed transmission or reception when CAN_MCR[RFEN]=0.
                    BUF0I_0 = 0x0,
                    /// The corresponding buffer has successfully completed transmission or reception when CAN_MCR[RFEN]=0.
                    BUF0I_1 = 0x1,
                },
                /// Buffer MB i Interrupt Or "reserved"
                BUF4TO1I: u4,
                /// Buffer MB5 Interrupt Or "Frames available in Legacy Rx FIFO"
                BUF5I: enum(u1) {
                    /// No occurrence of MB5 completing transmission/reception when CAN_MCR[RFEN]=0, or of frame(s) available in the Legacy FIFO, when CAN_MCR[RFEN]=1
                    BUF5I_0 = 0x0,
                    /// MB5 completed transmission/reception when CAN_MCR[RFEN]=0, or frame(s) available in the Legacy Rx FIFO when CAN_MCR[RFEN]=1. It generates a DMA request in case of CAN_MCR[RFEN] and CAN_MCR[DMA] are enabled.
                    BUF5I_1 = 0x1,
                },
                /// Buffer MB6 Interrupt Or "Legacy Rx FIFO Warning"
                BUF6I: enum(u1) {
                    /// No occurrence of MB6 completing transmission/reception when CAN_MCR[RFEN]=0, or of Legacy Rx FIFO almost full when CAN_MCR[RFEN]=1
                    BUF6I_0 = 0x0,
                    /// MB6 completed transmission/reception when CAN_MCR[RFEN]=0, or Legacy Rx FIFO almost full when CAN_MCR[RFEN]=1
                    BUF6I_1 = 0x1,
                },
                /// Buffer MB7 Interrupt Or "Legacy Rx FIFO Overflow"
                BUF7I: enum(u1) {
                    /// No occurrence of MB7 completing transmission/reception when CAN_MCR[RFEN]=0, or of Legacy Rx FIFO overflow when CAN_MCR[RFEN]=1
                    BUF7I_0 = 0x0,
                    /// MB7 completed transmission/reception when CAN_MCR[RFEN]=0, or Legacy Rx FIFO overflow when CAN_MCR[RFEN]=1
                    BUF7I_1 = 0x1,
                },
                /// Buffer MBi Interrupt
                BUF31TO8I: u24,
            }),
            /// Control 2 register
            CTRL2: mmio.Mmio(packed struct(u32) {
                reserved6: u6 = 0,
                /// Time Stamp Capture Point
                TSTAMPCAP: enum(u2) {
                    /// The high resolution time stamp capture is disabled
                    TSTAMPCAP_0 = 0x0,
                    /// The high resolution time stamp is captured in the end of the CAN frame
                    TSTAMPCAP_1 = 0x1,
                    /// The high resolution time stamp is captured in the start of the CAN frame
                    TSTAMPCAP_2 = 0x2,
                    /// The high resolution time stamp is captured in the start of frame for classical CAN frames and in res bit for CAN FD frames
                    TSTAMPCAP_3 = 0x3,
                },
                /// Message Buffer Time Stamp Base
                MBTSBASE: enum(u2) {
                    /// Message Buffer Time Stamp base is CAN_TIMER
                    MBTSBASE_0 = 0x0,
                    /// Message Buffer Time Stamp base is lower 16-bits of high resolution timer
                    MBTSBASE_1 = 0x1,
                    /// Message Buffer Time Stamp base is upper 16-bits of high resolution timerT
                    MBTSBASE_2 = 0x2,
                    _,
                },
                reserved11: u1 = 0,
                /// Edge Filter Disable
                EDFLTDIS: enum(u1) {
                    /// Edge Filter is enabled
                    EDFLTDIS_0 = 0x0,
                    /// Edge Filter is disabled
                    EDFLTDIS_1 = 0x1,
                },
                /// ISO CAN FD Enable
                ISOCANFDEN: enum(u1) {
                    /// FlexCAN operates using the non-ISO CAN FD protocol.
                    ISOCANFDEN_0 = 0x0,
                    /// FlexCAN operates using the ISO CAN FD protocol (ISO 11898-1).
                    ISOCANFDEN_1 = 0x1,
                },
                /// Bit Timing Expansion enable
                BTE: enum(u1) {
                    /// CAN Bit timing expansion is disabled.
                    BTE_0 = 0x0,
                    /// CAN bit timing expansion is enabled.
                    BTE_1 = 0x1,
                },
                /// Protocol Exception Enable
                PREXCEN: enum(u1) {
                    /// Protocol Exception is disabled.
                    PREXCEN_0 = 0x0,
                    /// Protocol Exception is enabled.
                    PREXCEN_1 = 0x1,
                },
                /// Timer Source
                TIMER_SRC: enum(u1) {
                    /// The Free Running Timer is clocked by the CAN bit clock, which defines the baud rate on the CAN bus.
                    TIMER_SRC_0 = 0x0,
                    /// The Free Running Timer is clocked by an external time tick. The period can be either adjusted to be equal to the baud rate on the CAN bus, or a different value as required. See the device specific section for details about the external time tick.
                    TIMER_SRC_1 = 0x1,
                },
                /// Entire Frame Arbitration Field Comparison Enable For Rx Mailboxes
                EACEN: enum(u1) {
                    /// Rx Mailbox filter's IDE bit is always compared and RTR is never compared despite mask bits.
                    EACEN_0 = 0x0,
                    /// Enables the comparison of both Rx Mailbox filter's IDE and RTR bit with their corresponding bits within the incoming frame. Mask bits do apply.
                    EACEN_1 = 0x1,
                },
                /// Remote Request Storing
                RRS: enum(u1) {
                    /// Remote Response Frame is generated.
                    RRS_0 = 0x0,
                    /// Remote Request Frame is stored.
                    RRS_1 = 0x1,
                },
                /// Mailboxes Reception Priority
                MRP: enum(u1) {
                    /// Matching starts from Legacy Rx FIFO or Enhanced Rx FIFO and continues on Mailboxes.
                    MRP_0 = 0x0,
                    /// Matching starts from Mailboxes and continues on Legacy Rx FIFO or Enhanced Rx FIFO .
                    MRP_1 = 0x1,
                },
                /// Tx Arbitration Start Delay
                TASD: u5,
                /// Number Of Legacy Rx FIFO Filters
                RFFN: u4,
                reserved30: u2 = 0,
                /// Bus Off Done Interrupt Mask
                BOFFDONEMSK: enum(u1) {
                    /// Bus Off Done interrupt disabled.
                    BOFFDONEMSK_0 = 0x0,
                    /// Bus Off Done interrupt enabled.
                    BOFFDONEMSK_1 = 0x1,
                },
                /// Error Interrupt Mask for errors detected in the Data Phase of fast CAN FD frames
                ERRMSK_FAST: enum(u1) {
                    /// ERRINT_FAST Error interrupt disabled.
                    ERRMSK_FAST_0 = 0x0,
                    /// ERRINT_FAST Error interrupt enabled.
                    ERRMSK_FAST_1 = 0x1,
                },
            }),
            /// Error and Status 2 register
            ESR2: mmio.Mmio(packed struct(u32) {
                reserved13: u13 = 0,
                /// Inactive Mailbox
                IMB: enum(u1) {
                    /// If CAN_ESR2[VPS] is asserted, the CAN_ESR2[LPTM] is not an inactive Mailbox.
                    IMB_0 = 0x0,
                    /// If CAN_ESR2[VPS] is asserted, there is at least one inactive Mailbox. LPTM content is the number of the first one.
                    IMB_1 = 0x1,
                },
                /// Valid Priority Status
                VPS: enum(u1) {
                    /// Contents of IMB and LPTM are invalid.
                    VPS_0 = 0x0,
                    /// Contents of IMB and LPTM are valid.
                    VPS_1 = 0x1,
                },
                reserved16: u1 = 0,
                /// Lowest Priority Tx Mailbox
                LPTM: u7,
                padding: u9 = 0,
            }),
            reserved68: [8]u8,
            /// CRC Register
            CRCR: mmio.Mmio(packed struct(u32) {
                /// Transmitted CRC value
                TXCRC: u15,
                reserved16: u1 = 0,
                /// CRC Mailbox
                MBCRC: u7,
                padding: u9 = 0,
            }),
            /// Legacy Rx FIFO Global Mask register
            RXFGMASK: mmio.Mmio(packed struct(u32) {
                /// Legacy Rx FIFO Global Mask Bits
                FGM: u32,
            }),
            /// Legacy Rx FIFO Information Register
            RXFIR: mmio.Mmio(packed struct(u32) {
                /// Identifier Acceptance Filter Hit Indicator
                IDHIT: u9,
                padding: u23 = 0,
            }),
            /// CAN Bit Timing Register
            CBT: mmio.Mmio(packed struct(u32) {
                /// Extended Phase Segment 2
                EPSEG2: u5,
                /// Extended Phase Segment 1
                EPSEG1: u5,
                /// Extended Propagation Segment
                EPROPSEG: u6,
                /// Extended Resync Jump Width
                ERJW: u5,
                /// Extended Prescaler Division Factor
                EPRESDIV: u10,
                /// Bit Timing Format Enable
                BTF: enum(u1) {
                    /// Extended bit time definitions disabled.
                    BTF_0 = 0x0,
                    /// Extended bit time definitions enabled.
                    BTF_1 = 0x1,
                },
            }),
            reserved128: [44]u8,
            /// Message Buffer 0 CS Register
            CS0: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 0 ID Register
            ID0: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 0 WORD_16B Register
            MB0_16B_WORD0: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_3: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_2: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_1: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_0: u8,
            }),
            /// Message Buffer 0 WORD_16B Register
            MB0_16B_WORD1: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_7: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_6: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_5: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_4: u8,
            }),
            /// Message Buffer 1 CS Register
            CS1: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 1 ID Register
            ID1: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 0 WORD_32B Register
            MB0_32B_WORD4: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_19: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_18: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_17: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_16: u8,
            }),
            /// Message Buffer 0 WORD_32B Register
            MB0_32B_WORD5: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_23: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_22: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_21: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_20: u8,
            }),
            /// Message Buffer 2 CS Register
            CS2: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 2 ID Register
            ID2: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 0 WORD_64B Register
            MB0_64B_WORD8: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_35: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_34: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_33: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_32: u8,
            }),
            /// Message Buffer 0 WORD_64B Register
            MB0_64B_WORD9: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_39: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_38: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_37: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_36: u8,
            }),
            /// Message Buffer 3 CS Register
            CS3: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 3 ID Register
            ID3: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 0 WORD_64B Register
            MB0_64B_WORD12: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_51: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_50: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_49: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_48: u8,
            }),
            /// Message Buffer 0 WORD_64B Register
            MB0_64B_WORD13: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_55: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_54: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_53: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_52: u8,
            }),
            /// Message Buffer 4 CS Register
            CS4: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 4 ID Register
            ID4: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 1 WORD_32B Register
            MB1_32B_WORD6: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_27: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_26: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_25: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_24: u8,
            }),
            /// Message Buffer 1 WORD_32B Register
            MB1_32B_WORD7: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_31: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_30: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_29: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_28: u8,
            }),
            /// Message Buffer 5 CS Register
            CS5: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 5 ID Register
            ID5: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 1 WORD_64B Register
            MB1_64B_WORD2: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_11: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_10: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_9: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_8: u8,
            }),
            /// Message Buffer 1 WORD_64B Register
            MB1_64B_WORD3: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_15: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_14: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_13: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_12: u8,
            }),
            /// Message Buffer 6 CS Register
            CS6: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 6 ID Register
            ID6: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 1 WORD_64B Register
            MB1_64B_WORD6: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_27: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_26: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_25: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_24: u8,
            }),
            /// Message Buffer 1 WORD_64B Register
            MB1_64B_WORD7: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_31: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_30: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_29: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_28: u8,
            }),
            /// Message Buffer 7 CS Register
            CS7: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 7 ID Register
            ID7: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 1 WORD_64B Register
            MB1_64B_WORD10: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_43: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_42: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_41: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_40: u8,
            }),
            /// Message Buffer 1 WORD_64B Register
            MB1_64B_WORD11: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_47: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_46: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_45: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_44: u8,
            }),
            /// Message Buffer 8 CS Register
            CS8: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 8 ID Register
            ID8: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 1 WORD_64B Register
            MB1_64B_WORD14: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_59: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_58: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_57: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_56: u8,
            }),
            /// Message Buffer 1 WORD_64B Register
            MB1_64B_WORD15: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_63: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_62: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_61: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_60: u8,
            }),
            /// Message Buffer 9 CS Register
            CS9: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 9 ID Register
            ID9: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 2 WORD_64B Register
            MB2_64B_WORD0: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_3: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_2: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_1: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_0: u8,
            }),
            /// Message Buffer 2 WORD_64B Register
            MB2_64B_WORD1: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_7: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_6: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_5: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_4: u8,
            }),
            /// Message Buffer 10 CS Register
            CS10: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 10 ID Register
            ID10: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 10 WORD_8B Register
            MB10_8B_WORD0: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_3: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_2: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_1: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_0: u8,
            }),
            /// Message Buffer 10 WORD_8B Register
            MB10_8B_WORD1: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_7: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_6: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_5: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_4: u8,
            }),
            /// Message Buffer 11 CS Register
            CS11: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 11 ID Register
            ID11: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 11 WORD_8B Register
            MB11_8B_WORD0: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_3: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_2: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_1: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_0: u8,
            }),
            /// Message Buffer 11 WORD_8B Register
            MB11_8B_WORD1: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_7: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_6: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_5: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_4: u8,
            }),
            /// Message Buffer 12 CS Register
            CS12: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 12 ID Register
            ID12: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 12 WORD_8B Register
            MB12_8B_WORD0: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_3: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_2: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_1: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_0: u8,
            }),
            /// Message Buffer 12 WORD_8B Register
            MB12_8B_WORD1: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_7: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_6: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_5: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_4: u8,
            }),
            /// Message Buffer 13 CS Register
            CS13: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 13 ID Register
            ID13: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 13 WORD_8B Register
            MB13_8B_WORD0: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_3: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_2: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_1: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_0: u8,
            }),
            /// Message Buffer 13 WORD_8B Register
            MB13_8B_WORD1: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_7: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_6: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_5: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_4: u8,
            }),
            /// Message Buffer 14 CS Register
            CS14: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 14 ID Register
            ID14: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 14 WORD_8B Register
            MB14_8B_WORD0: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_3: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_2: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_1: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_0: u8,
            }),
            /// Message Buffer 14 WORD_8B Register
            MB14_8B_WORD1: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_7: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_6: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_5: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_4: u8,
            }),
            /// Message Buffer 15 CS Register
            CS15: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 15 ID Register
            ID15: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 10 WORD_16B Register
            MB10_16B_WORD0: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_3: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_2: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_1: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_0: u8,
            }),
            /// Message Buffer 10 WORD_16B Register
            MB10_16B_WORD1: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_7: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_6: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_5: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_4: u8,
            }),
            /// Message Buffer 16 CS Register
            CS16: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 16 ID Register
            ID16: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 11 CS Register
            MB11_16B_CS: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 11 ID Register
            MB11_16B_ID: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 17 CS Register
            CS17: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 17 ID Register
            ID17: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 11 WORD_16B Register
            MB11_16B_WORD2: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_11: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_10: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_9: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_8: u8,
            }),
            /// Message Buffer 11 WORD_16B Register
            MB11_16B_WORD3: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_15: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_14: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_13: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_12: u8,
            }),
            /// Message Buffer 18 CS Register
            CS18: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 18 ID Register
            ID18: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 12 WORD_16B Register
            MB12_16B_WORD0: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_3: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_2: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_1: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_0: u8,
            }),
            /// Message Buffer 12 WORD_16B Register
            MB12_16B_WORD1: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_7: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_6: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_5: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_4: u8,
            }),
            /// Message Buffer 19 CS Register
            CS19: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 19 ID Register
            ID19: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 13 CS Register
            MB13_16B_CS: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 13 ID Register
            MB13_16B_ID: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 20 CS Register
            CS20: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 20 ID Register
            ID20: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 13 WORD_16B Register
            MB13_16B_WORD2: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_11: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_10: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_9: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_8: u8,
            }),
            /// Message Buffer 13 WORD_16B Register
            MB13_16B_WORD3: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_15: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_14: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_13: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_12: u8,
            }),
            /// Message Buffer 21 CS Register
            CS21: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 21 ID Register
            ID21: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 14 WORD_16B Register
            MB14_16B_WORD0: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_3: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_2: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_1: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_0: u8,
            }),
            /// Message Buffer 14 WORD_16B Register
            MB14_16B_WORD1: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_7: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_6: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_5: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_4: u8,
            }),
            /// Message Buffer 22 CS Register
            CS22: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 22 ID Register
            ID22: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 15 CS Register
            MB15_16B_CS: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 15 ID Register
            MB15_16B_ID: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 23 CS Register
            CS23: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 23 ID Register
            ID23: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 15 WORD_16B Register
            MB15_16B_WORD2: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_11: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_10: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_9: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_8: u8,
            }),
            /// Message Buffer 15 WORD_16B Register
            MB15_16B_WORD3: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_15: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_14: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_13: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_12: u8,
            }),
            /// Message Buffer 24 CS Register
            CS24: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 24 ID Register
            ID24: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 16 WORD_16B Register
            MB16_16B_WORD0: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_3: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_2: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_1: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_0: u8,
            }),
            /// Message Buffer 16 WORD_16B Register
            MB16_16B_WORD1: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_7: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_6: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_5: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_4: u8,
            }),
            /// Message Buffer 25 CS Register
            CS25: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 25 ID Register
            ID25: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 10 WORD_32B Register
            MB10_32B_WORD0: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_3: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_2: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_1: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_0: u8,
            }),
            /// Message Buffer 10 WORD_32B Register
            MB10_32B_WORD1: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_7: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_6: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_5: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_4: u8,
            }),
            /// Message Buffer 26 CS Register
            CS26: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 26 ID Register
            ID26: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 10 WORD_32B Register
            MB10_32B_WORD4: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_19: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_18: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_17: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_16: u8,
            }),
            /// Message Buffer 10 WORD_32B Register
            MB10_32B_WORD5: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_23: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_22: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_21: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_20: u8,
            }),
            /// Message Buffer 27 CS Register
            CS27: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 27 ID Register
            ID27: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 11 CS Register
            MB11_32B_CS: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 11 ID Register
            MB11_32B_ID: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 28 CS Register
            CS28: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 28 ID Register
            ID28: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 11 WORD_32B Register
            MB11_32B_WORD2: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_11: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_10: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_9: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_8: u8,
            }),
            /// Message Buffer 11 WORD_32B Register
            MB11_32B_WORD3: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_15: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_14: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_13: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_12: u8,
            }),
            /// Message Buffer 29 CS Register
            CS29: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 29 ID Register
            ID29: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 11 WORD_32B Register
            MB11_32B_WORD6: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_27: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_26: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_25: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_24: u8,
            }),
            /// Message Buffer 11 WORD_32B Register
            MB11_32B_WORD7: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_31: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_30: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_29: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_28: u8,
            }),
            /// Message Buffer 30 CS Register
            CS30: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 30 ID Register
            ID30: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 12 WORD_32B Register
            MB12_32B_WORD0: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_3: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_2: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_1: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_0: u8,
            }),
            /// Message Buffer 12 WORD_32B Register
            MB12_32B_WORD1: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_7: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_6: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_5: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_4: u8,
            }),
            /// Message Buffer 31 CS Register
            CS31: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 31 ID Register
            ID31: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 12 WORD_32B Register
            MB12_32B_WORD4: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_19: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_18: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_17: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_16: u8,
            }),
            /// Message Buffer 12 WORD_32B Register
            MB12_32B_WORD5: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_23: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_22: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_21: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_20: u8,
            }),
            /// Message Buffer 32 CS Register
            CS32: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 32 ID Register
            ID32: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 13 CS Register
            MB13_32B_CS: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 13 ID Register
            MB13_32B_ID: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 33 CS Register
            CS33: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 33 ID Register
            ID33: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 13 WORD_32B Register
            MB13_32B_WORD2: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_11: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_10: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_9: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_8: u8,
            }),
            /// Message Buffer 13 WORD_32B Register
            MB13_32B_WORD3: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_15: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_14: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_13: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_12: u8,
            }),
            /// Message Buffer 34 CS Register
            CS34: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 34 ID Register
            ID34: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 13 WORD_32B Register
            MB13_32B_WORD6: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_27: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_26: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_25: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_24: u8,
            }),
            /// Message Buffer 13 WORD_32B Register
            MB13_32B_WORD7: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_31: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_30: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_29: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_28: u8,
            }),
            /// Message Buffer 35 CS Register
            CS35: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 35 ID Register
            ID35: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 14 WORD_32B Register
            MB14_32B_WORD0: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_3: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_2: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_1: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_0: u8,
            }),
            /// Message Buffer 14 WORD_32B Register
            MB14_32B_WORD1: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_7: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_6: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_5: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_4: u8,
            }),
            /// Message Buffer 36 CS Register
            CS36: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 36 ID Register
            ID36: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 14 WORD_32B Register
            MB14_32B_WORD4: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_19: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_18: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_17: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_16: u8,
            }),
            /// Message Buffer 14 WORD_32B Register
            MB14_32B_WORD5: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_23: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_22: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_21: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_20: u8,
            }),
            /// Message Buffer 37 CS Register
            CS37: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 37 ID Register
            ID37: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 15 CS Register
            MB15_32B_CS: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 15 ID Register
            MB15_32B_ID: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 38 CS Register
            CS38: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 38 ID Register
            ID38: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 15 WORD_32B Register
            MB15_32B_WORD2: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_11: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_10: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_9: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_8: u8,
            }),
            /// Message Buffer 15 WORD_32B Register
            MB15_32B_WORD3: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_15: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_14: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_13: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_12: u8,
            }),
            /// Message Buffer 39 CS Register
            CS39: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 39 ID Register
            ID39: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 15 WORD_32B Register
            MB15_32B_WORD6: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_27: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_26: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_25: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_24: u8,
            }),
            /// Message Buffer 15 WORD_32B Register
            MB15_32B_WORD7: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_31: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_30: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_29: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_28: u8,
            }),
            /// Message Buffer 40 CS Register
            CS40: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 40 ID Register
            ID40: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 16 WORD_32B Register
            MB16_32B_WORD0: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_3: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_2: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_1: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_0: u8,
            }),
            /// Message Buffer 16 WORD_32B Register
            MB16_32B_WORD1: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_7: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_6: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_5: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_4: u8,
            }),
            /// Message Buffer 41 CS Register
            CS41: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 41 ID Register
            ID41: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 16 WORD_32B Register
            MB16_32B_WORD4: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_19: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_18: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_17: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_16: u8,
            }),
            /// Message Buffer 16 WORD_32B Register
            MB16_32B_WORD5: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_23: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_22: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_21: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_20: u8,
            }),
            /// Message Buffer 42 CS Register
            CS42: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 42 ID Register
            ID42: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 17 CS Register
            MB17_32B_CS: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 17 ID Register
            MB17_32B_ID: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 43 CS Register
            CS43: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 43 ID Register
            ID43: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 17 WORD_32B Register
            MB17_32B_WORD2: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_11: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_10: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_9: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_8: u8,
            }),
            /// Message Buffer 17 WORD_32B Register
            MB17_32B_WORD3: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_15: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_14: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_13: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_12: u8,
            }),
            /// Message Buffer 44 CS Register
            CS44: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 44 ID Register
            ID44: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 17 WORD_32B Register
            MB17_32B_WORD6: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_27: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_26: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_25: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_24: u8,
            }),
            /// Message Buffer 17 WORD_32B Register
            MB17_32B_WORD7: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_31: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_30: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_29: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_28: u8,
            }),
            /// Message Buffer 45 CS Register
            CS45: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 45 ID Register
            ID45: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 10 WORD_64B Register
            MB10_64B_WORD0: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_3: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_2: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_1: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_0: u8,
            }),
            /// Message Buffer 10 WORD_64B Register
            MB10_64B_WORD1: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_7: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_6: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_5: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_4: u8,
            }),
            /// Message Buffer 46 CS Register
            CS46: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 46 ID Register
            ID46: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 10 WORD_64B Register
            MB10_64B_WORD4: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_19: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_18: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_17: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_16: u8,
            }),
            /// Message Buffer 10 WORD_64B Register
            MB10_64B_WORD5: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_23: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_22: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_21: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_20: u8,
            }),
            /// Message Buffer 47 CS Register
            CS47: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 47 ID Register
            ID47: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 10 WORD_64B Register
            MB10_64B_WORD8: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_35: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_34: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_33: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_32: u8,
            }),
            /// Message Buffer 10 WORD_64B Register
            MB10_64B_WORD9: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_39: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_38: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_37: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_36: u8,
            }),
            /// Message Buffer 48 CS Register
            CS48: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 48 ID Register
            ID48: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 10 WORD_64B Register
            MB10_64B_WORD12: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_51: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_50: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_49: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_48: u8,
            }),
            /// Message Buffer 10 WORD_64B Register
            MB10_64B_WORD13: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_55: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_54: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_53: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_52: u8,
            }),
            /// Message Buffer 49 CS Register
            CS49: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 49 ID Register
            ID49: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 11 CS Register
            MB11_64B_CS: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 11 ID Register
            MB11_64B_ID: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 50 CS Register
            CS50: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 50 ID Register
            ID50: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 11 WORD_64B Register
            MB11_64B_WORD2: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_11: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_10: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_9: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_8: u8,
            }),
            /// Message Buffer 11 WORD_64B Register
            MB11_64B_WORD3: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_15: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_14: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_13: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_12: u8,
            }),
            /// Message Buffer 51 CS Register
            CS51: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 51 ID Register
            ID51: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 11 WORD_64B Register
            MB11_64B_WORD6: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_27: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_26: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_25: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_24: u8,
            }),
            /// Message Buffer 11 WORD_64B Register
            MB11_64B_WORD7: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_31: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_30: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_29: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_28: u8,
            }),
            /// Message Buffer 52 CS Register
            CS52: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 52 ID Register
            ID52: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 11 WORD_64B Register
            MB11_64B_WORD10: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_43: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_42: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_41: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_40: u8,
            }),
            /// Message Buffer 11 WORD_64B Register
            MB11_64B_WORD11: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_47: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_46: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_45: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_44: u8,
            }),
            /// Message Buffer 53 CS Register
            CS53: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 53 ID Register
            ID53: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 11 WORD_64B Register
            MB11_64B_WORD14: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_59: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_58: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_57: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_56: u8,
            }),
            /// Message Buffer 11 WORD_64B Register
            MB11_64B_WORD15: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_63: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_62: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_61: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_60: u8,
            }),
            /// Message Buffer 54 CS Register
            CS54: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 54 ID Register
            ID54: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 12 WORD_64B Register
            MB12_64B_WORD0: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_3: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_2: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_1: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_0: u8,
            }),
            /// Message Buffer 12 WORD_64B Register
            MB12_64B_WORD1: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_7: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_6: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_5: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_4: u8,
            }),
            /// Message Buffer 55 CS Register
            CS55: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 55 ID Register
            ID55: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 12 WORD_64B Register
            MB12_64B_WORD4: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_19: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_18: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_17: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_16: u8,
            }),
            /// Message Buffer 12 WORD_64B Register
            MB12_64B_WORD5: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_23: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_22: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_21: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_20: u8,
            }),
            /// Message Buffer 56 CS Register
            CS56: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 56 ID Register
            ID56: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 12 WORD_64B Register
            MB12_64B_WORD8: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_35: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_34: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_33: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_32: u8,
            }),
            /// Message Buffer 12 WORD_64B Register
            MB12_64B_WORD9: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_39: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_38: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_37: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_36: u8,
            }),
            /// Message Buffer 57 CS Register
            CS57: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 57 ID Register
            ID57: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 12 WORD_64B Register
            MB12_64B_WORD12: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_51: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_50: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_49: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_48: u8,
            }),
            /// Message Buffer 12 WORD_64B Register
            MB12_64B_WORD13: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_55: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_54: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_53: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_52: u8,
            }),
            /// Message Buffer 58 CS Register
            CS58: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 58 ID Register
            ID58: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 13 CS Register
            MB13_64B_CS: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 13 ID Register
            MB13_64B_ID: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 59 CS Register
            CS59: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 59 ID Register
            ID59: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 13 WORD_64B Register
            MB13_64B_WORD2: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_11: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_10: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_9: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_8: u8,
            }),
            /// Message Buffer 13 WORD_64B Register
            MB13_64B_WORD3: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_15: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_14: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_13: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_12: u8,
            }),
            /// Message Buffer 60 CS Register
            CS60: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 60 ID Register
            ID60: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 13 WORD_64B Register
            MB13_64B_WORD6: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_27: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_26: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_25: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_24: u8,
            }),
            /// Message Buffer 13 WORD_64B Register
            MB13_64B_WORD7: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_31: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_30: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_29: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_28: u8,
            }),
            /// Message Buffer 61 CS Register
            CS61: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 61 ID Register
            ID61: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 13 WORD_64B Register
            MB13_64B_WORD10: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_43: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_42: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_41: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_40: u8,
            }),
            /// Message Buffer 13 WORD_64B Register
            MB13_64B_WORD11: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_47: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_46: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_45: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_44: u8,
            }),
            /// Message Buffer 62 CS Register
            CS62: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 62 ID Register
            ID62: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 13 WORD_64B Register
            MB13_64B_WORD14: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_59: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_58: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_57: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_56: u8,
            }),
            /// Message Buffer 13 WORD_64B Register
            MB13_64B_WORD15: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_63: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_62: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_61: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_60: u8,
            }),
            /// Message Buffer 63 CS Register
            CS63: mmio.Mmio(packed struct(u32) {
                /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
                TIME_STAMP: u16,
                /// Length of the data to be stored/transmitted.
                DLC: u4,
                /// Remote Transmission Request. One/zero for remote/data frame.
                RTR: u1,
                /// ID Extended. One/zero for extended/standard format frame.
                IDE: u1,
                /// Substitute Remote Request. Contains a fixed recessive bit.
                SRR: u1,
                reserved24: u1 = 0,
                /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
                CODE: u4,
                reserved29: u1 = 0,
                /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
                ESI: u1,
                /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
                BRS: u1,
                /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
                EDL: u1,
            }),
            /// Message Buffer 63 ID Register
            ID63: mmio.Mmio(packed struct(u32) {
                /// Contains extended (LOW word) identifier of message buffer.
                EXT: u18,
                /// Contains standard/extended (HIGH word) identifier of message buffer.
                STD: u11,
                /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
                PRIO: u3,
            }),
            /// Message Buffer 63 WORD_8B Register
            MB63_8B_WORD0: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_3: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_2: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_1: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_0: u8,
            }),
            /// Message Buffer 63 WORD_8B Register
            MB63_8B_WORD1: mmio.Mmio(packed struct(u32) {
                /// Data byte 0 of Rx/Tx frame.
                DATA_BYTE_7: u8,
                /// Data byte 1 of Rx/Tx frame.
                DATA_BYTE_6: u8,
                /// Data byte 2 of Rx/Tx frame.
                DATA_BYTE_5: u8,
                /// Data byte 3 of Rx/Tx frame.
                DATA_BYTE_4: u8,
            }),
            reserved2176: [1024]u8,
            /// Rx Individual Mask Registers
            RXIMR: [64]mmio.Mmio(packed struct(u32) {
                /// Individual Mask Bits
                MI: u32,
            }),
            reserved3056: [624]u8,
            /// Enhanced CAN Bit Timing Prescalers
            EPRS: mmio.Mmio(packed struct(u32) {
                /// Extended Nominal Prescaler Division Factor
                ENPRESDIV: u10,
                reserved16: u6 = 0,
                /// Extended Data Phase Prescaler Division Factor
                EDPRESDIV: u10,
                padding: u6 = 0,
            }),
            /// Enhanced Nominal CAN Bit Timing
            ENCBT: mmio.Mmio(packed struct(u32) {
                /// Nominal Time Segment 1
                NTSEG1: u8,
                reserved12: u4 = 0,
                /// Nominal Time Segment 2
                NTSEG2: u7,
                reserved22: u3 = 0,
                /// Nominal Resynchronization Jump Width
                NRJW: u7,
                padding: u3 = 0,
            }),
            /// Enhanced Data Phase CAN bit Timing
            EDCBT: mmio.Mmio(packed struct(u32) {
                /// Data Phase Segment 1
                DTSEG1: u5,
                reserved12: u7 = 0,
                /// Data Phase Time Segment 2
                DTSEG2: u4,
                reserved22: u6 = 0,
                /// Data Phase Resynchronization Jump Width
                DRJW: u4,
                padding: u6 = 0,
            }),
            /// Enhanced Transceiver Delay Compensation
            ETDC: mmio.Mmio(packed struct(u32) {
                /// Enhanced Transceiver Delay Compensation Value
                ETDCVAL: u8,
                reserved16: u8 = 0,
                /// Enhanced Transceiver Delay Compensation Offset
                ETDCOFF: u7,
                reserved31: u8 = 0,
                /// Transceiver Delay Measurement Disable
                TDMDIS: enum(u1) {
                    /// TDC measurement is enabled
                    TDMDIS_0 = 0x0,
                    /// TDC measurement is disabled
                    TDMDIS_1 = 0x1,
                },
            }),
            /// CAN FD Control Register
            FDCTRL: mmio.Mmio(packed struct(u32) {
                /// Transceiver Delay Compensation Value
                TDCVAL: u6,
                reserved8: u2 = 0,
                /// Transceiver Delay Compensation Offset
                TDCOFF: u5,
                reserved14: u1 = 0,
                /// Transceiver Delay Compensation Fail
                TDCFAIL: enum(u1) {
                    /// Measured loop delay is in range.
                    TDCFAIL_0 = 0x0,
                    /// Measured loop delay is out of range.
                    TDCFAIL_1 = 0x1,
                },
                /// Transceiver Delay Compensation Enable
                TDCEN: enum(u1) {
                    /// TDC is disabled
                    TDCEN_0 = 0x0,
                    /// TDC is enabled
                    TDCEN_1 = 0x1,
                },
                /// Message Buffer Data Size for Region 0
                MBDSR0: enum(u2) {
                    /// Selects 8 bytes per Message Buffer.
                    MBDSR0_0 = 0x0,
                    /// Selects 16 bytes per Message Buffer.
                    MBDSR0_1 = 0x1,
                    /// Selects 32 bytes per Message Buffer.
                    MBDSR0_2 = 0x2,
                    /// Selects 64 bytes per Message Buffer.
                    MBDSR0_3 = 0x3,
                },
                reserved19: u1 = 0,
                /// Message Buffer Data Size for Region 1
                MBDSR1: enum(u2) {
                    /// Selects 8 bytes per Message Buffer.
                    MBDSR1_0 = 0x0,
                    /// Selects 16 bytes per Message Buffer.
                    MBDSR1_1 = 0x1,
                    /// Selects 32 bytes per Message Buffer.
                    MBDSR1_2 = 0x2,
                    /// Selects 64 bytes per Message Buffer.
                    MBDSR1_3 = 0x3,
                },
                reserved31: u10 = 0,
                /// Bit Rate Switch Enable
                FDRATE: enum(u1) {
                    /// Transmit a frame in nominal rate. The BRS bit in the Tx MB has no effect.
                    FDRATE_0 = 0x0,
                    /// Transmit a frame with bit rate switching if the BRS bit in the Tx MB is recessive.
                    FDRATE_1 = 0x1,
                },
            }),
            /// CAN FD Bit Timing Register
            FDCBT: mmio.Mmio(packed struct(u32) {
                /// Fast Phase Segment 2
                FPSEG2: u3,
                reserved5: u2 = 0,
                /// Fast Phase Segment 1
                FPSEG1: u3,
                reserved10: u2 = 0,
                /// Fast Propagation Segment
                FPROPSEG: u5,
                reserved16: u1 = 0,
                /// Fast Resync Jump Width
                FRJW: u3,
                reserved20: u1 = 0,
                /// Fast Prescaler Division Factor
                FPRESDIV: u10,
                padding: u2 = 0,
            }),
            /// CAN FD CRC Register
            FDCRC: mmio.Mmio(packed struct(u32) {
                /// Extended Transmitted CRC value
                FD_TXCRC: u21,
                reserved24: u3 = 0,
                /// CRC Mailbox Number for FD_TXCRC
                FD_MBCRC: u7,
                padding: u1 = 0,
            }),
            /// Enhanced Rx FIFO Control Register
            ERFCR: mmio.Mmio(packed struct(u32) {
                /// Enhanced Rx FIFO Watermark
                ERFWM: u5,
                reserved8: u3 = 0,
                /// Number of Enhanced Rx FIFO Filter Elements
                NFE: u6,
                reserved16: u2 = 0,
                /// Number of Extended ID Filter Elements
                NEXIF: u7,
                reserved26: u3 = 0,
                /// DMA Last Word
                DMALW: u5,
                /// Enhanced Rx FIFO enable
                ERFEN: enum(u1) {
                    /// Enhanced Rx FIFO is disabled
                    ERFEN_0 = 0x0,
                    /// Enhanced Rx FIFO is enabled
                    ERFEN_1 = 0x1,
                },
            }),
            /// Enhanced Rx FIFO Interrupt Enable register
            ERFIER: mmio.Mmio(packed struct(u32) {
                reserved28: u28 = 0,
                /// Enhanced Rx FIFO Data Available Interrupt Enable
                ERFDAIE: enum(u1) {
                    /// Enhanced Rx FIFO Data Available Interrupt is disabled
                    ERFDAIE_0 = 0x0,
                    /// Enhanced Rx FIFO Data Available Interrupt is enabled
                    ERFDAIE_1 = 0x1,
                },
                /// Enhanced Rx FIFO Watermark Indication Interrupt Enable
                ERFWMIIE: enum(u1) {
                    /// Enhanced Rx FIFO Watermark Interrupt is disabled
                    ERFWMIIE_0 = 0x0,
                    /// Enhanced Rx FIFO Watermark Interrupt is enabled
                    ERFWMIIE_1 = 0x1,
                },
                /// Enhanced Rx FIFO Overflow Interrupt Enable
                ERFOVFIE: enum(u1) {
                    /// Enhanced Rx FIFO Overflow is disabled
                    ERFOVFIE_0 = 0x0,
                    /// Enhanced Rx FIFO Overflow is enabled
                    ERFOVFIE_1 = 0x1,
                },
                /// Enhanced Rx FIFO Underflow Interrupt Enable
                ERFUFWIE: enum(u1) {
                    /// Enhanced Rx FIFO Underflow interrupt is disabled
                    ERFUFWIE_0 = 0x0,
                    /// Enhanced Rx FIFO Underflow interrupt is enabled
                    ERFUFWIE_1 = 0x1,
                },
            }),
            /// Enhanced Rx FIFO Status Register
            ERFSR: mmio.Mmio(packed struct(u32) {
                /// Enhanced Rx FIFO Elements
                ERFEL: u6,
                reserved16: u10 = 0,
                /// Enhanced Rx FIFO full
                ERFF: enum(u1) {
                    /// Enhanced Rx FIFO is not full
                    ERFF_0 = 0x0,
                    /// Enhanced Rx FIFO is full
                    ERFF_1 = 0x1,
                },
                /// Enhanced Rx FIFO empty
                ERFE: enum(u1) {
                    /// Enhanced Rx FIFO is not empty
                    ERFE_0 = 0x0,
                    /// Enhanced Rx FIFO is empty
                    ERFE_1 = 0x1,
                },
                reserved27: u9 = 0,
                /// Enhanced Rx FIFO Clear
                ERFCLR: enum(u1) {
                    /// No effect
                    ERFCLR_0 = 0x0,
                    /// Clear Enhanced Rx FIFO content
                    ERFCLR_1 = 0x1,
                },
                /// Enhanced Rx FIFO Data Available
                ERFDA: enum(u1) {
                    /// No such occurrence
                    ERFDA_0 = 0x0,
                    /// There is at least one message stored in Enhanced Rx FIFO
                    ERFDA_1 = 0x1,
                },
                /// Enhanced Rx FIFO Watermark Indication
                ERFWMI: enum(u1) {
                    /// No such occurrence
                    ERFWMI_0 = 0x0,
                    /// The number of messages in FIFO is greater than the watermark
                    ERFWMI_1 = 0x1,
                },
                /// Enhanced Rx FIFO Overflow
                ERFOVF: enum(u1) {
                    /// No such occurrence
                    ERFOVF_0 = 0x0,
                    /// Enhanced Rx FIFO overflow
                    ERFOVF_1 = 0x1,
                },
                /// Enhanced Rx FIFO Underflow
                ERFUFW: enum(u1) {
                    /// No such occurrence
                    ERFUFW_0 = 0x0,
                    /// Enhanced Rx FIFO underflow
                    ERFUFW_1 = 0x1,
                },
            }),
            reserved3120: [24]u8,
            /// High Resolution Time Stamp
            HR_TIME_STAMP: [64]mmio.Mmio(packed struct(u32) {
                /// High Resolution Time Stamp
                TS: u32,
            }),
            reserved12288: [8912]u8,
            /// Enhanced Rx FIFO Filter Element
            ERFFEL: [128]mmio.Mmio(packed struct(u32) {
                /// Filter Element Bits
                FEL: u32,
            }),
        };

        /// CCM
        pub const CCM = extern struct {
            /// CCM Control Register
            CCR: mmio.Mmio(packed struct(u32) {
                /// Oscillator ready counter value. These bits define value of 32KHz counter, that serve as counter for oscillator lock time (count to n+1 ckil's). This is used for oscillator lock time. Current estimation is ~5ms. This counter will be used in ignition sequence and in wake from stop sequence if sbyos bit was defined, to notify that on chip oscillator output is ready for the dpll_ip to use and only then the gate in dpll_ip can be opened.
                OSCNT: u8,
                reserved12: u4 = 0,
                /// On chip oscillator enable bit - this bit value is reflected on the output cosc_en
                COSC_EN: enum(u1) {
                    /// disable on chip oscillator
                    COSC_EN_0 = 0x0,
                    /// enable on chip oscillator
                    COSC_EN_1 = 0x1,
                },
                reserved21: u8 = 0,
                /// Counter for analog_reg_bypass signal assertion after standby voltage request by PMIC_STBY_REQ
                REG_BYPASS_COUNT: enum(u6) {
                    /// no delay
                    REG_BYPASS_COUNT_0 = 0x0,
                    /// 1 CKIL clock period delay
                    REG_BYPASS_COUNT_1 = 0x1,
                    /// 63 CKIL clock periods delay
                    REG_BYPASS_COUNT_63 = 0x3f,
                    _,
                },
                /// Enable for REG_BYPASS_COUNTER
                RBC_EN: enum(u1) {
                    /// REG_BYPASS_COUNTER disabled
                    RBC_EN_0 = 0x0,
                    /// REG_BYPASS_COUNTER enabled.
                    RBC_EN_1 = 0x1,
                },
                padding: u4 = 0,
            }),
            reserved8: [4]u8,
            /// CCM Status Register
            CSR: mmio.Mmio(packed struct(u32) {
                /// Status of the value of CCM_REF_EN_B output of ccm
                REF_EN_B: enum(u1) {
                    /// value of CCM_REF_EN_B is '0'
                    REF_EN_B_0 = 0x0,
                    /// value of CCM_REF_EN_B is '1'
                    REF_EN_B_1 = 0x1,
                },
                reserved3: u2 = 0,
                /// Status indication of CAMP2.
                CAMP2_READY: enum(u1) {
                    /// CAMP2 is not ready.
                    CAMP2_READY_0 = 0x0,
                    /// CAMP2 is ready.
                    CAMP2_READY_1 = 0x1,
                },
                reserved5: u1 = 0,
                /// Status indication of on board oscillator
                COSC_READY: enum(u1) {
                    /// on board oscillator is not ready.
                    COSC_READY_0 = 0x0,
                    /// on board oscillator is ready.
                    COSC_READY_1 = 0x1,
                },
                padding: u26 = 0,
            }),
            /// CCM Clock Switcher Register
            CCSR: mmio.Mmio(packed struct(u32) {
                /// Selects source to generate pll3_sw_clk. This bit should only be used for testing purposes.
                PLL3_SW_CLK_SEL: enum(u1) {
                    /// pll3_main_clk
                    PLL3_SW_CLK_SEL_0 = 0x0,
                    /// pll3 bypass clock
                    PLL3_SW_CLK_SEL_1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// CCM Arm Clock Root Register
            CACRR: mmio.Mmio(packed struct(u32) {
                /// Divider for ARM clock root
                ARM_PODF: enum(u3) {
                    /// divide by 1
                    ARM_PODF_0 = 0x0,
                    /// divide by 2
                    ARM_PODF_1 = 0x1,
                    /// divide by 3
                    ARM_PODF_2 = 0x2,
                    /// divide by 4
                    ARM_PODF_3 = 0x3,
                    /// divide by 5
                    ARM_PODF_4 = 0x4,
                    /// divide by 6
                    ARM_PODF_5 = 0x5,
                    /// divide by 7
                    ARM_PODF_6 = 0x6,
                    /// divide by 8
                    ARM_PODF_7 = 0x7,
                },
                padding: u29 = 0,
            }),
            /// CCM Bus Clock Divider Register
            CBCDR: mmio.Mmio(packed struct(u32) {
                reserved6: u6 = 0,
                /// SEMC clock source select
                SEMC_CLK_SEL: enum(u1) {
                    /// Periph_clk output will be used as SEMC clock root
                    SEMC_CLK_SEL_0 = 0x0,
                    /// SEMC alternative clock will be used as SEMC clock root
                    SEMC_CLK_SEL_1 = 0x1,
                },
                /// SEMC alternative clock select
                SEMC_ALT_CLK_SEL: enum(u1) {
                    /// PLL2 PFD2 will be selected as alternative clock for SEMC root clock
                    SEMC_ALT_CLK_SEL_0 = 0x0,
                    /// PLL3 PFD1 will be selected as alternative clock for SEMC root clock
                    SEMC_ALT_CLK_SEL_1 = 0x1,
                },
                /// Divider for ipg podf.
                IPG_PODF: enum(u2) {
                    /// divide by 1
                    IPG_PODF_0 = 0x0,
                    /// divide by 2
                    IPG_PODF_1 = 0x1,
                    /// divide by 3
                    IPG_PODF_2 = 0x2,
                    /// divide by 4
                    IPG_PODF_3 = 0x3,
                },
                /// Divider for AHB PODF
                AHB_PODF: enum(u3) {
                    /// divide by 1
                    AHB_PODF_0 = 0x0,
                    /// divide by 2
                    AHB_PODF_1 = 0x1,
                    /// divide by 3
                    AHB_PODF_2 = 0x2,
                    /// divide by 4
                    AHB_PODF_3 = 0x3,
                    /// divide by 5
                    AHB_PODF_4 = 0x4,
                    /// divide by 6
                    AHB_PODF_5 = 0x5,
                    /// divide by 7
                    AHB_PODF_6 = 0x6,
                    /// divide by 8
                    AHB_PODF_7 = 0x7,
                },
                reserved16: u3 = 0,
                /// Post divider for SEMC clock
                SEMC_PODF: enum(u3) {
                    /// divide by 1
                    SEMC_PODF_0 = 0x0,
                    /// divide by 2
                    SEMC_PODF_1 = 0x1,
                    /// divide by 3
                    SEMC_PODF_2 = 0x2,
                    /// divide by 4
                    SEMC_PODF_3 = 0x3,
                    /// divide by 5
                    SEMC_PODF_4 = 0x4,
                    /// divide by 6
                    SEMC_PODF_5 = 0x5,
                    /// divide by 7
                    SEMC_PODF_6 = 0x6,
                    /// divide by 8
                    SEMC_PODF_7 = 0x7,
                },
                reserved25: u6 = 0,
                /// Selector for peripheral main clock
                PERIPH_CLK_SEL: enum(u1) {
                    /// derive clock from pre_periph_clk_sel
                    PERIPH_CLK_SEL_0 = 0x0,
                    /// derive clock from periph_clk2_clk_divided
                    PERIPH_CLK_SEL_1 = 0x1,
                },
                reserved27: u1 = 0,
                /// Divider for periph_clk2_podf.
                PERIPH_CLK2_PODF: enum(u3) {
                    /// divide by 1
                    PERIPH_CLK2_PODF_0 = 0x0,
                    /// divide by 2
                    PERIPH_CLK2_PODF_1 = 0x1,
                    /// divide by 3
                    PERIPH_CLK2_PODF_2 = 0x2,
                    /// divide by 4
                    PERIPH_CLK2_PODF_3 = 0x3,
                    /// divide by 5
                    PERIPH_CLK2_PODF_4 = 0x4,
                    /// divide by 6
                    PERIPH_CLK2_PODF_5 = 0x5,
                    /// divide by 7
                    PERIPH_CLK2_PODF_6 = 0x6,
                    /// divide by 8
                    PERIPH_CLK2_PODF_7 = 0x7,
                },
                padding: u2 = 0,
            }),
            /// CCM Bus Clock Multiplexer Register
            CBCMR: mmio.Mmio(packed struct(u32) {
                reserved4: u4 = 0,
                /// Selector for lpspi clock multiplexer
                LPSPI_CLK_SEL: enum(u2) {
                    /// derive clock from PLL3 PFD1 clk
                    LPSPI_CLK_SEL_0 = 0x0,
                    /// derive clock from PLL3 PFD0
                    LPSPI_CLK_SEL_1 = 0x1,
                    /// derive clock from PLL2
                    LPSPI_CLK_SEL_2 = 0x2,
                    /// derive clock from PLL2 PFD2
                    LPSPI_CLK_SEL_3 = 0x3,
                },
                reserved8: u2 = 0,
                /// Selector for flexspi2 clock multiplexer
                FLEXSPI2_CLK_SEL: enum(u2) {
                    /// derive clock from PLL2 PFD2
                    FLEXSPI2_CLK_SEL_0 = 0x0,
                    /// derive clock from PLL3 PFD0
                    FLEXSPI2_CLK_SEL_1 = 0x1,
                    /// derive clock from PLL3 PFD1
                    FLEXSPI2_CLK_SEL_2 = 0x2,
                    /// derive clock from PLL2 (pll2_main_clk)
                    FLEXSPI2_CLK_SEL_3 = 0x3,
                },
                reserved12: u2 = 0,
                /// Selector for peripheral clk2 clock multiplexer
                PERIPH_CLK2_SEL: enum(u2) {
                    /// derive clock from pll3_sw_clk
                    PERIPH_CLK2_SEL_0 = 0x0,
                    /// derive clock from osc_clk (pll1_ref_clk)
                    PERIPH_CLK2_SEL_1 = 0x1,
                    /// derive clock from pll2_bypass_clk
                    PERIPH_CLK2_SEL_2 = 0x2,
                    _,
                },
                /// Selector for Trace clock multiplexer
                TRACE_CLK_SEL: enum(u2) {
                    /// derive clock from PLL2
                    TRACE_CLK_SEL_0 = 0x0,
                    /// derive clock from PLL2 PFD2
                    TRACE_CLK_SEL_1 = 0x1,
                    /// derive clock from PLL2 PFD0
                    TRACE_CLK_SEL_2 = 0x2,
                    /// derive clock from PLL2 PFD1
                    TRACE_CLK_SEL_3 = 0x3,
                },
                reserved18: u2 = 0,
                /// Selector for pre_periph clock multiplexer
                PRE_PERIPH_CLK_SEL: enum(u2) {
                    /// derive clock from PLL2
                    PRE_PERIPH_CLK_SEL_0 = 0x0,
                    /// derive clock from PLL2 PFD2
                    PRE_PERIPH_CLK_SEL_1 = 0x1,
                    /// derive clock from PLL2 PFD0
                    PRE_PERIPH_CLK_SEL_2 = 0x2,
                    /// derive clock from divided PLL1
                    PRE_PERIPH_CLK_SEL_3 = 0x3,
                },
                reserved23: u3 = 0,
                /// Post-divider for LCDIF clock.
                LCDIF_PODF: enum(u3) {
                    /// divide by 1
                    LCDIF_PODF_0 = 0x0,
                    /// divide by 2
                    LCDIF_PODF_1 = 0x1,
                    /// divide by 3
                    LCDIF_PODF_2 = 0x2,
                    /// divide by 4
                    LCDIF_PODF_3 = 0x3,
                    /// divide by 5
                    LCDIF_PODF_4 = 0x4,
                    /// divide by 6
                    LCDIF_PODF_5 = 0x5,
                    /// divide by 7
                    LCDIF_PODF_6 = 0x6,
                    /// divide by 8
                    LCDIF_PODF_7 = 0x7,
                },
                /// Divider for LPSPI. Divider should be updated when output clock is gated.
                LPSPI_PODF: enum(u3) {
                    /// divide by 1
                    LPSPI_PODF_0 = 0x0,
                    /// divide by 2
                    LPSPI_PODF_1 = 0x1,
                    /// divide by 3
                    LPSPI_PODF_2 = 0x2,
                    /// divide by 4
                    LPSPI_PODF_3 = 0x3,
                    /// divide by 5
                    LPSPI_PODF_4 = 0x4,
                    /// divide by 6
                    LPSPI_PODF_5 = 0x5,
                    /// divide by 7
                    LPSPI_PODF_6 = 0x6,
                    /// divide by 8
                    LPSPI_PODF_7 = 0x7,
                },
                /// Divider for flexspi2 clock root.
                FLEXSPI2_PODF: enum(u3) {
                    /// divide by 1
                    FLEXSPI2_PODF_0 = 0x0,
                    /// divide by 2
                    FLEXSPI2_PODF_1 = 0x1,
                    /// divide by 3
                    FLEXSPI2_PODF_2 = 0x2,
                    /// divide by 4
                    FLEXSPI2_PODF_3 = 0x3,
                    /// divide by 5
                    FLEXSPI2_PODF_4 = 0x4,
                    /// divide by 6
                    FLEXSPI2_PODF_5 = 0x5,
                    /// divide by 7
                    FLEXSPI2_PODF_6 = 0x6,
                    /// divide by 8
                    FLEXSPI2_PODF_7 = 0x7,
                },
            }),
            /// CCM Serial Clock Multiplexer Register 1
            CSCMR1: mmio.Mmio(packed struct(u32) {
                /// Divider for perclk podf.
                PERCLK_PODF: enum(u6) {
                    /// Divide by 1
                    DIVIDE_1 = 0x0,
                    /// Divide by 2
                    DIVIDE_2 = 0x1,
                    /// Divide by 3
                    DIVIDE_3 = 0x2,
                    /// Divide by 4
                    DIVIDE_4 = 0x3,
                    /// Divide by 5
                    DIVIDE_5 = 0x4,
                    /// Divide by 6
                    DIVIDE_6 = 0x5,
                    /// Divide by 7
                    DIVIDE_7 = 0x6,
                    /// Divide by 8
                    DIVIDE_8 = 0x7,
                    /// Divide by 9
                    DIVIDE_9 = 0x8,
                    /// Divide by 10
                    DIVIDE_10 = 0x9,
                    /// Divide by 11
                    DIVIDE_11 = 0xa,
                    /// Divide by 12
                    DIVIDE_12 = 0xb,
                    /// Divide by 13
                    DIVIDE_13 = 0xc,
                    /// Divide by 14
                    DIVIDE_14 = 0xd,
                    /// Divide by 15
                    DIVIDE_15 = 0xe,
                    /// Divide by 16
                    DIVIDE_16 = 0xf,
                    /// Divide by 17
                    DIVIDE_17 = 0x10,
                    /// Divide by 18
                    DIVIDE_18 = 0x11,
                    /// Divide by 19
                    DIVIDE_19 = 0x12,
                    /// Divide by 20
                    DIVIDE_20 = 0x13,
                    /// Divide by 21
                    DIVIDE_21 = 0x14,
                    /// Divide by 22
                    DIVIDE_22 = 0x15,
                    /// Divide by 23
                    DIVIDE_23 = 0x16,
                    /// Divide by 24
                    DIVIDE_24 = 0x17,
                    /// Divide by 25
                    DIVIDE_25 = 0x18,
                    /// Divide by 26
                    DIVIDE_26 = 0x19,
                    /// Divide by 27
                    DIVIDE_27 = 0x1a,
                    /// Divide by 28
                    DIVIDE_28 = 0x1b,
                    /// Divide by 29
                    DIVIDE_29 = 0x1c,
                    /// Divide by 30
                    DIVIDE_30 = 0x1d,
                    /// Divide by 31
                    DIVIDE_31 = 0x1e,
                    /// Divide by 32
                    DIVIDE_32 = 0x1f,
                    /// Divide by 33
                    DIVIDE_33 = 0x20,
                    /// Divide by 34
                    DIVIDE_34 = 0x21,
                    /// Divide by 35
                    DIVIDE_35 = 0x22,
                    /// Divide by 36
                    DIVIDE_36 = 0x23,
                    /// Divide by 37
                    DIVIDE_37 = 0x24,
                    /// Divide by 38
                    DIVIDE_38 = 0x25,
                    /// Divide by 39
                    DIVIDE_39 = 0x26,
                    /// Divide by 40
                    DIVIDE_40 = 0x27,
                    /// Divide by 41
                    DIVIDE_41 = 0x28,
                    /// Divide by 42
                    DIVIDE_42 = 0x29,
                    /// Divide by 43
                    DIVIDE_43 = 0x2a,
                    /// Divide by 44
                    DIVIDE_44 = 0x2b,
                    /// Divide by 45
                    DIVIDE_45 = 0x2c,
                    /// Divide by 46
                    DIVIDE_46 = 0x2d,
                    /// Divide by 47
                    DIVIDE_47 = 0x2e,
                    /// Divide by 48
                    DIVIDE_48 = 0x2f,
                    /// Divide by 49
                    DIVIDE_49 = 0x30,
                    /// Divide by 50
                    DIVIDE_50 = 0x31,
                    /// Divide by 51
                    DIVIDE_51 = 0x32,
                    /// Divide by 52
                    DIVIDE_52 = 0x33,
                    /// Divide by 53
                    DIVIDE_53 = 0x34,
                    /// Divide by 54
                    DIVIDE_54 = 0x35,
                    /// Divide by 55
                    DIVIDE_55 = 0x36,
                    /// Divide by 56
                    DIVIDE_56 = 0x37,
                    /// Divide by 57
                    DIVIDE_57 = 0x38,
                    /// Divide by 58
                    DIVIDE_58 = 0x39,
                    /// Divide by 59
                    DIVIDE_59 = 0x3a,
                    /// Divide by 60
                    DIVIDE_60 = 0x3b,
                    /// Divide by 61
                    DIVIDE_61 = 0x3c,
                    /// Divide by 62
                    DIVIDE_62 = 0x3d,
                    /// Divide by 63
                    DIVIDE_63 = 0x3e,
                    /// Divide by 64
                    DIVIDE_64 = 0x3f,
                },
                /// Selector for the perclk clock multiplexor
                PERCLK_CLK_SEL: enum(u1) {
                    /// derive clock from ipg clk root
                    PERCLK_CLK_SEL_0 = 0x0,
                    /// derive clock from osc_clk
                    PERCLK_CLK_SEL_1 = 0x1,
                },
                reserved10: u3 = 0,
                /// Selector for sai1 clock multiplexer
                SAI1_CLK_SEL: enum(u2) {
                    /// derive clock from PLL3 PFD2
                    SAI1_CLK_SEL_0 = 0x0,
                    /// derive clock from PLL5
                    SAI1_CLK_SEL_1 = 0x1,
                    /// derive clock from PLL4
                    SAI1_CLK_SEL_2 = 0x2,
                    _,
                },
                /// Selector for sai2 clock multiplexer
                SAI2_CLK_SEL: enum(u2) {
                    /// derive clock from PLL3 PFD2
                    SAI2_CLK_SEL_0 = 0x0,
                    /// derive clock from PLL5
                    SAI2_CLK_SEL_1 = 0x1,
                    /// derive clock from PLL4
                    SAI2_CLK_SEL_2 = 0x2,
                    _,
                },
                /// Selector for sai3/adc1/adc2 clock multiplexer
                SAI3_CLK_SEL: enum(u2) {
                    /// derive clock from PLL3 PFD2
                    SAI3_CLK_SEL_0 = 0x0,
                    /// derive clock from PLL5
                    SAI3_CLK_SEL_1 = 0x1,
                    /// derive clock from PLL4
                    SAI3_CLK_SEL_2 = 0x2,
                    _,
                },
                /// Selector for usdhc1 clock multiplexer
                USDHC1_CLK_SEL: enum(u1) {
                    /// derive clock from PLL2 PFD2
                    USDHC1_CLK_SEL_0 = 0x0,
                    /// derive clock from PLL2 PFD0
                    USDHC1_CLK_SEL_1 = 0x1,
                },
                /// Selector for usdhc2 clock multiplexer
                USDHC2_CLK_SEL: enum(u1) {
                    /// derive clock from PLL2 PFD2
                    USDHC2_CLK_SEL_0 = 0x0,
                    /// derive clock from PLL2 PFD0
                    USDHC2_CLK_SEL_1 = 0x1,
                },
                reserved23: u5 = 0,
                /// Divider for flexspi clock root.
                FLEXSPI_PODF: enum(u3) {
                    /// divide by 1
                    FLEXSPI_PODF_0 = 0x0,
                    /// divide by 2
                    FLEXSPI_PODF_1 = 0x1,
                    /// divide by 3
                    FLEXSPI_PODF_2 = 0x2,
                    /// divide by 4
                    FLEXSPI_PODF_3 = 0x3,
                    /// divide by 5
                    FLEXSPI_PODF_4 = 0x4,
                    /// divide by 6
                    FLEXSPI_PODF_5 = 0x5,
                    /// divide by 7
                    FLEXSPI_PODF_6 = 0x6,
                    /// divide by 8
                    FLEXSPI_PODF_7 = 0x7,
                },
                reserved29: u3 = 0,
                /// Selector for flexspi clock multiplexer
                FLEXSPI_CLK_SEL: enum(u2) {
                    /// derive clock from semc_clk_root_pre
                    FLEXSPI_CLK_SEL_0 = 0x0,
                    /// derive clock from pll3_sw_clk
                    FLEXSPI_CLK_SEL_1 = 0x1,
                    /// derive clock from PLL2 PFD2
                    FLEXSPI_CLK_SEL_2 = 0x2,
                    /// derive clock from PLL3 PFD0
                    FLEXSPI_CLK_SEL_3 = 0x3,
                },
                padding: u1 = 0,
            }),
            /// CCM Serial Clock Multiplexer Register 2
            CSCMR2: mmio.Mmio(packed struct(u32) {
                reserved2: u2 = 0,
                /// Divider for CAN/CANFD clock podf.
                CAN_CLK_PODF: enum(u6) {
                    /// Divide by 1
                    DIVIDE_1 = 0x0,
                    /// Divide by 2
                    DIVIDE_2 = 0x1,
                    /// Divide by 3
                    DIVIDE_3 = 0x2,
                    /// Divide by 4
                    DIVIDE_4 = 0x3,
                    /// Divide by 5
                    DIVIDE_5 = 0x4,
                    /// Divide by 6
                    DIVIDE_6 = 0x5,
                    /// Divide by 7
                    DIVIDE_7 = 0x6,
                    /// Divide by 8
                    DIVIDE_8 = 0x7,
                    /// Divide by 9
                    DIVIDE_9 = 0x8,
                    /// Divide by 10
                    DIVIDE_10 = 0x9,
                    /// Divide by 11
                    DIVIDE_11 = 0xa,
                    /// Divide by 12
                    DIVIDE_12 = 0xb,
                    /// Divide by 13
                    DIVIDE_13 = 0xc,
                    /// Divide by 14
                    DIVIDE_14 = 0xd,
                    /// Divide by 15
                    DIVIDE_15 = 0xe,
                    /// Divide by 16
                    DIVIDE_16 = 0xf,
                    /// Divide by 17
                    DIVIDE_17 = 0x10,
                    /// Divide by 18
                    DIVIDE_18 = 0x11,
                    /// Divide by 19
                    DIVIDE_19 = 0x12,
                    /// Divide by 20
                    DIVIDE_20 = 0x13,
                    /// Divide by 21
                    DIVIDE_21 = 0x14,
                    /// Divide by 22
                    DIVIDE_22 = 0x15,
                    /// Divide by 23
                    DIVIDE_23 = 0x16,
                    /// Divide by 24
                    DIVIDE_24 = 0x17,
                    /// Divide by 25
                    DIVIDE_25 = 0x18,
                    /// Divide by 26
                    DIVIDE_26 = 0x19,
                    /// Divide by 27
                    DIVIDE_27 = 0x1a,
                    /// Divide by 28
                    DIVIDE_28 = 0x1b,
                    /// Divide by 29
                    DIVIDE_29 = 0x1c,
                    /// Divide by 30
                    DIVIDE_30 = 0x1d,
                    /// Divide by 31
                    DIVIDE_31 = 0x1e,
                    /// Divide by 32
                    DIVIDE_32 = 0x1f,
                    /// Divide by 33
                    DIVIDE_33 = 0x20,
                    /// Divide by 34
                    DIVIDE_34 = 0x21,
                    /// Divide by 35
                    DIVIDE_35 = 0x22,
                    /// Divide by 36
                    DIVIDE_36 = 0x23,
                    /// Divide by 37
                    DIVIDE_37 = 0x24,
                    /// Divide by 38
                    DIVIDE_38 = 0x25,
                    /// Divide by 39
                    DIVIDE_39 = 0x26,
                    /// Divide by 40
                    DIVIDE_40 = 0x27,
                    /// Divide by 41
                    DIVIDE_41 = 0x28,
                    /// Divide by 42
                    DIVIDE_42 = 0x29,
                    /// Divide by 43
                    DIVIDE_43 = 0x2a,
                    /// Divide by 44
                    DIVIDE_44 = 0x2b,
                    /// Divide by 45
                    DIVIDE_45 = 0x2c,
                    /// Divide by 46
                    DIVIDE_46 = 0x2d,
                    /// Divide by 47
                    DIVIDE_47 = 0x2e,
                    /// Divide by 48
                    DIVIDE_48 = 0x2f,
                    /// Divide by 49
                    DIVIDE_49 = 0x30,
                    /// Divide by 50
                    DIVIDE_50 = 0x31,
                    /// Divide by 51
                    DIVIDE_51 = 0x32,
                    /// Divide by 52
                    DIVIDE_52 = 0x33,
                    /// Divide by 53
                    DIVIDE_53 = 0x34,
                    /// Divide by 54
                    DIVIDE_54 = 0x35,
                    /// Divide by 55
                    DIVIDE_55 = 0x36,
                    /// Divide by 56
                    DIVIDE_56 = 0x37,
                    /// Divide by 57
                    DIVIDE_57 = 0x38,
                    /// Divide by 58
                    DIVIDE_58 = 0x39,
                    /// Divide by 59
                    DIVIDE_59 = 0x3a,
                    /// Divide by 60
                    DIVIDE_60 = 0x3b,
                    /// Divide by 61
                    DIVIDE_61 = 0x3c,
                    /// Divide by 62
                    DIVIDE_62 = 0x3d,
                    /// Divide by 63
                    DIVIDE_63 = 0x3e,
                    /// Divide by 64
                    DIVIDE_64 = 0x3f,
                },
                /// Selector for CAN/CANFD clock multiplexer
                CAN_CLK_SEL: enum(u2) {
                    /// derive clock from pll3_sw_clk divided clock (60M)
                    CAN_CLK_SEL_0 = 0x0,
                    /// derive clock from osc_clk (24M)
                    CAN_CLK_SEL_1 = 0x1,
                    /// derive clock from pll3_sw_clk divided clock (80M)
                    CAN_CLK_SEL_2 = 0x2,
                    /// Disable FlexCAN clock
                    CAN_CLK_SEL_3 = 0x3,
                },
                reserved19: u9 = 0,
                /// Selector for flexio2/flexio3 clock multiplexer
                FLEXIO2_CLK_SEL: enum(u2) {
                    /// derive clock from PLL4 divided clock
                    FLEXIO2_CLK_SEL_0 = 0x0,
                    /// derive clock from PLL3 PFD2 clock
                    FLEXIO2_CLK_SEL_1 = 0x1,
                    /// derive clock from PLL5 clock
                    FLEXIO2_CLK_SEL_2 = 0x2,
                    /// derive clock from pll3_sw_clk
                    FLEXIO2_CLK_SEL_3 = 0x3,
                },
                padding: u11 = 0,
            }),
            /// CCM Serial Clock Divider Register 1
            CSCDR1: mmio.Mmio(packed struct(u32) {
                /// Divider for uart clock podf.
                UART_CLK_PODF: enum(u6) {
                    /// Divide by 1
                    DIVIDE_1 = 0x0,
                    /// Divide by 2
                    DIVIDE_2 = 0x1,
                    /// Divide by 3
                    DIVIDE_3 = 0x2,
                    /// Divide by 4
                    DIVIDE_4 = 0x3,
                    /// Divide by 5
                    DIVIDE_5 = 0x4,
                    /// Divide by 6
                    DIVIDE_6 = 0x5,
                    /// Divide by 7
                    DIVIDE_7 = 0x6,
                    /// Divide by 8
                    DIVIDE_8 = 0x7,
                    /// Divide by 9
                    DIVIDE_9 = 0x8,
                    /// Divide by 10
                    DIVIDE_10 = 0x9,
                    /// Divide by 11
                    DIVIDE_11 = 0xa,
                    /// Divide by 12
                    DIVIDE_12 = 0xb,
                    /// Divide by 13
                    DIVIDE_13 = 0xc,
                    /// Divide by 14
                    DIVIDE_14 = 0xd,
                    /// Divide by 15
                    DIVIDE_15 = 0xe,
                    /// Divide by 16
                    DIVIDE_16 = 0xf,
                    /// Divide by 17
                    DIVIDE_17 = 0x10,
                    /// Divide by 18
                    DIVIDE_18 = 0x11,
                    /// Divide by 19
                    DIVIDE_19 = 0x12,
                    /// Divide by 20
                    DIVIDE_20 = 0x13,
                    /// Divide by 21
                    DIVIDE_21 = 0x14,
                    /// Divide by 22
                    DIVIDE_22 = 0x15,
                    /// Divide by 23
                    DIVIDE_23 = 0x16,
                    /// Divide by 24
                    DIVIDE_24 = 0x17,
                    /// Divide by 25
                    DIVIDE_25 = 0x18,
                    /// Divide by 26
                    DIVIDE_26 = 0x19,
                    /// Divide by 27
                    DIVIDE_27 = 0x1a,
                    /// Divide by 28
                    DIVIDE_28 = 0x1b,
                    /// Divide by 29
                    DIVIDE_29 = 0x1c,
                    /// Divide by 30
                    DIVIDE_30 = 0x1d,
                    /// Divide by 31
                    DIVIDE_31 = 0x1e,
                    /// Divide by 32
                    DIVIDE_32 = 0x1f,
                    /// Divide by 33
                    DIVIDE_33 = 0x20,
                    /// Divide by 34
                    DIVIDE_34 = 0x21,
                    /// Divide by 35
                    DIVIDE_35 = 0x22,
                    /// Divide by 36
                    DIVIDE_36 = 0x23,
                    /// Divide by 37
                    DIVIDE_37 = 0x24,
                    /// Divide by 38
                    DIVIDE_38 = 0x25,
                    /// Divide by 39
                    DIVIDE_39 = 0x26,
                    /// Divide by 40
                    DIVIDE_40 = 0x27,
                    /// Divide by 41
                    DIVIDE_41 = 0x28,
                    /// Divide by 42
                    DIVIDE_42 = 0x29,
                    /// Divide by 43
                    DIVIDE_43 = 0x2a,
                    /// Divide by 44
                    DIVIDE_44 = 0x2b,
                    /// Divide by 45
                    DIVIDE_45 = 0x2c,
                    /// Divide by 46
                    DIVIDE_46 = 0x2d,
                    /// Divide by 47
                    DIVIDE_47 = 0x2e,
                    /// Divide by 48
                    DIVIDE_48 = 0x2f,
                    /// Divide by 49
                    DIVIDE_49 = 0x30,
                    /// Divide by 50
                    DIVIDE_50 = 0x31,
                    /// Divide by 51
                    DIVIDE_51 = 0x32,
                    /// Divide by 52
                    DIVIDE_52 = 0x33,
                    /// Divide by 53
                    DIVIDE_53 = 0x34,
                    /// Divide by 54
                    DIVIDE_54 = 0x35,
                    /// Divide by 55
                    DIVIDE_55 = 0x36,
                    /// Divide by 56
                    DIVIDE_56 = 0x37,
                    /// Divide by 57
                    DIVIDE_57 = 0x38,
                    /// Divide by 58
                    DIVIDE_58 = 0x39,
                    /// Divide by 59
                    DIVIDE_59 = 0x3a,
                    /// Divide by 60
                    DIVIDE_60 = 0x3b,
                    /// Divide by 61
                    DIVIDE_61 = 0x3c,
                    /// Divide by 62
                    DIVIDE_62 = 0x3d,
                    /// Divide by 63
                    DIVIDE_63 = 0x3e,
                    /// Divide by 64
                    DIVIDE_64 = 0x3f,
                },
                /// Selector for the UART clock multiplexor
                UART_CLK_SEL: enum(u1) {
                    /// derive clock from pll3_80m
                    UART_CLK_SEL_0 = 0x0,
                    /// derive clock from osc_clk
                    UART_CLK_SEL_1 = 0x1,
                },
                reserved11: u4 = 0,
                /// Divider for usdhc1 clock podf. Divider should be updated when output clock is gated.
                USDHC1_PODF: enum(u3) {
                    /// divide by 1
                    USDHC1_PODF_0 = 0x0,
                    /// divide by 2
                    USDHC1_PODF_1 = 0x1,
                    /// divide by 3
                    USDHC1_PODF_2 = 0x2,
                    /// divide by 4
                    USDHC1_PODF_3 = 0x3,
                    /// divide by 5
                    USDHC1_PODF_4 = 0x4,
                    /// divide by 6
                    USDHC1_PODF_5 = 0x5,
                    /// divide by 7
                    USDHC1_PODF_6 = 0x6,
                    /// divide by 8
                    USDHC1_PODF_7 = 0x7,
                },
                reserved16: u2 = 0,
                /// Divider for usdhc2 clock. Divider should be updated when output clock is gated.
                USDHC2_PODF: enum(u3) {
                    /// divide by 1
                    USDHC2_PODF_0 = 0x0,
                    /// divide by 2
                    USDHC2_PODF_1 = 0x1,
                    /// divide by 3
                    USDHC2_PODF_2 = 0x2,
                    /// divide by 4
                    USDHC2_PODF_3 = 0x3,
                    /// divide by 5
                    USDHC2_PODF_4 = 0x4,
                    /// divide by 6
                    USDHC2_PODF_5 = 0x5,
                    /// divide by 7
                    USDHC2_PODF_6 = 0x6,
                    /// divide by 8
                    USDHC2_PODF_7 = 0x7,
                },
                reserved25: u6 = 0,
                /// Divider for trace clock. Divider should be updated when output clock is gated.
                TRACE_PODF: enum(u2) {
                    /// divide by 1
                    TRACE_PODF_0 = 0x0,
                    /// divide by 2
                    TRACE_PODF_1 = 0x1,
                    /// divide by 3
                    TRACE_PODF_2 = 0x2,
                    /// divide by 4
                    TRACE_PODF_3 = 0x3,
                },
                padding: u5 = 0,
            }),
            /// CCM Clock Divider Register
            CS1CDR: mmio.Mmio(packed struct(u32) {
                /// Divider for sai1 clock podf. The input clock to this divider should be lower than 300Mhz, the predivider can be used to achieve this.
                SAI1_CLK_PODF: enum(u6) {
                    /// Divide by 1
                    DIVIDE_1 = 0x0,
                    /// Divide by 2
                    DIVIDE_2 = 0x1,
                    /// Divide by 3
                    DIVIDE_3 = 0x2,
                    /// Divide by 4
                    DIVIDE_4 = 0x3,
                    /// Divide by 5
                    DIVIDE_5 = 0x4,
                    /// Divide by 6
                    DIVIDE_6 = 0x5,
                    /// Divide by 7
                    DIVIDE_7 = 0x6,
                    /// Divide by 8
                    DIVIDE_8 = 0x7,
                    /// Divide by 9
                    DIVIDE_9 = 0x8,
                    /// Divide by 10
                    DIVIDE_10 = 0x9,
                    /// Divide by 11
                    DIVIDE_11 = 0xa,
                    /// Divide by 12
                    DIVIDE_12 = 0xb,
                    /// Divide by 13
                    DIVIDE_13 = 0xc,
                    /// Divide by 14
                    DIVIDE_14 = 0xd,
                    /// Divide by 15
                    DIVIDE_15 = 0xe,
                    /// Divide by 16
                    DIVIDE_16 = 0xf,
                    /// Divide by 17
                    DIVIDE_17 = 0x10,
                    /// Divide by 18
                    DIVIDE_18 = 0x11,
                    /// Divide by 19
                    DIVIDE_19 = 0x12,
                    /// Divide by 20
                    DIVIDE_20 = 0x13,
                    /// Divide by 21
                    DIVIDE_21 = 0x14,
                    /// Divide by 22
                    DIVIDE_22 = 0x15,
                    /// Divide by 23
                    DIVIDE_23 = 0x16,
                    /// Divide by 24
                    DIVIDE_24 = 0x17,
                    /// Divide by 25
                    DIVIDE_25 = 0x18,
                    /// Divide by 26
                    DIVIDE_26 = 0x19,
                    /// Divide by 27
                    DIVIDE_27 = 0x1a,
                    /// Divide by 28
                    DIVIDE_28 = 0x1b,
                    /// Divide by 29
                    DIVIDE_29 = 0x1c,
                    /// Divide by 30
                    DIVIDE_30 = 0x1d,
                    /// Divide by 31
                    DIVIDE_31 = 0x1e,
                    /// Divide by 32
                    DIVIDE_32 = 0x1f,
                    /// Divide by 33
                    DIVIDE_33 = 0x20,
                    /// Divide by 34
                    DIVIDE_34 = 0x21,
                    /// Divide by 35
                    DIVIDE_35 = 0x22,
                    /// Divide by 36
                    DIVIDE_36 = 0x23,
                    /// Divide by 37
                    DIVIDE_37 = 0x24,
                    /// Divide by 38
                    DIVIDE_38 = 0x25,
                    /// Divide by 39
                    DIVIDE_39 = 0x26,
                    /// Divide by 40
                    DIVIDE_40 = 0x27,
                    /// Divide by 41
                    DIVIDE_41 = 0x28,
                    /// Divide by 42
                    DIVIDE_42 = 0x29,
                    /// Divide by 43
                    DIVIDE_43 = 0x2a,
                    /// Divide by 44
                    DIVIDE_44 = 0x2b,
                    /// Divide by 45
                    DIVIDE_45 = 0x2c,
                    /// Divide by 46
                    DIVIDE_46 = 0x2d,
                    /// Divide by 47
                    DIVIDE_47 = 0x2e,
                    /// Divide by 48
                    DIVIDE_48 = 0x2f,
                    /// Divide by 49
                    DIVIDE_49 = 0x30,
                    /// Divide by 50
                    DIVIDE_50 = 0x31,
                    /// Divide by 51
                    DIVIDE_51 = 0x32,
                    /// Divide by 52
                    DIVIDE_52 = 0x33,
                    /// Divide by 53
                    DIVIDE_53 = 0x34,
                    /// Divide by 54
                    DIVIDE_54 = 0x35,
                    /// Divide by 55
                    DIVIDE_55 = 0x36,
                    /// Divide by 56
                    DIVIDE_56 = 0x37,
                    /// Divide by 57
                    DIVIDE_57 = 0x38,
                    /// Divide by 58
                    DIVIDE_58 = 0x39,
                    /// Divide by 59
                    DIVIDE_59 = 0x3a,
                    /// Divide by 60
                    DIVIDE_60 = 0x3b,
                    /// Divide by 61
                    DIVIDE_61 = 0x3c,
                    /// Divide by 62
                    DIVIDE_62 = 0x3d,
                    /// Divide by 63
                    DIVIDE_63 = 0x3e,
                    /// Divide by 64
                    DIVIDE_64 = 0x3f,
                },
                /// Divider for sai1 clock pred.
                SAI1_CLK_PRED: enum(u3) {
                    /// divide by 1
                    SAI1_CLK_PRED_0 = 0x0,
                    /// divide by 2
                    SAI1_CLK_PRED_1 = 0x1,
                    /// divide by 3
                    SAI1_CLK_PRED_2 = 0x2,
                    /// divide by 4
                    SAI1_CLK_PRED_3 = 0x3,
                    /// divide by 5
                    SAI1_CLK_PRED_4 = 0x4,
                    /// divide by 6
                    SAI1_CLK_PRED_5 = 0x5,
                    /// divide by 7
                    SAI1_CLK_PRED_6 = 0x6,
                    /// divide by 8
                    SAI1_CLK_PRED_7 = 0x7,
                },
                /// Divider for flexio2/flexio3 clock.
                FLEXIO2_CLK_PRED: enum(u3) {
                    /// divide by 1
                    FLEXIO2_CLK_PRED_0 = 0x0,
                    /// divide by 2
                    FLEXIO2_CLK_PRED_1 = 0x1,
                    /// divide by 3
                    FLEXIO2_CLK_PRED_2 = 0x2,
                    /// divide by 4
                    FLEXIO2_CLK_PRED_3 = 0x3,
                    /// divide by 5
                    FLEXIO2_CLK_PRED_4 = 0x4,
                    /// divide by 6
                    FLEXIO2_CLK_PRED_5 = 0x5,
                    /// divide by 7
                    FLEXIO2_CLK_PRED_6 = 0x6,
                    /// divide by 8
                    FLEXIO2_CLK_PRED_7 = 0x7,
                },
                reserved16: u4 = 0,
                /// Divider for sai3 clock podf. The input clock to this divider should be lower than 300Mhz, the predivider can be used to achieve this.
                SAI3_CLK_PODF: enum(u6) {
                    /// Divide by 1
                    DIVIDE_1 = 0x0,
                    /// Divide by 2
                    DIVIDE_2 = 0x1,
                    /// Divide by 3
                    DIVIDE_3 = 0x2,
                    /// Divide by 4
                    DIVIDE_4 = 0x3,
                    /// Divide by 5
                    DIVIDE_5 = 0x4,
                    /// Divide by 6
                    DIVIDE_6 = 0x5,
                    /// Divide by 7
                    DIVIDE_7 = 0x6,
                    /// Divide by 8
                    DIVIDE_8 = 0x7,
                    /// Divide by 9
                    DIVIDE_9 = 0x8,
                    /// Divide by 10
                    DIVIDE_10 = 0x9,
                    /// Divide by 11
                    DIVIDE_11 = 0xa,
                    /// Divide by 12
                    DIVIDE_12 = 0xb,
                    /// Divide by 13
                    DIVIDE_13 = 0xc,
                    /// Divide by 14
                    DIVIDE_14 = 0xd,
                    /// Divide by 15
                    DIVIDE_15 = 0xe,
                    /// Divide by 16
                    DIVIDE_16 = 0xf,
                    /// Divide by 17
                    DIVIDE_17 = 0x10,
                    /// Divide by 18
                    DIVIDE_18 = 0x11,
                    /// Divide by 19
                    DIVIDE_19 = 0x12,
                    /// Divide by 20
                    DIVIDE_20 = 0x13,
                    /// Divide by 21
                    DIVIDE_21 = 0x14,
                    /// Divide by 22
                    DIVIDE_22 = 0x15,
                    /// Divide by 23
                    DIVIDE_23 = 0x16,
                    /// Divide by 24
                    DIVIDE_24 = 0x17,
                    /// Divide by 25
                    DIVIDE_25 = 0x18,
                    /// Divide by 26
                    DIVIDE_26 = 0x19,
                    /// Divide by 27
                    DIVIDE_27 = 0x1a,
                    /// Divide by 28
                    DIVIDE_28 = 0x1b,
                    /// Divide by 29
                    DIVIDE_29 = 0x1c,
                    /// Divide by 30
                    DIVIDE_30 = 0x1d,
                    /// Divide by 31
                    DIVIDE_31 = 0x1e,
                    /// Divide by 32
                    DIVIDE_32 = 0x1f,
                    /// Divide by 33
                    DIVIDE_33 = 0x20,
                    /// Divide by 34
                    DIVIDE_34 = 0x21,
                    /// Divide by 35
                    DIVIDE_35 = 0x22,
                    /// Divide by 36
                    DIVIDE_36 = 0x23,
                    /// Divide by 37
                    DIVIDE_37 = 0x24,
                    /// Divide by 38
                    DIVIDE_38 = 0x25,
                    /// Divide by 39
                    DIVIDE_39 = 0x26,
                    /// Divide by 40
                    DIVIDE_40 = 0x27,
                    /// Divide by 41
                    DIVIDE_41 = 0x28,
                    /// Divide by 42
                    DIVIDE_42 = 0x29,
                    /// Divide by 43
                    DIVIDE_43 = 0x2a,
                    /// Divide by 44
                    DIVIDE_44 = 0x2b,
                    /// Divide by 45
                    DIVIDE_45 = 0x2c,
                    /// Divide by 46
                    DIVIDE_46 = 0x2d,
                    /// Divide by 47
                    DIVIDE_47 = 0x2e,
                    /// Divide by 48
                    DIVIDE_48 = 0x2f,
                    /// Divide by 49
                    DIVIDE_49 = 0x30,
                    /// Divide by 50
                    DIVIDE_50 = 0x31,
                    /// Divide by 51
                    DIVIDE_51 = 0x32,
                    /// Divide by 52
                    DIVIDE_52 = 0x33,
                    /// Divide by 53
                    DIVIDE_53 = 0x34,
                    /// Divide by 54
                    DIVIDE_54 = 0x35,
                    /// Divide by 55
                    DIVIDE_55 = 0x36,
                    /// Divide by 56
                    DIVIDE_56 = 0x37,
                    /// Divide by 57
                    DIVIDE_57 = 0x38,
                    /// Divide by 58
                    DIVIDE_58 = 0x39,
                    /// Divide by 59
                    DIVIDE_59 = 0x3a,
                    /// Divide by 60
                    DIVIDE_60 = 0x3b,
                    /// Divide by 61
                    DIVIDE_61 = 0x3c,
                    /// Divide by 62
                    DIVIDE_62 = 0x3d,
                    /// Divide by 63
                    DIVIDE_63 = 0x3e,
                    /// Divide by 64
                    DIVIDE_64 = 0x3f,
                },
                /// Divider for sai3/adc1/adc2 clock pred.
                SAI3_CLK_PRED: enum(u3) {
                    /// divide by 1
                    SAI3_CLK_PRED_0 = 0x0,
                    /// divide by 2
                    SAI3_CLK_PRED_1 = 0x1,
                    /// divide by 3
                    SAI3_CLK_PRED_2 = 0x2,
                    /// divide by 4
                    SAI3_CLK_PRED_3 = 0x3,
                    /// divide by 5
                    SAI3_CLK_PRED_4 = 0x4,
                    /// divide by 6
                    SAI3_CLK_PRED_5 = 0x5,
                    /// divide by 7
                    SAI3_CLK_PRED_6 = 0x6,
                    /// divide by 8
                    SAI3_CLK_PRED_7 = 0x7,
                },
                /// Divider for flexio2/flexio3 clock. Divider should be updated when output clock is gated.
                FLEXIO2_CLK_PODF: enum(u3) {
                    /// Divide by 1
                    DIVIDE_1 = 0x0,
                    /// Divide by 2
                    DIVIDE_2 = 0x1,
                    /// Divide by 3
                    DIVIDE_3 = 0x2,
                    /// Divide by 4
                    DIVIDE_4 = 0x3,
                    /// Divide by 5
                    DIVIDE_5 = 0x4,
                    /// Divide by 6
                    DIVIDE_6 = 0x5,
                    /// Divide by 7
                    DIVIDE_7 = 0x6,
                    /// Divide by 8
                    DIVIDE_8 = 0x7,
                },
                padding: u4 = 0,
            }),
            /// CCM Clock Divider Register
            CS2CDR: mmio.Mmio(packed struct(u32) {
                /// Divider for sai2 clock podf. The input clock to this divider should be lower than 300Mhz, the predivider can be used to achieve this.
                SAI2_CLK_PODF: enum(u6) {
                    /// Divide by 1
                    DIVIDE_1 = 0x0,
                    /// Divide by 2
                    DIVIDE_2 = 0x1,
                    /// Divide by 3
                    DIVIDE_3 = 0x2,
                    /// Divide by 4
                    DIVIDE_4 = 0x3,
                    /// Divide by 5
                    DIVIDE_5 = 0x4,
                    /// Divide by 6
                    DIVIDE_6 = 0x5,
                    /// Divide by 7
                    DIVIDE_7 = 0x6,
                    /// Divide by 8
                    DIVIDE_8 = 0x7,
                    /// Divide by 9
                    DIVIDE_9 = 0x8,
                    /// Divide by 10
                    DIVIDE_10 = 0x9,
                    /// Divide by 11
                    DIVIDE_11 = 0xa,
                    /// Divide by 12
                    DIVIDE_12 = 0xb,
                    /// Divide by 13
                    DIVIDE_13 = 0xc,
                    /// Divide by 14
                    DIVIDE_14 = 0xd,
                    /// Divide by 15
                    DIVIDE_15 = 0xe,
                    /// Divide by 16
                    DIVIDE_16 = 0xf,
                    /// Divide by 17
                    DIVIDE_17 = 0x10,
                    /// Divide by 18
                    DIVIDE_18 = 0x11,
                    /// Divide by 19
                    DIVIDE_19 = 0x12,
                    /// Divide by 20
                    DIVIDE_20 = 0x13,
                    /// Divide by 21
                    DIVIDE_21 = 0x14,
                    /// Divide by 22
                    DIVIDE_22 = 0x15,
                    /// Divide by 23
                    DIVIDE_23 = 0x16,
                    /// Divide by 24
                    DIVIDE_24 = 0x17,
                    /// Divide by 25
                    DIVIDE_25 = 0x18,
                    /// Divide by 26
                    DIVIDE_26 = 0x19,
                    /// Divide by 27
                    DIVIDE_27 = 0x1a,
                    /// Divide by 28
                    DIVIDE_28 = 0x1b,
                    /// Divide by 29
                    DIVIDE_29 = 0x1c,
                    /// Divide by 30
                    DIVIDE_30 = 0x1d,
                    /// Divide by 31
                    DIVIDE_31 = 0x1e,
                    /// Divide by 32
                    DIVIDE_32 = 0x1f,
                    /// Divide by 33
                    DIVIDE_33 = 0x20,
                    /// Divide by 34
                    DIVIDE_34 = 0x21,
                    /// Divide by 35
                    DIVIDE_35 = 0x22,
                    /// Divide by 36
                    DIVIDE_36 = 0x23,
                    /// Divide by 37
                    DIVIDE_37 = 0x24,
                    /// Divide by 38
                    DIVIDE_38 = 0x25,
                    /// Divide by 39
                    DIVIDE_39 = 0x26,
                    /// Divide by 40
                    DIVIDE_40 = 0x27,
                    /// Divide by 41
                    DIVIDE_41 = 0x28,
                    /// Divide by 42
                    DIVIDE_42 = 0x29,
                    /// Divide by 43
                    DIVIDE_43 = 0x2a,
                    /// Divide by 44
                    DIVIDE_44 = 0x2b,
                    /// Divide by 45
                    DIVIDE_45 = 0x2c,
                    /// Divide by 46
                    DIVIDE_46 = 0x2d,
                    /// Divide by 47
                    DIVIDE_47 = 0x2e,
                    /// Divide by 48
                    DIVIDE_48 = 0x2f,
                    /// Divide by 49
                    DIVIDE_49 = 0x30,
                    /// Divide by 50
                    DIVIDE_50 = 0x31,
                    /// Divide by 51
                    DIVIDE_51 = 0x32,
                    /// Divide by 52
                    DIVIDE_52 = 0x33,
                    /// Divide by 53
                    DIVIDE_53 = 0x34,
                    /// Divide by 54
                    DIVIDE_54 = 0x35,
                    /// Divide by 55
                    DIVIDE_55 = 0x36,
                    /// Divide by 56
                    DIVIDE_56 = 0x37,
                    /// Divide by 57
                    DIVIDE_57 = 0x38,
                    /// Divide by 58
                    DIVIDE_58 = 0x39,
                    /// Divide by 59
                    DIVIDE_59 = 0x3a,
                    /// Divide by 60
                    DIVIDE_60 = 0x3b,
                    /// Divide by 61
                    DIVIDE_61 = 0x3c,
                    /// Divide by 62
                    DIVIDE_62 = 0x3d,
                    /// Divide by 63
                    DIVIDE_63 = 0x3e,
                    /// Divide by 64
                    DIVIDE_64 = 0x3f,
                },
                /// Divider for sai2 clock pred.Divider should be updated when output clock is gated.
                SAI2_CLK_PRED: enum(u3) {
                    /// divide by 1
                    SAI2_CLK_PRED_0 = 0x0,
                    /// divide by 2
                    SAI2_CLK_PRED_1 = 0x1,
                    /// divide by 3
                    SAI2_CLK_PRED_2 = 0x2,
                    /// divide by 4
                    SAI2_CLK_PRED_3 = 0x3,
                    /// divide by 5
                    SAI2_CLK_PRED_4 = 0x4,
                    /// divide by 6
                    SAI2_CLK_PRED_5 = 0x5,
                    /// divide by 7
                    SAI2_CLK_PRED_6 = 0x6,
                    /// divide by 8
                    SAI2_CLK_PRED_7 = 0x7,
                },
                padding: u23 = 0,
            }),
            /// CCM D1 Clock Divider Register
            CDCDR: mmio.Mmio(packed struct(u32) {
                reserved7: u7 = 0,
                /// Selector for flexio1 clock multiplexer
                FLEXIO1_CLK_SEL: enum(u2) {
                    /// derive clock from PLL4
                    FLEXIO1_CLK_SEL_0 = 0x0,
                    /// derive clock from PLL3 PFD2
                    FLEXIO1_CLK_SEL_1 = 0x1,
                    /// derive clock from PLL5
                    FLEXIO1_CLK_SEL_2 = 0x2,
                    /// derive clock from pll3_sw_clk
                    FLEXIO1_CLK_SEL_3 = 0x3,
                },
                /// Divider for flexio1 clock podf. Divider should be updated when output clock is gated.
                FLEXIO1_CLK_PODF: enum(u3) {
                    /// Divide by 1
                    DIVIDE_1 = 0x0,
                    /// Divide by 2
                    DIVIDE_2 = 0x1,
                    /// Divide by 3
                    DIVIDE_3 = 0x2,
                    /// Divide by 4
                    DIVIDE_4 = 0x3,
                    /// Divide by 5
                    DIVIDE_5 = 0x4,
                    /// Divide by 6
                    DIVIDE_6 = 0x5,
                    /// Divide by 7
                    DIVIDE_7 = 0x6,
                    /// Divide by 8
                    DIVIDE_8 = 0x7,
                },
                /// Divider for flexio1 clock pred. Divider should be updated when output clock is gated.
                FLEXIO1_CLK_PRED: enum(u3) {
                    /// Divide by 1
                    DIVIDE_1 = 0x0,
                    /// Divide by 2
                    DIVIDE_2 = 0x1,
                    /// Divide by 3
                    DIVIDE_3 = 0x2,
                    /// Divide by 4
                    DIVIDE_4 = 0x3,
                    /// Divide by 5
                    DIVIDE_5 = 0x4,
                    /// Divide by 6
                    DIVIDE_6 = 0x5,
                    /// Divide by 7
                    DIVIDE_7 = 0x6,
                    /// Divide by 8
                    DIVIDE_8 = 0x7,
                },
                reserved20: u5 = 0,
                /// Selector for spdif0 clock multiplexer
                SPDIF0_CLK_SEL: enum(u2) {
                    /// derive clock from PLL4
                    SPDIF0_CLK_SEL_0 = 0x0,
                    /// derive clock from PLL3 PFD2
                    SPDIF0_CLK_SEL_1 = 0x1,
                    /// derive clock from PLL5
                    SPDIF0_CLK_SEL_2 = 0x2,
                    /// derive clock from pll3_sw_clk
                    SPDIF0_CLK_SEL_3 = 0x3,
                },
                /// Divider for spdif0 clock podf. Divider should be updated when output clock is gated.
                SPDIF0_CLK_PODF: enum(u3) {
                    /// Divide by 1
                    DIVIDE_1 = 0x0,
                    /// Divide by 2
                    DIVIDE_2 = 0x1,
                    /// Divide by 3
                    DIVIDE_3 = 0x2,
                    /// Divide by 4
                    DIVIDE_4 = 0x3,
                    /// Divide by 5
                    DIVIDE_5 = 0x4,
                    /// Divide by 6
                    DIVIDE_6 = 0x5,
                    /// Divide by 7
                    DIVIDE_7 = 0x6,
                    /// Divide by 8
                    DIVIDE_8 = 0x7,
                },
                /// Divider for spdif0 clock pred. Divider should be updated when output clock is gated.
                SPDIF0_CLK_PRED: enum(u3) {
                    /// Divide by 1
                    DIVIDE_1 = 0x0,
                    /// Divide by 2
                    DIVIDE_2 = 0x1,
                    /// Divide by 3
                    DIVIDE_3 = 0x2,
                    /// Divide by 4
                    DIVIDE_4 = 0x3,
                    /// Divide by 5
                    DIVIDE_5 = 0x4,
                    /// Divide by 6
                    DIVIDE_6 = 0x5,
                    /// Divide by 7
                    DIVIDE_7 = 0x6,
                    /// Divide by 8
                    DIVIDE_8 = 0x7,
                },
                padding: u4 = 0,
            }),
            reserved56: [4]u8,
            /// CCM Serial Clock Divider Register 2
            CSCDR2: mmio.Mmio(packed struct(u32) {
                reserved12: u12 = 0,
                /// Pre-divider for lcdif clock. Divider should be updated when output clock is gated.
                LCDIF_PRED: enum(u3) {
                    /// divide by 1
                    LCDIF_PRED_0 = 0x0,
                    /// divide by 2
                    LCDIF_PRED_1 = 0x1,
                    /// divide by 3
                    LCDIF_PRED_2 = 0x2,
                    /// divide by 4
                    LCDIF_PRED_3 = 0x3,
                    /// divide by 5
                    LCDIF_PRED_4 = 0x4,
                    /// divide by 6
                    LCDIF_PRED_5 = 0x5,
                    /// divide by 7
                    LCDIF_PRED_6 = 0x6,
                    /// divide by 8
                    LCDIF_PRED_7 = 0x7,
                },
                /// Selector for lcdif root clock pre-multiplexer
                LCDIF_PRE_CLK_SEL: enum(u3) {
                    /// derive clock from PLL2
                    LCDIF_PRE_CLK_SEL_0 = 0x0,
                    /// derive clock from PLL3 PFD3
                    LCDIF_PRE_CLK_SEL_1 = 0x1,
                    /// derive clock from PLL5
                    LCDIF_PRE_CLK_SEL_2 = 0x2,
                    /// derive clock from PLL2 PFD0
                    LCDIF_PRE_CLK_SEL_3 = 0x3,
                    /// derive clock from PLL2 PFD1
                    LCDIF_PRE_CLK_SEL_4 = 0x4,
                    /// derive clock from PLL3 PFD1
                    LCDIF_PRE_CLK_SEL_5 = 0x5,
                    _,
                },
                /// Selector for the LPI2C clock multiplexor
                LPI2C_CLK_SEL: enum(u1) {
                    /// derive clock from pll3_60m
                    LPI2C_CLK_SEL_0 = 0x0,
                    /// derive clock from osc_clk
                    LPI2C_CLK_SEL_1 = 0x1,
                },
                /// Divider for lpi2c clock podf. Divider should be updated when output clock is gated. The input clock to this divider should be lower than 300Mhz, the predivider can be used to achieve this.
                LPI2C_CLK_PODF: enum(u6) {
                    /// Divide by 1
                    DIVIDE_1 = 0x0,
                    /// Divide by 2
                    DIVIDE_2 = 0x1,
                    /// Divide by 3
                    DIVIDE_3 = 0x2,
                    /// Divide by 4
                    DIVIDE_4 = 0x3,
                    /// Divide by 5
                    DIVIDE_5 = 0x4,
                    /// Divide by 6
                    DIVIDE_6 = 0x5,
                    /// Divide by 7
                    DIVIDE_7 = 0x6,
                    /// Divide by 8
                    DIVIDE_8 = 0x7,
                    /// Divide by 9
                    DIVIDE_9 = 0x8,
                    /// Divide by 10
                    DIVIDE_10 = 0x9,
                    /// Divide by 11
                    DIVIDE_11 = 0xa,
                    /// Divide by 12
                    DIVIDE_12 = 0xb,
                    /// Divide by 13
                    DIVIDE_13 = 0xc,
                    /// Divide by 14
                    DIVIDE_14 = 0xd,
                    /// Divide by 15
                    DIVIDE_15 = 0xe,
                    /// Divide by 16
                    DIVIDE_16 = 0xf,
                    /// Divide by 17
                    DIVIDE_17 = 0x10,
                    /// Divide by 18
                    DIVIDE_18 = 0x11,
                    /// Divide by 19
                    DIVIDE_19 = 0x12,
                    /// Divide by 20
                    DIVIDE_20 = 0x13,
                    /// Divide by 21
                    DIVIDE_21 = 0x14,
                    /// Divide by 22
                    DIVIDE_22 = 0x15,
                    /// Divide by 23
                    DIVIDE_23 = 0x16,
                    /// Divide by 24
                    DIVIDE_24 = 0x17,
                    /// Divide by 25
                    DIVIDE_25 = 0x18,
                    /// Divide by 26
                    DIVIDE_26 = 0x19,
                    /// Divide by 27
                    DIVIDE_27 = 0x1a,
                    /// Divide by 28
                    DIVIDE_28 = 0x1b,
                    /// Divide by 29
                    DIVIDE_29 = 0x1c,
                    /// Divide by 30
                    DIVIDE_30 = 0x1d,
                    /// Divide by 31
                    DIVIDE_31 = 0x1e,
                    /// Divide by 32
                    DIVIDE_32 = 0x1f,
                    /// Divide by 33
                    DIVIDE_33 = 0x20,
                    /// Divide by 34
                    DIVIDE_34 = 0x21,
                    /// Divide by 35
                    DIVIDE_35 = 0x22,
                    /// Divide by 36
                    DIVIDE_36 = 0x23,
                    /// Divide by 37
                    DIVIDE_37 = 0x24,
                    /// Divide by 38
                    DIVIDE_38 = 0x25,
                    /// Divide by 39
                    DIVIDE_39 = 0x26,
                    /// Divide by 40
                    DIVIDE_40 = 0x27,
                    /// Divide by 41
                    DIVIDE_41 = 0x28,
                    /// Divide by 42
                    DIVIDE_42 = 0x29,
                    /// Divide by 43
                    DIVIDE_43 = 0x2a,
                    /// Divide by 44
                    DIVIDE_44 = 0x2b,
                    /// Divide by 45
                    DIVIDE_45 = 0x2c,
                    /// Divide by 46
                    DIVIDE_46 = 0x2d,
                    /// Divide by 47
                    DIVIDE_47 = 0x2e,
                    /// Divide by 48
                    DIVIDE_48 = 0x2f,
                    /// Divide by 49
                    DIVIDE_49 = 0x30,
                    /// Divide by 50
                    DIVIDE_50 = 0x31,
                    /// Divide by 51
                    DIVIDE_51 = 0x32,
                    /// Divide by 52
                    DIVIDE_52 = 0x33,
                    /// Divide by 53
                    DIVIDE_53 = 0x34,
                    /// Divide by 54
                    DIVIDE_54 = 0x35,
                    /// Divide by 55
                    DIVIDE_55 = 0x36,
                    /// Divide by 56
                    DIVIDE_56 = 0x37,
                    /// Divide by 57
                    DIVIDE_57 = 0x38,
                    /// Divide by 58
                    DIVIDE_58 = 0x39,
                    /// Divide by 59
                    DIVIDE_59 = 0x3a,
                    /// Divide by 60
                    DIVIDE_60 = 0x3b,
                    /// Divide by 61
                    DIVIDE_61 = 0x3c,
                    /// Divide by 62
                    DIVIDE_62 = 0x3d,
                    /// Divide by 63
                    DIVIDE_63 = 0x3e,
                    /// Divide by 64
                    DIVIDE_64 = 0x3f,
                },
                padding: u7 = 0,
            }),
            /// CCM Serial Clock Divider Register 3
            CSCDR3: mmio.Mmio(packed struct(u32) {
                reserved9: u9 = 0,
                /// Selector for csi_mclk multiplexer
                CSI_CLK_SEL: enum(u2) {
                    /// derive clock from osc_clk (24M)
                    CSI_CLK_SEL_0 = 0x0,
                    /// derive clock from PLL2 PFD2
                    CSI_CLK_SEL_1 = 0x1,
                    /// derive clock from pll3_120M
                    CSI_CLK_SEL_2 = 0x2,
                    /// derive clock from PLL3 PFD1
                    CSI_CLK_SEL_3 = 0x3,
                },
                /// Post divider for csi_mclk. Divider should be updated when output clock is gated.
                CSI_PODF: enum(u3) {
                    /// divide by 1
                    CSI_PODF_0 = 0x0,
                    /// divide by 2
                    CSI_PODF_1 = 0x1,
                    /// divide by 3
                    CSI_PODF_2 = 0x2,
                    /// divide by 4
                    CSI_PODF_3 = 0x3,
                    /// divide by 5
                    CSI_PODF_4 = 0x4,
                    /// divide by 6
                    CSI_PODF_5 = 0x5,
                    /// divide by 7
                    CSI_PODF_6 = 0x6,
                    /// divide by 8
                    CSI_PODF_7 = 0x7,
                },
                padding: u18 = 0,
            }),
            reserved72: [8]u8,
            /// CCM Divider Handshake In-Process Register
            CDHIPR: mmio.Mmio(packed struct(u32) {
                /// Busy indicator for semc_podf.
                SEMC_PODF_BUSY: enum(u1) {
                    /// divider is not busy and its value represents the actual division.
                    SEMC_PODF_BUSY_0 = 0x0,
                    /// divider is busy with handshake process with module. The value read in the divider represents the previous value of the division factor, and after the handshake the written value of the semc_podf will be applied.
                    SEMC_PODF_BUSY_1 = 0x1,
                },
                /// Busy indicator for ahb_podf.
                AHB_PODF_BUSY: enum(u1) {
                    /// divider is not busy and its value represents the actual division.
                    AHB_PODF_BUSY_0 = 0x0,
                    /// divider is busy with handshake process with module. The value read in the divider represents the previous value of the division factor, and after the handshake the written value of the ahb_podf will be applied.
                    AHB_PODF_BUSY_1 = 0x1,
                },
                reserved3: u1 = 0,
                /// Busy indicator for periph2_clk_sel mux control.
                PERIPH2_CLK_SEL_BUSY: enum(u1) {
                    /// mux is not busy and its value represents the actual division.
                    PERIPH2_CLK_SEL_BUSY_0 = 0x0,
                    /// mux is busy with handshake process with module. The value read in the periph2_clk_sel represents the previous value of select, and after the handshake periph2_clk_sel value will be applied.
                    PERIPH2_CLK_SEL_BUSY_1 = 0x1,
                },
                reserved5: u1 = 0,
                /// Busy indicator for periph_clk_sel mux control.
                PERIPH_CLK_SEL_BUSY: enum(u1) {
                    /// mux is not busy and its value represents the actual division.
                    PERIPH_CLK_SEL_BUSY_0 = 0x0,
                    /// mux is busy with handshake process with module. The value read in the periph_clk_sel represents the previous value of select, and after the handshake periph_clk_sel value will be applied.
                    PERIPH_CLK_SEL_BUSY_1 = 0x1,
                },
                reserved16: u10 = 0,
                /// Busy indicator for arm_podf.
                ARM_PODF_BUSY: enum(u1) {
                    /// divider is not busy and its value represents the actual division.
                    ARM_PODF_BUSY_0 = 0x0,
                    /// divider is busy with handshake process with module. The value read in the divider represents the previous value of the division factor, and after the handshake the written value of the arm_podf will be applied.
                    ARM_PODF_BUSY_1 = 0x1,
                },
                padding: u15 = 0,
            }),
            reserved84: [8]u8,
            /// CCM Low Power Control Register
            CLPCR: mmio.Mmio(packed struct(u32) {
                /// Setting the low power mode that system will enter on next assertion of dsm_request signal.
                LPM: enum(u2) {
                    /// Remain in run mode
                    LPM_0 = 0x0,
                    /// Transfer to wait mode
                    LPM_1 = 0x1,
                    /// Transfer to stop mode
                    LPM_2 = 0x2,
                    _,
                },
                reserved5: u3 = 0,
                /// Define if ARM clocks (arm_clk, soc_mxclk, soc_pclk, soc_dbg_pclk, vl_wrck) will be disabled on wait mode
                ARM_CLK_DIS_ON_LPM: enum(u1) {
                    /// ARM clock enabled on wait mode.
                    ARM_CLK_DIS_ON_LPM_0 = 0x0,
                    /// ARM clock disabled on wait mode. .
                    ARM_CLK_DIS_ON_LPM_1 = 0x1,
                },
                /// Standby clock oscillator bit
                SBYOS: enum(u1) {
                    /// On-chip oscillator will not be powered down, after next entrance to STOP mode. (CCM_REF_EN_B will remain asserted - '0' and cosc_pwrdown will remain de asserted - '0')
                    SBYOS_0 = 0x0,
                    /// On-chip oscillator will be powered down, after next entrance to STOP mode. (CCM_REF_EN_B will be deasserted - '1' and cosc_pwrdown will be asserted - '1'). When returning from STOP mode, external oscillator will be enabled again, on-chip oscillator will return to oscillator mode, and after oscnt count, CCM will continue with the exit from the STOP mode process.
                    SBYOS_1 = 0x1,
                },
                /// dis_ref_osc - in run mode, software can manually control closing of external reference oscillator clock, i
                DIS_REF_OSC: enum(u1) {
                    /// external high frequency oscillator will be enabled, i.e. CCM_REF_EN_B = '0'.
                    DIS_REF_OSC_0 = 0x0,
                    /// external high frequency oscillator will be disabled, i.e. CCM_REF_EN_B = '1'
                    DIS_REF_OSC_1 = 0x1,
                },
                /// Voltage standby request bit
                VSTBY: enum(u1) {
                    /// Voltage will not be changed to standby voltage after next entrance to STOP mode. ( PMIC_STBY_REQ will remain negated - '0')
                    VSTBY_0 = 0x0,
                    /// Voltage will be requested to change to standby voltage after next entrance to stop mode. ( PMIC_STBY_REQ will be asserted - '1').
                    VSTBY_1 = 0x1,
                },
                /// Standby counter definition
                STBY_COUNT: enum(u2) {
                    /// CCM will wait (1*pmic_delay_scaler)+1 ckil clock cycles
                    STBY_COUNT_0 = 0x0,
                    /// CCM will wait (3*pmic_delay_scaler)+1 ckil clock cycles
                    STBY_COUNT_1 = 0x1,
                    /// CCM will wait (7*pmic_delay_scaler)+1 ckil clock cycles
                    STBY_COUNT_2 = 0x2,
                    /// CCM will wait (15*pmic_delay_scaler)+1 ckil clock cycles
                    STBY_COUNT_3 = 0x3,
                },
                /// In run mode, software can manually control powering down of on chip oscillator, i
                COSC_PWRDOWN: enum(u1) {
                    /// On chip oscillator will not be powered down, i.e. cosc_pwrdown = '0'.
                    COSC_PWRDOWN_0 = 0x0,
                    /// On chip oscillator will be powered down, i.e. cosc_pwrdown = '1'.
                    COSC_PWRDOWN_1 = 0x1,
                },
                reserved19: u7 = 0,
                /// Bypass low power mode handshake. This bit should always be set to 1'b1 by software.
                BYPASS_LPM_HS1: u1,
                reserved21: u1 = 0,
                /// Bypass low power mode handshake. This bit should always be set to 1'b1 by software.
                BYPASS_LPM_HS0: u1,
                /// Mask WFI of core0 for entering low power mode Assertion of all bits[27:22] will generate low power mode request
                MASK_CORE0_WFI: enum(u1) {
                    /// WFI of core0 is not masked
                    MASK_CORE0_WFI_0 = 0x0,
                    /// WFI of core0 is masked
                    MASK_CORE0_WFI_1 = 0x1,
                },
                reserved26: u3 = 0,
                /// Mask SCU IDLE for entering low power mode Assertion of all bits[27:22] will generate low power mode request
                MASK_SCU_IDLE: enum(u1) {
                    /// SCU IDLE is not masked
                    MASK_SCU_IDLE_0 = 0x0,
                    /// SCU IDLE is masked
                    MASK_SCU_IDLE_1 = 0x1,
                },
                /// Mask L2CC IDLE for entering low power mode
                MASK_L2CC_IDLE: enum(u1) {
                    /// L2CC IDLE is not masked
                    MASK_L2CC_IDLE_0 = 0x0,
                    /// L2CC IDLE is masked
                    MASK_L2CC_IDLE_1 = 0x1,
                },
                padding: u4 = 0,
            }),
            /// CCM Interrupt Status Register
            CISR: mmio.Mmio(packed struct(u32) {
                /// CCM interrupt request 2 generated due to lock of all enabled and not bypaseed PLLs
                LRF_PLL: enum(u1) {
                    /// interrupt is not generated due to lock ready of all enabled and not bypaseed PLLs
                    LRF_PLL_0 = 0x0,
                    /// interrupt generated due to lock ready of all enabled and not bypaseed PLLs
                    LRF_PLL_1 = 0x1,
                },
                reserved6: u5 = 0,
                /// CCM interrupt request 2 generated due to on board oscillator ready, i
                COSC_READY: enum(u1) {
                    /// interrupt is not generated due to on board oscillator ready
                    COSC_READY_0 = 0x0,
                    /// interrupt generated due to on board oscillator ready
                    COSC_READY_1 = 0x1,
                },
                reserved17: u10 = 0,
                /// CCM interrupt request 1 generated due to frequency change of semc_podf
                SEMC_PODF_LOADED: enum(u1) {
                    /// interrupt is not generated due to frequency change of semc_podf
                    SEMC_PODF_LOADED_0 = 0x0,
                    /// interrupt generated due to frequency change of semc_podf
                    SEMC_PODF_LOADED_1 = 0x1,
                },
                reserved19: u1 = 0,
                /// CCM interrupt request 1 generated due to frequency change of periph2_clk_sel
                PERIPH2_CLK_SEL_LOADED: enum(u1) {
                    /// interrupt is not generated due to frequency change of periph2_clk_sel
                    PERIPH2_CLK_SEL_LOADED_0 = 0x0,
                    /// interrupt generated due to frequency change of periph2_clk_sel
                    PERIPH2_CLK_SEL_LOADED_1 = 0x1,
                },
                /// CCM interrupt request 1 generated due to frequency change of ahb_podf
                AHB_PODF_LOADED: enum(u1) {
                    /// interrupt is not generated due to frequency change of ahb_podf
                    AHB_PODF_LOADED_0 = 0x0,
                    /// interrupt generated due to frequency change of ahb_podf
                    AHB_PODF_LOADED_1 = 0x1,
                },
                reserved22: u1 = 0,
                /// CCM interrupt request 1 generated due to update of periph_clk_sel.
                PERIPH_CLK_SEL_LOADED: enum(u1) {
                    /// interrupt is not generated due to update of periph_clk_sel.
                    PERIPH_CLK_SEL_LOADED_0 = 0x0,
                    /// interrupt generated due to update of periph_clk_sel.
                    PERIPH_CLK_SEL_LOADED_1 = 0x1,
                },
                reserved26: u3 = 0,
                /// CCM interrupt request 1 generated due to frequency change of arm_podf
                ARM_PODF_LOADED: enum(u1) {
                    /// interrupt is not generated due to frequency change of arm_podf
                    ARM_PODF_LOADED_0 = 0x0,
                    /// interrupt generated due to frequency change of arm_podf
                    ARM_PODF_LOADED_1 = 0x1,
                },
                padding: u5 = 0,
            }),
            /// CCM Interrupt Mask Register
            CIMR: mmio.Mmio(packed struct(u32) {
                /// mask interrupt generation due to lrf of PLLs
                MASK_LRF_PLL: enum(u1) {
                    /// don't mask interrupt due to lrf of PLLs - interrupt will be created
                    MASK_LRF_PLL_0 = 0x0,
                    /// mask interrupt due to lrf of PLLs
                    MASK_LRF_PLL_1 = 0x1,
                },
                reserved6: u5 = 0,
                /// mask interrupt generation due to on board oscillator ready
                MASK_COSC_READY: enum(u1) {
                    /// don't mask interrupt due to on board oscillator ready - interrupt will be created
                    MASK_COSC_READY_0 = 0x0,
                    /// mask interrupt due to on board oscillator ready
                    MASK_COSC_READY_1 = 0x1,
                },
                reserved17: u10 = 0,
                /// mask interrupt generation due to frequency change of semc_podf
                MASK_SEMC_PODF_LOADED: enum(u1) {
                    /// don't mask interrupt due to frequency change of semc_podf - interrupt will be created
                    MASK_SEMC_PODF_LOADED_0 = 0x0,
                    /// mask interrupt due to frequency change of semc_podf
                    MASK_SEMC_PODF_LOADED_1 = 0x1,
                },
                reserved19: u1 = 0,
                /// mask interrupt generation due to update of periph2_clk_sel.
                MASK_PERIPH2_CLK_SEL_LOADED: enum(u1) {
                    /// don't mask interrupt due to update of periph2_clk_sel - interrupt will be created
                    MASK_PERIPH2_CLK_SEL_LOADED_0 = 0x0,
                    /// mask interrupt due to update of periph2_clk_sel
                    MASK_PERIPH2_CLK_SEL_LOADED_1 = 0x1,
                },
                /// mask interrupt generation due to frequency change of ahb_podf
                MASK_AHB_PODF_LOADED: enum(u1) {
                    /// don't mask interrupt due to frequency change of ahb_podf - interrupt will be created
                    MASK_AHB_PODF_LOADED_0 = 0x0,
                    /// mask interrupt due to frequency change of ahb_podf
                    MASK_AHB_PODF_LOADED_1 = 0x1,
                },
                reserved22: u1 = 0,
                /// mask interrupt generation due to update of periph_clk_sel.
                MASK_PERIPH_CLK_SEL_LOADED: enum(u1) {
                    /// don't mask interrupt due to update of periph_clk_sel - interrupt will be created
                    MASK_PERIPH_CLK_SEL_LOADED_0 = 0x0,
                    /// mask interrupt due to update of periph_clk_sel
                    MASK_PERIPH_CLK_SEL_LOADED_1 = 0x1,
                },
                reserved26: u3 = 0,
                /// mask interrupt generation due to frequency change of arm_podf
                ARM_PODF_LOADED: enum(u1) {
                    /// don't mask interrupt due to frequency change of arm_podf - interrupt will be created
                    ARM_PODF_LOADED_0 = 0x0,
                    /// mask interrupt due to frequency change of arm_podf
                    ARM_PODF_LOADED_1 = 0x1,
                },
                padding: u5 = 0,
            }),
            /// CCM Clock Output Source Register
            CCOSR: mmio.Mmio(packed struct(u32) {
                /// Selection of the clock to be generated on CCM_CLKO1
                CLKO1_SEL: enum(u4) {
                    /// USB1 PLL clock (divided by 2)
                    CLKO1_SEL_0 = 0x0,
                    /// SYS PLL clock (divided by 2)
                    CLKO1_SEL_1 = 0x1,
                    /// VIDEO PLL clock (divided by 2)
                    CLKO1_SEL_3 = 0x3,
                    /// semc_clk_root
                    CLKO1_SEL_5 = 0x5,
                    /// lcdif_pix_clk_root
                    CLKO1_SEL_10 = 0xa,
                    /// ahb_clk_root
                    CLKO1_SEL_11 = 0xb,
                    /// ipg_clk_root
                    CLKO1_SEL_12 = 0xc,
                    /// perclk_root
                    CLKO1_SEL_13 = 0xd,
                    /// ckil_sync_clk_root
                    CLKO1_SEL_14 = 0xe,
                    /// pll4_main_clk
                    CLKO1_SEL_15 = 0xf,
                    _,
                },
                /// Setting the divider of CCM_CLKO1
                CLKO1_DIV: enum(u3) {
                    /// divide by 1
                    CLKO1_DIV_0 = 0x0,
                    /// divide by 2
                    CLKO1_DIV_1 = 0x1,
                    /// divide by 3
                    CLKO1_DIV_2 = 0x2,
                    /// divide by 4
                    CLKO1_DIV_3 = 0x3,
                    /// divide by 5
                    CLKO1_DIV_4 = 0x4,
                    /// divide by 6
                    CLKO1_DIV_5 = 0x5,
                    /// divide by 7
                    CLKO1_DIV_6 = 0x6,
                    /// divide by 8
                    CLKO1_DIV_7 = 0x7,
                },
                /// Enable of CCM_CLKO1 clock
                CLKO1_EN: enum(u1) {
                    /// CCM_CLKO1 disabled.
                    CLKO1_EN_0 = 0x0,
                    /// CCM_CLKO1 enabled.
                    CLKO1_EN_1 = 0x1,
                },
                /// CCM_CLKO1 output to reflect CCM_CLKO1 or CCM_CLKO2 clocks
                CLK_OUT_SEL: enum(u1) {
                    /// CCM_CLKO1 output drives CCM_CLKO1 clock
                    CLK_OUT_SEL_0 = 0x0,
                    /// CCM_CLKO1 output drives CCM_CLKO2 clock
                    CLK_OUT_SEL_1 = 0x1,
                },
                reserved16: u7 = 0,
                /// Selection of the clock to be generated on CCM_CLKO2
                CLKO2_SEL: enum(u5) {
                    /// usdhc1_clk_root
                    CLKO2_SEL_3 = 0x3,
                    /// lpi2c_clk_root
                    CLKO2_SEL_6 = 0x6,
                    /// csi_clk_root
                    CLKO2_SEL_11 = 0xb,
                    /// osc_clk
                    CLKO2_SEL_14 = 0xe,
                    /// usdhc2_clk_root
                    CLKO2_SEL_17 = 0x11,
                    /// sai1_clk_root
                    CLKO2_SEL_18 = 0x12,
                    /// sai2_clk_root
                    CLKO2_SEL_19 = 0x13,
                    /// sai3_clk_root (shared with ADC1 and ADC2 alt_clk root)
                    CLKO2_SEL_20 = 0x14,
                    /// can_clk_root (FlexCAN, shared with CANFD)
                    CLKO2_SEL_23 = 0x17,
                    /// flexspi_clk_root
                    CLKO2_SEL_27 = 0x1b,
                    /// uart_clk_root
                    CLKO2_SEL_28 = 0x1c,
                    /// spdif0_clk_root
                    CLKO2_SEL_29 = 0x1d,
                    _,
                },
                /// Setting the divider of CCM_CLKO2
                CLKO2_DIV: enum(u3) {
                    /// divide by 1
                    CLKO2_DIV_0 = 0x0,
                    /// divide by 2
                    CLKO2_DIV_1 = 0x1,
                    /// divide by 3
                    CLKO2_DIV_2 = 0x2,
                    /// divide by 4
                    CLKO2_DIV_3 = 0x3,
                    /// divide by 5
                    CLKO2_DIV_4 = 0x4,
                    /// divide by 6
                    CLKO2_DIV_5 = 0x5,
                    /// divide by 7
                    CLKO2_DIV_6 = 0x6,
                    /// divide by 8
                    CLKO2_DIV_7 = 0x7,
                },
                /// Enable of CCM_CLKO2 clock
                CLKO2_EN: enum(u1) {
                    /// CCM_CLKO2 disabled.
                    CLKO2_EN_0 = 0x0,
                    /// CCM_CLKO2 enabled.
                    CLKO2_EN_1 = 0x1,
                },
                padding: u7 = 0,
            }),
            /// CCM General Purpose Register
            CGPR: mmio.Mmio(packed struct(u32) {
                /// Defines clock dividion of clock for stby_count (pmic delay counter)
                PMIC_DELAY_SCALER: enum(u1) {
                    /// clock is not divided
                    PMIC_DELAY_SCALER_0 = 0x0,
                    /// clock is divided /8
                    PMIC_DELAY_SCALER_1 = 0x1,
                },
                reserved4: u3 = 0,
                /// Defines the value of the output signal cgpr_dout[4]. Gate of program supply for efuse programing
                EFUSE_PROG_SUPPLY_GATE: enum(u1) {
                    /// fuse programing supply voltage is gated off to the efuse module
                    EFUSE_PROG_SUPPLY_GATE_0 = 0x0,
                    /// allow fuse programing.
                    EFUSE_PROG_SUPPLY_GATE_1 = 0x1,
                },
                reserved16: u11 = 0,
                /// Fast PLL enable.
                FPL: enum(u1) {
                    /// Engage PLL enable default way.
                    FPL_0 = 0x0,
                    /// Engage PLL enable 3 CKIL clocks earlier at exiting low power mode (STOP). Should be used only if 24MHz OSC was active in low power mode.
                    FPL_1 = 0x1,
                },
                /// Control for the Deep Sleep signal to the ARM Platform memories with additional control logic based on the ARM WFI signal
                INT_MEM_CLK_LPM: enum(u1) {
                    /// Disable the clock to the ARM platform memories when entering Low Power Mode
                    INT_MEM_CLK_LPM_0 = 0x0,
                    /// Keep the clocks to the ARM platform memories enabled only if an interrupt is pending when entering Low Power Modes (WAIT and STOP without power gating)
                    INT_MEM_CLK_LPM_1 = 0x1,
                },
                padding: u14 = 0,
            }),
            /// CCM Clock Gating Register 0
            CCGR0: mmio.Mmio(packed struct(u32) {
                /// aips_tz1 clocks (aips_tz1_clk_enable)
                CG0: u2,
                /// aips_tz2 clocks (aips_tz2_clk_enable)
                CG1: u2,
                /// mqs clock ( mqs_hmclk_clock_enable)
                CG2: u2,
                /// flexspi_exsc clock (flexspi_exsc_clk_enable)
                CG3: u2,
                /// sim_m or sim_main register access clock (sim_m_mainclk_r_enable)
                CG4: u2,
                /// dcp clock (dcp_clk_enable)
                CG5: u2,
                /// lpuart3 clock (lpuart3_clk_enable)
                CG6: u2,
                /// can1 clock (can1_clk_enable)
                CG7: u2,
                /// can1_serial clock (can1_serial_clk_enable)
                CG8: u2,
                /// can2 clock (can2_clk_enable)
                CG9: u2,
                /// can2_serial clock (can2_serial_clk_enable)
                CG10: u2,
                /// trace clock (trace_clk_enable)
                CG11: u2,
                /// gpt2 bus clocks (gpt2_bus_clk_enable)
                CG12: u2,
                /// gpt2 serial clocks (gpt2_serial_clk_enable)
                CG13: u2,
                /// lpuart2 clock (lpuart2_clk_enable)
                CG14: u2,
                /// gpio2_clocks (gpio2_clk_enable)
                CG15: u2,
            }),
            /// CCM Clock Gating Register 1
            CCGR1: mmio.Mmio(packed struct(u32) {
                /// lpspi1 clocks (lpspi1_clk_enable)
                CG0: u2,
                /// lpspi2 clocks (lpspi2_clk_enable)
                CG1: u2,
                /// lpspi3 clocks (lpspi3_clk_enable)
                CG2: u2,
                /// lpspi4 clocks (lpspi4_clk_enable)
                CG3: u2,
                /// adc2 clock (adc2_clk_enable)
                CG4: u2,
                /// enet clock (enet_clk_enable)
                CG5: u2,
                /// pit clocks (pit_clk_enable)
                CG6: u2,
                /// aoi2 clocks (aoi2_clk_enable)
                CG7: u2,
                /// adc1 clock (adc1_clk_enable)
                CG8: u2,
                /// semc_exsc clock (semc_exsc_clk_enable)
                CG9: u2,
                /// gpt1 bus clock (gpt_clk_enable)
                CG10: u2,
                /// gpt1 serial clock (gpt_serial_clk_enable)
                CG11: u2,
                /// lpuart4 clock (lpuart4_clk_enable)
                CG12: u2,
                /// gpio1 clock (gpio1_clk_enable)
                CG13: u2,
                /// csu clock (csu_clk_enable)
                CG14: u2,
                /// Reserved
                CG15: u2,
            }),
            /// CCM Clock Gating Register 2
            CCGR2: mmio.Mmio(packed struct(u32) {
                /// ocram_exsc clock (ocram_exsc_clk_enable)
                CG0: u2,
                /// csi clock (csi_clk_enable)
                CG1: u2,
                /// iomuxc_snvs clock (iomuxc_snvs_clk_enable)
                CG2: u2,
                /// lpi2c1 clock (lpi2c1_clk_enable)
                CG3: u2,
                /// lpi2c2 clock (lpi2c2_clk_enable)
                CG4: u2,
                /// lpi2c3 clock (lpi2c3_clk_enable)
                CG5: u2,
                /// OCOTP_CTRL clock (iim_clk_enable)
                CG6: u2,
                /// xbar3 clock (xbar3_clk_enable)
                CG7: u2,
                /// ipmux1 clock (ipmux1_clk_enable)
                CG8: u2,
                /// ipmux2 clock (ipmux2_clk_enable)
                CG9: u2,
                /// ipmux3 clock (ipmux3_clk_enable)
                CG10: u2,
                /// xbar1 clock (xbar1_clk_enable)
                CG11: u2,
                /// xbar2 clock (xbar2_clk_enable)
                CG12: u2,
                /// gpio3 clock (gpio3_clk_enable)
                CG13: u2,
                /// lcd clocks (lcd_clk_enable)
                CG14: u2,
                /// pxp clocks (pxp_clk_enable)
                CG15: u2,
            }),
            /// CCM Clock Gating Register 3
            CCGR3: mmio.Mmio(packed struct(u32) {
                /// flexio2 clocks (flexio2_clk_enable)
                CG0: u2,
                /// lpuart5 clock (lpuart5_clk_enable)
                CG1: u2,
                /// semc clocks (semc_clk_enable)
                CG2: u2,
                /// lpuart6 clock (lpuart6_clk_enable)
                CG3: u2,
                /// aoi1 clock (aoi1_clk_enable)
                CG4: u2,
                /// lcdif pix clock (lcdif_pix_clk_enable)
                CG5: u2,
                /// gpio4 clock (gpio4_clk_enable)
                CG6: u2,
                /// ewm clocks (ewm_clk_enable)
                CG7: u2,
                /// wdog1 clock (wdog1_clk_enable)
                CG8: u2,
                /// flexram clock (flexram_clk_enable)
                CG9: u2,
                /// acmp1 clocks (acmp1_clk_enable)
                CG10: u2,
                /// acmp2 clocks (acmp2_clk_enable)
                CG11: u2,
                /// acmp3 clocks (acmp3_clk_enable)
                CG12: u2,
                /// acmp4 clocks (acmp4_clk_enable)
                CG13: u2,
                /// The OCRAM clock cannot be turned off when the CM cache is running on this device.
                CG14: u2,
                /// iomuxc_snvs_gpr clock (iomuxc_snvs_gpr_clk_enable)
                CG15: u2,
            }),
            /// CCM Clock Gating Register 4
            CCGR4: mmio.Mmio(packed struct(u32) {
                /// sim_m7 register access clock (sim_m7_mainclk_r_enable)
                CG0: u2,
                /// iomuxc clock (iomuxc_clk_enable)
                CG1: u2,
                /// iomuxc gpr clock (iomuxc_gpr_clk_enable)
                CG2: u2,
                /// bee clock(bee_clk_enable)
                CG3: u2,
                /// sim_m7 clock (sim_m7_clk_enable)
                CG4: u2,
                /// tsc_dig clock (tsc_clk_enable)
                CG5: u2,
                /// sim_m clocks (sim_m_clk_enable)
                CG6: u2,
                /// sim_ems clocks (sim_ems_clk_enable)
                CG7: u2,
                /// pwm1 clocks (pwm1_clk_enable)
                CG8: u2,
                /// pwm2 clocks (pwm2_clk_enable)
                CG9: u2,
                /// pwm3 clocks (pwm3_clk_enable)
                CG10: u2,
                /// pwm4 clocks (pwm4_clk_enable)
                CG11: u2,
                /// enc1 clocks (enc1_clk_enable)
                CG12: u2,
                /// enc2 clocks (enc2_clk_enable)
                CG13: u2,
                /// enc3 clocks (enc3_clk_enable)
                CG14: u2,
                /// enc4 clocks (enc4_clk_enable)
                CG15: u2,
            }),
            /// CCM Clock Gating Register 5
            CCGR5: mmio.Mmio(packed struct(u32) {
                /// rom clock (rom_clk_enable)
                CG0: u2,
                /// flexio1 clock (flexio1_clk_enable)
                CG1: u2,
                /// wdog3 clock (wdog3_clk_enable)
                CG2: u2,
                /// dma clock (dma_clk_enable)
                CG3: u2,
                /// kpp clock (kpp_clk_enable)
                CG4: u2,
                /// wdog2 clock (wdog2_clk_enable)
                CG5: u2,
                /// aipstz4 clocks (aips_tz4_clk_enable)
                CG6: u2,
                /// spdif clock (spdif_clk_enable)
                CG7: u2,
                /// sim_main clock (sim_main_clk_enable)
                CG8: u2,
                /// sai1 clock (sai1_clk_enable)
                CG9: u2,
                /// sai2 clock (sai2_clk_enable)
                CG10: u2,
                /// sai3 clock (sai3_clk_enable)
                CG11: u2,
                /// lpuart1 clock (lpuart1_clk_enable)
                CG12: u2,
                /// lpuart7 clock (lpuart7_clk_enable)
                CG13: u2,
                /// snvs_hp clock (snvs_hp_clk_enable)
                CG14: u2,
                /// snvs_lp clock (snvs_lp_clk_enable)
                CG15: u2,
            }),
            /// CCM Clock Gating Register 6
            CCGR6: mmio.Mmio(packed struct(u32) {
                /// usboh3 clock (usboh3_clk_enable)
                CG0: u2,
                /// usdhc1 clocks (usdhc1_clk_enable)
                CG1: u2,
                /// usdhc2 clocks (usdhc2_clk_enable)
                CG2: u2,
                /// dcdc clocks (dcdc_clk_enable)
                CG3: u2,
                /// ipmux4 clock (ipmux4_clk_enable)
                CG4: u2,
                /// flexspi clocks (flexspi_clk_enable) sim_ems_clk_enable must also be cleared, when flexspi_clk_enable is cleared
                CG5: u2,
                /// trng clock (trng_clk_enable)
                CG6: u2,
                /// lpuart8 clocks (lpuart8_clk_enable)
                CG7: u2,
                /// timer4 clocks (timer4_clk_enable)
                CG8: u2,
                /// aips_tz3 clock (aips_tz3_clk_enable)
                CG9: u2,
                /// sim_axbs_p_clk_enable
                CG10: u2,
                /// anadig clocks (anadig_clk_enable)
                CG11: u2,
                /// lpi2c4 serial clock (lpi2c4_serial_clk_enable)
                CG12: u2,
                /// timer1 clocks (timer1_clk_enable)
                CG13: u2,
                /// timer2 clocks (timer2_clk_enable)
                CG14: u2,
                /// timer3 clocks (timer3_clk_enable)
                CG15: u2,
            }),
            /// CCM Clock Gating Register 7
            CCGR7: mmio.Mmio(packed struct(u32) {
                /// enet2_clk_enable
                CG0: u2,
                /// flexspi2_clk_enable
                CG1: u2,
                /// axbs_l_clk_enable
                CG2: u2,
                /// can3_clk_enable
                CG3: u2,
                /// can3_serial_clk_enable
                CG4: u2,
                /// aips_lite_clk_enable
                CG5: u2,
                /// flexio3_clk_enable
                CG6: u2,
                padding: u18 = 0,
            }),
            /// CCM Module Enable Overide Register
            CMEOR: mmio.Mmio(packed struct(u32) {
                reserved5: u5 = 0,
                /// Overide clock enable signal from GPT - clock will not be gated based on GPT's signal 'ipg_enable_clk'
                MOD_EN_OV_GPT: enum(u1) {
                    /// don't override module enable signal
                    MOD_EN_OV_GPT_0 = 0x0,
                    /// override module enable signal
                    MOD_EN_OV_GPT_1 = 0x1,
                },
                /// Overide clock enable signal from PIT - clock will not be gated based on PIT's signal 'ipg_enable_clk'
                MOD_EN_OV_PIT: enum(u1) {
                    /// don't override module enable signal
                    MOD_EN_OV_PIT_0 = 0x0,
                    /// override module enable signal
                    MOD_EN_OV_PIT_1 = 0x1,
                },
                /// overide clock enable signal from USDHC.
                MOD_EN_USDHC: enum(u1) {
                    /// don't override module enable signal
                    MOD_EN_USDHC_0 = 0x0,
                    /// override module enable signal
                    MOD_EN_USDHC_1 = 0x1,
                },
                reserved9: u1 = 0,
                /// Overide clock enable signal from TRNG
                MOD_EN_OV_TRNG: enum(u1) {
                    /// don't override module enable signal
                    MOD_EN_OV_TRNG_0 = 0x0,
                    /// override module enable signal
                    MOD_EN_OV_TRNG_1 = 0x1,
                },
                /// Overide clock enable signal from FlexCAN3(CANFD) - clock will not be gated based on CAN's signal 'enable_clk_cpi'
                MOD_EN_OV_CANFD_CPI: enum(u1) {
                    /// don't override module enable signal
                    MOD_EN_OV_CANFD_CPI_0 = 0x0,
                    /// override module enable signal
                    MOD_EN_OV_CANFD_CPI_1 = 0x1,
                },
                reserved28: u17 = 0,
                /// Overide clock enable signal from CAN2 - clock will not be gated based on CAN's signal 'enable_clk_cpi'
                MOD_EN_OV_CAN2_CPI: enum(u1) {
                    /// don't override module enable signal
                    MOD_EN_OV_CAN2_CPI_0 = 0x0,
                    /// override module enable signal
                    MOD_EN_OV_CAN2_CPI_1 = 0x1,
                },
                reserved30: u1 = 0,
                /// Overide clock enable signal from CAN1 - clock will not be gated based on CAN's signal 'enable_clk_cpi'
                MOD_EN_OV_CAN1_CPI: enum(u1) {
                    /// don't overide module enable signal
                    MOD_EN_OV_CAN1_CPI_0 = 0x0,
                    /// overide module enable signal
                    MOD_EN_OV_CAN1_CPI_1 = 0x1,
                },
                padding: u1 = 0,
            }),
        };

        /// CCM_ANALOG
        pub const CCM_ANALOG = extern struct {
            /// Analog ARM PLL control Register
            PLL_ARM: mmio.Mmio(packed struct(u32) {
                /// This field controls the PLL loop divider
                DIV_SELECT: u7,
                reserved12: u5 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enable the clock output.
                ENABLE: u1,
                /// Determines the bypass source
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved19: u2 = 0,
                /// Reserved
                PLL_SEL: u1,
                reserved31: u11 = 0,
                /// 1 - PLL is currently locked. 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog ARM PLL control Register
            PLL_ARM_SET: mmio.Mmio(packed struct(u32) {
                /// This field controls the PLL loop divider
                DIV_SELECT: u7,
                reserved12: u5 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enable the clock output.
                ENABLE: u1,
                /// Determines the bypass source
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved19: u2 = 0,
                /// Reserved
                PLL_SEL: u1,
                reserved31: u11 = 0,
                /// 1 - PLL is currently locked. 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog ARM PLL control Register
            PLL_ARM_CLR: mmio.Mmio(packed struct(u32) {
                /// This field controls the PLL loop divider
                DIV_SELECT: u7,
                reserved12: u5 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enable the clock output.
                ENABLE: u1,
                /// Determines the bypass source
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved19: u2 = 0,
                /// Reserved
                PLL_SEL: u1,
                reserved31: u11 = 0,
                /// 1 - PLL is currently locked. 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog ARM PLL control Register
            PLL_ARM_TOG: mmio.Mmio(packed struct(u32) {
                /// This field controls the PLL loop divider
                DIV_SELECT: u7,
                reserved12: u5 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enable the clock output.
                ENABLE: u1,
                /// Determines the bypass source
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved19: u2 = 0,
                /// Reserved
                PLL_SEL: u1,
                reserved31: u11 = 0,
                /// 1 - PLL is currently locked. 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog USB1 480MHz PLL Control Register
            PLL_USB1: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
                DIV_SELECT: u1,
                reserved6: u4 = 0,
                /// Powers the 9-phase PLL outputs for USBPHYn
                EN_USB_CLKS: enum(u1) {
                    /// PLL outputs for USBPHYn off.
                    EN_USB_CLKS_0 = 0x0,
                    /// PLL outputs for USBPHYn on.
                    EN_USB_CLKS_1 = 0x1,
                },
                reserved12: u5 = 0,
                /// Powers up the PLL. This bit will be set automatically when USBPHY0 remote wakeup event happens.
                POWER: u1,
                /// Enable the PLL clock output.
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved31: u14 = 0,
                /// 1 - PLL is currently locked. 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog USB1 480MHz PLL Control Register
            PLL_USB1_SET: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
                DIV_SELECT: u1,
                reserved6: u4 = 0,
                /// Powers the 9-phase PLL outputs for USBPHYn
                EN_USB_CLKS: enum(u1) {
                    /// PLL outputs for USBPHYn off.
                    EN_USB_CLKS_0 = 0x0,
                    /// PLL outputs for USBPHYn on.
                    EN_USB_CLKS_1 = 0x1,
                },
                reserved12: u5 = 0,
                /// Powers up the PLL. This bit will be set automatically when USBPHY0 remote wakeup event happens.
                POWER: u1,
                /// Enable the PLL clock output.
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved31: u14 = 0,
                /// 1 - PLL is currently locked. 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog USB1 480MHz PLL Control Register
            PLL_USB1_CLR: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
                DIV_SELECT: u1,
                reserved6: u4 = 0,
                /// Powers the 9-phase PLL outputs for USBPHYn
                EN_USB_CLKS: enum(u1) {
                    /// PLL outputs for USBPHYn off.
                    EN_USB_CLKS_0 = 0x0,
                    /// PLL outputs for USBPHYn on.
                    EN_USB_CLKS_1 = 0x1,
                },
                reserved12: u5 = 0,
                /// Powers up the PLL. This bit will be set automatically when USBPHY0 remote wakeup event happens.
                POWER: u1,
                /// Enable the PLL clock output.
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved31: u14 = 0,
                /// 1 - PLL is currently locked. 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog USB1 480MHz PLL Control Register
            PLL_USB1_TOG: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
                DIV_SELECT: u1,
                reserved6: u4 = 0,
                /// Powers the 9-phase PLL outputs for USBPHYn
                EN_USB_CLKS: enum(u1) {
                    /// PLL outputs for USBPHYn off.
                    EN_USB_CLKS_0 = 0x0,
                    /// PLL outputs for USBPHYn on.
                    EN_USB_CLKS_1 = 0x1,
                },
                reserved12: u5 = 0,
                /// Powers up the PLL. This bit will be set automatically when USBPHY0 remote wakeup event happens.
                POWER: u1,
                /// Enable the PLL clock output.
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved31: u14 = 0,
                /// 1 - PLL is currently locked. 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog USB2 480MHz PLL Control Register
            PLL_USB2: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
                DIV_SELECT: u1,
                reserved6: u4 = 0,
                /// 0: 8-phase PLL outputs for USBPHY1 are powered down
                EN_USB_CLKS: u1,
                reserved12: u5 = 0,
                /// Powers up the PLL. This bit will be set automatically when USBPHY1 remote wakeup event happens.
                POWER: u1,
                /// Enable the PLL clock output.
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved31: u14 = 0,
                /// 1 - PLL is currently locked. 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog USB2 480MHz PLL Control Register
            PLL_USB2_SET: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
                DIV_SELECT: u1,
                reserved6: u4 = 0,
                /// 0: 8-phase PLL outputs for USBPHY1 are powered down
                EN_USB_CLKS: u1,
                reserved12: u5 = 0,
                /// Powers up the PLL. This bit will be set automatically when USBPHY1 remote wakeup event happens.
                POWER: u1,
                /// Enable the PLL clock output.
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved31: u14 = 0,
                /// 1 - PLL is currently locked. 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog USB2 480MHz PLL Control Register
            PLL_USB2_CLR: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
                DIV_SELECT: u1,
                reserved6: u4 = 0,
                /// 0: 8-phase PLL outputs for USBPHY1 are powered down
                EN_USB_CLKS: u1,
                reserved12: u5 = 0,
                /// Powers up the PLL. This bit will be set automatically when USBPHY1 remote wakeup event happens.
                POWER: u1,
                /// Enable the PLL clock output.
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved31: u14 = 0,
                /// 1 - PLL is currently locked. 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog USB2 480MHz PLL Control Register
            PLL_USB2_TOG: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
                DIV_SELECT: u1,
                reserved6: u4 = 0,
                /// 0: 8-phase PLL outputs for USBPHY1 are powered down
                EN_USB_CLKS: u1,
                reserved12: u5 = 0,
                /// Powers up the PLL. This bit will be set automatically when USBPHY1 remote wakeup event happens.
                POWER: u1,
                /// Enable the PLL clock output.
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved31: u14 = 0,
                /// 1 - PLL is currently locked. 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog System PLL Control Register
            PLL_SYS: mmio.Mmio(packed struct(u32) {
                /// This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
                DIV_SELECT: u1,
                reserved12: u11 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enable PLL output
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved31: u14 = 0,
                /// 1 - PLL is currently locked; 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog System PLL Control Register
            PLL_SYS_SET: mmio.Mmio(packed struct(u32) {
                /// This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
                DIV_SELECT: u1,
                reserved12: u11 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enable PLL output
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved31: u14 = 0,
                /// 1 - PLL is currently locked; 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog System PLL Control Register
            PLL_SYS_CLR: mmio.Mmio(packed struct(u32) {
                /// This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
                DIV_SELECT: u1,
                reserved12: u11 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enable PLL output
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved31: u14 = 0,
                /// 1 - PLL is currently locked; 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog System PLL Control Register
            PLL_SYS_TOG: mmio.Mmio(packed struct(u32) {
                /// This field controls the PLL loop divider. 0 - Fout=Fref*20; 1 - Fout=Fref*22.
                DIV_SELECT: u1,
                reserved12: u11 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enable PLL output
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved31: u14 = 0,
                /// 1 - PLL is currently locked; 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// 528MHz System PLL Spread Spectrum Register
            PLL_SYS_SS: mmio.Mmio(packed struct(u32) {
                /// Frequency change step = step/CCM_ANALOG_PLL_SYS_DENOM[B]*24MHz.
                STEP: u15,
                /// Enable bit
                ENABLE: enum(u1) {
                    /// Spread spectrum modulation disabled
                    ENABLE_0 = 0x0,
                    /// Soread spectrum modulation enabled
                    ENABLE_1 = 0x1,
                },
                /// Frequency change = stop/CCM_ANALOG_PLL_SYS_DENOM[B]*24MHz.
                STOP: u16,
            }),
            reserved80: [12]u8,
            /// Numerator of 528MHz System PLL Fractional Loop Divider Register
            PLL_SYS_NUM: mmio.Mmio(packed struct(u32) {
                /// 30 bit numerator (A) of fractional loop divider (signed integer).
                A: u30,
                padding: u2 = 0,
            }),
            reserved96: [12]u8,
            /// Denominator of 528MHz System PLL Fractional Loop Divider Register
            PLL_SYS_DENOM: mmio.Mmio(packed struct(u32) {
                /// 30 bit Denominator (B) of fractional loop divider (unsigned integer).
                B: u30,
                padding: u2 = 0,
            }),
            reserved112: [12]u8,
            /// Analog Audio PLL control Register
            PLL_AUDIO: mmio.Mmio(packed struct(u32) {
                /// This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
                DIV_SELECT: u7,
                reserved12: u5 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enable PLL output
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved19: u2 = 0,
                /// These bits implement a divider after the PLL, but before the enable and bypass mux.
                POST_DIV_SELECT: enum(u2) {
                    /// Divide by 4.
                    POST_DIV_SELECT_0 = 0x0,
                    /// Divide by 2.
                    POST_DIV_SELECT_1 = 0x1,
                    /// Divide by 1.
                    POST_DIV_SELECT_2 = 0x2,
                    _,
                },
                reserved31: u10 = 0,
                /// 1 - PLL is currently locked. 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog Audio PLL control Register
            PLL_AUDIO_SET: mmio.Mmio(packed struct(u32) {
                /// This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
                DIV_SELECT: u7,
                reserved12: u5 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enable PLL output
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved19: u2 = 0,
                /// These bits implement a divider after the PLL, but before the enable and bypass mux.
                POST_DIV_SELECT: enum(u2) {
                    /// Divide by 4.
                    POST_DIV_SELECT_0 = 0x0,
                    /// Divide by 2.
                    POST_DIV_SELECT_1 = 0x1,
                    /// Divide by 1.
                    POST_DIV_SELECT_2 = 0x2,
                    _,
                },
                reserved31: u10 = 0,
                /// 1 - PLL is currently locked. 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog Audio PLL control Register
            PLL_AUDIO_CLR: mmio.Mmio(packed struct(u32) {
                /// This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
                DIV_SELECT: u7,
                reserved12: u5 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enable PLL output
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved19: u2 = 0,
                /// These bits implement a divider after the PLL, but before the enable and bypass mux.
                POST_DIV_SELECT: enum(u2) {
                    /// Divide by 4.
                    POST_DIV_SELECT_0 = 0x0,
                    /// Divide by 2.
                    POST_DIV_SELECT_1 = 0x1,
                    /// Divide by 1.
                    POST_DIV_SELECT_2 = 0x2,
                    _,
                },
                reserved31: u10 = 0,
                /// 1 - PLL is currently locked. 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog Audio PLL control Register
            PLL_AUDIO_TOG: mmio.Mmio(packed struct(u32) {
                /// This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
                DIV_SELECT: u7,
                reserved12: u5 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enable PLL output
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved19: u2 = 0,
                /// These bits implement a divider after the PLL, but before the enable and bypass mux.
                POST_DIV_SELECT: enum(u2) {
                    /// Divide by 4.
                    POST_DIV_SELECT_0 = 0x0,
                    /// Divide by 2.
                    POST_DIV_SELECT_1 = 0x1,
                    /// Divide by 1.
                    POST_DIV_SELECT_2 = 0x2,
                    _,
                },
                reserved31: u10 = 0,
                /// 1 - PLL is currently locked. 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Numerator of Audio PLL Fractional Loop Divider Register
            PLL_AUDIO_NUM: mmio.Mmio(packed struct(u32) {
                /// 30 bit numerator of fractional loop divider.
                A: u30,
                padding: u2 = 0,
            }),
            reserved144: [12]u8,
            /// Denominator of Audio PLL Fractional Loop Divider Register
            PLL_AUDIO_DENOM: mmio.Mmio(packed struct(u32) {
                /// 30 bit Denominator of fractional loop divider.
                B: u30,
                padding: u2 = 0,
            }),
            reserved160: [12]u8,
            /// Analog Video PLL control Register
            PLL_VIDEO: mmio.Mmio(packed struct(u32) {
                /// This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
                DIV_SELECT: u7,
                reserved12: u5 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enalbe PLL output
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved19: u2 = 0,
                /// These bits implement a divider after the PLL, but before the enable and bypass mux.
                POST_DIV_SELECT: enum(u2) {
                    /// Divide by 4.
                    POST_DIV_SELECT_0 = 0x0,
                    /// Divide by 2.
                    POST_DIV_SELECT_1 = 0x1,
                    /// Divide by 1.
                    POST_DIV_SELECT_2 = 0x2,
                    _,
                },
                reserved31: u10 = 0,
                /// 1 - PLL is currently locked; 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog Video PLL control Register
            PLL_VIDEO_SET: mmio.Mmio(packed struct(u32) {
                /// This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
                DIV_SELECT: u7,
                reserved12: u5 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enalbe PLL output
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved19: u2 = 0,
                /// These bits implement a divider after the PLL, but before the enable and bypass mux.
                POST_DIV_SELECT: enum(u2) {
                    /// Divide by 4.
                    POST_DIV_SELECT_0 = 0x0,
                    /// Divide by 2.
                    POST_DIV_SELECT_1 = 0x1,
                    /// Divide by 1.
                    POST_DIV_SELECT_2 = 0x2,
                    _,
                },
                reserved31: u10 = 0,
                /// 1 - PLL is currently locked; 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog Video PLL control Register
            PLL_VIDEO_CLR: mmio.Mmio(packed struct(u32) {
                /// This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
                DIV_SELECT: u7,
                reserved12: u5 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enalbe PLL output
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved19: u2 = 0,
                /// These bits implement a divider after the PLL, but before the enable and bypass mux.
                POST_DIV_SELECT: enum(u2) {
                    /// Divide by 4.
                    POST_DIV_SELECT_0 = 0x0,
                    /// Divide by 2.
                    POST_DIV_SELECT_1 = 0x1,
                    /// Divide by 1.
                    POST_DIV_SELECT_2 = 0x2,
                    _,
                },
                reserved31: u10 = 0,
                /// 1 - PLL is currently locked; 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog Video PLL control Register
            PLL_VIDEO_TOG: mmio.Mmio(packed struct(u32) {
                /// This field controls the PLL loop divider. Valid range for DIV_SELECT divider value: 27~54.
                DIV_SELECT: u7,
                reserved12: u5 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enalbe PLL output
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved19: u2 = 0,
                /// These bits implement a divider after the PLL, but before the enable and bypass mux.
                POST_DIV_SELECT: enum(u2) {
                    /// Divide by 4.
                    POST_DIV_SELECT_0 = 0x0,
                    /// Divide by 2.
                    POST_DIV_SELECT_1 = 0x1,
                    /// Divide by 1.
                    POST_DIV_SELECT_2 = 0x2,
                    _,
                },
                reserved31: u10 = 0,
                /// 1 - PLL is currently locked; 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Numerator of Video PLL Fractional Loop Divider Register
            PLL_VIDEO_NUM: mmio.Mmio(packed struct(u32) {
                /// 30 bit numerator of fractional loop divider(Signed number), absolute value should be less than denominator
                A: u30,
                padding: u2 = 0,
            }),
            reserved192: [12]u8,
            /// Denominator of Video PLL Fractional Loop Divider Register
            PLL_VIDEO_DENOM: mmio.Mmio(packed struct(u32) {
                /// 30 bit Denominator of fractional loop divider.
                B: u30,
                padding: u2 = 0,
            }),
            reserved224: [28]u8,
            /// Analog ENET PLL Control Register
            PLL_ENET: mmio.Mmio(packed struct(u32) {
                /// Controls the frequency of the ethernet reference clock
                DIV_SELECT: u2,
                /// Controls the frequency of the ENET2 reference clock.
                ENET2_DIV_SELECT: enum(u2) {
                    /// 25MHz
                    ENET2_DIV_SELECT_0 = 0x0,
                    /// 50MHz
                    ENET2_DIV_SELECT_1 = 0x1,
                    /// 100MHz (not 50% duty cycle)
                    ENET2_DIV_SELECT_2 = 0x2,
                    /// 125MHz
                    ENET2_DIV_SELECT_3 = 0x3,
                },
                reserved12: u8 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enable the PLL providing the ENET reference clock.
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved20: u3 = 0,
                /// Enable the PLL providing the ENET2 reference clock
                ENET2_REF_EN: u1,
                /// Enable the PLL providing ENET 25 MHz reference clock
                ENET_25M_REF_EN: u1,
                reserved31: u9 = 0,
                /// 1 - PLL is currently locked; 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog ENET PLL Control Register
            PLL_ENET_SET: mmio.Mmio(packed struct(u32) {
                /// Controls the frequency of the ethernet reference clock
                DIV_SELECT: u2,
                /// Controls the frequency of the ENET2 reference clock.
                ENET2_DIV_SELECT: enum(u2) {
                    /// 25MHz
                    ENET2_DIV_SELECT_0 = 0x0,
                    /// 50MHz
                    ENET2_DIV_SELECT_1 = 0x1,
                    /// 100MHz (not 50% duty cycle)
                    ENET2_DIV_SELECT_2 = 0x2,
                    /// 125MHz
                    ENET2_DIV_SELECT_3 = 0x3,
                },
                reserved12: u8 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enable the PLL providing the ENET reference clock.
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved20: u3 = 0,
                /// Enable the PLL providing the ENET2 reference clock
                ENET2_REF_EN: u1,
                /// Enable the PLL providing ENET 25 MHz reference clock
                ENET_25M_REF_EN: u1,
                reserved31: u9 = 0,
                /// 1 - PLL is currently locked; 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog ENET PLL Control Register
            PLL_ENET_CLR: mmio.Mmio(packed struct(u32) {
                /// Controls the frequency of the ethernet reference clock
                DIV_SELECT: u2,
                /// Controls the frequency of the ENET2 reference clock.
                ENET2_DIV_SELECT: enum(u2) {
                    /// 25MHz
                    ENET2_DIV_SELECT_0 = 0x0,
                    /// 50MHz
                    ENET2_DIV_SELECT_1 = 0x1,
                    /// 100MHz (not 50% duty cycle)
                    ENET2_DIV_SELECT_2 = 0x2,
                    /// 125MHz
                    ENET2_DIV_SELECT_3 = 0x3,
                },
                reserved12: u8 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enable the PLL providing the ENET reference clock.
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved20: u3 = 0,
                /// Enable the PLL providing the ENET2 reference clock
                ENET2_REF_EN: u1,
                /// Enable the PLL providing ENET 25 MHz reference clock
                ENET_25M_REF_EN: u1,
                reserved31: u9 = 0,
                /// 1 - PLL is currently locked; 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// Analog ENET PLL Control Register
            PLL_ENET_TOG: mmio.Mmio(packed struct(u32) {
                /// Controls the frequency of the ethernet reference clock
                DIV_SELECT: u2,
                /// Controls the frequency of the ENET2 reference clock.
                ENET2_DIV_SELECT: enum(u2) {
                    /// 25MHz
                    ENET2_DIV_SELECT_0 = 0x0,
                    /// 50MHz
                    ENET2_DIV_SELECT_1 = 0x1,
                    /// 100MHz (not 50% duty cycle)
                    ENET2_DIV_SELECT_2 = 0x2,
                    /// 125MHz
                    ENET2_DIV_SELECT_3 = 0x3,
                },
                reserved12: u8 = 0,
                /// Powers down the PLL.
                POWERDOWN: u1,
                /// Enable the PLL providing the ENET reference clock.
                ENABLE: u1,
                /// Determines the bypass source.
                BYPASS_CLK_SRC: enum(u2) {
                    /// Select the 24MHz oscillator as source.
                    REF_CLK_24M = 0x0,
                    /// Select the CLK1_N / CLK1_P as source.
                    CLK1 = 0x1,
                    _,
                },
                /// Bypass the PLL.
                BYPASS: u1,
                reserved20: u3 = 0,
                /// Enable the PLL providing the ENET2 reference clock
                ENET2_REF_EN: u1,
                /// Enable the PLL providing ENET 25 MHz reference clock
                ENET_25M_REF_EN: u1,
                reserved31: u9 = 0,
                /// 1 - PLL is currently locked; 0 - PLL is not currently locked.
                LOCK: u1,
            }),
            /// 480MHz Clock (PLL3) Phase Fractional Divider Control Register
            PFD_480: mmio.Mmio(packed struct(u32) {
                /// This field controls the fractional divide value
                PFD0_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD0_STABLE: u1,
                /// If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
                PFD0_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD1_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD1_STABLE: u1,
                /// IO Clock Gate
                PFD1_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD2_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD2_STABLE: u1,
                /// IO Clock Gate
                PFD2_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD3_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD3_STABLE: u1,
                /// IO Clock Gate
                PFD3_CLKGATE: u1,
            }),
            /// 480MHz Clock (PLL3) Phase Fractional Divider Control Register
            PFD_480_SET: mmio.Mmio(packed struct(u32) {
                /// This field controls the fractional divide value
                PFD0_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD0_STABLE: u1,
                /// If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
                PFD0_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD1_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD1_STABLE: u1,
                /// IO Clock Gate
                PFD1_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD2_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD2_STABLE: u1,
                /// IO Clock Gate
                PFD2_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD3_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD3_STABLE: u1,
                /// IO Clock Gate
                PFD3_CLKGATE: u1,
            }),
            /// 480MHz Clock (PLL3) Phase Fractional Divider Control Register
            PFD_480_CLR: mmio.Mmio(packed struct(u32) {
                /// This field controls the fractional divide value
                PFD0_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD0_STABLE: u1,
                /// If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
                PFD0_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD1_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD1_STABLE: u1,
                /// IO Clock Gate
                PFD1_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD2_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD2_STABLE: u1,
                /// IO Clock Gate
                PFD2_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD3_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD3_STABLE: u1,
                /// IO Clock Gate
                PFD3_CLKGATE: u1,
            }),
            /// 480MHz Clock (PLL3) Phase Fractional Divider Control Register
            PFD_480_TOG: mmio.Mmio(packed struct(u32) {
                /// This field controls the fractional divide value
                PFD0_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD0_STABLE: u1,
                /// If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
                PFD0_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD1_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD1_STABLE: u1,
                /// IO Clock Gate
                PFD1_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD2_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD2_STABLE: u1,
                /// IO Clock Gate
                PFD2_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD3_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD3_STABLE: u1,
                /// IO Clock Gate
                PFD3_CLKGATE: u1,
            }),
            /// 528MHz Clock (PLL2) Phase Fractional Divider Control Register
            PFD_528: mmio.Mmio(packed struct(u32) {
                /// This field controls the fractional divide value
                PFD0_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD0_STABLE: u1,
                /// If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
                PFD0_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD1_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD1_STABLE: u1,
                /// IO Clock Gate
                PFD1_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD2_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD2_STABLE: u1,
                /// IO Clock Gate
                PFD2_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD3_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD3_STABLE: u1,
                /// IO Clock Gate
                PFD3_CLKGATE: u1,
            }),
            /// 528MHz Clock (PLL2) Phase Fractional Divider Control Register
            PFD_528_SET: mmio.Mmio(packed struct(u32) {
                /// This field controls the fractional divide value
                PFD0_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD0_STABLE: u1,
                /// If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
                PFD0_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD1_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD1_STABLE: u1,
                /// IO Clock Gate
                PFD1_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD2_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD2_STABLE: u1,
                /// IO Clock Gate
                PFD2_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD3_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD3_STABLE: u1,
                /// IO Clock Gate
                PFD3_CLKGATE: u1,
            }),
            /// 528MHz Clock (PLL2) Phase Fractional Divider Control Register
            PFD_528_CLR: mmio.Mmio(packed struct(u32) {
                /// This field controls the fractional divide value
                PFD0_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD0_STABLE: u1,
                /// If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
                PFD0_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD1_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD1_STABLE: u1,
                /// IO Clock Gate
                PFD1_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD2_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD2_STABLE: u1,
                /// IO Clock Gate
                PFD2_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD3_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD3_STABLE: u1,
                /// IO Clock Gate
                PFD3_CLKGATE: u1,
            }),
            /// 528MHz Clock (PLL2) Phase Fractional Divider Control Register
            PFD_528_TOG: mmio.Mmio(packed struct(u32) {
                /// This field controls the fractional divide value
                PFD0_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD0_STABLE: u1,
                /// If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)
                PFD0_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD1_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD1_STABLE: u1,
                /// IO Clock Gate
                PFD1_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD2_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD2_STABLE: u1,
                /// IO Clock Gate
                PFD2_CLKGATE: u1,
                /// This field controls the fractional divide value
                PFD3_FRAC: u6,
                /// This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code
                PFD3_STABLE: u1,
                /// IO Clock Gate
                PFD3_CLKGATE: u1,
            }),
            reserved336: [64]u8,
            /// Miscellaneous Register 0
            MISC0: mmio.Mmio(packed struct(u32) {
                /// Control bit to power-down the analog bandgap reference circuitry
                REFTOP_PWD: u1,
                reserved3: u2 = 0,
                /// Control bit to disable the self-bias circuit in the analog bandgap
                REFTOP_SELFBIASOFF: enum(u1) {
                    /// Uses coarse bias currents for startup
                    REFTOP_SELFBIASOFF_0 = 0x0,
                    /// Uses bandgap-based bias currents for best performance.
                    REFTOP_SELFBIASOFF_1 = 0x1,
                },
                /// Not related to CCM. See Power Management Unit (PMU)
                REFTOP_VBGADJ: enum(u3) {
                    /// Nominal VBG
                    REFTOP_VBGADJ_0 = 0x0,
                    /// VBG+0.78%
                    REFTOP_VBGADJ_1 = 0x1,
                    /// VBG+1.56%
                    REFTOP_VBGADJ_2 = 0x2,
                    /// VBG+2.34%
                    REFTOP_VBGADJ_3 = 0x3,
                    /// VBG-0.78%
                    REFTOP_VBGADJ_4 = 0x4,
                    /// VBG-1.56%
                    REFTOP_VBGADJ_5 = 0x5,
                    /// VBG-2.34%
                    REFTOP_VBGADJ_6 = 0x6,
                    /// VBG-3.12%
                    REFTOP_VBGADJ_7 = 0x7,
                },
                /// Status bit that signals the analog bandgap voltage is up and stable
                REFTOP_VBGUP: u1,
                reserved10: u2 = 0,
                /// Configure the analog behavior in stop mode.
                STOP_MODE_CONFIG: enum(u2) {
                    /// All analog except RTC powered down on stop mode assertion.
                    STOP_MODE_CONFIG_0 = 0x0,
                    /// Beside RTC, analog bandgap, 1p1 and 2p5 regulators are also on.
                    STOP_MODE_CONFIG_1 = 0x1,
                    /// Beside RTC, 1p1 and 2p5 regulators are also on, low-power bandgap is selected so that the normal analog bandgap together with the rest analog is powered down.
                    STOP_MODE_CONFIG_2 = 0x2,
                    /// Beside RTC, low-power bandgap is selected and the rest analog is powered down.
                    STOP_MODE_CONFIG_3 = 0x3,
                },
                /// This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
                DISCON_HIGH_SNVS: enum(u1) {
                    /// Turn on the switch
                    DISCON_HIGH_SNVS_0 = 0x0,
                    /// Turn off the switch
                    DISCON_HIGH_SNVS_1 = 0x1,
                },
                /// This field determines the bias current in the 24MHz oscillator
                OSC_I: enum(u2) {
                    /// Nominal
                    NOMINAL = 0x0,
                    /// Decrease current by 12.5%
                    MINUS_12_5_PERCENT = 0x1,
                    /// Decrease current by 25.0%
                    MINUS_25_PERCENT = 0x2,
                    /// Decrease current by 37.5%
                    MINUS_37_5_PERCENT = 0x3,
                },
                /// Status bit that signals that the output of the 24-MHz crystal oscillator is stable
                OSC_XTALOK: u1,
                /// This bit enables the detector that signals when the 24MHz crystal oscillator is stable
                OSC_XTALOK_EN: u1,
                reserved25: u8 = 0,
                /// This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
                CLKGATE_CTRL: enum(u1) {
                    /// Allow the logic to automatically gate the clock when the XTAL is powered down.
                    ALLOW_AUTO_GATE = 0x0,
                    /// Prevent the logic from ever gating off the clock.
                    NO_AUTO_GATE = 0x1,
                },
                /// This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
                CLKGATE_DELAY: enum(u3) {
                    /// 0.5ms
                    CLKGATE_DELAY_0 = 0x0,
                    /// 1.0ms
                    CLKGATE_DELAY_1 = 0x1,
                    /// 2.0ms
                    CLKGATE_DELAY_2 = 0x2,
                    /// 3.0ms
                    CLKGATE_DELAY_3 = 0x3,
                    /// 4.0ms
                    CLKGATE_DELAY_4 = 0x4,
                    /// 5.0ms
                    CLKGATE_DELAY_5 = 0x5,
                    /// 6.0ms
                    CLKGATE_DELAY_6 = 0x6,
                    /// 7.0ms
                    CLKGATE_DELAY_7 = 0x7,
                },
                /// This field indicates which chip source is being used for the rtc clock
                RTC_XTAL_SOURCE: enum(u1) {
                    /// Internal ring oscillator
                    RTC_XTAL_SOURCE_0 = 0x0,
                    /// RTC_XTAL
                    RTC_XTAL_SOURCE_1 = 0x1,
                },
                /// This field powers down the 24M crystal oscillator if set true
                XTAL_24M_PWD: u1,
                padding: u1 = 0,
            }),
            /// Miscellaneous Register 0
            MISC0_SET: mmio.Mmio(packed struct(u32) {
                /// Control bit to power-down the analog bandgap reference circuitry
                REFTOP_PWD: u1,
                reserved3: u2 = 0,
                /// Control bit to disable the self-bias circuit in the analog bandgap
                REFTOP_SELFBIASOFF: enum(u1) {
                    /// Uses coarse bias currents for startup
                    REFTOP_SELFBIASOFF_0 = 0x0,
                    /// Uses bandgap-based bias currents for best performance.
                    REFTOP_SELFBIASOFF_1 = 0x1,
                },
                /// Not related to CCM. See Power Management Unit (PMU)
                REFTOP_VBGADJ: enum(u3) {
                    /// Nominal VBG
                    REFTOP_VBGADJ_0 = 0x0,
                    /// VBG+0.78%
                    REFTOP_VBGADJ_1 = 0x1,
                    /// VBG+1.56%
                    REFTOP_VBGADJ_2 = 0x2,
                    /// VBG+2.34%
                    REFTOP_VBGADJ_3 = 0x3,
                    /// VBG-0.78%
                    REFTOP_VBGADJ_4 = 0x4,
                    /// VBG-1.56%
                    REFTOP_VBGADJ_5 = 0x5,
                    /// VBG-2.34%
                    REFTOP_VBGADJ_6 = 0x6,
                    /// VBG-3.12%
                    REFTOP_VBGADJ_7 = 0x7,
                },
                /// Status bit that signals the analog bandgap voltage is up and stable
                REFTOP_VBGUP: u1,
                reserved10: u2 = 0,
                /// Configure the analog behavior in stop mode.
                STOP_MODE_CONFIG: enum(u2) {
                    /// All analog except RTC powered down on stop mode assertion.
                    STOP_MODE_CONFIG_0 = 0x0,
                    /// Beside RTC, analog bandgap, 1p1 and 2p5 regulators are also on.
                    STOP_MODE_CONFIG_1 = 0x1,
                    /// Beside RTC, 1p1 and 2p5 regulators are also on, low-power bandgap is selected so that the normal analog bandgap together with the rest analog is powered down.
                    STOP_MODE_CONFIG_2 = 0x2,
                    /// Beside RTC, low-power bandgap is selected and the rest analog is powered down.
                    STOP_MODE_CONFIG_3 = 0x3,
                },
                /// This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
                DISCON_HIGH_SNVS: enum(u1) {
                    /// Turn on the switch
                    DISCON_HIGH_SNVS_0 = 0x0,
                    /// Turn off the switch
                    DISCON_HIGH_SNVS_1 = 0x1,
                },
                /// This field determines the bias current in the 24MHz oscillator
                OSC_I: enum(u2) {
                    /// Nominal
                    NOMINAL = 0x0,
                    /// Decrease current by 12.5%
                    MINUS_12_5_PERCENT = 0x1,
                    /// Decrease current by 25.0%
                    MINUS_25_PERCENT = 0x2,
                    /// Decrease current by 37.5%
                    MINUS_37_5_PERCENT = 0x3,
                },
                /// Status bit that signals that the output of the 24-MHz crystal oscillator is stable
                OSC_XTALOK: u1,
                /// This bit enables the detector that signals when the 24MHz crystal oscillator is stable
                OSC_XTALOK_EN: u1,
                reserved25: u8 = 0,
                /// This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
                CLKGATE_CTRL: enum(u1) {
                    /// Allow the logic to automatically gate the clock when the XTAL is powered down.
                    ALLOW_AUTO_GATE = 0x0,
                    /// Prevent the logic from ever gating off the clock.
                    NO_AUTO_GATE = 0x1,
                },
                /// This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
                CLKGATE_DELAY: enum(u3) {
                    /// 0.5ms
                    CLKGATE_DELAY_0 = 0x0,
                    /// 1.0ms
                    CLKGATE_DELAY_1 = 0x1,
                    /// 2.0ms
                    CLKGATE_DELAY_2 = 0x2,
                    /// 3.0ms
                    CLKGATE_DELAY_3 = 0x3,
                    /// 4.0ms
                    CLKGATE_DELAY_4 = 0x4,
                    /// 5.0ms
                    CLKGATE_DELAY_5 = 0x5,
                    /// 6.0ms
                    CLKGATE_DELAY_6 = 0x6,
                    /// 7.0ms
                    CLKGATE_DELAY_7 = 0x7,
                },
                /// This field indicates which chip source is being used for the rtc clock
                RTC_XTAL_SOURCE: enum(u1) {
                    /// Internal ring oscillator
                    RTC_XTAL_SOURCE_0 = 0x0,
                    /// RTC_XTAL
                    RTC_XTAL_SOURCE_1 = 0x1,
                },
                /// This field powers down the 24M crystal oscillator if set true
                XTAL_24M_PWD: u1,
                padding: u1 = 0,
            }),
            /// Miscellaneous Register 0
            MISC0_CLR: mmio.Mmio(packed struct(u32) {
                /// Control bit to power-down the analog bandgap reference circuitry
                REFTOP_PWD: u1,
                reserved3: u2 = 0,
                /// Control bit to disable the self-bias circuit in the analog bandgap
                REFTOP_SELFBIASOFF: enum(u1) {
                    /// Uses coarse bias currents for startup
                    REFTOP_SELFBIASOFF_0 = 0x0,
                    /// Uses bandgap-based bias currents for best performance.
                    REFTOP_SELFBIASOFF_1 = 0x1,
                },
                /// Not related to CCM. See Power Management Unit (PMU)
                REFTOP_VBGADJ: enum(u3) {
                    /// Nominal VBG
                    REFTOP_VBGADJ_0 = 0x0,
                    /// VBG+0.78%
                    REFTOP_VBGADJ_1 = 0x1,
                    /// VBG+1.56%
                    REFTOP_VBGADJ_2 = 0x2,
                    /// VBG+2.34%
                    REFTOP_VBGADJ_3 = 0x3,
                    /// VBG-0.78%
                    REFTOP_VBGADJ_4 = 0x4,
                    /// VBG-1.56%
                    REFTOP_VBGADJ_5 = 0x5,
                    /// VBG-2.34%
                    REFTOP_VBGADJ_6 = 0x6,
                    /// VBG-3.12%
                    REFTOP_VBGADJ_7 = 0x7,
                },
                /// Status bit that signals the analog bandgap voltage is up and stable
                REFTOP_VBGUP: u1,
                reserved10: u2 = 0,
                /// Configure the analog behavior in stop mode.
                STOP_MODE_CONFIG: enum(u2) {
                    /// All analog except RTC powered down on stop mode assertion.
                    STOP_MODE_CONFIG_0 = 0x0,
                    /// Beside RTC, analog bandgap, 1p1 and 2p5 regulators are also on.
                    STOP_MODE_CONFIG_1 = 0x1,
                    /// Beside RTC, 1p1 and 2p5 regulators are also on, low-power bandgap is selected so that the normal analog bandgap together with the rest analog is powered down.
                    STOP_MODE_CONFIG_2 = 0x2,
                    /// Beside RTC, low-power bandgap is selected and the rest analog is powered down.
                    STOP_MODE_CONFIG_3 = 0x3,
                },
                /// This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
                DISCON_HIGH_SNVS: enum(u1) {
                    /// Turn on the switch
                    DISCON_HIGH_SNVS_0 = 0x0,
                    /// Turn off the switch
                    DISCON_HIGH_SNVS_1 = 0x1,
                },
                /// This field determines the bias current in the 24MHz oscillator
                OSC_I: enum(u2) {
                    /// Nominal
                    NOMINAL = 0x0,
                    /// Decrease current by 12.5%
                    MINUS_12_5_PERCENT = 0x1,
                    /// Decrease current by 25.0%
                    MINUS_25_PERCENT = 0x2,
                    /// Decrease current by 37.5%
                    MINUS_37_5_PERCENT = 0x3,
                },
                /// Status bit that signals that the output of the 24-MHz crystal oscillator is stable
                OSC_XTALOK: u1,
                /// This bit enables the detector that signals when the 24MHz crystal oscillator is stable
                OSC_XTALOK_EN: u1,
                reserved25: u8 = 0,
                /// This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
                CLKGATE_CTRL: enum(u1) {
                    /// Allow the logic to automatically gate the clock when the XTAL is powered down.
                    ALLOW_AUTO_GATE = 0x0,
                    /// Prevent the logic from ever gating off the clock.
                    NO_AUTO_GATE = 0x1,
                },
                /// This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
                CLKGATE_DELAY: enum(u3) {
                    /// 0.5ms
                    CLKGATE_DELAY_0 = 0x0,
                    /// 1.0ms
                    CLKGATE_DELAY_1 = 0x1,
                    /// 2.0ms
                    CLKGATE_DELAY_2 = 0x2,
                    /// 3.0ms
                    CLKGATE_DELAY_3 = 0x3,
                    /// 4.0ms
                    CLKGATE_DELAY_4 = 0x4,
                    /// 5.0ms
                    CLKGATE_DELAY_5 = 0x5,
                    /// 6.0ms
                    CLKGATE_DELAY_6 = 0x6,
                    /// 7.0ms
                    CLKGATE_DELAY_7 = 0x7,
                },
                /// This field indicates which chip source is being used for the rtc clock
                RTC_XTAL_SOURCE: enum(u1) {
                    /// Internal ring oscillator
                    RTC_XTAL_SOURCE_0 = 0x0,
                    /// RTC_XTAL
                    RTC_XTAL_SOURCE_1 = 0x1,
                },
                /// This field powers down the 24M crystal oscillator if set true
                XTAL_24M_PWD: u1,
                padding: u1 = 0,
            }),
            /// Miscellaneous Register 0
            MISC0_TOG: mmio.Mmio(packed struct(u32) {
                /// Control bit to power-down the analog bandgap reference circuitry
                REFTOP_PWD: u1,
                reserved3: u2 = 0,
                /// Control bit to disable the self-bias circuit in the analog bandgap
                REFTOP_SELFBIASOFF: enum(u1) {
                    /// Uses coarse bias currents for startup
                    REFTOP_SELFBIASOFF_0 = 0x0,
                    /// Uses bandgap-based bias currents for best performance.
                    REFTOP_SELFBIASOFF_1 = 0x1,
                },
                /// Not related to CCM. See Power Management Unit (PMU)
                REFTOP_VBGADJ: enum(u3) {
                    /// Nominal VBG
                    REFTOP_VBGADJ_0 = 0x0,
                    /// VBG+0.78%
                    REFTOP_VBGADJ_1 = 0x1,
                    /// VBG+1.56%
                    REFTOP_VBGADJ_2 = 0x2,
                    /// VBG+2.34%
                    REFTOP_VBGADJ_3 = 0x3,
                    /// VBG-0.78%
                    REFTOP_VBGADJ_4 = 0x4,
                    /// VBG-1.56%
                    REFTOP_VBGADJ_5 = 0x5,
                    /// VBG-2.34%
                    REFTOP_VBGADJ_6 = 0x6,
                    /// VBG-3.12%
                    REFTOP_VBGADJ_7 = 0x7,
                },
                /// Status bit that signals the analog bandgap voltage is up and stable
                REFTOP_VBGUP: u1,
                reserved10: u2 = 0,
                /// Configure the analog behavior in stop mode.
                STOP_MODE_CONFIG: enum(u2) {
                    /// All analog except RTC powered down on stop mode assertion.
                    STOP_MODE_CONFIG_0 = 0x0,
                    /// Beside RTC, analog bandgap, 1p1 and 2p5 regulators are also on.
                    STOP_MODE_CONFIG_1 = 0x1,
                    /// Beside RTC, 1p1 and 2p5 regulators are also on, low-power bandgap is selected so that the normal analog bandgap together with the rest analog is powered down.
                    STOP_MODE_CONFIG_2 = 0x2,
                    /// Beside RTC, low-power bandgap is selected and the rest analog is powered down.
                    STOP_MODE_CONFIG_3 = 0x3,
                },
                /// This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
                DISCON_HIGH_SNVS: enum(u1) {
                    /// Turn on the switch
                    DISCON_HIGH_SNVS_0 = 0x0,
                    /// Turn off the switch
                    DISCON_HIGH_SNVS_1 = 0x1,
                },
                /// This field determines the bias current in the 24MHz oscillator
                OSC_I: enum(u2) {
                    /// Nominal
                    NOMINAL = 0x0,
                    /// Decrease current by 12.5%
                    MINUS_12_5_PERCENT = 0x1,
                    /// Decrease current by 25.0%
                    MINUS_25_PERCENT = 0x2,
                    /// Decrease current by 37.5%
                    MINUS_37_5_PERCENT = 0x3,
                },
                /// Status bit that signals that the output of the 24-MHz crystal oscillator is stable
                OSC_XTALOK: u1,
                /// This bit enables the detector that signals when the 24MHz crystal oscillator is stable
                OSC_XTALOK_EN: u1,
                reserved25: u8 = 0,
                /// This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
                CLKGATE_CTRL: enum(u1) {
                    /// Allow the logic to automatically gate the clock when the XTAL is powered down.
                    ALLOW_AUTO_GATE = 0x0,
                    /// Prevent the logic from ever gating off the clock.
                    NO_AUTO_GATE = 0x1,
                },
                /// This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
                CLKGATE_DELAY: enum(u3) {
                    /// 0.5ms
                    CLKGATE_DELAY_0 = 0x0,
                    /// 1.0ms
                    CLKGATE_DELAY_1 = 0x1,
                    /// 2.0ms
                    CLKGATE_DELAY_2 = 0x2,
                    /// 3.0ms
                    CLKGATE_DELAY_3 = 0x3,
                    /// 4.0ms
                    CLKGATE_DELAY_4 = 0x4,
                    /// 5.0ms
                    CLKGATE_DELAY_5 = 0x5,
                    /// 6.0ms
                    CLKGATE_DELAY_6 = 0x6,
                    /// 7.0ms
                    CLKGATE_DELAY_7 = 0x7,
                },
                /// This field indicates which chip source is being used for the rtc clock
                RTC_XTAL_SOURCE: enum(u1) {
                    /// Internal ring oscillator
                    RTC_XTAL_SOURCE_0 = 0x0,
                    /// RTC_XTAL
                    RTC_XTAL_SOURCE_1 = 0x1,
                },
                /// This field powers down the 24M crystal oscillator if set true
                XTAL_24M_PWD: u1,
                padding: u1 = 0,
            }),
            /// Miscellaneous Register 1
            MISC1: mmio.Mmio(packed struct(u32) {
                /// This field selects the clk to be routed to anaclk1/1b.
                LVDS1_CLK_SEL: enum(u5) {
                    /// Arm PLL
                    ARM_PLL = 0x0,
                    /// System PLL
                    SYS_PLL = 0x1,
                    /// ref_pfd4_clk == pll2_pfd0_clk
                    PFD4 = 0x2,
                    /// ref_pfd5_clk == pll2_pfd1_clk
                    PFD5 = 0x3,
                    /// ref_pfd6_clk == pll2_pfd2_clk
                    PFD6 = 0x4,
                    /// ref_pfd7_clk == pll2_pfd3_clk
                    PFD7 = 0x5,
                    /// Audio PLL
                    AUDIO_PLL = 0x6,
                    /// Video PLL
                    VIDEO_PLL = 0x7,
                    /// ethernet ref clock (ENET_PLL)
                    ETHERNET_REF = 0x9,
                    /// USB1 PLL clock
                    USB1_PLL = 0xc,
                    /// USB2 PLL clock
                    USB2_PLL = 0xd,
                    /// ref_pfd0_clk == pll3_pfd0_clk
                    PFD0 = 0xe,
                    /// ref_pfd1_clk == pll3_pfd1_clk
                    PFD1 = 0xf,
                    /// ref_pfd2_clk == pll3_pfd2_clk
                    PFD2 = 0x10,
                    /// ref_pfd3_clk == pll3_pfd3_clk
                    PFD3 = 0x11,
                    /// xtal (24M)
                    XTAL = 0x12,
                    _,
                },
                reserved10: u5 = 0,
                /// This enables the LVDS output buffer for anaclk1/1b
                LVDSCLK1_OBEN: u1,
                reserved12: u1 = 0,
                /// This enables the LVDS input buffer for anaclk1/1b
                LVDSCLK1_IBEN: u1,
                reserved16: u3 = 0,
                /// This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
                PFD_480_AUTOGATE_EN: u1,
                /// This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
                PFD_528_AUTOGATE_EN: u1,
                reserved27: u9 = 0,
                /// This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
                IRQ_TEMPPANIC: u1,
                /// This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
                IRQ_TEMPLOW: u1,
                /// This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
                IRQ_TEMPHIGH: u1,
                /// This status bit is set to one when when any of the analog regulator brownout interrupts assert
                IRQ_ANA_BO: u1,
                /// This status bit is set to one when when any of the digital regulator brownout interrupts assert
                IRQ_DIG_BO: u1,
            }),
            /// Miscellaneous Register 1
            MISC1_SET: mmio.Mmio(packed struct(u32) {
                /// This field selects the clk to be routed to anaclk1/1b.
                LVDS1_CLK_SEL: enum(u5) {
                    /// Arm PLL
                    ARM_PLL = 0x0,
                    /// System PLL
                    SYS_PLL = 0x1,
                    /// ref_pfd4_clk == pll2_pfd0_clk
                    PFD4 = 0x2,
                    /// ref_pfd5_clk == pll2_pfd1_clk
                    PFD5 = 0x3,
                    /// ref_pfd6_clk == pll2_pfd2_clk
                    PFD6 = 0x4,
                    /// ref_pfd7_clk == pll2_pfd3_clk
                    PFD7 = 0x5,
                    /// Audio PLL
                    AUDIO_PLL = 0x6,
                    /// Video PLL
                    VIDEO_PLL = 0x7,
                    /// ethernet ref clock (ENET_PLL)
                    ETHERNET_REF = 0x9,
                    /// USB1 PLL clock
                    USB1_PLL = 0xc,
                    /// USB2 PLL clock
                    USB2_PLL = 0xd,
                    /// ref_pfd0_clk == pll3_pfd0_clk
                    PFD0 = 0xe,
                    /// ref_pfd1_clk == pll3_pfd1_clk
                    PFD1 = 0xf,
                    /// ref_pfd2_clk == pll3_pfd2_clk
                    PFD2 = 0x10,
                    /// ref_pfd3_clk == pll3_pfd3_clk
                    PFD3 = 0x11,
                    /// xtal (24M)
                    XTAL = 0x12,
                    _,
                },
                reserved10: u5 = 0,
                /// This enables the LVDS output buffer for anaclk1/1b
                LVDSCLK1_OBEN: u1,
                reserved12: u1 = 0,
                /// This enables the LVDS input buffer for anaclk1/1b
                LVDSCLK1_IBEN: u1,
                reserved16: u3 = 0,
                /// This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
                PFD_480_AUTOGATE_EN: u1,
                /// This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
                PFD_528_AUTOGATE_EN: u1,
                reserved27: u9 = 0,
                /// This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
                IRQ_TEMPPANIC: u1,
                /// This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
                IRQ_TEMPLOW: u1,
                /// This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
                IRQ_TEMPHIGH: u1,
                /// This status bit is set to one when when any of the analog regulator brownout interrupts assert
                IRQ_ANA_BO: u1,
                /// This status bit is set to one when when any of the digital regulator brownout interrupts assert
                IRQ_DIG_BO: u1,
            }),
            /// Miscellaneous Register 1
            MISC1_CLR: mmio.Mmio(packed struct(u32) {
                /// This field selects the clk to be routed to anaclk1/1b.
                LVDS1_CLK_SEL: enum(u5) {
                    /// Arm PLL
                    ARM_PLL = 0x0,
                    /// System PLL
                    SYS_PLL = 0x1,
                    /// ref_pfd4_clk == pll2_pfd0_clk
                    PFD4 = 0x2,
                    /// ref_pfd5_clk == pll2_pfd1_clk
                    PFD5 = 0x3,
                    /// ref_pfd6_clk == pll2_pfd2_clk
                    PFD6 = 0x4,
                    /// ref_pfd7_clk == pll2_pfd3_clk
                    PFD7 = 0x5,
                    /// Audio PLL
                    AUDIO_PLL = 0x6,
                    /// Video PLL
                    VIDEO_PLL = 0x7,
                    /// ethernet ref clock (ENET_PLL)
                    ETHERNET_REF = 0x9,
                    /// USB1 PLL clock
                    USB1_PLL = 0xc,
                    /// USB2 PLL clock
                    USB2_PLL = 0xd,
                    /// ref_pfd0_clk == pll3_pfd0_clk
                    PFD0 = 0xe,
                    /// ref_pfd1_clk == pll3_pfd1_clk
                    PFD1 = 0xf,
                    /// ref_pfd2_clk == pll3_pfd2_clk
                    PFD2 = 0x10,
                    /// ref_pfd3_clk == pll3_pfd3_clk
                    PFD3 = 0x11,
                    /// xtal (24M)
                    XTAL = 0x12,
                    _,
                },
                reserved10: u5 = 0,
                /// This enables the LVDS output buffer for anaclk1/1b
                LVDSCLK1_OBEN: u1,
                reserved12: u1 = 0,
                /// This enables the LVDS input buffer for anaclk1/1b
                LVDSCLK1_IBEN: u1,
                reserved16: u3 = 0,
                /// This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
                PFD_480_AUTOGATE_EN: u1,
                /// This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
                PFD_528_AUTOGATE_EN: u1,
                reserved27: u9 = 0,
                /// This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
                IRQ_TEMPPANIC: u1,
                /// This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
                IRQ_TEMPLOW: u1,
                /// This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
                IRQ_TEMPHIGH: u1,
                /// This status bit is set to one when when any of the analog regulator brownout interrupts assert
                IRQ_ANA_BO: u1,
                /// This status bit is set to one when when any of the digital regulator brownout interrupts assert
                IRQ_DIG_BO: u1,
            }),
            /// Miscellaneous Register 1
            MISC1_TOG: mmio.Mmio(packed struct(u32) {
                /// This field selects the clk to be routed to anaclk1/1b.
                LVDS1_CLK_SEL: enum(u5) {
                    /// Arm PLL
                    ARM_PLL = 0x0,
                    /// System PLL
                    SYS_PLL = 0x1,
                    /// ref_pfd4_clk == pll2_pfd0_clk
                    PFD4 = 0x2,
                    /// ref_pfd5_clk == pll2_pfd1_clk
                    PFD5 = 0x3,
                    /// ref_pfd6_clk == pll2_pfd2_clk
                    PFD6 = 0x4,
                    /// ref_pfd7_clk == pll2_pfd3_clk
                    PFD7 = 0x5,
                    /// Audio PLL
                    AUDIO_PLL = 0x6,
                    /// Video PLL
                    VIDEO_PLL = 0x7,
                    /// ethernet ref clock (ENET_PLL)
                    ETHERNET_REF = 0x9,
                    /// USB1 PLL clock
                    USB1_PLL = 0xc,
                    /// USB2 PLL clock
                    USB2_PLL = 0xd,
                    /// ref_pfd0_clk == pll3_pfd0_clk
                    PFD0 = 0xe,
                    /// ref_pfd1_clk == pll3_pfd1_clk
                    PFD1 = 0xf,
                    /// ref_pfd2_clk == pll3_pfd2_clk
                    PFD2 = 0x10,
                    /// ref_pfd3_clk == pll3_pfd3_clk
                    PFD3 = 0x11,
                    /// xtal (24M)
                    XTAL = 0x12,
                    _,
                },
                reserved10: u5 = 0,
                /// This enables the LVDS output buffer for anaclk1/1b
                LVDSCLK1_OBEN: u1,
                reserved12: u1 = 0,
                /// This enables the LVDS input buffer for anaclk1/1b
                LVDSCLK1_IBEN: u1,
                reserved16: u3 = 0,
                /// This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
                PFD_480_AUTOGATE_EN: u1,
                /// This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
                PFD_528_AUTOGATE_EN: u1,
                reserved27: u9 = 0,
                /// This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
                IRQ_TEMPPANIC: u1,
                /// This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
                IRQ_TEMPLOW: u1,
                /// This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
                IRQ_TEMPHIGH: u1,
                /// This status bit is set to one when when any of the analog regulator brownout interrupts assert
                IRQ_ANA_BO: u1,
                /// This status bit is set to one when when any of the digital regulator brownout interrupts assert
                IRQ_DIG_BO: u1,
            }),
            /// Miscellaneous Register 2
            MISC2: mmio.Mmio(packed struct(u32) {
                /// This field defines the brown out voltage offset for the CORE power domain
                REG0_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG0_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG0_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg0 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
                REG0_BO_STATUS: enum(u1) {
                    /// Brownout, supply is below target minus brownout offset.
                    REG0_BO_STATUS_1 = 0x1,
                    _,
                },
                reserved5: u1 = 0,
                /// Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
                REG0_ENABLE_BO: u1,
                /// ARM supply Not related to CCM. See Power Management Unit (PMU)
                REG0_OK: u1,
                /// When USB is in low power suspend mode this Control bit is used to indicate if other system peripherals require the USB PLL3 clock when the SoC is not in low power mode
                PLL3_DISABLE: enum(u1) {
                    /// PLL3 is being used by peripherals and is enabled when SoC is not in any low power mode
                    PLL3_DISABLE_0 = 0x0,
                    /// PLL3 can be disabled when the SoC is not in any low power mode
                    PLL3_DISABLE_1 = 0x1,
                },
                /// This field defines the brown out voltage offset for the xPU power domain
                REG1_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG1_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG1_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg1 brownout status bit. Not related to CCM. See Power Management Unit (PMU)
                REG1_BO_STATUS: enum(u1) {
                    /// Brownout, supply is below target minus brownout offset.
                    REG1_BO_STATUS_1 = 0x1,
                    _,
                },
                reserved13: u1 = 0,
                /// Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
                REG1_ENABLE_BO: u1,
                /// GPU/VPU supply Not related to CCM. See Power Management Unit (PMU)
                REG1_OK: u1,
                /// LSB of Post-divider for Audio PLL
                AUDIO_DIV_LSB: enum(u1) {
                    /// divide by 1 (Default)
                    AUDIO_DIV_LSB_0 = 0x0,
                    /// divide by 2
                    AUDIO_DIV_LSB_1 = 0x1,
                },
                /// This field defines the brown out voltage offset for the xPU power domain
                REG2_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG2_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG2_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg2 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
                REG2_BO_STATUS: u1,
                reserved21: u1 = 0,
                /// Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
                REG2_ENABLE_BO: u1,
                /// Signals that the voltage is above the brownout level for the SOC supply
                REG2_OK: u1,
                /// MSB of Post-divider for Audio PLL
                AUDIO_DIV_MSB: enum(u1) {
                    /// divide by 1 (Default)
                    AUDIO_DIV_MSB_0 = 0x0,
                    /// divide by 2
                    AUDIO_DIV_MSB_1 = 0x1,
                },
                /// Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
                REG0_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
                REG1_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
                REG2_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Post-divider for video
                VIDEO_DIV: enum(u2) {
                    /// divide by 1 (Default)
                    VIDEO_DIV_0 = 0x0,
                    /// divide by 2
                    VIDEO_DIV_1 = 0x1,
                    /// divide by 1
                    VIDEO_DIV_2 = 0x2,
                    /// divide by 4
                    VIDEO_DIV_3 = 0x3,
                },
            }),
            /// Miscellaneous Register 2
            MISC2_SET: mmio.Mmio(packed struct(u32) {
                /// This field defines the brown out voltage offset for the CORE power domain
                REG0_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG0_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG0_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg0 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
                REG0_BO_STATUS: enum(u1) {
                    /// Brownout, supply is below target minus brownout offset.
                    REG0_BO_STATUS_1 = 0x1,
                    _,
                },
                reserved5: u1 = 0,
                /// Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
                REG0_ENABLE_BO: u1,
                /// ARM supply Not related to CCM. See Power Management Unit (PMU)
                REG0_OK: u1,
                /// When USB is in low power suspend mode this Control bit is used to indicate if other system peripherals require the USB PLL3 clock when the SoC is not in low power mode
                PLL3_DISABLE: enum(u1) {
                    /// PLL3 is being used by peripherals and is enabled when SoC is not in any low power mode
                    PLL3_DISABLE_0 = 0x0,
                    /// PLL3 can be disabled when the SoC is not in any low power mode
                    PLL3_DISABLE_1 = 0x1,
                },
                /// This field defines the brown out voltage offset for the xPU power domain
                REG1_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG1_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG1_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg1 brownout status bit. Not related to CCM. See Power Management Unit (PMU)
                REG1_BO_STATUS: enum(u1) {
                    /// Brownout, supply is below target minus brownout offset.
                    REG1_BO_STATUS_1 = 0x1,
                    _,
                },
                reserved13: u1 = 0,
                /// Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
                REG1_ENABLE_BO: u1,
                /// GPU/VPU supply Not related to CCM. See Power Management Unit (PMU)
                REG1_OK: u1,
                /// LSB of Post-divider for Audio PLL
                AUDIO_DIV_LSB: enum(u1) {
                    /// divide by 1 (Default)
                    AUDIO_DIV_LSB_0 = 0x0,
                    /// divide by 2
                    AUDIO_DIV_LSB_1 = 0x1,
                },
                /// This field defines the brown out voltage offset for the xPU power domain
                REG2_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG2_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG2_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg2 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
                REG2_BO_STATUS: u1,
                reserved21: u1 = 0,
                /// Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
                REG2_ENABLE_BO: u1,
                /// Signals that the voltage is above the brownout level for the SOC supply
                REG2_OK: u1,
                /// MSB of Post-divider for Audio PLL
                AUDIO_DIV_MSB: enum(u1) {
                    /// divide by 1 (Default)
                    AUDIO_DIV_MSB_0 = 0x0,
                    /// divide by 2
                    AUDIO_DIV_MSB_1 = 0x1,
                },
                /// Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
                REG0_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
                REG1_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
                REG2_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Post-divider for video
                VIDEO_DIV: enum(u2) {
                    /// divide by 1 (Default)
                    VIDEO_DIV_0 = 0x0,
                    /// divide by 2
                    VIDEO_DIV_1 = 0x1,
                    /// divide by 1
                    VIDEO_DIV_2 = 0x2,
                    /// divide by 4
                    VIDEO_DIV_3 = 0x3,
                },
            }),
            /// Miscellaneous Register 2
            MISC2_CLR: mmio.Mmio(packed struct(u32) {
                /// This field defines the brown out voltage offset for the CORE power domain
                REG0_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG0_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG0_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg0 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
                REG0_BO_STATUS: enum(u1) {
                    /// Brownout, supply is below target minus brownout offset.
                    REG0_BO_STATUS_1 = 0x1,
                    _,
                },
                reserved5: u1 = 0,
                /// Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
                REG0_ENABLE_BO: u1,
                /// ARM supply Not related to CCM. See Power Management Unit (PMU)
                REG0_OK: u1,
                /// When USB is in low power suspend mode this Control bit is used to indicate if other system peripherals require the USB PLL3 clock when the SoC is not in low power mode
                PLL3_DISABLE: enum(u1) {
                    /// PLL3 is being used by peripherals and is enabled when SoC is not in any low power mode
                    PLL3_DISABLE_0 = 0x0,
                    /// PLL3 can be disabled when the SoC is not in any low power mode
                    PLL3_DISABLE_1 = 0x1,
                },
                /// This field defines the brown out voltage offset for the xPU power domain
                REG1_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG1_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG1_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg1 brownout status bit. Not related to CCM. See Power Management Unit (PMU)
                REG1_BO_STATUS: enum(u1) {
                    /// Brownout, supply is below target minus brownout offset.
                    REG1_BO_STATUS_1 = 0x1,
                    _,
                },
                reserved13: u1 = 0,
                /// Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
                REG1_ENABLE_BO: u1,
                /// GPU/VPU supply Not related to CCM. See Power Management Unit (PMU)
                REG1_OK: u1,
                /// LSB of Post-divider for Audio PLL
                AUDIO_DIV_LSB: enum(u1) {
                    /// divide by 1 (Default)
                    AUDIO_DIV_LSB_0 = 0x0,
                    /// divide by 2
                    AUDIO_DIV_LSB_1 = 0x1,
                },
                /// This field defines the brown out voltage offset for the xPU power domain
                REG2_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG2_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG2_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg2 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
                REG2_BO_STATUS: u1,
                reserved21: u1 = 0,
                /// Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
                REG2_ENABLE_BO: u1,
                /// Signals that the voltage is above the brownout level for the SOC supply
                REG2_OK: u1,
                /// MSB of Post-divider for Audio PLL
                AUDIO_DIV_MSB: enum(u1) {
                    /// divide by 1 (Default)
                    AUDIO_DIV_MSB_0 = 0x0,
                    /// divide by 2
                    AUDIO_DIV_MSB_1 = 0x1,
                },
                /// Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
                REG0_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
                REG1_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
                REG2_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Post-divider for video
                VIDEO_DIV: enum(u2) {
                    /// divide by 1 (Default)
                    VIDEO_DIV_0 = 0x0,
                    /// divide by 2
                    VIDEO_DIV_1 = 0x1,
                    /// divide by 1
                    VIDEO_DIV_2 = 0x2,
                    /// divide by 4
                    VIDEO_DIV_3 = 0x3,
                },
            }),
            /// Miscellaneous Register 2
            MISC2_TOG: mmio.Mmio(packed struct(u32) {
                /// This field defines the brown out voltage offset for the CORE power domain
                REG0_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG0_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG0_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg0 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
                REG0_BO_STATUS: enum(u1) {
                    /// Brownout, supply is below target minus brownout offset.
                    REG0_BO_STATUS_1 = 0x1,
                    _,
                },
                reserved5: u1 = 0,
                /// Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
                REG0_ENABLE_BO: u1,
                /// ARM supply Not related to CCM. See Power Management Unit (PMU)
                REG0_OK: u1,
                /// When USB is in low power suspend mode this Control bit is used to indicate if other system peripherals require the USB PLL3 clock when the SoC is not in low power mode
                PLL3_DISABLE: enum(u1) {
                    /// PLL3 is being used by peripherals and is enabled when SoC is not in any low power mode
                    PLL3_DISABLE_0 = 0x0,
                    /// PLL3 can be disabled when the SoC is not in any low power mode
                    PLL3_DISABLE_1 = 0x1,
                },
                /// This field defines the brown out voltage offset for the xPU power domain
                REG1_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG1_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG1_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg1 brownout status bit. Not related to CCM. See Power Management Unit (PMU)
                REG1_BO_STATUS: enum(u1) {
                    /// Brownout, supply is below target minus brownout offset.
                    REG1_BO_STATUS_1 = 0x1,
                    _,
                },
                reserved13: u1 = 0,
                /// Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
                REG1_ENABLE_BO: u1,
                /// GPU/VPU supply Not related to CCM. See Power Management Unit (PMU)
                REG1_OK: u1,
                /// LSB of Post-divider for Audio PLL
                AUDIO_DIV_LSB: enum(u1) {
                    /// divide by 1 (Default)
                    AUDIO_DIV_LSB_0 = 0x0,
                    /// divide by 2
                    AUDIO_DIV_LSB_1 = 0x1,
                },
                /// This field defines the brown out voltage offset for the xPU power domain
                REG2_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG2_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG2_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg2 brownout status bit.Not related to CCM. See Power Management Unit (PMU)
                REG2_BO_STATUS: u1,
                reserved21: u1 = 0,
                /// Enables the brownout detection.Not related to CCM. See Power Management Unit (PMU)
                REG2_ENABLE_BO: u1,
                /// Signals that the voltage is above the brownout level for the SOC supply
                REG2_OK: u1,
                /// MSB of Post-divider for Audio PLL
                AUDIO_DIV_MSB: enum(u1) {
                    /// divide by 1 (Default)
                    AUDIO_DIV_MSB_0 = 0x0,
                    /// divide by 2
                    AUDIO_DIV_MSB_1 = 0x1,
                },
                /// Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
                REG0_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
                REG1_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Number of clock periods (24MHz clock).Not related to CCM. See Power Management Unit (PMU)
                REG2_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Post-divider for video
                VIDEO_DIV: enum(u2) {
                    /// divide by 1 (Default)
                    VIDEO_DIV_0 = 0x0,
                    /// divide by 2
                    VIDEO_DIV_1 = 0x1,
                    /// divide by 1
                    VIDEO_DIV_2 = 0x2,
                    /// divide by 4
                    VIDEO_DIV_3 = 0x3,
                },
            }),
        };

        /// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
        pub const CMP1 = extern struct {
            /// CMP Control Register 0
            CR0: mmio.Mmio(packed struct(u8) {
                /// Comparator hard block hysteresis control
                HYSTCTR: enum(u2) {
                    /// Level 0
                    HYSTCTR_0 = 0x0,
                    /// Level 1
                    HYSTCTR_1 = 0x1,
                    /// Level 2
                    HYSTCTR_2 = 0x2,
                    /// Level 3
                    HYSTCTR_3 = 0x3,
                },
                reserved4: u2 = 0,
                /// Filter Sample Count
                FILTER_CNT: enum(u3) {
                    /// Filter is disabled. If SE = 1, then COUT is a logic 0. This is not a legal state, and is not recommended. If SE = 0, COUT = COUTA.
                    FILTER_CNT_0 = 0x0,
                    /// One sample must agree. The comparator output is simply sampled.
                    FILTER_CNT_1 = 0x1,
                    /// 2 consecutive samples must agree.
                    FILTER_CNT_2 = 0x2,
                    /// 3 consecutive samples must agree.
                    FILTER_CNT_3 = 0x3,
                    /// 4 consecutive samples must agree.
                    FILTER_CNT_4 = 0x4,
                    /// 5 consecutive samples must agree.
                    FILTER_CNT_5 = 0x5,
                    /// 6 consecutive samples must agree.
                    FILTER_CNT_6 = 0x6,
                    /// 7 consecutive samples must agree.
                    FILTER_CNT_7 = 0x7,
                },
                padding: u1 = 0,
            }),
            /// CMP Control Register 1
            CR1: mmio.Mmio(packed struct(u8) {
                /// Comparator Module Enable
                EN: enum(u1) {
                    /// Analog Comparator is disabled.
                    EN_0 = 0x0,
                    /// Analog Comparator is enabled.
                    EN_1 = 0x1,
                },
                /// Comparator Output Pin Enable
                OPE: enum(u1) {
                    /// CMPO is not available on the associated CMPO output pin. If the comparator does not own the pin, this field has no effect.
                    OPE_0 = 0x0,
                    /// CMPO is available on the associated CMPO output pin. The comparator output (CMPO) is driven out on the associated CMPO output pin if the comparator owns the pin. If the comparator does not own the field, this bit has no effect.
                    OPE_1 = 0x1,
                },
                /// Comparator Output Select
                COS: enum(u1) {
                    /// Set the filtered comparator output (CMPO) to equal COUT.
                    COS_0 = 0x0,
                    /// Set the unfiltered comparator output (CMPO) to equal COUTA.
                    COS_1 = 0x1,
                },
                /// Comparator INVERT
                INV: enum(u1) {
                    /// Does not invert the comparator output.
                    INV_0 = 0x0,
                    /// Inverts the comparator output.
                    INV_1 = 0x1,
                },
                /// Power Mode Select
                PMODE: enum(u1) {
                    /// Low-Speed (LS) Comparison mode selected. In this mode, CMP has slower output propagation delay and lower current consumption.
                    PMODE_0 = 0x0,
                    /// High-Speed (HS) Comparison mode selected. In this mode, CMP has faster output propagation delay and higher current consumption.
                    PMODE_1 = 0x1,
                },
                reserved6: u1 = 0,
                /// Windowing Enable
                WE: enum(u1) {
                    /// Windowing mode is not selected.
                    WE_0 = 0x0,
                    /// Windowing mode is selected.
                    WE_1 = 0x1,
                },
                /// Sample Enable
                SE: enum(u1) {
                    /// Sampling mode is not selected.
                    SE_0 = 0x0,
                    /// Sampling mode is selected.
                    SE_1 = 0x1,
                },
            }),
            /// CMP Filter Period Register
            FPR: mmio.Mmio(packed struct(u8) {
                /// Filter Sample Period
                FILT_PER: u8,
            }),
            /// CMP Status and Control Register
            SCR: mmio.Mmio(packed struct(u8) {
                /// Analog Comparator Output
                COUT: u1,
                /// Analog Comparator Flag Falling
                CFF: enum(u1) {
                    /// Falling-edge on COUT has not been detected.
                    CFF_0 = 0x0,
                    /// Falling-edge on COUT has occurred.
                    CFF_1 = 0x1,
                },
                /// Analog Comparator Flag Rising
                CFR: enum(u1) {
                    /// Rising-edge on COUT has not been detected.
                    CFR_0 = 0x0,
                    /// Rising-edge on COUT has occurred.
                    CFR_1 = 0x1,
                },
                /// Comparator Interrupt Enable Falling
                IEF: enum(u1) {
                    /// Interrupt is disabled.
                    IEF_0 = 0x0,
                    /// Interrupt is enabled.
                    IEF_1 = 0x1,
                },
                /// Comparator Interrupt Enable Rising
                IER: enum(u1) {
                    /// Interrupt is disabled.
                    IER_0 = 0x0,
                    /// Interrupt is enabled.
                    IER_1 = 0x1,
                },
                reserved6: u1 = 0,
                /// DMA Enable Control
                DMAEN: enum(u1) {
                    /// DMA is disabled.
                    DMAEN_0 = 0x0,
                    /// DMA is enabled.
                    DMAEN_1 = 0x1,
                },
                padding: u1 = 0,
            }),
            /// DAC Control Register
            DACCR: mmio.Mmio(packed struct(u8) {
                /// DAC Output Voltage Select
                VOSEL: u6,
                /// Supply Voltage Reference Source Select
                VRSEL: enum(u1) {
                    /// Vin1 is selected as resistor ladder network supply reference.
                    VRSEL_0 = 0x0,
                    /// Vin2 is selected as resistor ladder network supply reference.
                    VRSEL_1 = 0x1,
                },
                /// DAC Enable
                DACEN: enum(u1) {
                    /// DAC is disabled.
                    DACEN_0 = 0x0,
                    /// DAC is enabled.
                    DACEN_1 = 0x1,
                },
            }),
            /// MUX Control Register
            MUXCR: mmio.Mmio(packed struct(u8) {
                /// Minus Input Mux Control
                MSEL: enum(u3) {
                    /// IN0
                    MSEL_0 = 0x0,
                    /// IN1
                    MSEL_1 = 0x1,
                    /// IN2
                    MSEL_2 = 0x2,
                    /// IN3
                    MSEL_3 = 0x3,
                    /// IN4
                    MSEL_4 = 0x4,
                    /// IN5
                    MSEL_5 = 0x5,
                    /// IN6
                    MSEL_6 = 0x6,
                    /// IN7
                    MSEL_7 = 0x7,
                },
                /// Plus Input Mux Control
                PSEL: enum(u3) {
                    /// IN0
                    PSEL_0 = 0x0,
                    /// IN1
                    PSEL_1 = 0x1,
                    /// IN2
                    PSEL_2 = 0x2,
                    /// IN3
                    PSEL_3 = 0x3,
                    /// IN4
                    PSEL_4 = 0x4,
                    /// IN5
                    PSEL_5 = 0x5,
                    /// IN6
                    PSEL_6 = 0x6,
                    /// IN7
                    PSEL_7 = 0x7,
                },
                padding: u2 = 0,
            }),
        };

        /// CSI
        pub const CSI = extern struct {
            /// CSI Control Register 1
            CSICR1: mmio.Mmio(packed struct(u32) {
                /// Pixel Bit
                PIXEL_BIT: enum(u1) {
                    /// 8-bit data for each pixel
                    PIXEL_BIT_0 = 0x0,
                    /// 10-bit data for each pixel
                    PIXEL_BIT_1 = 0x1,
                },
                /// Valid Pixel Clock Edge Select
                REDGE: enum(u1) {
                    /// Pixel data is latched at the falling edge of CSI_PIXCLK
                    REDGE_0 = 0x0,
                    /// Pixel data is latched at the rising edge of CSI_PIXCLK
                    REDGE_1 = 0x1,
                },
                /// Invert Pixel Clock Input
                INV_PCLK: enum(u1) {
                    /// CSI_PIXCLK is directly applied to internal circuitry
                    INV_PCLK_0 = 0x0,
                    /// CSI_PIXCLK is inverted before applied to internal circuitry
                    INV_PCLK_1 = 0x1,
                },
                /// Invert Data Input. This bit enables or disables internal inverters on the data lines.
                INV_DATA: enum(u1) {
                    /// CSI_D[7:0] data lines are directly applied to internal circuitry
                    INV_DATA_0 = 0x0,
                    /// CSI_D[7:0] data lines are inverted before applied to internal circuitry
                    INV_DATA_1 = 0x1,
                },
                /// Gated Clock Mode Enable
                GCLK_MODE: enum(u1) {
                    /// Non-gated clock mode. All incoming pixel clocks are valid. HSYNC is ignored.
                    GCLK_MODE_0 = 0x0,
                    /// Gated clock mode. Pixel clock signal is valid only when HSYNC is active.
                    GCLK_MODE_1 = 0x1,
                },
                /// Asynchronous RXFIFO Clear
                CLR_RXFIFO: u1,
                /// Asynchronous STATFIFO Clear
                CLR_STATFIFO: u1,
                /// Data Packing Direction
                PACK_DIR: enum(u1) {
                    /// Pack from LSB first. For image data, 0x11, 0x22, 0x33, 0x44, it will appear as 0x44332211 in RX FIFO. For stat data, 0xAAAA, 0xBBBB, it will appear as 0xBBBBAAAA in STAT FIFO.
                    PACK_DIR_0 = 0x0,
                    /// Pack from MSB first. For image data, 0x11, 0x22, 0x33, 0x44, it will appear as 0x11223344 in RX FIFO. For stat data, 0xAAAA, 0xBBBB, it will appear as 0xAAAABBBB in STAT FIFO.
                    PACK_DIR_1 = 0x1,
                },
                /// FIFO Clear Control
                FCC: enum(u1) {
                    /// Asynchronous FIFO clear is selected.
                    FCC_0 = 0x0,
                    /// Synchronous FIFO clear is selected.
                    FCC_1 = 0x1,
                },
                reserved10: u1 = 0,
                /// CCIR656 Interface Enable
                CCIR_EN: enum(u1) {
                    /// Traditional interface is selected. Timing interface logic is used to latch data.
                    CCIR_EN_0 = 0x0,
                    /// CCIR656 interface is selected.
                    CCIR_EN_1 = 0x1,
                },
                /// HSYNC Polarity Select
                HSYNC_POL: enum(u1) {
                    /// HSYNC is active low
                    HSYNC_POL_0 = 0x0,
                    /// HSYNC is active high
                    HSYNC_POL_1 = 0x1,
                },
                reserved16: u4 = 0,
                /// Start Of Frame (SOF) Interrupt Enable. This bit enables the SOF interrupt.
                SOF_INTEN: enum(u1) {
                    /// SOF interrupt disable
                    SOF_INTEN_0 = 0x0,
                    /// SOF interrupt enable
                    SOF_INTEN_1 = 0x1,
                },
                /// SOF Interrupt Polarity. This bit controls the condition that generates an SOF interrupt.
                SOF_POL: enum(u1) {
                    /// SOF interrupt is generated on SOF falling edge
                    SOF_POL_0 = 0x0,
                    /// SOF interrupt is generated on SOF rising edge
                    SOF_POL_1 = 0x1,
                },
                /// RxFIFO Full Interrupt Enable. This bit enables the RxFIFO full interrupt.
                RXFF_INTEN: enum(u1) {
                    /// RxFIFO full interrupt disable
                    RXFF_INTEN_0 = 0x0,
                    /// RxFIFO full interrupt enable
                    RXFF_INTEN_1 = 0x1,
                },
                /// Frame Buffer1 DMA Transfer Done Interrupt Enable
                FB1_DMA_DONE_INTEN: enum(u1) {
                    /// Frame Buffer1 DMA Transfer Done interrupt disable
                    FB1_DMA_DONE_INTEN_0 = 0x0,
                    /// Frame Buffer1 DMA Transfer Done interrupt enable
                    FB1_DMA_DONE_INTEN_1 = 0x1,
                },
                /// Frame Buffer2 DMA Transfer Done Interrupt Enable
                FB2_DMA_DONE_INTEN: enum(u1) {
                    /// Frame Buffer2 DMA Transfer Done interrupt disable
                    FB2_DMA_DONE_INTEN_0 = 0x0,
                    /// Frame Buffer2 DMA Transfer Done interrupt enable
                    FB2_DMA_DONE_INTEN_1 = 0x1,
                },
                /// STATFIFO Full Interrupt Enable. This bit enables the STAT FIFO interrupt.
                STATFF_INTEN: enum(u1) {
                    /// STATFIFO full interrupt disable
                    STATFF_INTEN_0 = 0x0,
                    /// STATFIFO full interrupt enable
                    STATFF_INTEN_1 = 0x1,
                },
                /// STATFIFO DMA Transfer Done Interrupt Enable
                SFF_DMA_DONE_INTEN: enum(u1) {
                    /// STATFIFO DMA Transfer Done interrupt disable
                    SFF_DMA_DONE_INTEN_0 = 0x0,
                    /// STATFIFO DMA Transfer Done interrupt enable
                    SFF_DMA_DONE_INTEN_1 = 0x1,
                },
                reserved24: u1 = 0,
                /// RxFIFO Overrun Interrupt Enable. This bit enables the RX FIFO overrun interrupt.
                RF_OR_INTEN: enum(u1) {
                    /// RxFIFO overrun interrupt is disabled
                    RF_OR_INTEN_0 = 0x0,
                    /// RxFIFO overrun interrupt is enabled
                    RF_OR_INTEN_1 = 0x1,
                },
                /// STAT FIFO Overrun Interrupt Enable. This bit enables the STATFIFO overrun interrupt.
                SF_OR_INTEN: enum(u1) {
                    /// STATFIFO overrun interrupt is disabled
                    SF_OR_INTEN_0 = 0x0,
                    /// STATFIFO overrun interrupt is enabled
                    SF_OR_INTEN_1 = 0x1,
                },
                /// Change Of Image Field (COF) Interrupt Enable
                COF_INT_EN: enum(u1) {
                    /// COF interrupt is disabled
                    COF_INT_EN_0 = 0x0,
                    /// COF interrupt is enabled
                    COF_INT_EN_1 = 0x1,
                },
                /// CCIR Mode Select
                CCIR_MODE: enum(u1) {
                    /// Progressive mode is selected
                    CCIR_MODE_0 = 0x0,
                    /// Interlace mode is selected
                    CCIR_MODE_1 = 0x1,
                },
                /// CSI-PrP Interface Enable
                PrP_IF_EN: enum(u1) {
                    /// CSI to PrP bus is disabled
                    PrP_IF_EN_0 = 0x0,
                    /// CSI to PrP bus is enabled
                    PrP_IF_EN_1 = 0x1,
                },
                /// End-of-Frame Interrupt Enable. This bit enables and disables the EOF interrupt.
                EOF_INT_EN: enum(u1) {
                    /// EOF interrupt is disabled.
                    EOF_INT_EN_0 = 0x0,
                    /// EOF interrupt is generated when RX count value is reached.
                    EOF_INT_EN_1 = 0x1,
                },
                /// External VSYNC Enable
                EXT_VSYNC: enum(u1) {
                    /// Internal VSYNC mode
                    EXT_VSYNC_0 = 0x0,
                    /// External VSYNC mode
                    EXT_VSYNC_1 = 0x1,
                },
                /// SWAP 16-Bit Enable
                SWAP16_EN: enum(u1) {
                    /// Disable swapping
                    SWAP16_EN_0 = 0x0,
                    /// Enable swapping
                    SWAP16_EN_1 = 0x1,
                },
            }),
            /// CSI Control Register 2
            CSICR2: mmio.Mmio(packed struct(u32) {
                /// Horizontal Skip Count
                HSC: u8,
                /// Vertical Skip Count. Contains the number of rows to skip. SCE must be 1, otherwise VSC is ignored.
                VSC: u8,
                /// Live View Resolution Mode. Selects the grid size used for live view resolution.
                LVRM: enum(u3) {
                    /// 512 x 384
                    LVRM_0 = 0x0,
                    /// 448 x 336
                    LVRM_1 = 0x1,
                    /// 384 x 288
                    LVRM_2 = 0x2,
                    /// 384 x 256
                    LVRM_3 = 0x3,
                    /// 320 x 240
                    LVRM_4 = 0x4,
                    /// 288 x 216
                    LVRM_5 = 0x5,
                    /// 400 x 300
                    LVRM_6 = 0x6,
                    _,
                },
                /// Bayer Tile Start. Controls the Bayer pattern starting point.
                BTS: enum(u2) {
                    /// GR
                    BTS_0 = 0x0,
                    /// RG
                    BTS_1 = 0x1,
                    /// BG
                    BTS_2 = 0x2,
                    /// GB
                    BTS_3 = 0x3,
                },
                reserved23: u2 = 0,
                /// Skip Count Enable. Enables or disables the skip count feature.
                SCE: enum(u1) {
                    /// Skip count disable
                    SCE_0 = 0x0,
                    /// Skip count enable
                    SCE_1 = 0x1,
                },
                reserved26: u2 = 0,
                /// Double Resolution Mode. Controls size of statistics grid.
                DRM: enum(u1) {
                    /// Stats grid of 8 x 6
                    DRM_0 = 0x0,
                    /// Stats grid of 8 x 12
                    DRM_1 = 0x1,
                },
                padding: u5 = 0,
            }),
            /// CSI Control Register 3
            CSICR3: mmio.Mmio(packed struct(u32) {
                /// Automatic Error Correction Enable
                ECC_AUTO_EN: enum(u1) {
                    /// Auto Error correction is disabled.
                    ECC_AUTO_EN_0 = 0x0,
                    /// Auto Error correction is enabled.
                    ECC_AUTO_EN_1 = 0x1,
                },
                /// Error Detection Interrupt Enable
                ECC_INT_EN: enum(u1) {
                    /// No interrupt is generated when error is detected. Only the status bit ECC_INT is set.
                    ECC_INT_EN_0 = 0x0,
                    /// Interrupt is generated when error is detected.
                    ECC_INT_EN_1 = 0x1,
                },
                /// Dummy Zero Packing Enable
                ZERO_PACK_EN: enum(u1) {
                    /// Zero packing disabled
                    ZERO_PACK_EN_0 = 0x0,
                    /// Zero packing enabled
                    ZERO_PACK_EN_1 = 0x1,
                },
                /// Two 8-bit Sensor Mode
                TWO_8BIT_SENSOR: enum(u1) {
                    /// Only one sensor is connected.
                    TWO_8BIT_SENSOR_0 = 0x0,
                    /// Two 8-bit sensors are connected or one 16-bit sensor is connected.
                    TWO_8BIT_SENSOR_1 = 0x1,
                },
                /// RxFIFO Full Level
                RxFF_LEVEL: enum(u3) {
                    /// 4 Double words
                    RxFF_LEVEL_0 = 0x0,
                    /// 8 Double words
                    RxFF_LEVEL_1 = 0x1,
                    /// 16 Double words
                    RxFF_LEVEL_2 = 0x2,
                    /// 24 Double words
                    RxFF_LEVEL_3 = 0x3,
                    /// 32 Double words
                    RxFF_LEVEL_4 = 0x4,
                    /// 48 Double words
                    RxFF_LEVEL_5 = 0x5,
                    /// 64 Double words
                    RxFF_LEVEL_6 = 0x6,
                    /// 96 Double words
                    RxFF_LEVEL_7 = 0x7,
                },
                /// Hresponse Error Enable. This bit enables the hresponse error interrupt.
                HRESP_ERR_EN: enum(u1) {
                    /// Disable hresponse error interrupt
                    HRESP_ERR_EN_0 = 0x0,
                    /// Enable hresponse error interrupt
                    HRESP_ERR_EN_1 = 0x1,
                },
                /// STATFIFO Full Level
                STATFF_LEVEL: enum(u3) {
                    /// 4 Double words
                    STATFF_LEVEL_0 = 0x0,
                    /// 8 Double words
                    STATFF_LEVEL_1 = 0x1,
                    /// 12 Double words
                    STATFF_LEVEL_2 = 0x2,
                    /// 16 Double words
                    STATFF_LEVEL_3 = 0x3,
                    /// 24 Double words
                    STATFF_LEVEL_4 = 0x4,
                    /// 32 Double words
                    STATFF_LEVEL_5 = 0x5,
                    /// 48 Double words
                    STATFF_LEVEL_6 = 0x6,
                    /// 64 Double words
                    STATFF_LEVEL_7 = 0x7,
                },
                /// DMA Request Enable for STATFIFO
                DMA_REQ_EN_SFF: enum(u1) {
                    /// Disable the dma request
                    DMA_REQ_EN_SFF_0 = 0x0,
                    /// Enable the dma request
                    DMA_REQ_EN_SFF_1 = 0x1,
                },
                /// DMA Request Enable for RxFIFO
                DMA_REQ_EN_RFF: enum(u1) {
                    /// Disable the dma request
                    DMA_REQ_EN_RFF_0 = 0x0,
                    /// Enable the dma request
                    DMA_REQ_EN_RFF_1 = 0x1,
                },
                /// Reflash DMA Controller for STATFIFO
                DMA_REFLASH_SFF: enum(u1) {
                    /// No reflashing
                    DMA_REFLASH_SFF_0 = 0x0,
                    /// Reflash the embedded DMA controller
                    DMA_REFLASH_SFF_1 = 0x1,
                },
                /// Reflash DMA Controller for RxFIFO
                DMA_REFLASH_RFF: enum(u1) {
                    /// No reflashing
                    DMA_REFLASH_RFF_0 = 0x0,
                    /// Reflash the embedded DMA controller
                    DMA_REFLASH_RFF_1 = 0x1,
                },
                /// Frame Count Reset. Resets the Frame Counter. (Cleared automatically after reset is done)
                FRMCNT_RST: enum(u1) {
                    /// Do not reset
                    FRMCNT_RST_0 = 0x0,
                    /// Reset frame counter immediately
                    FRMCNT_RST_1 = 0x1,
                },
                /// Frame Counter
                FRMCNT: u16,
            }),
            /// CSI Statistic FIFO Register
            CSISTATFIFO: mmio.Mmio(packed struct(u32) {
                /// Static data from sensor
                STAT: u32,
            }),
            /// CSI RX FIFO Register
            CSIRFIFO: mmio.Mmio(packed struct(u32) {
                /// Received image data
                IMAGE: u32,
            }),
            /// CSI RX Count Register
            CSIRXCNT: mmio.Mmio(packed struct(u32) {
                /// RxFIFO Count
                RXCNT: u22,
                padding: u10 = 0,
            }),
            /// CSI Status Register
            CSISR: mmio.Mmio(packed struct(u32) {
                /// RXFIFO Data Ready
                DRDY: enum(u1) {
                    /// No data (word) is ready
                    DRDY_0 = 0x0,
                    /// At least 1 datum (word) is ready in RXFIFO.
                    DRDY_1 = 0x1,
                },
                /// CCIR Error Interrupt
                ECC_INT: enum(u1) {
                    /// No error detected
                    ECC_INT_0 = 0x0,
                    /// Error is detected in CCIR coding
                    ECC_INT_1 = 0x1,
                },
                reserved7: u5 = 0,
                /// Hresponse Error Interrupt Status
                HRESP_ERR_INT: enum(u1) {
                    /// No hresponse error.
                    HRESP_ERR_INT_0 = 0x0,
                    /// Hresponse error is detected.
                    HRESP_ERR_INT_1 = 0x1,
                },
                reserved13: u5 = 0,
                /// Change Of Field Interrupt Status
                COF_INT: enum(u1) {
                    /// Video field has no change.
                    COF_INT_0 = 0x0,
                    /// Change of video field is detected.
                    COF_INT_1 = 0x1,
                },
                /// CCIR Field 1 Interrupt Status
                F1_INT: enum(u1) {
                    /// Field 1 of video is not detected.
                    F1_INT_0 = 0x0,
                    /// Field 1 of video is about to start.
                    F1_INT_1 = 0x1,
                },
                /// CCIR Field 2 Interrupt Status
                F2_INT: enum(u1) {
                    /// Field 2 of video is not detected
                    F2_INT_0 = 0x0,
                    /// Field 2 of video is about to start
                    F2_INT_1 = 0x1,
                },
                /// Start of Frame Interrupt Status. Indicates when SOF is detected. (Cleared by writing 1)
                SOF_INT: enum(u1) {
                    /// SOF is not detected.
                    SOF_INT_0 = 0x0,
                    /// SOF is detected.
                    SOF_INT_1 = 0x1,
                },
                /// End of Frame (EOF) Interrupt Status. Indicates when EOF is detected. (Cleared by writing 1)
                EOF_INT: enum(u1) {
                    /// EOF is not detected.
                    EOF_INT_0 = 0x0,
                    /// EOF is detected.
                    EOF_INT_1 = 0x1,
                },
                /// RXFIFO Full Interrupt Status
                RxFF_INT: enum(u1) {
                    /// RxFIFO is not full.
                    RxFF_INT_0 = 0x0,
                    /// RxFIFO is full.
                    RxFF_INT_1 = 0x1,
                },
                /// DMA Transfer Done in Frame Buffer1
                DMA_TSF_DONE_FB1: enum(u1) {
                    /// DMA transfer is not completed.
                    DMA_TSF_DONE_FB1_0 = 0x0,
                    /// DMA transfer is completed.
                    DMA_TSF_DONE_FB1_1 = 0x1,
                },
                /// DMA Transfer Done in Frame Buffer2
                DMA_TSF_DONE_FB2: enum(u1) {
                    /// DMA transfer is not completed.
                    DMA_TSF_DONE_FB2_0 = 0x0,
                    /// DMA transfer is completed.
                    DMA_TSF_DONE_FB2_1 = 0x1,
                },
                /// STATFIFO Full Interrupt Status
                STATFF_INT: enum(u1) {
                    /// STATFIFO is not full.
                    STATFF_INT_0 = 0x0,
                    /// STATFIFO is full.
                    STATFF_INT_1 = 0x1,
                },
                /// DMA Transfer Done from StatFIFO
                DMA_TSF_DONE_SFF: enum(u1) {
                    /// DMA transfer is not completed.
                    DMA_TSF_DONE_SFF_0 = 0x0,
                    /// DMA transfer is completed.
                    DMA_TSF_DONE_SFF_1 = 0x1,
                },
                reserved24: u1 = 0,
                /// RxFIFO Overrun Interrupt Status
                RF_OR_INT: enum(u1) {
                    /// RXFIFO has not overflowed.
                    RF_OR_INT_0 = 0x0,
                    /// RXFIFO has overflowed.
                    RF_OR_INT_1 = 0x1,
                },
                /// STATFIFO Overrun Interrupt Status
                SF_OR_INT: enum(u1) {
                    /// STATFIFO has not overflowed.
                    SF_OR_INT_0 = 0x0,
                    /// STATFIFO has overflowed.
                    SF_OR_INT_1 = 0x1,
                },
                /// When DMA field 0 is complete, this bit will be set to 1(clear by writing 1).
                DMA_FIELD1_DONE: u1,
                /// When DMA field 0 is complete, this bit will be set to 1(clear by writing 1).
                DMA_FIELD0_DONE: u1,
                /// When using base address switching enable, this bit will be 1 when switching occur before DMA complete
                BASEADDR_CHHANGE_ERROR: u1,
                padding: u3 = 0,
            }),
            reserved32: [4]u8,
            /// CSI DMA Start Address Register - for STATFIFO
            CSIDMASA_STATFIFO: mmio.Mmio(packed struct(u32) {
                reserved2: u2 = 0,
                /// DMA Start Address for STATFIFO
                DMA_START_ADDR_SFF: u30,
            }),
            /// CSI DMA Transfer Size Register - for STATFIFO
            CSIDMATS_STATFIFO: mmio.Mmio(packed struct(u32) {
                /// DMA Transfer Size for STATFIFO
                DMA_TSF_SIZE_SFF: u32,
            }),
            /// CSI DMA Start Address Register - for Frame Buffer1
            CSIDMASA_FB1: mmio.Mmio(packed struct(u32) {
                reserved2: u2 = 0,
                /// DMA Start Address in Frame Buffer1
                DMA_START_ADDR_FB1: u30,
            }),
            /// CSI DMA Transfer Size Register - for Frame Buffer2
            CSIDMASA_FB2: mmio.Mmio(packed struct(u32) {
                reserved2: u2 = 0,
                /// DMA Start Address in Frame Buffer2
                DMA_START_ADDR_FB2: u30,
            }),
            /// CSI Frame Buffer Parameter Register
            CSIFBUF_PARA: mmio.Mmio(packed struct(u32) {
                /// Frame Buffer Parameter
                FBUF_STRIDE: u16,
                /// DEINTERLACE_STRIDE is only used in the deinterlace mode
                DEINTERLACE_STRIDE: u16,
            }),
            /// CSI Image Parameter Register
            CSIIMAG_PARA: mmio.Mmio(packed struct(u32) {
                /// Image Height. Indicates how many pixels in a column of the image from the sensor.
                IMAGE_HEIGHT: u16,
                /// Image Width
                IMAGE_WIDTH: u16,
            }),
            reserved72: [16]u8,
            /// CSI Control Register 18
            CSICR18: mmio.Mmio(packed struct(u32) {
                reserved2: u2 = 0,
                /// This bit is used to select the output method When input is standard CCIR656 video.
                DEINTERLACE_EN: enum(u1) {
                    /// Deinterlace disabled
                    DEINTERLACE_EN_0 = 0x0,
                    /// Deinterlace enabled
                    DEINTERLACE_EN_1 = 0x1,
                },
                /// When input is parallel rgb888/yuv444 24bit, this bit can be enabled.
                PARALLEL24_EN: u1,
                /// When this bit is enabled, CSI DMA will switch the base address according to BASEADDR_SWITCH_SEL rather than atomically by DMA completed
                BASEADDR_SWITCH_EN: u1,
                /// CSI 2 base addresses switching method. When using this bit, BASEADDR_SWITCH_EN is 1.
                BASEADDR_SWITCH_SEL: enum(u1) {
                    /// Switching base address at the edge of the vsync
                    BASEADDR_SWITCH_SEL_0 = 0x0,
                    /// Switching base address at the edge of the first data of each frame
                    BASEADDR_SWITCH_SEL_1 = 0x1,
                },
                /// In interlace mode, fileld 0 means interrupt enabled.
                FIELD0_DONE_IE: enum(u1) {
                    /// Interrupt disabled
                    FIELD0_DONE_IE_0 = 0x0,
                    /// Interrupt enabled
                    FIELD0_DONE_IE_1 = 0x1,
                },
                /// When in interlace mode, field 1 done interrupt enable.
                DMA_FIELD1_DONE_IE: enum(u1) {
                    /// Interrupt disabled
                    DMA_FIELD1_DONE_IE_0 = 0x0,
                    /// Interrupt enabled
                    DMA_FIELD1_DONE_IE_1 = 0x1,
                },
                /// Choosing the last DMA request condition.
                LAST_DMA_REQ_SEL: enum(u1) {
                    /// fifo_full_level
                    LAST_DMA_REQ_SEL_0 = 0x0,
                    /// hburst_length
                    LAST_DMA_REQ_SEL_1 = 0x1,
                },
                /// Base address change error interrupt enable signal.
                BASEADDR_CHANGE_ERROR_IE: u1,
                /// Output is 32-bit format.
                RGB888A_FORMAT_SEL: enum(u1) {
                    /// {8'h0, data[23:0]}
                    RGB888A_FORMAT_SEL_0 = 0x0,
                    /// {data[23:0], 8'h0}
                    RGB888A_FORMAT_SEL_1 = 0x1,
                },
                reserved12: u1 = 0,
                /// Hprot value in AHB bus protocol.
                AHB_HPROT: u4,
                reserved18: u2 = 0,
                /// These bits used to choose the method to mask the CSI input.
                MASK_OPTION: enum(u2) {
                    /// Writing to memory from first completely frame, when using this option, the CSI_ENABLE should be 1.
                    MASK_OPTION_0 = 0x0,
                    /// Writing to memory when CSI_ENABLE is 1.
                    MASK_OPTION_1 = 0x1,
                    /// Writing to memory from second completely frame, when using this option, the CSI_ENABLE should be 1.
                    MASK_OPTION_2 = 0x2,
                    /// Writing to memory when data comes in, not matter the CSI_ENABLE is 1 or 0.
                    MASK_OPTION_3 = 0x3,
                },
                reserved31: u11 = 0,
                /// CSI global enable signal
                CSI_ENABLE: u1,
            }),
            /// CSI Control Register 19
            CSICR19: mmio.Mmio(packed struct(u32) {
                /// This byte stores the highest FIFO level achieved by CSI FIFO timely and will be clear by writing 8'ff to it
                DMA_RFIFO_HIGHEST_FIFO_LEVEL: u8,
                padding: u24 = 0,
            }),
        };

        /// CSU registers
        pub const CSU = extern struct {
            reserved512: [512]u8,
            /// HP0 register
            HP0: mmio.Mmio(packed struct(u32) {
                reserved2: u2 = 0,
                /// Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the eDMA
                HP_DMA: enum(u1) {
                    /// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
                    HP_DMA_0 = 0x0,
                    /// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
                    HP_DMA_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the eDMA
                L_DMA: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_DMA_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_DMA_1 = 0x1,
                },
                /// Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the LCDIF
                HP_LCDIF: enum(u1) {
                    /// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
                    HP_LCDIF_0 = 0x0,
                    /// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
                    HP_LCDIF_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the LCDIF
                L_LCDIF: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_LCDIF_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_LCDIF_1 = 0x1,
                },
                /// Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the CSI
                HP_CSI: enum(u1) {
                    /// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
                    HP_CSI_0 = 0x0,
                    /// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
                    HP_CSI_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the CSI
                L_CSI: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_CSI_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_CSI_1 = 0x1,
                },
                /// Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the PXP
                HP_PXP: enum(u1) {
                    /// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
                    HP_PXP_0 = 0x0,
                    /// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
                    HP_PXP_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the PXP
                L_PXP: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_PXP_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_PXP_1 = 0x1,
                },
                /// Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the DCP
                HP_DCP: enum(u1) {
                    /// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
                    HP_DCP_0 = 0x0,
                    /// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
                    HP_DCP_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the DCP
                L_DCP: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_DCP_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit cannot be written by the software.
                    L_DCP_1 = 0x1,
                },
                reserved14: u2 = 0,
                /// Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the ENET
                HP_ENET: enum(u1) {
                    /// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
                    HP_ENET_0 = 0x0,
                    /// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
                    HP_ENET_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the ENET
                L_ENET: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_ENET_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_ENET_1 = 0x1,
                },
                /// Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the USDHC1
                HP_USDHC1: enum(u1) {
                    /// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
                    HP_USDHC1_0 = 0x0,
                    /// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
                    HP_USDHC1_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the USDHC1
                L_USDHC1: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_USDHC1_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_USDHC1_1 = 0x1,
                },
                /// Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the USDHC2
                HP_USDHC2: enum(u1) {
                    /// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
                    HP_USDHC2_0 = 0x0,
                    /// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
                    HP_USDHC2_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the USDHC2
                L_USDHC2: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_USDHC2_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_USDHC2_1 = 0x1,
                },
                /// Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the TPSMP
                HP_TPSMP: enum(u1) {
                    /// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
                    HP_TPSMP_0 = 0x0,
                    /// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
                    HP_TPSMP_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the TPSMP
                L_TPSMP: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_TPSMP_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_TPSMP_1 = 0x1,
                },
                /// Determines whether the register value of the corresponding HP field is passed as the hprot[1] of the USB
                HP_USB: enum(u1) {
                    /// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
                    HP_USB_0 = 0x0,
                    /// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
                    HP_USB_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the USB
                L_USB: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_USB_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_USB_1 = 0x1,
                },
                padding: u8 = 0,
            }),
            reserved536: [20]u8,
            /// Secure access register
            SA: mmio.Mmio(packed struct(u32) {
                reserved2: u2 = 0,
                /// Non-secure access policy indicator bit
                NSA_DMA: enum(u1) {
                    /// Secure access for the corresponding type-1 master
                    NSA_DMA_0 = 0x0,
                    /// Non-secure access for the corresponding type-1 master
                    NSA_DMA_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the eDMA
                L_DMA: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_DMA_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_DMA_1 = 0x1,
                },
                /// Non-secure access policy indicator bit
                NSA_LCDIF: enum(u1) {
                    /// Secure access for the corresponding type-1 master
                    NSA_LCDIF_0 = 0x0,
                    /// Non-secure access for the corresponding type-1 master
                    NSA_LCDIF_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the LCDIF
                L_LCDIF: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_LCDIF_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_LCDIF_1 = 0x1,
                },
                /// Non-secure access policy indicator bit
                NSA_CSI: enum(u1) {
                    /// Secure access for the corresponding type-1 master
                    NSA_CSI_0 = 0x0,
                    /// Non-secure access for the corresponding type-1 master
                    NSA_CSI_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the CSI
                L_CSI: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_CSI_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_CSI_1 = 0x1,
                },
                /// Non-Secure Access Policy indicator bit
                NSA_PXP: enum(u1) {
                    /// Secure access for the corresponding type-1 master
                    NSA_PXP_0 = 0x0,
                    /// Non-secure access for the corresponding type-1 master
                    NSA_PXP_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the PXP
                L_PXP: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_PXP_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_PXP_1 = 0x1,
                },
                /// Non-secure access policy indicator bit
                NSA_DCP: enum(u1) {
                    /// Secure access for the corresponding type-1 master
                    NSA_DCP_0 = 0x0,
                    /// Non-secure access for the corresponding type-1 master
                    NSA_DCP_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the DCP
                L_DCP: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_DCP_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_DCP_1 = 0x1,
                },
                reserved14: u2 = 0,
                /// Non-secure access policy indicator bit
                NSA_ENET: enum(u1) {
                    /// Secure access for the corresponding type-1 master
                    NSA_ENET_0 = 0x0,
                    /// Non-secure access for the corresponding type-1 master
                    NSA_ENET_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the ENET1 and ENET2
                L_ENET: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_ENET_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_ENET_1 = 0x1,
                },
                /// Non-secure access policy indicator bit
                NSA_USDHC1: enum(u1) {
                    /// Secure access for the corresponding type-1 master
                    NSA_USDHC1_0 = 0x0,
                    /// Non-secure access for the corresponding type-1 master
                    NSA_USDHC1_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the USDHC1
                L_USDHC1: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_USDHC1_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_USDHC1_1 = 0x1,
                },
                /// Non-secure access policy indicator bit
                NSA_USDHC2: enum(u1) {
                    /// Secure access for the corresponding type-1 master
                    NSA_USDHC2_0 = 0x0,
                    /// Non-secure access for the corresponding type-1 master
                    NSA_USDHC2_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the USDHC2
                L_USDHC2: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_USDHC2_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_USDHC2_1 = 0x1,
                },
                /// Non-secure access policy indicator bit
                NSA_TPSMP: enum(u1) {
                    /// Secure access for the corresponding type-1 master
                    NSA_TPSMP_0 = 0x0,
                    /// Non-secure access for the corresponding type-1 master
                    NSA_TPSMP_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the TPSMP
                L_TPSMP: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_TPSMP_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_TPSMP_1 = 0x1,
                },
                /// Non-secure access policy indicator bit
                NSA_USB: enum(u1) {
                    /// Secure access for the corresponding type-1 master
                    NSA_USB_0 = 0x0,
                    /// Non-secure access for the corresponding type-1 master
                    NSA_USB_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the USB
                L_USB: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_USB_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_USB_1 = 0x1,
                },
                padding: u8 = 0,
            }),
            reserved856: [316]u8,
            /// HPCONTROL0 register
            HPCONTROL0: mmio.Mmio(packed struct(u32) {
                reserved2: u2 = 0,
                /// Indicates the privilege/user mode for the eDMA
                HPC_DMA: enum(u1) {
                    /// User mode for the corresponding master
                    HPC_DMA_0 = 0x0,
                    /// Supervisor mode for the corresponding master
                    HPC_DMA_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the eDMA
                L_DMA: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_DMA_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_DMA_1 = 0x1,
                },
                /// Indicates the privilege/user mode for the LCDIF
                HPC_LCDIF: enum(u1) {
                    /// User mode for the corresponding master
                    HPC_LCDIF_0 = 0x0,
                    /// Supervisor mode for the corresponding master
                    HPC_LCDIF_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the LCDIF
                L_LCDIF: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_LCDIF_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_LCDIF_1 = 0x1,
                },
                /// Indicates the privilege/user mode for the CSI
                HPC_CSI: enum(u1) {
                    /// User mode for the corresponding master
                    HPC_CSI_0 = 0x0,
                    /// Supervisor mode for the corresponding master
                    HPC_CSI_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the CSI
                L_CSI: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_CSI_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_CSI_1 = 0x1,
                },
                /// Indicates the privilege/user mode for the PXP
                HPC_PXP: enum(u1) {
                    /// User mode for the corresponding master
                    HPC_PXP_0 = 0x0,
                    /// Supervisor mode for the corresponding master
                    HPC_PXP_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the PXP
                L_PXP: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_PXP_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_PXP_1 = 0x1,
                },
                /// Indicates the privilege/user mode for the DCP
                HPC_DCP: enum(u1) {
                    /// User mode for the corresponding master
                    HPC_DCP_0 = 0x0,
                    /// Supervisor mode for the corresponding master
                    HPC_DCP_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the DCP
                L_DCP: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_DCP_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_DCP_1 = 0x1,
                },
                reserved14: u2 = 0,
                /// Indicates the privilege/user mode for the ENET
                HPC_ENET: enum(u1) {
                    /// User mode for the corresponding master
                    HPC_ENET_0 = 0x0,
                    /// Supervisor mode for the corresponding master
                    HPC_ENET_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the ENET
                L_ENET: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_ENET_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_ENET_1 = 0x1,
                },
                /// Indicates the privilege/user mode for the USDHC1
                HPC_USDHC1: enum(u1) {
                    /// User mode for the corresponding master
                    HPC_USDHC1_0 = 0x0,
                    /// Supervisor mode for the corresponding master
                    HPC_USDHC1_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the USDHC1
                L_USDHC1: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_USDHC1_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_USDHC1_1 = 0x1,
                },
                /// Indicates the privilege/user mode for the USDHC2
                HPC_USDHC2: enum(u1) {
                    /// User mode for the corresponding master
                    HPC_USDHC2_0 = 0x0,
                    /// Supervisor mode for the corresponding master
                    HPC_USDHC2_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the USDHC2.
                L_USDHC2: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_USDHC2_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_USDHC2_1 = 0x1,
                },
                /// Indicates the privilege/user mode for the TPSMP
                HPC_TPSMP: enum(u1) {
                    /// User mode for the corresponding master
                    HPC_TPSMP_0 = 0x0,
                    /// Supervisor mode for the corresponding master
                    HPC_TPSMP_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the TPSMP.
                L_TPSMP: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_TPSMP_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_TPSMP_1 = 0x1,
                },
                /// Indicates the privilege/user mode for the USB
                HPC_USB: enum(u1) {
                    /// User mode for the corresponding master
                    HPC_USB_0 = 0x0,
                    /// Supervisor mode for the corresponding master
                    HPC_USB_1 = 0x1,
                },
                /// Lock bit set by the TZ software for the USB.
                L_USB: enum(u1) {
                    /// No lock-the adjacent (next lower) bit can be written by the software.
                    L_USB_0 = 0x0,
                    /// Lock-the adjacent (next lower) bit can't be written by the software.
                    L_USB_1 = 0x1,
                },
                padding: u8 = 0,
            }),
        };

        /// DCDC
        pub const DCDC = extern struct {
            /// DCDC Register 0
            REG0: mmio.Mmio(packed struct(u32) {
                /// power down the zero cross detection function for discontinuous conductor mode
                PWD_ZCD: u1,
                /// Disable automatic clock switch from internal osc to xtal clock.
                DISABLE_AUTO_CLK_SWITCH: u1,
                /// select 24 MHz Crystal clock for DCDC, when dcdc_disable_auto_clk_switch is set.
                SEL_CLK: u1,
                /// Power down internal osc. Only set this bit, when 24 MHz crystal osc is available
                PWD_OSC_INT: u1,
                /// The power down signal of the current detector.
                PWD_CUR_SNS_CMP: u1,
                /// Set the threshold of current detector, if the peak current of the inductor exceeds the threshold, the current detector will assert
                CUR_SNS_THRSH: u3,
                /// power down overcurrent detection comparator
                PWD_OVERCUR_DET: u1,
                /// The threshold of over current detection in run mode and power save mode: run mode power save mode 0x0 1 A 0
                OVERCUR_TRIG_ADJ: u2,
                /// set to "1" to power down the low voltage detection comparator
                PWD_CMP_BATT_DET: u1,
                /// adjust value to poslimit_buck register
                ADJ_POSLIMIT_BUCK: u4,
                /// enable the overload detection in power save mode, if current is larger than the overloading threshold (typical value is 50 mA), DCDC will switch to the run mode automatically
                EN_LP_OVERLOAD_SNS: u1,
                /// power down overvoltage detection comparator
                PWD_HIGH_VOLT_DET: u1,
                /// the threshold of the counting number of charging times during the period that lp_overload_freq_sel sets in power save mode
                LP_OVERLOAD_THRSH: u2,
                /// the period of counting the charging times in power save mode 0: eight 32k cycle 1: sixteen 32k cycle
                LP_OVERLOAD_FREQ_SEL: u1,
                /// Adjust hysteretic value in low power from 12.5mV to 25mV
                LP_HIGH_HYS: u1,
                reserved26: u4 = 0,
                /// power down output range comparator
                PWD_CMP_OFFSET: u1,
                /// 1'b1: Disable xtalok detection circuit 1'b0: Enable xtalok detection circuit
                XTALOK_DISABLE: u1,
                /// reset current alert signal
                CURRENT_ALERT_RESET: u1,
                /// set to 1 to switch internal ring osc to xtal 24M
                XTAL_24M_OK: u1,
                reserved31: u1 = 0,
                /// Status register to indicate DCDC status. 1'b1: DCDC already settled 1'b0: DCDC is settling
                STS_DC_OK: u1,
            }),
            /// DCDC Register 1
            REG1: mmio.Mmio(packed struct(u32) {
                reserved7: u7 = 0,
                /// select the feedback point of the internal regulator
                REG_FBK_SEL: u2,
                /// control the load resistor of the internal regulator of DCDC, the load resistor is connected as default "1", and need set to "0" to disconnect the load resistor
                REG_RLOAD_SW: u1,
                reserved12: u2 = 0,
                /// set the current bias of low power comparator 0x0: 50 nA 0x1: 100 nA 0x2: 200 nA 0x3: 400 nA
                LP_CMP_ISRC_SEL: u2,
                reserved21: u7 = 0,
                /// increase the threshold detection for common mode analog comparator
                LOOPCTRL_HST_THRESH: u1,
                reserved23: u1 = 0,
                /// Enable hysteresis in switching converter common mode analog comparators
                LOOPCTRL_EN_HYST: u1,
                /// trim bandgap voltage
                VBG_TRIM: u5,
                padding: u3 = 0,
            }),
            /// DCDC Register 2
            REG2: mmio.Mmio(packed struct(u32) {
                /// Ratio of integral control parameter to proportional control parameter in the switching DC-DC converter, and can be used to optimize efficiency and loop response
                LOOPCTRL_DC_C: u2,
                /// Magnitude of proportional control parameter in the switching DC-DC converter control loop.
                LOOPCTRL_DC_R: u4,
                /// Two's complement feed forward step in duty cycle in the switching DC-DC converter
                LOOPCTRL_DC_FF: u3,
                /// Enable analog circuit of DC-DC converter to respond faster under transient load conditions.
                LOOPCTRL_EN_RCSCALE: u3,
                /// Increase the threshold detection for RC scale circuit.
                LOOPCTRL_RCSCALE_THRSH: u1,
                /// Invert the sign of the hysteresis in DC-DC analog comparators.
                LOOPCTRL_HYST_SIGN: u1,
                reserved27: u13 = 0,
                /// Set to "0" : stop charging if the duty cycle is lower than what set by dcdc_neglimit_in
                DISABLE_PULSE_SKIP: u1,
                /// Set high to improve the transition from heavy load to light load
                DCM_SET_CTRL: u1,
                padding: u3 = 0,
            }),
            /// DCDC Register 3
            REG3: mmio.Mmio(packed struct(u32) {
                /// Target value of VDD_SOC, 25 mV each step 0x0: 0.8V 0xE: 1.15V 0x1F:1.575V
                TRG: u5,
                reserved8: u3 = 0,
                /// Target value of standby (low power) mode 0x0: 0
                TARGET_LP: u3,
                reserved24: u13 = 0,
                /// Set DCDC clock to half freqeuncy for continuous mode
                MINPWR_DC_HALFCLK: u1,
                reserved27: u2 = 0,
                /// Ajust delay to reduce ground noise
                MISC_DELAY_TIMING: u1,
                /// Reserved
                MISC_DISABLEFET_LOGIC: u1,
                reserved30: u1 = 0,
                /// Disable stepping for the output VDD_SOC of DCDC
                DISABLE_STEP: u1,
                padding: u1 = 0,
            }),
        };

        /// DCP register reference index
        pub const DCP = extern struct {
            /// DCP control register 0
            CTRL: mmio.Mmio(packed struct(u32) {
                /// Per-channel interrupt enable bit
                CHANNEL_INTERRUPT_ENABLE: enum(u8) {
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x4,
                    /// CH3
                    CH3 = 0x8,
                    _,
                },
                reserved21: u13 = 0,
                /// Enable automatic context switching for the channels
                ENABLE_CONTEXT_SWITCHING: u1,
                /// The software must set this bit to enable the caching of contexts between the operations
                ENABLE_CONTEXT_CACHING: u1,
                /// The software must set this bit to enable the ragged writes to the unaligned buffers to be gathered between multiple write operations
                GATHER_RESIDUAL_WRITES: u1,
                reserved28: u4 = 0,
                /// Indicates whether the SHA1/SHA2 functions are present.
                PRESENT_SHA: enum(u1) {
                    /// Absent
                    Absent = 0x0,
                    /// Present
                    Present = 0x1,
                },
                /// Indicates whether the crypto (cipher/hash) functions are present.
                PRESENT_CRYPTO: enum(u1) {
                    /// Absent
                    Absent = 0x0,
                    /// Present
                    Present = 0x1,
                },
                /// This bit must be set to zero for a normal operation
                CLKGATE: u1,
                /// Set this bit to zero to enable a normal DCP operation
                SFTRST: u1,
            }),
            /// DCP control register 0
            CTRL_SET: mmio.Mmio(packed struct(u32) {
                /// Per-channel interrupt enable bit
                CHANNEL_INTERRUPT_ENABLE: enum(u8) {
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x4,
                    /// CH3
                    CH3 = 0x8,
                    _,
                },
                reserved21: u13 = 0,
                /// Enable automatic context switching for the channels
                ENABLE_CONTEXT_SWITCHING: u1,
                /// The software must set this bit to enable the caching of contexts between the operations
                ENABLE_CONTEXT_CACHING: u1,
                /// The software must set this bit to enable the ragged writes to the unaligned buffers to be gathered between multiple write operations
                GATHER_RESIDUAL_WRITES: u1,
                reserved28: u4 = 0,
                /// Indicates whether the SHA1/SHA2 functions are present.
                PRESENT_SHA: enum(u1) {
                    /// Absent
                    Absent = 0x0,
                    /// Present
                    Present = 0x1,
                },
                /// Indicates whether the crypto (cipher/hash) functions are present.
                PRESENT_CRYPTO: enum(u1) {
                    /// Absent
                    Absent = 0x0,
                    /// Present
                    Present = 0x1,
                },
                /// This bit must be set to zero for a normal operation
                CLKGATE: u1,
                /// Set this bit to zero to enable a normal DCP operation
                SFTRST: u1,
            }),
            /// DCP control register 0
            CTRL_CLR: mmio.Mmio(packed struct(u32) {
                /// Per-channel interrupt enable bit
                CHANNEL_INTERRUPT_ENABLE: enum(u8) {
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x4,
                    /// CH3
                    CH3 = 0x8,
                    _,
                },
                reserved21: u13 = 0,
                /// Enable automatic context switching for the channels
                ENABLE_CONTEXT_SWITCHING: u1,
                /// The software must set this bit to enable the caching of contexts between the operations
                ENABLE_CONTEXT_CACHING: u1,
                /// The software must set this bit to enable the ragged writes to the unaligned buffers to be gathered between multiple write operations
                GATHER_RESIDUAL_WRITES: u1,
                reserved28: u4 = 0,
                /// Indicates whether the SHA1/SHA2 functions are present.
                PRESENT_SHA: enum(u1) {
                    /// Absent
                    Absent = 0x0,
                    /// Present
                    Present = 0x1,
                },
                /// Indicates whether the crypto (cipher/hash) functions are present.
                PRESENT_CRYPTO: enum(u1) {
                    /// Absent
                    Absent = 0x0,
                    /// Present
                    Present = 0x1,
                },
                /// This bit must be set to zero for a normal operation
                CLKGATE: u1,
                /// Set this bit to zero to enable a normal DCP operation
                SFTRST: u1,
            }),
            /// DCP control register 0
            CTRL_TOG: mmio.Mmio(packed struct(u32) {
                /// Per-channel interrupt enable bit
                CHANNEL_INTERRUPT_ENABLE: enum(u8) {
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x4,
                    /// CH3
                    CH3 = 0x8,
                    _,
                },
                reserved21: u13 = 0,
                /// Enable automatic context switching for the channels
                ENABLE_CONTEXT_SWITCHING: u1,
                /// The software must set this bit to enable the caching of contexts between the operations
                ENABLE_CONTEXT_CACHING: u1,
                /// The software must set this bit to enable the ragged writes to the unaligned buffers to be gathered between multiple write operations
                GATHER_RESIDUAL_WRITES: u1,
                reserved28: u4 = 0,
                /// Indicates whether the SHA1/SHA2 functions are present.
                PRESENT_SHA: enum(u1) {
                    /// Absent
                    Absent = 0x0,
                    /// Present
                    Present = 0x1,
                },
                /// Indicates whether the crypto (cipher/hash) functions are present.
                PRESENT_CRYPTO: enum(u1) {
                    /// Absent
                    Absent = 0x0,
                    /// Present
                    Present = 0x1,
                },
                /// This bit must be set to zero for a normal operation
                CLKGATE: u1,
                /// Set this bit to zero to enable a normal DCP operation
                SFTRST: u1,
            }),
            /// DCP status register
            STAT: mmio.Mmio(packed struct(u32) {
                /// Indicates which channels have pending interrupt requests
                IRQ: u4,
                reserved16: u12 = 0,
                /// Indicates which channels are ready to proceed with a transfer (the active channel is also included)
                READY_CHANNELS: enum(u8) {
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x4,
                    /// CH3
                    CH3 = 0x8,
                    _,
                },
                /// Current (active) channel (encoded)
                CUR_CHANNEL: enum(u4) {
                    /// None
                    None = 0x0,
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x3,
                    /// CH3
                    CH3 = 0x4,
                    _,
                },
                /// When set, it indicates that the OTP key is shifted from the fuse block and is ready for use.
                OTP_KEY_READY: u1,
                padding: u3 = 0,
            }),
            /// DCP status register
            STAT_SET: mmio.Mmio(packed struct(u32) {
                /// Indicates which channels have pending interrupt requests
                IRQ: u4,
                reserved16: u12 = 0,
                /// Indicates which channels are ready to proceed with a transfer (the active channel is also included)
                READY_CHANNELS: enum(u8) {
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x4,
                    /// CH3
                    CH3 = 0x8,
                    _,
                },
                /// Current (active) channel (encoded)
                CUR_CHANNEL: enum(u4) {
                    /// None
                    None = 0x0,
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x3,
                    /// CH3
                    CH3 = 0x4,
                    _,
                },
                /// When set, it indicates that the OTP key is shifted from the fuse block and is ready for use.
                OTP_KEY_READY: u1,
                padding: u3 = 0,
            }),
            /// DCP status register
            STAT_CLR: mmio.Mmio(packed struct(u32) {
                /// Indicates which channels have pending interrupt requests
                IRQ: u4,
                reserved16: u12 = 0,
                /// Indicates which channels are ready to proceed with a transfer (the active channel is also included)
                READY_CHANNELS: enum(u8) {
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x4,
                    /// CH3
                    CH3 = 0x8,
                    _,
                },
                /// Current (active) channel (encoded)
                CUR_CHANNEL: enum(u4) {
                    /// None
                    None = 0x0,
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x3,
                    /// CH3
                    CH3 = 0x4,
                    _,
                },
                /// When set, it indicates that the OTP key is shifted from the fuse block and is ready for use.
                OTP_KEY_READY: u1,
                padding: u3 = 0,
            }),
            /// DCP status register
            STAT_TOG: mmio.Mmio(packed struct(u32) {
                /// Indicates which channels have pending interrupt requests
                IRQ: u4,
                reserved16: u12 = 0,
                /// Indicates which channels are ready to proceed with a transfer (the active channel is also included)
                READY_CHANNELS: enum(u8) {
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x4,
                    /// CH3
                    CH3 = 0x8,
                    _,
                },
                /// Current (active) channel (encoded)
                CUR_CHANNEL: enum(u4) {
                    /// None
                    None = 0x0,
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x3,
                    /// CH3
                    CH3 = 0x4,
                    _,
                },
                /// When set, it indicates that the OTP key is shifted from the fuse block and is ready for use.
                OTP_KEY_READY: u1,
                padding: u3 = 0,
            }),
            /// DCP channel control register
            CHANNELCTRL: mmio.Mmio(packed struct(u32) {
                /// Setting a bit in this field enables the DMA channel associated with it
                ENABLE_CHANNEL: enum(u8) {
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x4,
                    /// CH3
                    CH3 = 0x8,
                    _,
                },
                /// Setting a bit in this field causes the corresponding channel to have high-priority arbitration
                HIGH_PRIORITY_CHANNEL: enum(u8) {
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x4,
                    /// CH3
                    CH3 = 0x8,
                    _,
                },
                /// Indicates that the interrupt for channel 0 must be merged with the other interrupts on the shared dcp_irq interrupt
                CH0_IRQ_MERGED: u1,
                padding: u15 = 0,
            }),
            /// DCP channel control register
            CHANNELCTRL_SET: mmio.Mmio(packed struct(u32) {
                /// Setting a bit in this field enables the DMA channel associated with it
                ENABLE_CHANNEL: enum(u8) {
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x4,
                    /// CH3
                    CH3 = 0x8,
                    _,
                },
                /// Setting a bit in this field causes the corresponding channel to have high-priority arbitration
                HIGH_PRIORITY_CHANNEL: enum(u8) {
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x4,
                    /// CH3
                    CH3 = 0x8,
                    _,
                },
                /// Indicates that the interrupt for channel 0 must be merged with the other interrupts on the shared dcp_irq interrupt
                CH0_IRQ_MERGED: u1,
                padding: u15 = 0,
            }),
            /// DCP channel control register
            CHANNELCTRL_CLR: mmio.Mmio(packed struct(u32) {
                /// Setting a bit in this field enables the DMA channel associated with it
                ENABLE_CHANNEL: enum(u8) {
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x4,
                    /// CH3
                    CH3 = 0x8,
                    _,
                },
                /// Setting a bit in this field causes the corresponding channel to have high-priority arbitration
                HIGH_PRIORITY_CHANNEL: enum(u8) {
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x4,
                    /// CH3
                    CH3 = 0x8,
                    _,
                },
                /// Indicates that the interrupt for channel 0 must be merged with the other interrupts on the shared dcp_irq interrupt
                CH0_IRQ_MERGED: u1,
                padding: u15 = 0,
            }),
            /// DCP channel control register
            CHANNELCTRL_TOG: mmio.Mmio(packed struct(u32) {
                /// Setting a bit in this field enables the DMA channel associated with it
                ENABLE_CHANNEL: enum(u8) {
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x4,
                    /// CH3
                    CH3 = 0x8,
                    _,
                },
                /// Setting a bit in this field causes the corresponding channel to have high-priority arbitration
                HIGH_PRIORITY_CHANNEL: enum(u8) {
                    /// CH0
                    CH0 = 0x1,
                    /// CH1
                    CH1 = 0x2,
                    /// CH2
                    CH2 = 0x4,
                    /// CH3
                    CH3 = 0x8,
                    _,
                },
                /// Indicates that the interrupt for channel 0 must be merged with the other interrupts on the shared dcp_irq interrupt
                CH0_IRQ_MERGED: u1,
                padding: u15 = 0,
            }),
            /// DCP capability 0 register
            CAPABILITY0: mmio.Mmio(packed struct(u32) {
                /// Encoded value indicating the number of key-storage locations implemented in the design
                NUM_KEYS: u8,
                /// Encoded value indicating the number of channels implemented in the design
                NUM_CHANNELS: u4,
                reserved29: u17 = 0,
                /// Write to a 1 to disable the per-device unique key
                DISABLE_UNIQUE_KEY: u1,
                reserved31: u1 = 0,
                /// Write to 1 to disable the decryption
                DISABLE_DECRYPT: u1,
            }),
            reserved64: [12]u8,
            /// DCP capability 1 register
            CAPABILITY1: mmio.Mmio(packed struct(u32) {
                /// One-hot field indicating which cipher algorithms are available
                CIPHER_ALGORITHMS: enum(u16) {
                    /// AES128
                    AES128 = 0x1,
                    _,
                },
                /// One-hot field indicating which hashing features are implemented in the hardware
                HASH_ALGORITHMS: enum(u16) {
                    /// SHA1
                    SHA1 = 0x1,
                    /// CRC32
                    CRC32 = 0x2,
                    /// SHA256
                    SHA256 = 0x4,
                    _,
                },
            }),
            reserved80: [12]u8,
            /// DCP context buffer pointer
            CONTEXT: mmio.Mmio(packed struct(u32) {
                /// Context pointer address
                ADDR: u32,
            }),
            reserved96: [12]u8,
            /// DCP key index
            KEY: mmio.Mmio(packed struct(u32) {
                /// Key subword pointer
                SUBWORD: u2,
                reserved4: u2 = 0,
                /// Key index pointer. The valid indices are 0-[number_keys].
                INDEX: u2,
                padding: u26 = 0,
            }),
            reserved112: [12]u8,
            /// DCP key data
            KEYDATA: mmio.Mmio(packed struct(u32) {
                /// Word 0 data for the key. This is the least-significant word.
                DATA: u32,
            }),
            reserved128: [12]u8,
            /// DCP work packet 0 status register
            PACKET0: mmio.Mmio(packed struct(u32) {
                /// Next pointer register
                ADDR: u32,
            }),
            reserved144: [12]u8,
            /// DCP work packet 1 status register
            PACKET1: mmio.Mmio(packed struct(u32) {
                /// Reflects whether the channel must issue an interrupt upon the completion of the packet.
                INTERRUPT: u1,
                /// Reflects whether the channel's semaphore must be decremented at the end of the current operation
                DECR_SEMAPHORE: u1,
                /// Reflects whether the next command pointer register must be loaded into the channel's current descriptor pointer
                CHAIN: u1,
                /// Reflects whether the next packet's address is located following this packet's payload.
                CHAIN_CONTIGUOUS: u1,
                /// Reflects whether the selected hashing function should be enabled for this operation.
                ENABLE_MEMCOPY: u1,
                /// Reflects whether the selected cipher function must be enabled for this operation.
                ENABLE_CIPHER: u1,
                /// Reflects whether the selected hashing function must be enabled for this operation.
                ENABLE_HASH: u1,
                /// Reflects whether the DCP must perform a blit operation
                ENABLE_BLIT: u1,
                /// When the cipher block is enabled, this bit indicates whether the operation is encryption or decryption
                CIPHER_ENCRYPT: enum(u1) {
                    /// DECRYPT
                    DECRYPT = 0x0,
                    /// ENCRYPT
                    ENCRYPT = 0x1,
                },
                /// Reflects whether the cipher block must load the initialization vector from the payload for this operation
                CIPHER_INIT: u1,
                /// Reflects whether a hardware-based key must be used
                OTP_KEY: u1,
                /// When set, it indicates the payload contains the key
                PAYLOAD_KEY: u1,
                /// Reflects whether the current hashing block is the initial block in the hashing operation, so the hash registers must be initialized before the operation
                HASH_INIT: u1,
                /// Reflects whether the current hashing block is the final block in the hashing operation, so the hash padding must be applied by the hardware
                HASH_TERM: u1,
                /// Reflects whether the calculated hash value must be compared to the hash provided in the payload.
                CHECK_HASH: u1,
                /// When the hashing is enabled, this bit controls whether the input or output data is hashed.
                HASH_OUTPUT: enum(u1) {
                    /// INPUT
                    INPUT = 0x0,
                    /// OUTPUT
                    OUTPUT = 0x1,
                },
                /// When this bit is set (MEMCOPY and BLIT modes only), the DCP simply fills the destination buffer with the value found in the source address field
                CONSTANT_FILL: u1,
                /// This bit is used to test the channel semaphore transition to 0. FOR TEST USE ONLY!
                TEST_SEMA_IRQ: u1,
                /// Reflects whether the DCP engine swaps the key bytes (big-endian key).
                KEY_BYTESWAP: u1,
                /// Reflects whether the DCP engine swaps the key words (big-endian key).
                KEY_WORDSWAP: u1,
                /// Reflects whether the DCP engine byteswaps the input data (big-endian data).
                INPUT_BYTESWAP: u1,
                /// Reflects whether the DCP engine wordswaps the input data (big-endian data).
                INPUT_WORDSWAP: u1,
                /// Reflects whether the DCP engine byteswaps the output data (big-endian data).
                OUTPUT_BYTESWAP: u1,
                /// Reflects whether the DCP engine wordswaps the output data (big-endian data).
                OUTPUT_WORDSWAP: u1,
                /// Packet Tag
                TAG: u8,
            }),
            reserved160: [12]u8,
            /// DCP work packet 2 status register
            PACKET2: mmio.Mmio(packed struct(u32) {
                /// Cipher selection field
                CIPHER_SELECT: enum(u4) {
                    /// AES128
                    AES128 = 0x0,
                    _,
                },
                /// Cipher mode selection field. Reflects the mode of operation for the cipher operations.
                CIPHER_MODE: enum(u4) {
                    /// ECB
                    ECB = 0x0,
                    /// CBC
                    CBC = 0x1,
                    _,
                },
                /// Key selection field
                KEY_SELECT: enum(u8) {
                    /// KEY0
                    KEY0 = 0x0,
                    /// KEY1
                    KEY1 = 0x1,
                    /// KEY2
                    KEY2 = 0x2,
                    /// KEY3
                    KEY3 = 0x3,
                    /// UNIQUE_KEY
                    UNIQUE_KEY = 0xfe,
                    /// OTP_KEY
                    OTP_KEY = 0xff,
                    _,
                },
                /// Hash Selection Field
                HASH_SELECT: enum(u4) {
                    /// SHA1
                    SHA1 = 0x0,
                    /// CRC32
                    CRC32 = 0x1,
                    /// SHA256
                    SHA256 = 0x2,
                    _,
                },
                reserved24: u4 = 0,
                /// Cipher configuration bits. Optional configuration bits are required for the ciphers.
                CIPHER_CFG: u8,
            }),
            reserved176: [12]u8,
            /// DCP work packet 3 status register
            PACKET3: mmio.Mmio(packed struct(u32) {
                /// Source buffer address pointer
                ADDR: u32,
            }),
            reserved192: [12]u8,
            /// DCP work packet 4 status register
            PACKET4: mmio.Mmio(packed struct(u32) {
                /// Destination buffer address pointer
                ADDR: u32,
            }),
            reserved208: [12]u8,
            /// DCP work packet 5 status register
            PACKET5: mmio.Mmio(packed struct(u32) {
                /// Byte count register. This value is the working value and updates as the operation proceeds.
                COUNT: u32,
            }),
            reserved224: [12]u8,
            /// DCP work packet 6 status register
            PACKET6: mmio.Mmio(packed struct(u32) {
                /// This regiser reflects the payload pointer for the current control packet.
                ADDR: u32,
            }),
            reserved256: [28]u8,
            /// DCP channel 0 command pointer address register
            CH0CMDPTR: mmio.Mmio(packed struct(u32) {
                /// Pointer to the descriptor structure to be processed for channel 0.
                ADDR: u32,
            }),
            reserved272: [12]u8,
            /// DCP channel 0 semaphore register
            CH0SEMA: mmio.Mmio(packed struct(u32) {
                /// The value written to this field is added to the semaphore count in an atomic way such that the simultaneous software adds and DCP hardware substracts happening on the same clock are protected
                INCREMENT: u8,
                reserved16: u8 = 0,
                /// This read-only field shows the current (instantaneous) value of the semaphore counter.
                VALUE: u8,
                padding: u8 = 0,
            }),
            reserved288: [12]u8,
            /// DCP channel 0 status register
            CH0STAT: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This bit indicates that a hashing check operation mismatched for the control packets that enable the HASH_CHECK bit
                HASH_MISMATCH: u1,
                /// This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
                ERROR_SETUP: u1,
                /// This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet payload
                ERROR_PACKET: u1,
                /// This bit indicates that a bus error occurred when reading from the source buffer
                ERROR_SRC: u1,
                /// This bit indicates that a bus error occurred when storing to the destination buffer
                ERROR_DST: u1,
                /// This bit indicates that a page fault occurred while converting a virtual address to a physical address
                ERROR_PAGEFAULT: u1,
                reserved16: u9 = 0,
                /// Indicates the additional error codes for some of the error conditions
                ERROR_CODE: enum(u8) {
                    /// Error signalled because the next pointer is 0x00000000
                    NEXT_CHAIN_IS_0 = 0x1,
                    /// Error signalled because the semaphore is non-zero and neither chain bit is set
                    NO_CHAIN = 0x2,
                    /// Error signalled because an error is reported reading/writing the context buffer
                    CONTEXT_ERROR = 0x3,
                    /// Error signalled because an error is reported reading/writing the payload
                    PAYLOAD_ERROR = 0x4,
                    /// Error signalled because the control packet specifies an invalid mode select (for instance, blit + hash)
                    INVALID_MODE = 0x5,
                    _,
                },
                /// Indicates the tag from the last completed packet in the command structure
                TAG: u8,
            }),
            /// DCP channel 0 status register
            CH0STAT_SET: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This bit indicates that a hashing check operation mismatched for the control packets that enable the HASH_CHECK bit
                HASH_MISMATCH: u1,
                /// This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
                ERROR_SETUP: u1,
                /// This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet payload
                ERROR_PACKET: u1,
                /// This bit indicates that a bus error occurred when reading from the source buffer
                ERROR_SRC: u1,
                /// This bit indicates that a bus error occurred when storing to the destination buffer
                ERROR_DST: u1,
                /// This bit indicates that a page fault occurred while converting a virtual address to a physical address
                ERROR_PAGEFAULT: u1,
                reserved16: u9 = 0,
                /// Indicates the additional error codes for some of the error conditions
                ERROR_CODE: enum(u8) {
                    /// Error signalled because the next pointer is 0x00000000
                    NEXT_CHAIN_IS_0 = 0x1,
                    /// Error signalled because the semaphore is non-zero and neither chain bit is set
                    NO_CHAIN = 0x2,
                    /// Error signalled because an error is reported reading/writing the context buffer
                    CONTEXT_ERROR = 0x3,
                    /// Error signalled because an error is reported reading/writing the payload
                    PAYLOAD_ERROR = 0x4,
                    /// Error signalled because the control packet specifies an invalid mode select (for instance, blit + hash)
                    INVALID_MODE = 0x5,
                    _,
                },
                /// Indicates the tag from the last completed packet in the command structure
                TAG: u8,
            }),
            /// DCP channel 0 status register
            CH0STAT_CLR: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This bit indicates that a hashing check operation mismatched for the control packets that enable the HASH_CHECK bit
                HASH_MISMATCH: u1,
                /// This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
                ERROR_SETUP: u1,
                /// This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet payload
                ERROR_PACKET: u1,
                /// This bit indicates that a bus error occurred when reading from the source buffer
                ERROR_SRC: u1,
                /// This bit indicates that a bus error occurred when storing to the destination buffer
                ERROR_DST: u1,
                /// This bit indicates that a page fault occurred while converting a virtual address to a physical address
                ERROR_PAGEFAULT: u1,
                reserved16: u9 = 0,
                /// Indicates the additional error codes for some of the error conditions
                ERROR_CODE: enum(u8) {
                    /// Error signalled because the next pointer is 0x00000000
                    NEXT_CHAIN_IS_0 = 0x1,
                    /// Error signalled because the semaphore is non-zero and neither chain bit is set
                    NO_CHAIN = 0x2,
                    /// Error signalled because an error is reported reading/writing the context buffer
                    CONTEXT_ERROR = 0x3,
                    /// Error signalled because an error is reported reading/writing the payload
                    PAYLOAD_ERROR = 0x4,
                    /// Error signalled because the control packet specifies an invalid mode select (for instance, blit + hash)
                    INVALID_MODE = 0x5,
                    _,
                },
                /// Indicates the tag from the last completed packet in the command structure
                TAG: u8,
            }),
            /// DCP channel 0 status register
            CH0STAT_TOG: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This bit indicates that a hashing check operation mismatched for the control packets that enable the HASH_CHECK bit
                HASH_MISMATCH: u1,
                /// This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
                ERROR_SETUP: u1,
                /// This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet payload
                ERROR_PACKET: u1,
                /// This bit indicates that a bus error occurred when reading from the source buffer
                ERROR_SRC: u1,
                /// This bit indicates that a bus error occurred when storing to the destination buffer
                ERROR_DST: u1,
                /// This bit indicates that a page fault occurred while converting a virtual address to a physical address
                ERROR_PAGEFAULT: u1,
                reserved16: u9 = 0,
                /// Indicates the additional error codes for some of the error conditions
                ERROR_CODE: enum(u8) {
                    /// Error signalled because the next pointer is 0x00000000
                    NEXT_CHAIN_IS_0 = 0x1,
                    /// Error signalled because the semaphore is non-zero and neither chain bit is set
                    NO_CHAIN = 0x2,
                    /// Error signalled because an error is reported reading/writing the context buffer
                    CONTEXT_ERROR = 0x3,
                    /// Error signalled because an error is reported reading/writing the payload
                    PAYLOAD_ERROR = 0x4,
                    /// Error signalled because the control packet specifies an invalid mode select (for instance, blit + hash)
                    INVALID_MODE = 0x5,
                    _,
                },
                /// Indicates the tag from the last completed packet in the command structure
                TAG: u8,
            }),
            /// DCP channel 0 options register
            CH0OPTS: mmio.Mmio(packed struct(u32) {
                /// This field indicates the recovery time for the channel
                RECOVERY_TIMER: u16,
                padding: u16 = 0,
            }),
            /// DCP channel 0 options register
            CH0OPTS_SET: mmio.Mmio(packed struct(u32) {
                /// This field indicates the recovery time for the channel
                RECOVERY_TIMER: u16,
                padding: u16 = 0,
            }),
            /// DCP channel 0 options register
            CH0OPTS_CLR: mmio.Mmio(packed struct(u32) {
                /// This field indicates the recovery time for the channel
                RECOVERY_TIMER: u16,
                padding: u16 = 0,
            }),
            /// DCP channel 0 options register
            CH0OPTS_TOG: mmio.Mmio(packed struct(u32) {
                /// This field indicates the recovery time for the channel
                RECOVERY_TIMER: u16,
                padding: u16 = 0,
            }),
            /// DCP channel 1 command pointer address register
            CH1CMDPTR: mmio.Mmio(packed struct(u32) {
                /// Pointer to the descriptor structure to be processed for channel 1.
                ADDR: u32,
            }),
            reserved336: [12]u8,
            /// DCP channel 1 semaphore register
            CH1SEMA: mmio.Mmio(packed struct(u32) {
                /// The value written to this field is added to the semaphore count in an atomic way, such that the simultaneous software adds and the DCP hardware substracts happening on the same clock are protected
                INCREMENT: u8,
                reserved16: u8 = 0,
                /// This read-only field shows the current (instantaneous) value of the semaphore counter.
                VALUE: u8,
                padding: u8 = 0,
            }),
            reserved352: [12]u8,
            /// DCP channel 1 status register
            CH1STAT: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
                HASH_MISMATCH: u1,
                /// This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
                ERROR_SETUP: u1,
                /// This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
                ERROR_PACKET: u1,
                /// This bit indicates that a bus error occurred when reading from the source buffer
                ERROR_SRC: u1,
                /// This bit indicates that a bus error occurred when storing to the destination buffer
                ERROR_DST: u1,
                /// This bit indicates that a page fault occurred while converting a virtual address to a physical address
                ERROR_PAGEFAULT: u1,
                reserved16: u9 = 0,
                /// Indicates the additional error codes for some of the error conditions.
                ERROR_CODE: enum(u8) {
                    /// Error is signalled because the next pointer is 0x00000000.
                    NEXT_CHAIN_IS_0 = 0x1,
                    /// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
                    NO_CHAIN = 0x2,
                    /// Error is signalled because an error was reported when reading/writing the context buffer.
                    CONTEXT_ERROR = 0x3,
                    /// Error is signalled because an error was reported when reading/writing the payload.
                    PAYLOAD_ERROR = 0x4,
                    /// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
                    INVALID_MODE = 0x5,
                    _,
                },
                /// Indicates the tag from the last completed packet in the command structure.
                TAG: u8,
            }),
            /// DCP channel 1 status register
            CH1STAT_SET: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
                HASH_MISMATCH: u1,
                /// This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
                ERROR_SETUP: u1,
                /// This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
                ERROR_PACKET: u1,
                /// This bit indicates that a bus error occurred when reading from the source buffer
                ERROR_SRC: u1,
                /// This bit indicates that a bus error occurred when storing to the destination buffer
                ERROR_DST: u1,
                /// This bit indicates that a page fault occurred while converting a virtual address to a physical address
                ERROR_PAGEFAULT: u1,
                reserved16: u9 = 0,
                /// Indicates the additional error codes for some of the error conditions.
                ERROR_CODE: enum(u8) {
                    /// Error is signalled because the next pointer is 0x00000000.
                    NEXT_CHAIN_IS_0 = 0x1,
                    /// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
                    NO_CHAIN = 0x2,
                    /// Error is signalled because an error was reported when reading/writing the context buffer.
                    CONTEXT_ERROR = 0x3,
                    /// Error is signalled because an error was reported when reading/writing the payload.
                    PAYLOAD_ERROR = 0x4,
                    /// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
                    INVALID_MODE = 0x5,
                    _,
                },
                /// Indicates the tag from the last completed packet in the command structure.
                TAG: u8,
            }),
            /// DCP channel 1 status register
            CH1STAT_CLR: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
                HASH_MISMATCH: u1,
                /// This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
                ERROR_SETUP: u1,
                /// This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
                ERROR_PACKET: u1,
                /// This bit indicates that a bus error occurred when reading from the source buffer
                ERROR_SRC: u1,
                /// This bit indicates that a bus error occurred when storing to the destination buffer
                ERROR_DST: u1,
                /// This bit indicates that a page fault occurred while converting a virtual address to a physical address
                ERROR_PAGEFAULT: u1,
                reserved16: u9 = 0,
                /// Indicates the additional error codes for some of the error conditions.
                ERROR_CODE: enum(u8) {
                    /// Error is signalled because the next pointer is 0x00000000.
                    NEXT_CHAIN_IS_0 = 0x1,
                    /// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
                    NO_CHAIN = 0x2,
                    /// Error is signalled because an error was reported when reading/writing the context buffer.
                    CONTEXT_ERROR = 0x3,
                    /// Error is signalled because an error was reported when reading/writing the payload.
                    PAYLOAD_ERROR = 0x4,
                    /// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
                    INVALID_MODE = 0x5,
                    _,
                },
                /// Indicates the tag from the last completed packet in the command structure.
                TAG: u8,
            }),
            /// DCP channel 1 status register
            CH1STAT_TOG: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
                HASH_MISMATCH: u1,
                /// This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
                ERROR_SETUP: u1,
                /// This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
                ERROR_PACKET: u1,
                /// This bit indicates that a bus error occurred when reading from the source buffer
                ERROR_SRC: u1,
                /// This bit indicates that a bus error occurred when storing to the destination buffer
                ERROR_DST: u1,
                /// This bit indicates that a page fault occurred while converting a virtual address to a physical address
                ERROR_PAGEFAULT: u1,
                reserved16: u9 = 0,
                /// Indicates the additional error codes for some of the error conditions.
                ERROR_CODE: enum(u8) {
                    /// Error is signalled because the next pointer is 0x00000000.
                    NEXT_CHAIN_IS_0 = 0x1,
                    /// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
                    NO_CHAIN = 0x2,
                    /// Error is signalled because an error was reported when reading/writing the context buffer.
                    CONTEXT_ERROR = 0x3,
                    /// Error is signalled because an error was reported when reading/writing the payload.
                    PAYLOAD_ERROR = 0x4,
                    /// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
                    INVALID_MODE = 0x5,
                    _,
                },
                /// Indicates the tag from the last completed packet in the command structure.
                TAG: u8,
            }),
            /// DCP channel 1 options register
            CH1OPTS: mmio.Mmio(packed struct(u32) {
                /// This field indicates the recovery time for the channel
                RECOVERY_TIMER: u16,
                padding: u16 = 0,
            }),
            /// DCP channel 1 options register
            CH1OPTS_SET: mmio.Mmio(packed struct(u32) {
                /// This field indicates the recovery time for the channel
                RECOVERY_TIMER: u16,
                padding: u16 = 0,
            }),
            /// DCP channel 1 options register
            CH1OPTS_CLR: mmio.Mmio(packed struct(u32) {
                /// This field indicates the recovery time for the channel
                RECOVERY_TIMER: u16,
                padding: u16 = 0,
            }),
            /// DCP channel 1 options register
            CH1OPTS_TOG: mmio.Mmio(packed struct(u32) {
                /// This field indicates the recovery time for the channel
                RECOVERY_TIMER: u16,
                padding: u16 = 0,
            }),
            /// DCP channel 2 command pointer address register
            CH2CMDPTR: mmio.Mmio(packed struct(u32) {
                /// Pointer to the descriptor structure to be processed for channel 2.
                ADDR: u32,
            }),
            reserved400: [12]u8,
            /// DCP channel 2 semaphore register
            CH2SEMA: mmio.Mmio(packed struct(u32) {
                /// The value written to this field is added to the semaphore count in an atomic way, such that the simultaneous software adds and DCP hardware substracts happening on the same clock are protected
                INCREMENT: u8,
                reserved16: u8 = 0,
                /// This read-only field shows the current (instantaneous) value of the semaphore counter.
                VALUE: u8,
                padding: u8 = 0,
            }),
            reserved416: [12]u8,
            /// DCP channel 2 status register
            CH2STAT: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
                HASH_MISMATCH: u1,
                /// This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
                ERROR_SETUP: u1,
                /// This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
                ERROR_PACKET: u1,
                /// This bit indicates that a bus error occurred when reading from the source buffer
                ERROR_SRC: u1,
                /// This bit indicates that a bus error occurred when storing to the destination buffer
                ERROR_DST: u1,
                /// This bit indicates that a page fault occurred while converting a virtual address to a physical address
                ERROR_PAGEFAULT: u1,
                reserved16: u9 = 0,
                /// Indicates additional error codes for some of the error conditions.
                ERROR_CODE: enum(u8) {
                    /// Error is signalled because the next pointer is 0x00000000.
                    NEXT_CHAIN_IS_0 = 0x1,
                    /// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
                    NO_CHAIN = 0x2,
                    /// Error is signalled because an error was reported while reading/writing the context buffer.
                    CONTEXT_ERROR = 0x3,
                    /// Error is signalled because an error was reported while reading/writing the payload.
                    PAYLOAD_ERROR = 0x4,
                    /// Error is signalled because the control packet specifies an invalid mode select (for instance, blit + hash).
                    INVALID_MODE = 0x5,
                    _,
                },
                /// Indicates the tag from the last completed packet in the command structure.
                TAG: u8,
            }),
            /// DCP channel 2 status register
            CH2STAT_SET: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
                HASH_MISMATCH: u1,
                /// This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
                ERROR_SETUP: u1,
                /// This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
                ERROR_PACKET: u1,
                /// This bit indicates that a bus error occurred when reading from the source buffer
                ERROR_SRC: u1,
                /// This bit indicates that a bus error occurred when storing to the destination buffer
                ERROR_DST: u1,
                /// This bit indicates that a page fault occurred while converting a virtual address to a physical address
                ERROR_PAGEFAULT: u1,
                reserved16: u9 = 0,
                /// Indicates additional error codes for some of the error conditions.
                ERROR_CODE: enum(u8) {
                    /// Error is signalled because the next pointer is 0x00000000.
                    NEXT_CHAIN_IS_0 = 0x1,
                    /// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
                    NO_CHAIN = 0x2,
                    /// Error is signalled because an error was reported while reading/writing the context buffer.
                    CONTEXT_ERROR = 0x3,
                    /// Error is signalled because an error was reported while reading/writing the payload.
                    PAYLOAD_ERROR = 0x4,
                    /// Error is signalled because the control packet specifies an invalid mode select (for instance, blit + hash).
                    INVALID_MODE = 0x5,
                    _,
                },
                /// Indicates the tag from the last completed packet in the command structure.
                TAG: u8,
            }),
            /// DCP channel 2 status register
            CH2STAT_CLR: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
                HASH_MISMATCH: u1,
                /// This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
                ERROR_SETUP: u1,
                /// This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
                ERROR_PACKET: u1,
                /// This bit indicates that a bus error occurred when reading from the source buffer
                ERROR_SRC: u1,
                /// This bit indicates that a bus error occurred when storing to the destination buffer
                ERROR_DST: u1,
                /// This bit indicates that a page fault occurred while converting a virtual address to a physical address
                ERROR_PAGEFAULT: u1,
                reserved16: u9 = 0,
                /// Indicates additional error codes for some of the error conditions.
                ERROR_CODE: enum(u8) {
                    /// Error is signalled because the next pointer is 0x00000000.
                    NEXT_CHAIN_IS_0 = 0x1,
                    /// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
                    NO_CHAIN = 0x2,
                    /// Error is signalled because an error was reported while reading/writing the context buffer.
                    CONTEXT_ERROR = 0x3,
                    /// Error is signalled because an error was reported while reading/writing the payload.
                    PAYLOAD_ERROR = 0x4,
                    /// Error is signalled because the control packet specifies an invalid mode select (for instance, blit + hash).
                    INVALID_MODE = 0x5,
                    _,
                },
                /// Indicates the tag from the last completed packet in the command structure.
                TAG: u8,
            }),
            /// DCP channel 2 status register
            CH2STAT_TOG: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
                HASH_MISMATCH: u1,
                /// This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
                ERROR_SETUP: u1,
                /// This bit indicates that a bus error occurred when reading the packet or payload, or when writing the status back to the packet paylaod
                ERROR_PACKET: u1,
                /// This bit indicates that a bus error occurred when reading from the source buffer
                ERROR_SRC: u1,
                /// This bit indicates that a bus error occurred when storing to the destination buffer
                ERROR_DST: u1,
                /// This bit indicates that a page fault occurred while converting a virtual address to a physical address
                ERROR_PAGEFAULT: u1,
                reserved16: u9 = 0,
                /// Indicates additional error codes for some of the error conditions.
                ERROR_CODE: enum(u8) {
                    /// Error is signalled because the next pointer is 0x00000000.
                    NEXT_CHAIN_IS_0 = 0x1,
                    /// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
                    NO_CHAIN = 0x2,
                    /// Error is signalled because an error was reported while reading/writing the context buffer.
                    CONTEXT_ERROR = 0x3,
                    /// Error is signalled because an error was reported while reading/writing the payload.
                    PAYLOAD_ERROR = 0x4,
                    /// Error is signalled because the control packet specifies an invalid mode select (for instance, blit + hash).
                    INVALID_MODE = 0x5,
                    _,
                },
                /// Indicates the tag from the last completed packet in the command structure.
                TAG: u8,
            }),
            /// DCP channel 2 options register
            CH2OPTS: mmio.Mmio(packed struct(u32) {
                /// This field indicates the recovery time for the channel
                RECOVERY_TIMER: u16,
                padding: u16 = 0,
            }),
            /// DCP channel 2 options register
            CH2OPTS_SET: mmio.Mmio(packed struct(u32) {
                /// This field indicates the recovery time for the channel
                RECOVERY_TIMER: u16,
                padding: u16 = 0,
            }),
            /// DCP channel 2 options register
            CH2OPTS_CLR: mmio.Mmio(packed struct(u32) {
                /// This field indicates the recovery time for the channel
                RECOVERY_TIMER: u16,
                padding: u16 = 0,
            }),
            /// DCP channel 2 options register
            CH2OPTS_TOG: mmio.Mmio(packed struct(u32) {
                /// This field indicates the recovery time for the channel
                RECOVERY_TIMER: u16,
                padding: u16 = 0,
            }),
            /// DCP channel 3 command pointer address register
            CH3CMDPTR: mmio.Mmio(packed struct(u32) {
                /// Pointer to the descriptor structure to be processed for channel 3.
                ADDR: u32,
            }),
            reserved464: [12]u8,
            /// DCP channel 3 semaphore register
            CH3SEMA: mmio.Mmio(packed struct(u32) {
                /// The value written to this field is added to the semaphore count in an atomic way, such that the simultaneous software adds and DCP hardware substracts happening on the same clock are protected
                INCREMENT: u8,
                reserved16: u8 = 0,
                /// This read-only field shows the current (instantaneous) value of the semaphore counter.
                VALUE: u8,
                padding: u8 = 0,
            }),
            reserved480: [12]u8,
            /// DCP channel 3 status register
            CH3STAT: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
                HASH_MISMATCH: u1,
                /// This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
                ERROR_SETUP: u1,
                /// This bit indicates that a bus error occurred when reading the packet or payload or when writing the status back to the packet paylaod
                ERROR_PACKET: u1,
                /// This bit indicates that a bus error occurred when reading from the source buffer
                ERROR_SRC: u1,
                /// This bit indicates that a bus error occurred when storing to the destination buffer
                ERROR_DST: u1,
                /// This bit indicates that a page fault occurred while converting a virtual address to a physical address
                ERROR_PAGEFAULT: u1,
                reserved16: u9 = 0,
                /// Indicates additional error codes for some of the error conditions.
                ERROR_CODE: enum(u8) {
                    /// Error is signalled because the next pointer is 0x00000000.
                    NEXT_CHAIN_IS_0 = 0x1,
                    /// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
                    NO_CHAIN = 0x2,
                    /// Error is signalled because an error was reported while reading/writing the context buffer.
                    CONTEXT_ERROR = 0x3,
                    /// Error is signalled because an error was reported while reading/writing the payload.
                    PAYLOAD_ERROR = 0x4,
                    /// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
                    INVALID_MODE = 0x5,
                    _,
                },
                /// Indicates the tag from the last completed packet in the command structure.
                TAG: u8,
            }),
            /// DCP channel 3 status register
            CH3STAT_SET: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
                HASH_MISMATCH: u1,
                /// This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
                ERROR_SETUP: u1,
                /// This bit indicates that a bus error occurred when reading the packet or payload or when writing the status back to the packet paylaod
                ERROR_PACKET: u1,
                /// This bit indicates that a bus error occurred when reading from the source buffer
                ERROR_SRC: u1,
                /// This bit indicates that a bus error occurred when storing to the destination buffer
                ERROR_DST: u1,
                /// This bit indicates that a page fault occurred while converting a virtual address to a physical address
                ERROR_PAGEFAULT: u1,
                reserved16: u9 = 0,
                /// Indicates additional error codes for some of the error conditions.
                ERROR_CODE: enum(u8) {
                    /// Error is signalled because the next pointer is 0x00000000.
                    NEXT_CHAIN_IS_0 = 0x1,
                    /// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
                    NO_CHAIN = 0x2,
                    /// Error is signalled because an error was reported while reading/writing the context buffer.
                    CONTEXT_ERROR = 0x3,
                    /// Error is signalled because an error was reported while reading/writing the payload.
                    PAYLOAD_ERROR = 0x4,
                    /// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
                    INVALID_MODE = 0x5,
                    _,
                },
                /// Indicates the tag from the last completed packet in the command structure.
                TAG: u8,
            }),
            /// DCP channel 3 status register
            CH3STAT_CLR: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
                HASH_MISMATCH: u1,
                /// This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
                ERROR_SETUP: u1,
                /// This bit indicates that a bus error occurred when reading the packet or payload or when writing the status back to the packet paylaod
                ERROR_PACKET: u1,
                /// This bit indicates that a bus error occurred when reading from the source buffer
                ERROR_SRC: u1,
                /// This bit indicates that a bus error occurred when storing to the destination buffer
                ERROR_DST: u1,
                /// This bit indicates that a page fault occurred while converting a virtual address to a physical address
                ERROR_PAGEFAULT: u1,
                reserved16: u9 = 0,
                /// Indicates additional error codes for some of the error conditions.
                ERROR_CODE: enum(u8) {
                    /// Error is signalled because the next pointer is 0x00000000.
                    NEXT_CHAIN_IS_0 = 0x1,
                    /// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
                    NO_CHAIN = 0x2,
                    /// Error is signalled because an error was reported while reading/writing the context buffer.
                    CONTEXT_ERROR = 0x3,
                    /// Error is signalled because an error was reported while reading/writing the payload.
                    PAYLOAD_ERROR = 0x4,
                    /// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
                    INVALID_MODE = 0x5,
                    _,
                },
                /// Indicates the tag from the last completed packet in the command structure.
                TAG: u8,
            }),
            /// DCP channel 3 status register
            CH3STAT_TOG: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// This bit indicates that a hashing check operation is mismatched for the control packets that enable the HASH_CHECK bit
                HASH_MISMATCH: u1,
                /// This bit indicates that the hardware detected an invalid programming configuration (such as a buffer length that is not a multiple of the natural data size for the operation)
                ERROR_SETUP: u1,
                /// This bit indicates that a bus error occurred when reading the packet or payload or when writing the status back to the packet paylaod
                ERROR_PACKET: u1,
                /// This bit indicates that a bus error occurred when reading from the source buffer
                ERROR_SRC: u1,
                /// This bit indicates that a bus error occurred when storing to the destination buffer
                ERROR_DST: u1,
                /// This bit indicates that a page fault occurred while converting a virtual address to a physical address
                ERROR_PAGEFAULT: u1,
                reserved16: u9 = 0,
                /// Indicates additional error codes for some of the error conditions.
                ERROR_CODE: enum(u8) {
                    /// Error is signalled because the next pointer is 0x00000000.
                    NEXT_CHAIN_IS_0 = 0x1,
                    /// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
                    NO_CHAIN = 0x2,
                    /// Error is signalled because an error was reported while reading/writing the context buffer.
                    CONTEXT_ERROR = 0x3,
                    /// Error is signalled because an error was reported while reading/writing the payload.
                    PAYLOAD_ERROR = 0x4,
                    /// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
                    INVALID_MODE = 0x5,
                    _,
                },
                /// Indicates the tag from the last completed packet in the command structure.
                TAG: u8,
            }),
            /// DCP channel 3 options register
            CH3OPTS: mmio.Mmio(packed struct(u32) {
                /// This field indicates the recovery time for the channel
                RECOVERY_TIMER: u16,
                padding: u16 = 0,
            }),
            /// DCP channel 3 options register
            CH3OPTS_SET: mmio.Mmio(packed struct(u32) {
                /// This field indicates the recovery time for the channel
                RECOVERY_TIMER: u16,
                padding: u16 = 0,
            }),
            /// DCP channel 3 options register
            CH3OPTS_CLR: mmio.Mmio(packed struct(u32) {
                /// This field indicates the recovery time for the channel
                RECOVERY_TIMER: u16,
                padding: u16 = 0,
            }),
            /// DCP channel 3 options register
            CH3OPTS_TOG: mmio.Mmio(packed struct(u32) {
                /// This field indicates the recovery time for the channel
                RECOVERY_TIMER: u16,
                padding: u16 = 0,
            }),
            reserved1024: [512]u8,
            /// DCP debug select register
            DBGSELECT: mmio.Mmio(packed struct(u32) {
                /// Selects a value to read via the debug data register.
                INDEX: enum(u8) {
                    /// CONTROL
                    CONTROL = 0x1,
                    /// OTPKEY0
                    OTPKEY0 = 0x10,
                    /// OTPKEY1
                    OTPKEY1 = 0x11,
                    /// OTPKEY2
                    OTPKEY2 = 0x12,
                    /// OTPKEY3
                    OTPKEY3 = 0x13,
                    _,
                },
                padding: u24 = 0,
            }),
            reserved1040: [12]u8,
            /// DCP debug data register
            DBGDATA: mmio.Mmio(packed struct(u32) {
                /// Debug data
                DATA: u32,
            }),
            reserved1056: [12]u8,
            /// DCP page table register
            PAGETABLE: mmio.Mmio(packed struct(u32) {
                /// Page table enable control
                ENABLE: u1,
                /// Page table flush control. To flush the TLB, write this bit to 1 and then back to 0.
                FLUSH: u1,
                /// Page table base address
                BASE: u30,
            }),
            reserved1072: [12]u8,
            /// DCP version register
            VERSION: mmio.Mmio(packed struct(u32) {
                /// Fixed read-only value reflecting the stepping of the version of the design implementation.
                STEP: u16,
                /// Fixed read-only value reflecting the MINOR version of the design implementation.
                MINOR: u8,
                /// Fixed read-only value reflecting the MAJOR version of the design implementation.
                MAJOR: u8,
            }),
        };

        /// DMA
        pub const DMA0 = extern struct {
            /// Control Register
            CR: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// Enable Debug
                EDBG: enum(u1) {
                    /// When in debug mode, the DMA continues to operate.
                    EDBG_0 = 0x0,
                    /// When in debug mode, the DMA stalls the start of a new channel. Executing channels are allowed to complete. Channel execution resumes when the system exits debug mode or the EDBG bit is cleared.
                    EDBG_1 = 0x1,
                },
                /// Enable Round Robin Channel Arbitration
                ERCA: enum(u1) {
                    /// Fixed priority arbitration is used for channel selection within each group.
                    ERCA_0 = 0x0,
                    /// Round robin arbitration is used for channel selection within each group.
                    ERCA_1 = 0x1,
                },
                /// Enable Round Robin Group Arbitration
                ERGA: enum(u1) {
                    /// Fixed priority arbitration is used for selection among the groups.
                    ERGA_0 = 0x0,
                    /// Round robin arbitration is used for selection among the groups.
                    ERGA_1 = 0x1,
                },
                /// Halt On Error
                HOE: enum(u1) {
                    /// Normal operation
                    HOE_0 = 0x0,
                    /// Any error causes the HALT bit to set. Subsequently, all service requests are ignored until the HALT bit is cleared.
                    HOE_1 = 0x1,
                },
                /// Halt DMA Operations
                HALT: enum(u1) {
                    /// Normal operation
                    HALT_0 = 0x0,
                    /// Stall the start of any new channels. Executing channels are allowed to complete. Channel execution resumes when this bit is cleared.
                    HALT_1 = 0x1,
                },
                /// Continuous Link Mode
                CLM: enum(u1) {
                    /// A minor loop channel link made to itself goes through channel arbitration before being activated again.
                    CLM_0 = 0x0,
                    /// A minor loop channel link made to itself does not go through channel arbitration before being activated again. Upon minor loop completion, the channel activates again if that channel has a minor loop channel link enabled and the link channel is itself. This effectively applies the minor loop offsets and restarts the next minor loop.
                    CLM_1 = 0x1,
                },
                /// Enable Minor Loop Mapping
                EMLM: enum(u1) {
                    /// Disabled. TCDn.word2 is defined as a 32-bit NBYTES field.
                    EMLM_0 = 0x0,
                    /// Enabled. TCDn.word2 is redefined to include individual enable fields, an offset field, and the NBYTES field. The individual enable fields allow the minor loop offset to be applied to the source address, the destination address, or both. The NBYTES field is reduced when either offset is enabled.
                    EMLM_1 = 0x1,
                },
                /// Channel Group 0 Priority
                GRP0PRI: u1,
                reserved10: u1 = 0,
                /// Channel Group 1 Priority
                GRP1PRI: u1,
                reserved16: u5 = 0,
                /// Error Cancel Transfer
                ECX: enum(u1) {
                    /// Normal operation
                    ECX_0 = 0x0,
                    /// Cancel the remaining data transfer in the same fashion as the CX bit. Stop the executing channel and force the minor loop to finish. The cancel takes effect after the last write of the current read/write sequence. The ECX bit clears itself after the cancel is honored. In addition to cancelling the transfer, ECX treats the cancel as an error condition, thus updating the Error Status register (DMAx_ES) and generating an optional error interrupt.
                    ECX_1 = 0x1,
                },
                /// Cancel Transfer
                CX: enum(u1) {
                    /// Normal operation
                    CX_0 = 0x0,
                    /// Cancel the remaining data transfer. Stop the executing channel and force the minor loop to finish. The cancel takes effect after the last write of the current read/write sequence. The CX bit clears itself after the cancel has been honored. This cancel retires the channel normally as if the minor loop was completed.
                    CX_1 = 0x1,
                },
                reserved31: u13 = 0,
                /// DMA Active Status
                ACTIVE: enum(u1) {
                    /// eDMA is idle.
                    ACTIVE_0 = 0x0,
                    /// eDMA is executing a channel.
                    ACTIVE_1 = 0x1,
                },
            }),
            /// Error Status Register
            ES: mmio.Mmio(packed struct(u32) {
                /// Destination Bus Error
                DBE: enum(u1) {
                    /// No destination bus error
                    DBE_0 = 0x0,
                    /// The last recorded error was a bus error on a destination write
                    DBE_1 = 0x1,
                },
                /// Source Bus Error
                SBE: enum(u1) {
                    /// No source bus error
                    SBE_0 = 0x0,
                    /// The last recorded error was a bus error on a source read
                    SBE_1 = 0x1,
                },
                /// Scatter/Gather Configuration Error
                SGE: enum(u1) {
                    /// No scatter/gather configuration error
                    SGE_0 = 0x0,
                    /// The last recorded error was a configuration error detected in the TCDn_DLASTSGA field. This field is checked at the beginning of a scatter/gather operation after major loop completion if TCDn_CSR[ESG] is enabled. TCDn_DLASTSGA is not on a 32 byte boundary.
                    SGE_1 = 0x1,
                },
                /// NBYTES/CITER Configuration Error
                NCE: enum(u1) {
                    /// No NBYTES/CITER configuration error
                    NCE_0 = 0x0,
                    /// The last recorded error was a configuration error detected in the TCDn_NBYTES or TCDn_CITER fields. TCDn_NBYTES is not a multiple of TCDn_ATTR[SSIZE] and TCDn_ATTR[DSIZE], or TCDn_CITER[CITER] is equal to zero, or TCDn_CITER[ELINK] is not equal to TCDn_BITER[ELINK]
                    NCE_1 = 0x1,
                },
                /// Destination Offset Error
                DOE: enum(u1) {
                    /// No destination offset configuration error
                    DOE_0 = 0x0,
                    /// The last recorded error was a configuration error detected in the TCDn_DOFF field. TCDn_DOFF is inconsistent with TCDn_ATTR[DSIZE].
                    DOE_1 = 0x1,
                },
                /// Destination Address Error
                DAE: enum(u1) {
                    /// No destination address configuration error
                    DAE_0 = 0x0,
                    /// The last recorded error was a configuration error detected in the TCDn_DADDR field. TCDn_DADDR is inconsistent with TCDn_ATTR[DSIZE].
                    DAE_1 = 0x1,
                },
                /// Source Offset Error
                SOE: enum(u1) {
                    /// No source offset configuration error
                    SOE_0 = 0x0,
                    /// The last recorded error was a configuration error detected in the TCDn_SOFF field. TCDn_SOFF is inconsistent with TCDn_ATTR[SSIZE].
                    SOE_1 = 0x1,
                },
                /// Source Address Error
                SAE: enum(u1) {
                    /// No source address configuration error.
                    SAE_0 = 0x0,
                    /// The last recorded error was a configuration error detected in the TCDn_SADDR field. TCDn_SADDR is inconsistent with TCDn_ATTR[SSIZE].
                    SAE_1 = 0x1,
                },
                /// Error Channel Number or Canceled Channel Number
                ERRCHN: u5,
                reserved14: u1 = 0,
                /// Channel Priority Error
                CPE: enum(u1) {
                    /// No channel priority error
                    CPE_0 = 0x0,
                    /// The last recorded error was a configuration error in the channel priorities within a group. Channel priorities within a group are not unique.
                    CPE_1 = 0x1,
                },
                /// Group Priority Error
                GPE: enum(u1) {
                    /// No group priority error
                    GPE_0 = 0x0,
                    /// The last recorded error was a configuration error among the group priorities. All group priorities are not unique.
                    GPE_1 = 0x1,
                },
                /// Transfer Canceled
                ECX: enum(u1) {
                    /// No canceled transfers
                    ECX_0 = 0x0,
                    /// The last recorded entry was a canceled transfer by the error cancel transfer input
                    ECX_1 = 0x1,
                },
                reserved31: u14 = 0,
                /// VLD
                VLD: enum(u1) {
                    /// No ERR bits are set.
                    VLD_0 = 0x0,
                    /// At least one ERR bit is set indicating a valid error exists that has not been cleared.
                    VLD_1 = 0x1,
                },
            }),
            reserved12: [4]u8,
            /// Enable Request Register
            ERQ: mmio.Mmio(packed struct(u32) {
                /// Enable DMA Request 0
                ERQ0: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ0_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ0_1 = 0x1,
                },
                /// Enable DMA Request 1
                ERQ1: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ1_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ1_1 = 0x1,
                },
                /// Enable DMA Request 2
                ERQ2: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ2_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ2_1 = 0x1,
                },
                /// Enable DMA Request 3
                ERQ3: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ3_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ3_1 = 0x1,
                },
                /// Enable DMA Request 4
                ERQ4: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ4_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ4_1 = 0x1,
                },
                /// Enable DMA Request 5
                ERQ5: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ5_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ5_1 = 0x1,
                },
                /// Enable DMA Request 6
                ERQ6: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ6_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ6_1 = 0x1,
                },
                /// Enable DMA Request 7
                ERQ7: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ7_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ7_1 = 0x1,
                },
                /// Enable DMA Request 8
                ERQ8: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ8_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ8_1 = 0x1,
                },
                /// Enable DMA Request 9
                ERQ9: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ9_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ9_1 = 0x1,
                },
                /// Enable DMA Request 10
                ERQ10: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ10_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ10_1 = 0x1,
                },
                /// Enable DMA Request 11
                ERQ11: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ11_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ11_1 = 0x1,
                },
                /// Enable DMA Request 12
                ERQ12: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ12_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ12_1 = 0x1,
                },
                /// Enable DMA Request 13
                ERQ13: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ13_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ13_1 = 0x1,
                },
                /// Enable DMA Request 14
                ERQ14: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ14_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ14_1 = 0x1,
                },
                /// Enable DMA Request 15
                ERQ15: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ15_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ15_1 = 0x1,
                },
                /// Enable DMA Request 16
                ERQ16: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ16_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ16_1 = 0x1,
                },
                /// Enable DMA Request 17
                ERQ17: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ17_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ17_1 = 0x1,
                },
                /// Enable DMA Request 18
                ERQ18: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ18_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ18_1 = 0x1,
                },
                /// Enable DMA Request 19
                ERQ19: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ19_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ19_1 = 0x1,
                },
                /// Enable DMA Request 20
                ERQ20: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ20_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ20_1 = 0x1,
                },
                /// Enable DMA Request 21
                ERQ21: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ21_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ21_1 = 0x1,
                },
                /// Enable DMA Request 22
                ERQ22: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ22_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ22_1 = 0x1,
                },
                /// Enable DMA Request 23
                ERQ23: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ23_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ23_1 = 0x1,
                },
                /// Enable DMA Request 24
                ERQ24: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ24_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ24_1 = 0x1,
                },
                /// Enable DMA Request 25
                ERQ25: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ25_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ25_1 = 0x1,
                },
                /// Enable DMA Request 26
                ERQ26: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ26_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ26_1 = 0x1,
                },
                /// Enable DMA Request 27
                ERQ27: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ27_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ27_1 = 0x1,
                },
                /// Enable DMA Request 28
                ERQ28: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ28_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ28_1 = 0x1,
                },
                /// Enable DMA Request 29
                ERQ29: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ29_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ29_1 = 0x1,
                },
                /// Enable DMA Request 30
                ERQ30: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ30_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ30_1 = 0x1,
                },
                /// Enable DMA Request 31
                ERQ31: enum(u1) {
                    /// The DMA request signal for the corresponding channel is disabled
                    ERQ31_0 = 0x0,
                    /// The DMA request signal for the corresponding channel is enabled
                    ERQ31_1 = 0x1,
                },
            }),
            reserved20: [4]u8,
            /// Enable Error Interrupt Register
            EEI: mmio.Mmio(packed struct(u32) {
                /// Enable Error Interrupt 0
                EEI0: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI0_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI0_1 = 0x1,
                },
                /// Enable Error Interrupt 1
                EEI1: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI1_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI1_1 = 0x1,
                },
                /// Enable Error Interrupt 2
                EEI2: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI2_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI2_1 = 0x1,
                },
                /// Enable Error Interrupt 3
                EEI3: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI3_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI3_1 = 0x1,
                },
                /// Enable Error Interrupt 4
                EEI4: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI4_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI4_1 = 0x1,
                },
                /// Enable Error Interrupt 5
                EEI5: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI5_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI5_1 = 0x1,
                },
                /// Enable Error Interrupt 6
                EEI6: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI6_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI6_1 = 0x1,
                },
                /// Enable Error Interrupt 7
                EEI7: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI7_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI7_1 = 0x1,
                },
                /// Enable Error Interrupt 8
                EEI8: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI8_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI8_1 = 0x1,
                },
                /// Enable Error Interrupt 9
                EEI9: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI9_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI9_1 = 0x1,
                },
                /// Enable Error Interrupt 10
                EEI10: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI10_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI10_1 = 0x1,
                },
                /// Enable Error Interrupt 11
                EEI11: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI11_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI11_1 = 0x1,
                },
                /// Enable Error Interrupt 12
                EEI12: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI12_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI12_1 = 0x1,
                },
                /// Enable Error Interrupt 13
                EEI13: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI13_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI13_1 = 0x1,
                },
                /// Enable Error Interrupt 14
                EEI14: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI14_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI14_1 = 0x1,
                },
                /// Enable Error Interrupt 15
                EEI15: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI15_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI15_1 = 0x1,
                },
                /// Enable Error Interrupt 16
                EEI16: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI16_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI16_1 = 0x1,
                },
                /// Enable Error Interrupt 17
                EEI17: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI17_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI17_1 = 0x1,
                },
                /// Enable Error Interrupt 18
                EEI18: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI18_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI18_1 = 0x1,
                },
                /// Enable Error Interrupt 19
                EEI19: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI19_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI19_1 = 0x1,
                },
                /// Enable Error Interrupt 20
                EEI20: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI20_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI20_1 = 0x1,
                },
                /// Enable Error Interrupt 21
                EEI21: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI21_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI21_1 = 0x1,
                },
                /// Enable Error Interrupt 22
                EEI22: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI22_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI22_1 = 0x1,
                },
                /// Enable Error Interrupt 23
                EEI23: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI23_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI23_1 = 0x1,
                },
                /// Enable Error Interrupt 24
                EEI24: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI24_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI24_1 = 0x1,
                },
                /// Enable Error Interrupt 25
                EEI25: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI25_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI25_1 = 0x1,
                },
                /// Enable Error Interrupt 26
                EEI26: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI26_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI26_1 = 0x1,
                },
                /// Enable Error Interrupt 27
                EEI27: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI27_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI27_1 = 0x1,
                },
                /// Enable Error Interrupt 28
                EEI28: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI28_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI28_1 = 0x1,
                },
                /// Enable Error Interrupt 29
                EEI29: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI29_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI29_1 = 0x1,
                },
                /// Enable Error Interrupt 30
                EEI30: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI30_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI30_1 = 0x1,
                },
                /// Enable Error Interrupt 31
                EEI31: enum(u1) {
                    /// The error signal for corresponding channel does not generate an error interrupt
                    EEI31_0 = 0x0,
                    /// The assertion of the error signal for corresponding channel generates an error interrupt request
                    EEI31_1 = 0x1,
                },
            }),
            /// Clear Enable Error Interrupt Register
            CEEI: mmio.Mmio(packed struct(u8) {
                /// Clear Enable Error Interrupt
                CEEI: u5,
                reserved6: u1 = 0,
                /// Clear All Enable Error Interrupts
                CAEE: enum(u1) {
                    /// Clear only the EEI bit specified in the CEEI field
                    CAEE_0 = 0x0,
                    /// Clear all bits in EEI
                    CAEE_1 = 0x1,
                },
                /// No Op enable
                NOP: enum(u1) {
                    /// Normal operation
                    NOP_0 = 0x0,
                    /// No operation, ignore the other bits in this register
                    NOP_1 = 0x1,
                },
            }),
            /// Set Enable Error Interrupt Register
            SEEI: mmio.Mmio(packed struct(u8) {
                /// Set Enable Error Interrupt
                SEEI: u5,
                reserved6: u1 = 0,
                /// Sets All Enable Error Interrupts
                SAEE: enum(u1) {
                    /// Set only the EEI bit specified in the SEEI field.
                    SAEE_0 = 0x0,
                    /// Sets all bits in EEI
                    SAEE_1 = 0x1,
                },
                /// No Op enable
                NOP: enum(u1) {
                    /// Normal operation
                    NOP_0 = 0x0,
                    /// No operation, ignore the other bits in this register
                    NOP_1 = 0x1,
                },
            }),
            /// Clear Enable Request Register
            CERQ: mmio.Mmio(packed struct(u8) {
                /// Clear Enable Request
                CERQ: u5,
                reserved6: u1 = 0,
                /// Clear All Enable Requests
                CAER: enum(u1) {
                    /// Clear only the ERQ bit specified in the CERQ field
                    CAER_0 = 0x0,
                    /// Clear all bits in ERQ
                    CAER_1 = 0x1,
                },
                /// No Op enable
                NOP: enum(u1) {
                    /// Normal operation
                    NOP_0 = 0x0,
                    /// No operation, ignore the other bits in this register
                    NOP_1 = 0x1,
                },
            }),
            /// Set Enable Request Register
            SERQ: mmio.Mmio(packed struct(u8) {
                /// Set Enable Request
                SERQ: u5,
                reserved6: u1 = 0,
                /// Set All Enable Requests
                SAER: enum(u1) {
                    /// Set only the ERQ bit specified in the SERQ field
                    SAER_0 = 0x0,
                    /// Set all bits in ERQ
                    SAER_1 = 0x1,
                },
                /// No Op enable
                NOP: enum(u1) {
                    /// Normal operation
                    NOP_0 = 0x0,
                    /// No operation, ignore the other bits in this register
                    NOP_1 = 0x1,
                },
            }),
            /// Clear DONE Status Bit Register
            CDNE: mmio.Mmio(packed struct(u8) {
                /// Clear DONE Bit
                CDNE: u5,
                reserved6: u1 = 0,
                /// Clears All DONE Bits
                CADN: enum(u1) {
                    /// Clears only the TCDn_CSR[DONE] bit specified in the CDNE field
                    CADN_0 = 0x0,
                    /// Clears all bits in TCDn_CSR[DONE]
                    CADN_1 = 0x1,
                },
                /// No Op enable
                NOP: enum(u1) {
                    /// Normal operation
                    NOP_0 = 0x0,
                    /// No operation, ignore the other bits in this register
                    NOP_1 = 0x1,
                },
            }),
            /// Set START Bit Register
            SSRT: mmio.Mmio(packed struct(u8) {
                /// Set START Bit
                SSRT: u5,
                reserved6: u1 = 0,
                /// Set All START Bits (activates all channels)
                SAST: enum(u1) {
                    /// Set only the TCDn_CSR[START] bit specified in the SSRT field
                    SAST_0 = 0x0,
                    /// Set all bits in TCDn_CSR[START]
                    SAST_1 = 0x1,
                },
                /// No Op enable
                NOP: enum(u1) {
                    /// Normal operation
                    NOP_0 = 0x0,
                    /// No operation, ignore the other bits in this register
                    NOP_1 = 0x1,
                },
            }),
            /// Clear Error Register
            CERR: mmio.Mmio(packed struct(u8) {
                /// Clear Error Indicator
                CERR: u5,
                reserved6: u1 = 0,
                /// Clear All Error Indicators
                CAEI: enum(u1) {
                    /// Clear only the ERR bit specified in the CERR field
                    CAEI_0 = 0x0,
                    /// Clear all bits in ERR
                    CAEI_1 = 0x1,
                },
                /// No Op enable
                NOP: enum(u1) {
                    /// Normal operation
                    NOP_0 = 0x0,
                    /// No operation, ignore the other bits in this register
                    NOP_1 = 0x1,
                },
            }),
            /// Clear Interrupt Request Register
            CINT: mmio.Mmio(packed struct(u8) {
                /// Clear Interrupt Request
                CINT: u5,
                reserved6: u1 = 0,
                /// Clear All Interrupt Requests
                CAIR: enum(u1) {
                    /// Clear only the INT bit specified in the CINT field
                    CAIR_0 = 0x0,
                    /// Clear all bits in INT
                    CAIR_1 = 0x1,
                },
                /// No Op enable
                NOP: enum(u1) {
                    /// Normal operation
                    NOP_0 = 0x0,
                    /// No operation, ignore the other bits in this register
                    NOP_1 = 0x1,
                },
            }),
            reserved36: [4]u8,
            /// Interrupt Request Register
            INT: mmio.Mmio(packed struct(u32) {
                /// Interrupt Request 0
                INT0: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT0_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT0_1 = 0x1,
                },
                /// Interrupt Request 1
                INT1: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT1_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT1_1 = 0x1,
                },
                /// Interrupt Request 2
                INT2: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT2_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT2_1 = 0x1,
                },
                /// Interrupt Request 3
                INT3: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT3_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT3_1 = 0x1,
                },
                /// Interrupt Request 4
                INT4: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT4_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT4_1 = 0x1,
                },
                /// Interrupt Request 5
                INT5: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT5_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT5_1 = 0x1,
                },
                /// Interrupt Request 6
                INT6: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT6_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT6_1 = 0x1,
                },
                /// Interrupt Request 7
                INT7: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT7_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT7_1 = 0x1,
                },
                /// Interrupt Request 8
                INT8: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT8_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT8_1 = 0x1,
                },
                /// Interrupt Request 9
                INT9: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT9_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT9_1 = 0x1,
                },
                /// Interrupt Request 10
                INT10: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT10_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT10_1 = 0x1,
                },
                /// Interrupt Request 11
                INT11: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT11_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT11_1 = 0x1,
                },
                /// Interrupt Request 12
                INT12: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT12_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT12_1 = 0x1,
                },
                /// Interrupt Request 13
                INT13: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT13_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT13_1 = 0x1,
                },
                /// Interrupt Request 14
                INT14: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT14_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT14_1 = 0x1,
                },
                /// Interrupt Request 15
                INT15: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT15_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT15_1 = 0x1,
                },
                /// Interrupt Request 16
                INT16: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT16_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT16_1 = 0x1,
                },
                /// Interrupt Request 17
                INT17: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT17_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT17_1 = 0x1,
                },
                /// Interrupt Request 18
                INT18: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT18_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT18_1 = 0x1,
                },
                /// Interrupt Request 19
                INT19: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT19_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT19_1 = 0x1,
                },
                /// Interrupt Request 20
                INT20: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT20_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT20_1 = 0x1,
                },
                /// Interrupt Request 21
                INT21: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT21_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT21_1 = 0x1,
                },
                /// Interrupt Request 22
                INT22: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT22_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT22_1 = 0x1,
                },
                /// Interrupt Request 23
                INT23: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT23_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT23_1 = 0x1,
                },
                /// Interrupt Request 24
                INT24: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT24_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT24_1 = 0x1,
                },
                /// Interrupt Request 25
                INT25: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT25_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT25_1 = 0x1,
                },
                /// Interrupt Request 26
                INT26: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT26_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT26_1 = 0x1,
                },
                /// Interrupt Request 27
                INT27: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT27_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT27_1 = 0x1,
                },
                /// Interrupt Request 28
                INT28: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT28_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT28_1 = 0x1,
                },
                /// Interrupt Request 29
                INT29: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT29_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT29_1 = 0x1,
                },
                /// Interrupt Request 30
                INT30: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT30_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT30_1 = 0x1,
                },
                /// Interrupt Request 31
                INT31: enum(u1) {
                    /// The interrupt request for corresponding channel is cleared
                    INT31_0 = 0x0,
                    /// The interrupt request for corresponding channel is active
                    INT31_1 = 0x1,
                },
            }),
            reserved44: [4]u8,
            /// Error Register
            ERR: mmio.Mmio(packed struct(u32) {
                /// Error In Channel 0
                ERR0: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR0_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR0_1 = 0x1,
                },
                /// Error In Channel 1
                ERR1: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR1_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR1_1 = 0x1,
                },
                /// Error In Channel 2
                ERR2: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR2_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR2_1 = 0x1,
                },
                /// Error In Channel 3
                ERR3: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR3_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR3_1 = 0x1,
                },
                /// Error In Channel 4
                ERR4: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR4_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR4_1 = 0x1,
                },
                /// Error In Channel 5
                ERR5: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR5_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR5_1 = 0x1,
                },
                /// Error In Channel 6
                ERR6: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR6_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR6_1 = 0x1,
                },
                /// Error In Channel 7
                ERR7: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR7_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR7_1 = 0x1,
                },
                /// Error In Channel 8
                ERR8: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR8_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR8_1 = 0x1,
                },
                /// Error In Channel 9
                ERR9: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR9_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR9_1 = 0x1,
                },
                /// Error In Channel 10
                ERR10: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR10_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR10_1 = 0x1,
                },
                /// Error In Channel 11
                ERR11: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR11_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR11_1 = 0x1,
                },
                /// Error In Channel 12
                ERR12: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR12_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR12_1 = 0x1,
                },
                /// Error In Channel 13
                ERR13: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR13_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR13_1 = 0x1,
                },
                /// Error In Channel 14
                ERR14: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR14_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR14_1 = 0x1,
                },
                /// Error In Channel 15
                ERR15: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR15_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR15_1 = 0x1,
                },
                /// Error In Channel 16
                ERR16: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR16_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR16_1 = 0x1,
                },
                /// Error In Channel 17
                ERR17: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR17_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR17_1 = 0x1,
                },
                /// Error In Channel 18
                ERR18: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR18_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR18_1 = 0x1,
                },
                /// Error In Channel 19
                ERR19: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR19_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR19_1 = 0x1,
                },
                /// Error In Channel 20
                ERR20: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR20_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR20_1 = 0x1,
                },
                /// Error In Channel 21
                ERR21: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR21_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR21_1 = 0x1,
                },
                /// Error In Channel 22
                ERR22: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR22_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR22_1 = 0x1,
                },
                /// Error In Channel 23
                ERR23: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR23_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR23_1 = 0x1,
                },
                /// Error In Channel 24
                ERR24: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR24_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR24_1 = 0x1,
                },
                /// Error In Channel 25
                ERR25: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR25_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR25_1 = 0x1,
                },
                /// Error In Channel 26
                ERR26: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR26_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR26_1 = 0x1,
                },
                /// Error In Channel 27
                ERR27: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR27_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR27_1 = 0x1,
                },
                /// Error In Channel 28
                ERR28: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR28_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR28_1 = 0x1,
                },
                /// Error In Channel 29
                ERR29: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR29_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR29_1 = 0x1,
                },
                /// Error In Channel 30
                ERR30: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR30_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR30_1 = 0x1,
                },
                /// Error In Channel 31
                ERR31: enum(u1) {
                    /// An error in this channel has not occurred
                    ERR31_0 = 0x0,
                    /// An error in this channel has occurred
                    ERR31_1 = 0x1,
                },
            }),
            reserved52: [4]u8,
            /// Hardware Request Status Register
            HRS: mmio.Mmio(packed struct(u32) {
                /// Hardware Request Status Channel 0
                HRS0: enum(u1) {
                    /// A hardware service request for channel 0 is not present
                    HRS0_0 = 0x0,
                    /// A hardware service request for channel 0 is present
                    HRS0_1 = 0x1,
                },
                /// Hardware Request Status Channel 1
                HRS1: enum(u1) {
                    /// A hardware service request for channel 1 is not present
                    HRS1_0 = 0x0,
                    /// A hardware service request for channel 1 is present
                    HRS1_1 = 0x1,
                },
                /// Hardware Request Status Channel 2
                HRS2: enum(u1) {
                    /// A hardware service request for channel 2 is not present
                    HRS2_0 = 0x0,
                    /// A hardware service request for channel 2 is present
                    HRS2_1 = 0x1,
                },
                /// Hardware Request Status Channel 3
                HRS3: enum(u1) {
                    /// A hardware service request for channel 3 is not present
                    HRS3_0 = 0x0,
                    /// A hardware service request for channel 3 is present
                    HRS3_1 = 0x1,
                },
                /// Hardware Request Status Channel 4
                HRS4: enum(u1) {
                    /// A hardware service request for channel 4 is not present
                    HRS4_0 = 0x0,
                    /// A hardware service request for channel 4 is present
                    HRS4_1 = 0x1,
                },
                /// Hardware Request Status Channel 5
                HRS5: enum(u1) {
                    /// A hardware service request for channel 5 is not present
                    HRS5_0 = 0x0,
                    /// A hardware service request for channel 5 is present
                    HRS5_1 = 0x1,
                },
                /// Hardware Request Status Channel 6
                HRS6: enum(u1) {
                    /// A hardware service request for channel 6 is not present
                    HRS6_0 = 0x0,
                    /// A hardware service request for channel 6 is present
                    HRS6_1 = 0x1,
                },
                /// Hardware Request Status Channel 7
                HRS7: enum(u1) {
                    /// A hardware service request for channel 7 is not present
                    HRS7_0 = 0x0,
                    /// A hardware service request for channel 7 is present
                    HRS7_1 = 0x1,
                },
                /// Hardware Request Status Channel 8
                HRS8: enum(u1) {
                    /// A hardware service request for channel 8 is not present
                    HRS8_0 = 0x0,
                    /// A hardware service request for channel 8 is present
                    HRS8_1 = 0x1,
                },
                /// Hardware Request Status Channel 9
                HRS9: enum(u1) {
                    /// A hardware service request for channel 9 is not present
                    HRS9_0 = 0x0,
                    /// A hardware service request for channel 9 is present
                    HRS9_1 = 0x1,
                },
                /// Hardware Request Status Channel 10
                HRS10: enum(u1) {
                    /// A hardware service request for channel 10 is not present
                    HRS10_0 = 0x0,
                    /// A hardware service request for channel 10 is present
                    HRS10_1 = 0x1,
                },
                /// Hardware Request Status Channel 11
                HRS11: enum(u1) {
                    /// A hardware service request for channel 11 is not present
                    HRS11_0 = 0x0,
                    /// A hardware service request for channel 11 is present
                    HRS11_1 = 0x1,
                },
                /// Hardware Request Status Channel 12
                HRS12: enum(u1) {
                    /// A hardware service request for channel 12 is not present
                    HRS12_0 = 0x0,
                    /// A hardware service request for channel 12 is present
                    HRS12_1 = 0x1,
                },
                /// Hardware Request Status Channel 13
                HRS13: enum(u1) {
                    /// A hardware service request for channel 13 is not present
                    HRS13_0 = 0x0,
                    /// A hardware service request for channel 13 is present
                    HRS13_1 = 0x1,
                },
                /// Hardware Request Status Channel 14
                HRS14: enum(u1) {
                    /// A hardware service request for channel 14 is not present
                    HRS14_0 = 0x0,
                    /// A hardware service request for channel 14 is present
                    HRS14_1 = 0x1,
                },
                /// Hardware Request Status Channel 15
                HRS15: enum(u1) {
                    /// A hardware service request for channel 15 is not present
                    HRS15_0 = 0x0,
                    /// A hardware service request for channel 15 is present
                    HRS15_1 = 0x1,
                },
                /// Hardware Request Status Channel 16
                HRS16: enum(u1) {
                    /// A hardware service request for channel 16 is not present
                    HRS16_0 = 0x0,
                    /// A hardware service request for channel 16 is present
                    HRS16_1 = 0x1,
                },
                /// Hardware Request Status Channel 17
                HRS17: enum(u1) {
                    /// A hardware service request for channel 17 is not present
                    HRS17_0 = 0x0,
                    /// A hardware service request for channel 17 is present
                    HRS17_1 = 0x1,
                },
                /// Hardware Request Status Channel 18
                HRS18: enum(u1) {
                    /// A hardware service request for channel 18 is not present
                    HRS18_0 = 0x0,
                    /// A hardware service request for channel 18 is present
                    HRS18_1 = 0x1,
                },
                /// Hardware Request Status Channel 19
                HRS19: enum(u1) {
                    /// A hardware service request for channel 19 is not present
                    HRS19_0 = 0x0,
                    /// A hardware service request for channel 19 is present
                    HRS19_1 = 0x1,
                },
                /// Hardware Request Status Channel 20
                HRS20: enum(u1) {
                    /// A hardware service request for channel 20 is not present
                    HRS20_0 = 0x0,
                    /// A hardware service request for channel 20 is present
                    HRS20_1 = 0x1,
                },
                /// Hardware Request Status Channel 21
                HRS21: enum(u1) {
                    /// A hardware service request for channel 21 is not present
                    HRS21_0 = 0x0,
                    /// A hardware service request for channel 21 is present
                    HRS21_1 = 0x1,
                },
                /// Hardware Request Status Channel 22
                HRS22: enum(u1) {
                    /// A hardware service request for channel 22 is not present
                    HRS22_0 = 0x0,
                    /// A hardware service request for channel 22 is present
                    HRS22_1 = 0x1,
                },
                /// Hardware Request Status Channel 23
                HRS23: enum(u1) {
                    /// A hardware service request for channel 23 is not present
                    HRS23_0 = 0x0,
                    /// A hardware service request for channel 23 is present
                    HRS23_1 = 0x1,
                },
                /// Hardware Request Status Channel 24
                HRS24: enum(u1) {
                    /// A hardware service request for channel 24 is not present
                    HRS24_0 = 0x0,
                    /// A hardware service request for channel 24 is present
                    HRS24_1 = 0x1,
                },
                /// Hardware Request Status Channel 25
                HRS25: enum(u1) {
                    /// A hardware service request for channel 25 is not present
                    HRS25_0 = 0x0,
                    /// A hardware service request for channel 25 is present
                    HRS25_1 = 0x1,
                },
                /// Hardware Request Status Channel 26
                HRS26: enum(u1) {
                    /// A hardware service request for channel 26 is not present
                    HRS26_0 = 0x0,
                    /// A hardware service request for channel 26 is present
                    HRS26_1 = 0x1,
                },
                /// Hardware Request Status Channel 27
                HRS27: enum(u1) {
                    /// A hardware service request for channel 27 is not present
                    HRS27_0 = 0x0,
                    /// A hardware service request for channel 27 is present
                    HRS27_1 = 0x1,
                },
                /// Hardware Request Status Channel 28
                HRS28: enum(u1) {
                    /// A hardware service request for channel 28 is not present
                    HRS28_0 = 0x0,
                    /// A hardware service request for channel 28 is present
                    HRS28_1 = 0x1,
                },
                /// Hardware Request Status Channel 29
                HRS29: enum(u1) {
                    /// A hardware service request for channel 29 is not preset
                    HRS29_0 = 0x0,
                    /// A hardware service request for channel 29 is present
                    HRS29_1 = 0x1,
                },
                /// Hardware Request Status Channel 30
                HRS30: enum(u1) {
                    /// A hardware service request for channel 30 is not present
                    HRS30_0 = 0x0,
                    /// A hardware service request for channel 30 is present
                    HRS30_1 = 0x1,
                },
                /// Hardware Request Status Channel 31
                HRS31: enum(u1) {
                    /// A hardware service request for channel 31 is not present
                    HRS31_0 = 0x0,
                    /// A hardware service request for channel 31 is present
                    HRS31_1 = 0x1,
                },
            }),
            reserved68: [12]u8,
            /// Enable Asynchronous Request in Stop Register
            EARS: mmio.Mmio(packed struct(u32) {
                /// Enable asynchronous DMA request in stop mode for channel 0.
                EDREQ_0: enum(u1) {
                    /// Disable asynchronous DMA request for channel 0.
                    EDREQ_0_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 0.
                    EDREQ_0_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 1.
                EDREQ_1: enum(u1) {
                    /// Disable asynchronous DMA request for channel 1
                    EDREQ_1_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 1.
                    EDREQ_1_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 2.
                EDREQ_2: enum(u1) {
                    /// Disable asynchronous DMA request for channel 2.
                    EDREQ_2_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 2.
                    EDREQ_2_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 3.
                EDREQ_3: enum(u1) {
                    /// Disable asynchronous DMA request for channel 3.
                    EDREQ_3_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 3.
                    EDREQ_3_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 4
                EDREQ_4: enum(u1) {
                    /// Disable asynchronous DMA request for channel 4.
                    EDREQ_4_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 4.
                    EDREQ_4_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 5
                EDREQ_5: enum(u1) {
                    /// Disable asynchronous DMA request for channel 5.
                    EDREQ_5_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 5.
                    EDREQ_5_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 6
                EDREQ_6: enum(u1) {
                    /// Disable asynchronous DMA request for channel 6.
                    EDREQ_6_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 6.
                    EDREQ_6_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 7
                EDREQ_7: enum(u1) {
                    /// Disable asynchronous DMA request for channel 7.
                    EDREQ_7_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 7.
                    EDREQ_7_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 8
                EDREQ_8: enum(u1) {
                    /// Disable asynchronous DMA request for channel 8.
                    EDREQ_8_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 8.
                    EDREQ_8_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 9
                EDREQ_9: enum(u1) {
                    /// Disable asynchronous DMA request for channel 9.
                    EDREQ_9_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 9.
                    EDREQ_9_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 10
                EDREQ_10: enum(u1) {
                    /// Disable asynchronous DMA request for channel 10.
                    EDREQ_10_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 10.
                    EDREQ_10_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 11
                EDREQ_11: enum(u1) {
                    /// Disable asynchronous DMA request for channel 11.
                    EDREQ_11_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 11.
                    EDREQ_11_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 12
                EDREQ_12: enum(u1) {
                    /// Disable asynchronous DMA request for channel 12.
                    EDREQ_12_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 12.
                    EDREQ_12_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 13
                EDREQ_13: enum(u1) {
                    /// Disable asynchronous DMA request for channel 13.
                    EDREQ_13_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 13.
                    EDREQ_13_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 14
                EDREQ_14: enum(u1) {
                    /// Disable asynchronous DMA request for channel 14.
                    EDREQ_14_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 14.
                    EDREQ_14_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 15
                EDREQ_15: enum(u1) {
                    /// Disable asynchronous DMA request for channel 15.
                    EDREQ_15_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 15.
                    EDREQ_15_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 16
                EDREQ_16: enum(u1) {
                    /// Disable asynchronous DMA request for channel 16
                    EDREQ_16_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 16
                    EDREQ_16_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 17
                EDREQ_17: enum(u1) {
                    /// Disable asynchronous DMA request for channel 17
                    EDREQ_17_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 17
                    EDREQ_17_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 18
                EDREQ_18: enum(u1) {
                    /// Disable asynchronous DMA request for channel 18
                    EDREQ_18_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 18
                    EDREQ_18_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 19
                EDREQ_19: enum(u1) {
                    /// Disable asynchronous DMA request for channel 19
                    EDREQ_19_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 19
                    EDREQ_19_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 20
                EDREQ_20: enum(u1) {
                    /// Disable asynchronous DMA request for channel 20
                    EDREQ_20_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 20
                    EDREQ_20_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 21
                EDREQ_21: enum(u1) {
                    /// Disable asynchronous DMA request for channel 21
                    EDREQ_21_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 21
                    EDREQ_21_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 22
                EDREQ_22: enum(u1) {
                    /// Disable asynchronous DMA request for channel 22
                    EDREQ_22_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 22
                    EDREQ_22_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 23
                EDREQ_23: enum(u1) {
                    /// Disable asynchronous DMA request for channel 23
                    EDREQ_23_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 23
                    EDREQ_23_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 24
                EDREQ_24: enum(u1) {
                    /// Disable asynchronous DMA request for channel 24
                    EDREQ_24_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 24
                    EDREQ_24_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 25
                EDREQ_25: enum(u1) {
                    /// Disable asynchronous DMA request for channel 25
                    EDREQ_25_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 25
                    EDREQ_25_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 26
                EDREQ_26: enum(u1) {
                    /// Disable asynchronous DMA request for channel 26
                    EDREQ_26_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 26
                    EDREQ_26_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 27
                EDREQ_27: enum(u1) {
                    /// Disable asynchronous DMA request for channel 27
                    EDREQ_27_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 27
                    EDREQ_27_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 28
                EDREQ_28: enum(u1) {
                    /// Disable asynchronous DMA request for channel 28
                    EDREQ_28_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 28
                    EDREQ_28_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 29
                EDREQ_29: enum(u1) {
                    /// Disable asynchronous DMA request for channel 29
                    EDREQ_29_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 29
                    EDREQ_29_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 30
                EDREQ_30: enum(u1) {
                    /// Disable asynchronous DMA request for channel 30
                    EDREQ_30_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 30
                    EDREQ_30_1 = 0x1,
                },
                /// Enable asynchronous DMA request in stop mode for channel 31
                EDREQ_31: enum(u1) {
                    /// Disable asynchronous DMA request for channel 31
                    EDREQ_31_0 = 0x0,
                    /// Enable asynchronous DMA request for channel 31
                    EDREQ_31_1 = 0x1,
                },
            }),
            reserved256: [184]u8,
            /// Channel n Priority Register
            DCHPRI3: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI2: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI1: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI0: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI7: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI6: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI5: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI4: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI11: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI10: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI9: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI8: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI15: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI14: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI13: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI12: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI19: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI18: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI17: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI16: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI23: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI22: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI21: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI20: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI27: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI26: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI25: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI24: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI31: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI30: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI29: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            /// Channel n Priority Register
            DCHPRI28: mmio.Mmio(packed struct(u8) {
                /// Channel n Arbitration Priority
                CHPRI: u4,
                /// Channel n Current Group Priority
                GRPPRI: u2,
                /// Disable Preempt Ability. This field resets to 0.
                DPA: enum(u1) {
                    /// Channel n can suspend a lower priority channel.
                    DPA_0 = 0x0,
                    /// Channel n cannot suspend any channel, regardless of channel priority.
                    DPA_1 = 0x1,
                },
                /// Enable Channel Preemption. This field resets to 0.
                ECP: enum(u1) {
                    /// Channel n cannot be suspended by a higher priority channel's service request.
                    ECP_0 = 0x0,
                    /// Channel n can be temporarily suspended by the service request of a higher priority channel.
                    ECP_1 = 0x1,
                },
            }),
            reserved4096: [3808]u8,
            /// TCD Source Address
            TCD0_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD0_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD0_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD0_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD0_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD0_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD0_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD0_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD0_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD0_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD0_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD1_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD1_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD1_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD1_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD1_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD1_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD1_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD1_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD1_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD1_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD1_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD2_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD2_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD2_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD2_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD2_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD2_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD2_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD2_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD2_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD2_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD2_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD3_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD3_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD3_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD3_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD3_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD3_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD3_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD3_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD3_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD3_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD3_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD4_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD4_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD4_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD4_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD4_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD4_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD4_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD4_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD4_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD4_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD4_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD5_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD5_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD5_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD5_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD5_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD5_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD5_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD5_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD5_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD5_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD5_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD6_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD6_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD6_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD6_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD6_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD6_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD6_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD6_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD6_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD6_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD6_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD7_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD7_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD7_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD7_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD7_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD7_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD7_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD7_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD7_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD7_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD7_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD8_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD8_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD8_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD8_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD8_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD8_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD8_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD8_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD8_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD8_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD8_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD9_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD9_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD9_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD9_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD9_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD9_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD9_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD9_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD9_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD9_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD9_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD10_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD10_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD10_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD10_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD10_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD10_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD10_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD10_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD10_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD10_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD10_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD11_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD11_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD11_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD11_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD11_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD11_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD11_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD11_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD11_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD11_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD11_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD12_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD12_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD12_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD12_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD12_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD12_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD12_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD12_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD12_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD12_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD12_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD13_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD13_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD13_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD13_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD13_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD13_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD13_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD13_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD13_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD13_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD13_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD14_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD14_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD14_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD14_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD14_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD14_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD14_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD14_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD14_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD14_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD14_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD15_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD15_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD15_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD15_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD15_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD15_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD15_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD15_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD15_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD15_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD15_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD16_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD16_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD16_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD16_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD16_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD16_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD16_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD16_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD16_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD16_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD16_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD17_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD17_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD17_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD17_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD17_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD17_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD17_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD17_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD17_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD17_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD17_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD18_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD18_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD18_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD18_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD18_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD18_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD18_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD18_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD18_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD18_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD18_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD19_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD19_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD19_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD19_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD19_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD19_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD19_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD19_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD19_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD19_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD19_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD20_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD20_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD20_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD20_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD20_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD20_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD20_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD20_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD20_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD20_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD20_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD21_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD21_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD21_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD21_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD21_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD21_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD21_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD21_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD21_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD21_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD21_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD22_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD22_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD22_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD22_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD22_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD22_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD22_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD22_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD22_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD22_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD22_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD23_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD23_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD23_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD23_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD23_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD23_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD23_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD23_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD23_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD23_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD23_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD24_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD24_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD24_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD24_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD24_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD24_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD24_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD24_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD24_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD24_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD24_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD25_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD25_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD25_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD25_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD25_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD25_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD25_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD25_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD25_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD25_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD25_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD26_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD26_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD26_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD26_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD26_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD26_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD26_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD26_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD26_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD26_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD26_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD27_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD27_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD27_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD27_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD27_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD27_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD27_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD27_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD27_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD27_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD27_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD28_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD28_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD28_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD28_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD28_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD28_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD28_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD28_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD28_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD28_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD28_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD29_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD29_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD29_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD29_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD29_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD29_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD29_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD29_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD29_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD29_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD29_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD30_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD30_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD30_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD30_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD30_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD30_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD30_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD30_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD30_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD30_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD30_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Source Address
            TCD31_SADDR: mmio.Mmio(packed struct(u32) {
                /// Source Address
                SADDR: u32,
            }),
            /// TCD Signed Source Address Offset
            TCD31_SOFF: mmio.Mmio(packed struct(u16) {
                /// Source address signed offset
                SOFF: u16,
            }),
            /// TCD Transfer Attributes
            TCD31_ATTR: mmio.Mmio(packed struct(u16) {
                /// Destination data transfer size
                DSIZE: u3,
                /// Destination Address Modulo
                DMOD: u5,
                /// Source data transfer size
                SSIZE: enum(u3) {
                    /// 8-bit
                    SSIZE_0 = 0x0,
                    /// 16-bit
                    SSIZE_1 = 0x1,
                    /// 32-bit
                    SSIZE_2 = 0x2,
                    /// 64-bit
                    SSIZE_3 = 0x3,
                    /// 32-byte burst (4 beats of 64 bits)
                    SSIZE_5 = 0x5,
                    _,
                },
                /// Source Address Modulo
                SMOD: enum(u5) {
                    /// Source address modulo feature is disabled
                    SMOD_0 = 0x0,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_1 = 0x1,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_2 = 0x2,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_3 = 0x3,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_4 = 0x4,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_5 = 0x5,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_6 = 0x6,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_7 = 0x7,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_8 = 0x8,
                    /// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
                    SMOD_9 = 0x9,
                    _,
                },
            }),
            /// TCD Minor Byte Count (Minor Loop Mapping Disabled)
            TCD31_NBYTES_MLNO: mmio.Mmio(packed struct(u32) {
                /// Minor Byte Transfer Count
                NBYTES: u32,
            }),
            /// TCD Last Source Address Adjustment
            TCD31_SLAST: mmio.Mmio(packed struct(u32) {
                /// Last Source Address Adjustment
                SLAST: u32,
            }),
            /// TCD Destination Address
            TCD31_DADDR: mmio.Mmio(packed struct(u32) {
                /// Destination Address
                DADDR: u32,
            }),
            /// TCD Signed Destination Address Offset
            TCD31_DOFF: mmio.Mmio(packed struct(u16) {
                /// Destination Address Signed Offset
                DOFF: u16,
            }),
            /// TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD31_CITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Current Major Iteration Count
                CITER: u15,
                /// Enable channel-to-channel linking on minor-loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
            /// TCD Last Destination Address Adjustment/Scatter Gather Address
            TCD31_DLASTSGA: mmio.Mmio(packed struct(u32) {
                /// DLASTSGA
                DLASTSGA: u32,
            }),
            /// TCD Control and Status
            TCD31_CSR: mmio.Mmio(packed struct(u16) {
                /// Channel Start
                START: enum(u1) {
                    /// The channel is not explicitly started.
                    START_0 = 0x0,
                    /// The channel is explicitly started via a software initiated service request.
                    START_1 = 0x1,
                },
                /// Enable an interrupt when major iteration count completes.
                INTMAJOR: enum(u1) {
                    /// The end-of-major loop interrupt is disabled.
                    INTMAJOR_0 = 0x0,
                    /// The end-of-major loop interrupt is enabled.
                    INTMAJOR_1 = 0x1,
                },
                /// Enable an interrupt when major counter is half complete.
                INTHALF: enum(u1) {
                    /// The half-point interrupt is disabled.
                    INTHALF_0 = 0x0,
                    /// The half-point interrupt is enabled.
                    INTHALF_1 = 0x1,
                },
                /// Disable Request
                DREQ: enum(u1) {
                    /// The channel's ERQ bit is not affected.
                    DREQ_0 = 0x0,
                    /// The channel's ERQ bit is cleared when the major loop is complete.
                    DREQ_1 = 0x1,
                },
                /// Enable Scatter/Gather Processing
                ESG: enum(u1) {
                    /// The current channel's TCD is normal format.
                    ESG_0 = 0x0,
                    /// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
                    ESG_1 = 0x1,
                },
                /// Enable channel-to-channel linking on major loop complete
                MAJORELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled.
                    MAJORELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled.
                    MAJORELINK_1 = 0x1,
                },
                /// Channel Active
                ACTIVE: u1,
                /// Channel Done
                DONE: u1,
                /// Major Loop Link Channel Number
                MAJORLINKCH: u5,
                reserved14: u1 = 0,
                /// Bandwidth Control
                BWC: enum(u2) {
                    /// No eDMA engine stalls.
                    BWC_0 = 0x0,
                    /// eDMA engine stalls for 4 cycles after each R/W.
                    BWC_2 = 0x2,
                    /// eDMA engine stalls for 8 cycles after each R/W.
                    BWC_3 = 0x3,
                    _,
                },
            }),
            /// TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
            TCD31_BITER_ELINKNO: mmio.Mmio(packed struct(u16) {
                /// Starting Major Iteration Count
                BITER: u15,
                /// Enables channel-to-channel linking on minor loop complete
                ELINK: enum(u1) {
                    /// The channel-to-channel linking is disabled
                    ELINK_0 = 0x0,
                    /// The channel-to-channel linking is enabled
                    ELINK_1 = 0x1,
                },
            }),
        };

        /// DMA_CH_MUX
        pub const DMAMUX = extern struct {
            /// Channel 0 Configuration Register
            CHCFG: [32]mmio.Mmio(packed struct(u32) {
                /// DMA Channel Source (Slot Number)
                SOURCE: u7,
                reserved29: u22 = 0,
                /// DMA Channel Always Enable
                A_ON: enum(u1) {
                    /// DMA Channel Always ON function is disabled
                    A_ON_0 = 0x0,
                    /// DMA Channel Always ON function is enabled
                    A_ON_1 = 0x1,
                },
                /// DMA Channel Trigger Enable
                TRIG: enum(u1) {
                    /// Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
                    TRIG_0 = 0x0,
                    /// Triggering is enabled. If triggering is enabled and ENBL is set, the DMA_CH_MUX is in Periodic Trigger mode.
                    TRIG_1 = 0x1,
                },
                /// DMA Mux Channel Enable
                ENBL: enum(u1) {
                    /// DMA Mux channel is disabled
                    ENBL_0 = 0x0,
                    /// DMA Mux channel is enabled
                    ENBL_1 = 0x1,
                },
            }),
        };

        /// Quadrature Decoder
        pub const ENC1 = extern struct {
            /// Control Register
            CTRL: mmio.Mmio(packed struct(u16) {
                /// Compare Interrupt Enable
                CMPIE: enum(u1) {
                    /// Compare interrupt is disabled
                    CMPIE_0 = 0x0,
                    /// Compare interrupt is enabled
                    CMPIE_1 = 0x1,
                },
                /// Compare Interrupt Request
                CMPIRQ: enum(u1) {
                    /// No match has occurred
                    CMPIRQ_0 = 0x0,
                    /// COMP match has occurred
                    CMPIRQ_1 = 0x1,
                },
                /// Watchdog Enable
                WDE: enum(u1) {
                    /// Watchdog timer is disabled
                    WDE_0 = 0x0,
                    /// Watchdog timer is enabled
                    WDE_1 = 0x1,
                },
                /// Watchdog Timeout Interrupt Enable
                DIE: enum(u1) {
                    /// Watchdog timer interrupt is disabled
                    DIE_0 = 0x0,
                    /// Watchdog timer interrupt is enabled
                    DIE_1 = 0x1,
                },
                /// Watchdog Timeout Interrupt Request
                DIRQ: enum(u1) {
                    /// No interrupt has occurred
                    DIRQ_0 = 0x0,
                    /// Watchdog timeout interrupt has occurred
                    DIRQ_1 = 0x1,
                },
                /// Use Negative Edge of INDEX Pulse
                XNE: enum(u1) {
                    /// Use positive transition edge of INDEX pulse
                    XNE_0 = 0x0,
                    /// Use negative transition edge of INDEX pulse
                    XNE_1 = 0x1,
                },
                /// INDEX Triggered Initialization of Position Counters UPOS and LPOS
                XIP: enum(u1) {
                    /// No action
                    XIP_0 = 0x0,
                    /// INDEX pulse initializes the position counter
                    XIP_1 = 0x1,
                },
                /// INDEX Pulse Interrupt Enable
                XIE: enum(u1) {
                    /// INDEX pulse interrupt is disabled
                    XIE_0 = 0x0,
                    /// INDEX pulse interrupt is enabled
                    XIE_1 = 0x1,
                },
                /// INDEX Pulse Interrupt Request
                XIRQ: enum(u1) {
                    /// No interrupt has occurred
                    XIRQ_0 = 0x0,
                    /// INDEX pulse interrupt has occurred
                    XIRQ_1 = 0x1,
                },
                /// Enable Signal Phase Count Mode
                PH1: enum(u1) {
                    /// Use standard quadrature decoder where PHASEA and PHASEB represent a two phase quadrature signal.
                    PH1_0 = 0x0,
                    /// Bypass the quadrature decoder. A positive transition of the PHASEA input generates a count signal. The PHASEB input and the REV bit control the counter direction. If CTRL[REV] = 0, PHASEB = 0, then count up If CTRL[REV] = 0, PHASEB = 1, then count down If CTRL[REV] = 1, PHASEB = 0, then count down If CTRL[REV] = 1, PHASEB = 1, then count up
                    PH1_1 = 0x1,
                },
                /// Enable Reverse Direction Counting
                REV: enum(u1) {
                    /// Count normally
                    REV_0 = 0x0,
                    /// Count in the reverse direction
                    REV_1 = 0x1,
                },
                /// Software Triggered Initialization of Position Counters UPOS and LPOS
                SWIP: enum(u1) {
                    /// No action
                    SWIP_0 = 0x0,
                    /// Initialize position counter
                    SWIP_1 = 0x1,
                },
                /// Use Negative Edge of HOME Input
                HNE: enum(u1) {
                    /// Use positive going edge-to-trigger initialization of position counters UPOS and LPOS
                    HNE_0 = 0x0,
                    /// Use negative going edge-to-trigger initialization of position counters UPOS and LPOS
                    HNE_1 = 0x1,
                },
                /// Enable HOME to Initialize Position Counters UPOS and LPOS
                HIP: enum(u1) {
                    /// No action
                    HIP_0 = 0x0,
                    /// HOME signal initializes the position counter
                    HIP_1 = 0x1,
                },
                /// HOME Interrupt Enable
                HIE: enum(u1) {
                    /// Disable HOME interrupts
                    HIE_0 = 0x0,
                    /// Enable HOME interrupts
                    HIE_1 = 0x1,
                },
                /// HOME Signal Transition Interrupt Request
                HIRQ: enum(u1) {
                    /// No interrupt
                    HIRQ_0 = 0x0,
                    /// HOME signal transition interrupt request
                    HIRQ_1 = 0x1,
                },
            }),
            /// Input Filter Register
            FILT: mmio.Mmio(packed struct(u16) {
                /// Input Filter Sample Period
                FILT_PER: u8,
                /// Input Filter Sample Count
                FILT_CNT: u3,
                padding: u5 = 0,
            }),
            /// Watchdog Timeout Register
            WTR: mmio.Mmio(packed struct(u16) {
                /// WDOG[15:0] is a binary representation of the number of clock cycles plus one that the watchdog timer counts before timing out and optionally generating an interrupt
                WDOG: u16,
            }),
            /// Position Difference Counter Register
            POSD: mmio.Mmio(packed struct(u16) {
                /// This read/write register contains the position change in value occurring between each read of the position register
                POSD: u16,
            }),
            /// Position Difference Hold Register
            POSDH: mmio.Mmio(packed struct(u16) {
                /// This read-only register contains a snapshot of the value of the POSD register
                POSDH: u16,
            }),
            /// Revolution Counter Register
            REV: mmio.Mmio(packed struct(u16) {
                /// This read/write register contains the current value of the revolution counter.
                REV: u16,
            }),
            /// Revolution Hold Register
            REVH: mmio.Mmio(packed struct(u16) {
                /// This read-only register contains a snapshot of the value of the REV register.
                REVH: u16,
            }),
            /// Upper Position Counter Register
            UPOS: mmio.Mmio(packed struct(u16) {
                /// This read/write register contains the upper (most significant) half of the position counter
                POS: u16,
            }),
            /// Lower Position Counter Register
            LPOS: mmio.Mmio(packed struct(u16) {
                /// This read/write register contains the lower (least significant) half of the position counter
                POS: u16,
            }),
            /// Upper Position Hold Register
            UPOSH: mmio.Mmio(packed struct(u16) {
                /// This read-only register contains a snapshot of the UPOS register.
                POSH: u16,
            }),
            /// Lower Position Hold Register
            LPOSH: mmio.Mmio(packed struct(u16) {
                /// This read-only register contains a snapshot of the LPOS register.
                POSH: u16,
            }),
            /// Upper Initialization Register
            UINIT: mmio.Mmio(packed struct(u16) {
                /// This read/write register contains the value to be used to initialize the upper half of the position counter (UPOS)
                INIT: u16,
            }),
            /// Lower Initialization Register
            LINIT: mmio.Mmio(packed struct(u16) {
                /// This read/write register contains the value to be used to initialize the lower half of the position counter (LPOS)
                INIT: u16,
            }),
            /// Input Monitor Register
            IMR: mmio.Mmio(packed struct(u16) {
                /// This is the raw HOME input.
                HOME: u1,
                /// This is the raw INDEX input.
                INDEX: u1,
                /// This is the raw PHASEB input.
                PHB: u1,
                /// This is the raw PHASEA input.
                PHA: u1,
                /// This is the filtered version of HOME input.
                FHOM: u1,
                /// This is the filtered version of INDEX input.
                FIND: u1,
                /// This is the filtered version of PHASEB input.
                FPHB: u1,
                /// This is the filtered version of PHASEA input.
                FPHA: u1,
                padding: u8 = 0,
            }),
            /// Test Register
            TST: mmio.Mmio(packed struct(u16) {
                /// These bits hold the number of quadrature advances to generate.
                TEST_COUNT: u8,
                /// These bits hold the period of quadrature phase in IPBus clock cycles.
                TEST_PERIOD: u5,
                /// Quadrature Decoder Negative Signal
                QDN: enum(u1) {
                    /// Leaves quadrature decoder signal in a positive direction
                    QDN_0 = 0x0,
                    /// Generates a negative quadrature decoder signal
                    QDN_1 = 0x1,
                },
                /// Test Counter Enable
                TCE: enum(u1) {
                    /// Test count is not enabled
                    TCE_0 = 0x0,
                    /// Test count is enabled
                    TCE_1 = 0x1,
                },
                /// Test Mode Enable
                TEN: enum(u1) {
                    /// Test module is not enabled
                    TEN_0 = 0x0,
                    /// Test module is enabled
                    TEN_1 = 0x1,
                },
            }),
            /// Control 2 Register
            CTRL2: mmio.Mmio(packed struct(u16) {
                /// Update Hold Registers
                UPDHLD: enum(u1) {
                    /// Disable updates of hold registers on rising edge of TRIGGER
                    UPDHLD_0 = 0x0,
                    /// Enable updates of hold registers on rising edge of TRIGGER
                    UPDHLD_1 = 0x1,
                },
                /// Update Position Registers
                UPDPOS: enum(u1) {
                    /// No action for POSD, REV, UPOS and LPOS on rising edge of TRIGGER
                    UPDPOS_0 = 0x0,
                    /// Clear POSD, REV, UPOS and LPOS on rising edge of TRIGGER
                    UPDPOS_1 = 0x1,
                },
                /// Enable Modulo Counting
                MOD: enum(u1) {
                    /// Disable modulo counting
                    MOD_0 = 0x0,
                    /// Enable modulo counting
                    MOD_1 = 0x1,
                },
                /// Count Direction Flag
                DIR: enum(u1) {
                    /// Last count was in the down direction
                    DIR_0 = 0x0,
                    /// Last count was in the up direction
                    DIR_1 = 0x1,
                },
                /// Roll-under Interrupt Enable
                RUIE: enum(u1) {
                    /// Roll-under interrupt is disabled
                    RUIE_0 = 0x0,
                    /// Roll-under interrupt is enabled
                    RUIE_1 = 0x1,
                },
                /// Roll-under Interrupt Request
                RUIRQ: enum(u1) {
                    /// No roll-under has occurred
                    RUIRQ_0 = 0x0,
                    /// Roll-under has occurred
                    RUIRQ_1 = 0x1,
                },
                /// Roll-over Interrupt Enable
                ROIE: enum(u1) {
                    /// Roll-over interrupt is disabled
                    ROIE_0 = 0x0,
                    /// Roll-over interrupt is enabled
                    ROIE_1 = 0x1,
                },
                /// Roll-over Interrupt Request
                ROIRQ: enum(u1) {
                    /// No roll-over has occurred
                    ROIRQ_0 = 0x0,
                    /// Roll-over has occurred
                    ROIRQ_1 = 0x1,
                },
                /// Revolution Counter Modulus Enable
                REVMOD: enum(u1) {
                    /// Use INDEX pulse to increment/decrement revolution counter (REV).
                    REVMOD_0 = 0x0,
                    /// Use modulus counting roll-over/under to increment/decrement revolution counter (REV).
                    REVMOD_1 = 0x1,
                },
                /// Output Control
                OUTCTL: enum(u1) {
                    /// POSMATCH pulses when a match occurs between the position counters (POS) and the compare value (COMP).
                    OUTCTL_0 = 0x0,
                    /// POSMATCH pulses when the UPOS, LPOS, REV, or POSD registers are read.
                    OUTCTL_1 = 0x1,
                },
                /// Simultaneous PHASEA and PHASEB Change Interrupt Enable
                SABIE: enum(u1) {
                    /// Simultaneous PHASEA and PHASEB change interrupt disabled.
                    SABIE_0 = 0x0,
                    /// Simultaneous PHASEA and PHASEB change interrupt enabled.
                    SABIE_1 = 0x1,
                },
                /// Simultaneous PHASEA and PHASEB Change Interrupt Request
                SABIRQ: enum(u1) {
                    /// No simultaneous change of PHASEA and PHASEB has occurred.
                    SABIRQ_0 = 0x0,
                    /// A simultaneous change of PHASEA and PHASEB has occurred.
                    SABIRQ_1 = 0x1,
                },
                padding: u4 = 0,
            }),
            /// Upper Modulus Register
            UMOD: mmio.Mmio(packed struct(u16) {
                /// This read/write register contains the upper (most significant) half of the modulus register
                MOD: u16,
            }),
            /// Lower Modulus Register
            LMOD: mmio.Mmio(packed struct(u16) {
                /// This read/write register contains the lower (least significant) half of the modulus register
                MOD: u16,
            }),
            /// Upper Position Compare Register
            UCOMP: mmio.Mmio(packed struct(u16) {
                /// This read/write register contains the upper (most significant) half of the position compare register
                COMP: u16,
            }),
            /// Lower Position Compare Register
            LCOMP: mmio.Mmio(packed struct(u16) {
                /// This read/write register contains the lower (least significant) half of the position compare register
                COMP: u16,
            }),
        };

        /// Ethernet MAC-NET Core
        pub const ENET = extern struct {
            reserved4: [4]u8,
            /// Interrupt Event Register
            EIR: mmio.Mmio(packed struct(u32) {
                reserved15: u15 = 0,
                /// Timestamp Timer
                TS_TIMER: u1,
                /// Transmit Timestamp Available
                TS_AVAIL: u1,
                /// Node Wakeup Request Indication
                WAKEUP: u1,
                /// Payload Receive Error
                PLR: u1,
                /// Transmit FIFO Underrun
                UN: u1,
                /// Collision Retry Limit
                RL: u1,
                /// Late Collision
                LC: u1,
                /// Ethernet Bus Error
                EBERR: u1,
                /// MII Interrupt.
                MII: u1,
                /// Receive Buffer Interrupt
                RXB: u1,
                /// Receive Frame Interrupt
                RXF: u1,
                /// Transmit Buffer Interrupt
                TXB: u1,
                /// Transmit Frame Interrupt
                TXF: u1,
                /// Graceful Stop Complete
                GRA: u1,
                /// Babbling Transmit Error
                BABT: u1,
                /// Babbling Receive Error
                BABR: u1,
                padding: u1 = 0,
            }),
            /// Interrupt Mask Register
            EIMR: mmio.Mmio(packed struct(u32) {
                reserved15: u15 = 0,
                /// TS_TIMER Interrupt Mask
                TS_TIMER: u1,
                /// TS_AVAIL Interrupt Mask
                TS_AVAIL: u1,
                /// WAKEUP Interrupt Mask
                WAKEUP: u1,
                /// PLR Interrupt Mask
                PLR: u1,
                /// UN Interrupt Mask
                UN: u1,
                /// RL Interrupt Mask
                RL: u1,
                /// LC Interrupt Mask
                LC: u1,
                /// EBERR Interrupt Mask
                EBERR: u1,
                /// MII Interrupt Mask
                MII: u1,
                /// RXB Interrupt Mask
                RXB: u1,
                /// RXF Interrupt Mask
                RXF: u1,
                /// TXB Interrupt Mask
                TXB: enum(u1) {
                    /// The corresponding interrupt source is masked.
                    TXB_0 = 0x0,
                    /// The corresponding interrupt source is not masked.
                    TXB_1 = 0x1,
                },
                /// TXF Interrupt Mask
                TXF: enum(u1) {
                    /// The corresponding interrupt source is masked.
                    TXF_0 = 0x0,
                    /// The corresponding interrupt source is not masked.
                    TXF_1 = 0x1,
                },
                /// GRA Interrupt Mask
                GRA: enum(u1) {
                    /// The corresponding interrupt source is masked.
                    GRA_0 = 0x0,
                    /// The corresponding interrupt source is not masked.
                    GRA_1 = 0x1,
                },
                /// BABT Interrupt Mask
                BABT: enum(u1) {
                    /// The corresponding interrupt source is masked.
                    BABT_0 = 0x0,
                    /// The corresponding interrupt source is not masked.
                    BABT_1 = 0x1,
                },
                /// BABR Interrupt Mask
                BABR: enum(u1) {
                    /// The corresponding interrupt source is masked.
                    BABR_0 = 0x0,
                    /// The corresponding interrupt source is not masked.
                    BABR_1 = 0x1,
                },
                padding: u1 = 0,
            }),
            reserved16: [4]u8,
            /// Receive Descriptor Active Register
            RDAR: mmio.Mmio(packed struct(u32) {
                reserved24: u24 = 0,
                /// Receive Descriptor Active
                RDAR: u1,
                padding: u7 = 0,
            }),
            /// Transmit Descriptor Active Register
            TDAR: mmio.Mmio(packed struct(u32) {
                reserved24: u24 = 0,
                /// Transmit Descriptor Active
                TDAR: u1,
                padding: u7 = 0,
            }),
            reserved36: [12]u8,
            /// Ethernet Control Register
            ECR: mmio.Mmio(packed struct(u32) {
                /// Ethernet MAC Reset
                RESET: u1,
                /// Ethernet Enable
                ETHEREN: enum(u1) {
                    /// Reception immediately stops and transmission stops after a bad CRC is appended to any currently transmitted frame.
                    ETHEREN_0 = 0x0,
                    /// MAC is enabled, and reception and transmission are possible.
                    ETHEREN_1 = 0x1,
                },
                /// Magic Packet Detection Enable
                MAGICEN: enum(u1) {
                    /// Magic detection logic disabled.
                    MAGICEN_0 = 0x0,
                    /// The MAC core detects magic packets and asserts EIR[WAKEUP] when a frame is detected.
                    MAGICEN_1 = 0x1,
                },
                /// Sleep Mode Enable
                SLEEP: enum(u1) {
                    /// Normal operating mode.
                    SLEEP_0 = 0x0,
                    /// Sleep mode.
                    SLEEP_1 = 0x1,
                },
                /// EN1588 Enable
                EN1588: enum(u1) {
                    /// Legacy FEC buffer descriptors and functions enabled.
                    EN1588_0 = 0x0,
                    /// Enhanced frame time-stamping functions enabled.
                    EN1588_1 = 0x1,
                },
                reserved6: u1 = 0,
                /// Debug Enable
                DBGEN: enum(u1) {
                    /// MAC continues operation in debug mode.
                    DBGEN_0 = 0x0,
                    /// MAC enters hardware freeze mode when the processor is in debug mode.
                    DBGEN_1 = 0x1,
                },
                reserved8: u1 = 0,
                /// Descriptor Byte Swapping Enable
                DBSWP: enum(u1) {
                    /// The buffer descriptor bytes are not swapped to support big-endian devices.
                    DBSWP_0 = 0x0,
                    /// The buffer descriptor bytes are swapped to support little-endian devices.
                    DBSWP_1 = 0x1,
                },
                padding: u23 = 0,
            }),
            reserved64: [24]u8,
            /// MII Management Frame Register
            MMFR: mmio.Mmio(packed struct(u32) {
                /// Management Frame Data
                DATA: u16,
                /// Turn Around
                TA: u2,
                /// Register Address
                RA: u5,
                /// PHY Address
                PA: u5,
                /// Operation Code
                OP: u2,
                /// Start Of Frame Delimiter
                ST: u2,
            }),
            /// MII Speed Control Register
            MSCR: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// MII Speed
                MII_SPEED: u6,
                /// Disable Preamble
                DIS_PRE: enum(u1) {
                    /// Preamble enabled.
                    DIS_PRE_0 = 0x0,
                    /// Preamble (32 ones) is not prepended to the MII management frame.
                    DIS_PRE_1 = 0x1,
                },
                /// Hold time On MDIO Output
                HOLDTIME: enum(u3) {
                    /// 1 internal module clock cycle
                    HOLDTIME_0 = 0x0,
                    /// 2 internal module clock cycles
                    HOLDTIME_1 = 0x1,
                    /// 3 internal module clock cycles
                    HOLDTIME_2 = 0x2,
                    /// 8 internal module clock cycles
                    HOLDTIME_7 = 0x7,
                    _,
                },
                padding: u21 = 0,
            }),
            reserved100: [28]u8,
            /// MIB Control Register
            MIBC: mmio.Mmio(packed struct(u32) {
                reserved29: u29 = 0,
                /// MIB Clear
                MIB_CLEAR: enum(u1) {
                    /// See note above.
                    MIB_CLEAR_0 = 0x0,
                    /// All statistics counters are reset to 0.
                    MIB_CLEAR_1 = 0x1,
                },
                /// MIB Idle
                MIB_IDLE: enum(u1) {
                    /// The MIB block is updating MIB counters.
                    MIB_IDLE_0 = 0x0,
                    /// The MIB block is not currently updating any MIB counters.
                    MIB_IDLE_1 = 0x1,
                },
                /// Disable MIB Logic
                MIB_DIS: enum(u1) {
                    /// MIB logic is enabled.
                    MIB_DIS_0 = 0x0,
                    /// MIB logic is disabled. The MIB logic halts and does not update any MIB counters.
                    MIB_DIS_1 = 0x1,
                },
            }),
            reserved132: [28]u8,
            /// Receive Control Register
            RCR: mmio.Mmio(packed struct(u32) {
                /// Internal Loopback
                LOOP: enum(u1) {
                    /// Loopback disabled.
                    LOOP_0 = 0x0,
                    /// Transmitted frames are looped back internal to the device and transmit MII output signals are not asserted. DRT must be cleared.
                    LOOP_1 = 0x1,
                },
                /// Disable Receive On Transmit
                DRT: enum(u1) {
                    /// Receive path operates independently of transmit (i.e., full-duplex mode). Can also be used to monitor transmit activity in half-duplex mode.
                    DRT_0 = 0x0,
                    /// Disable reception of frames while transmitting. (Normally used for half-duplex mode.)
                    DRT_1 = 0x1,
                },
                /// Media Independent Interface Mode
                MII_MODE: enum(u1) {
                    /// MII or RMII mode, as indicated by the RMII_MODE field.
                    MII_MODE_1 = 0x1,
                    _,
                },
                /// Promiscuous Mode
                PROM: enum(u1) {
                    /// Disabled.
                    PROM_0 = 0x0,
                    /// Enabled.
                    PROM_1 = 0x1,
                },
                /// Broadcast Frame Reject
                BC_REJ: u1,
                /// Flow Control Enable
                FCE: u1,
                reserved8: u2 = 0,
                /// RMII Mode Enable
                RMII_MODE: enum(u1) {
                    /// MAC configured for MII mode.
                    RMII_MODE_0 = 0x0,
                    /// MAC configured for RMII operation.
                    RMII_MODE_1 = 0x1,
                },
                /// Enables 10-Mbit/s mode of the RMII .
                RMII_10T: enum(u1) {
                    /// 100-Mbit/s operation.
                    RMII_10T_0 = 0x0,
                    /// 10-Mbit/s operation.
                    RMII_10T_1 = 0x1,
                },
                reserved12: u2 = 0,
                /// Enable Frame Padding Remove On Receive
                PADEN: enum(u1) {
                    /// No padding is removed on receive by the MAC.
                    PADEN_0 = 0x0,
                    /// Padding is removed from received frames.
                    PADEN_1 = 0x1,
                },
                /// Terminate/Forward Pause Frames
                PAUFWD: enum(u1) {
                    /// Pause frames are terminated and discarded in the MAC.
                    PAUFWD_0 = 0x0,
                    /// Pause frames are forwarded to the user application.
                    PAUFWD_1 = 0x1,
                },
                /// Terminate/Forward Received CRC
                CRCFWD: enum(u1) {
                    /// The CRC field of received frames is transmitted to the user application.
                    CRCFWD_0 = 0x0,
                    /// The CRC field is stripped from the frame.
                    CRCFWD_1 = 0x1,
                },
                /// MAC Control Frame Enable
                CFEN: enum(u1) {
                    /// MAC control frames with any opcode other than 0x0001 (pause frame) are accepted and forwarded to the client interface.
                    CFEN_0 = 0x0,
                    /// MAC control frames with any opcode other than 0x0001 (pause frame) are silently discarded.
                    CFEN_1 = 0x1,
                },
                /// Maximum Frame Length
                MAX_FL: u14,
                /// Payload Length Check Disable
                NLC: enum(u1) {
                    /// The payload length check is disabled.
                    NLC_0 = 0x0,
                    /// The core checks the frame's payload length with the frame length/type field. Errors are indicated in the EIR[PLR] field.
                    NLC_1 = 0x1,
                },
                /// Graceful Receive Stopped
                GRS: u1,
            }),
            reserved196: [60]u8,
            /// Transmit Control Register
            TCR: mmio.Mmio(packed struct(u32) {
                /// Graceful Transmit Stop
                GTS: u1,
                reserved2: u1 = 0,
                /// Full-Duplex Enable
                FDEN: u1,
                /// Transmit Frame Control Pause
                TFC_PAUSE: enum(u1) {
                    /// No PAUSE frame transmitted.
                    TFC_PAUSE_0 = 0x0,
                    /// The MAC stops transmission of data frames after the current transmission is complete.
                    TFC_PAUSE_1 = 0x1,
                },
                /// Receive Frame Control Pause
                RFC_PAUSE: u1,
                /// Source MAC Address Select On Transmit
                ADDSEL: enum(u3) {
                    /// Node MAC address programmed on PADDR1/2 registers.
                    ADDSEL_0 = 0x0,
                    _,
                },
                /// Set MAC Address On Transmit
                ADDINS: enum(u1) {
                    /// The source MAC address is not modified by the MAC.
                    ADDINS_0 = 0x0,
                    /// The MAC overwrites the source MAC address with the programmed MAC address according to ADDSEL.
                    ADDINS_1 = 0x1,
                },
                /// Forward Frame From Application With CRC
                CRCFWD: enum(u1) {
                    /// TxBD[TC] controls whether the frame has a CRC from the application.
                    CRCFWD_0 = 0x0,
                    /// The transmitter does not append any CRC to transmitted frames, as it is expecting a frame with CRC from the application.
                    CRCFWD_1 = 0x1,
                },
                padding: u22 = 0,
            }),
            reserved228: [28]u8,
            /// Physical Address Lower Register
            PALR: mmio.Mmio(packed struct(u32) {
                /// Pause Address
                PADDR1: u32,
            }),
            /// Physical Address Upper Register
            PAUR: mmio.Mmio(packed struct(u32) {
                /// Type Field In PAUSE Frames
                TYPE: u16,
                /// Bytes 4 (bits 31:24) and 5 (bits 23:16) of the 6-byte individual address used for exact match, and the source address field in PAUSE frames
                PADDR2: u16,
            }),
            /// Opcode/Pause Duration Register
            OPD: mmio.Mmio(packed struct(u32) {
                /// Pause Duration
                PAUSE_DUR: u16,
                /// Opcode Field In PAUSE Frames
                OPCODE: u16,
            }),
            /// Transmit Interrupt Coalescing Register
            TXIC: mmio.Mmio(packed struct(u32) {
                /// Interrupt coalescing timer threshold
                ICTT: u16,
                reserved20: u4 = 0,
                /// Interrupt coalescing frame count threshold
                ICFT: u8,
                reserved30: u2 = 0,
                /// Interrupt Coalescing Timer Clock Source Select
                ICCS: enum(u1) {
                    /// Use MII/GMII TX clocks.
                    ICCS_0 = 0x0,
                    /// Use ENET system clock.
                    ICCS_1 = 0x1,
                },
                /// Interrupt Coalescing Enable
                ICEN: enum(u1) {
                    /// Disable Interrupt coalescing.
                    ICEN_0 = 0x0,
                    /// Enable Interrupt coalescing.
                    ICEN_1 = 0x1,
                },
            }),
            reserved256: [12]u8,
            /// Receive Interrupt Coalescing Register
            RXIC: mmio.Mmio(packed struct(u32) {
                /// Interrupt coalescing timer threshold
                ICTT: u16,
                reserved20: u4 = 0,
                /// Interrupt coalescing frame count threshold
                ICFT: u8,
                reserved30: u2 = 0,
                /// Interrupt Coalescing Timer Clock Source Select
                ICCS: enum(u1) {
                    /// Use MII/GMII TX clocks.
                    ICCS_0 = 0x0,
                    /// Use ENET system clock.
                    ICCS_1 = 0x1,
                },
                /// Interrupt Coalescing Enable
                ICEN: enum(u1) {
                    /// Disable Interrupt coalescing.
                    ICEN_0 = 0x0,
                    /// Enable Interrupt coalescing.
                    ICEN_1 = 0x1,
                },
            }),
            reserved280: [20]u8,
            /// Descriptor Individual Upper Address Register
            IAUR: mmio.Mmio(packed struct(u32) {
                /// Contains the upper 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a unicast address
                IADDR1: u32,
            }),
            /// Descriptor Individual Lower Address Register
            IALR: mmio.Mmio(packed struct(u32) {
                /// Contains the lower 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a unicast address
                IADDR2: u32,
            }),
            /// Descriptor Group Upper Address Register
            GAUR: mmio.Mmio(packed struct(u32) {
                /// Contains the upper 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a multicast address
                GADDR1: u32,
            }),
            /// Descriptor Group Lower Address Register
            GALR: mmio.Mmio(packed struct(u32) {
                /// Contains the lower 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a multicast address
                GADDR2: u32,
            }),
            reserved324: [28]u8,
            /// Transmit FIFO Watermark Register
            TFWR: mmio.Mmio(packed struct(u32) {
                /// Transmit FIFO Write
                TFWR: enum(u6) {
                    /// 64 bytes written.
                    TFWR_0 = 0x0,
                    /// 64 bytes written.
                    TFWR_1 = 0x1,
                    /// 128 bytes written.
                    TFWR_2 = 0x2,
                    /// 192 bytes written.
                    TFWR_3 = 0x3,
                    /// 1984 bytes written.
                    TFWR_31 = 0x1f,
                    _,
                },
                reserved8: u2 = 0,
                /// Store And Forward Enable
                STRFWD: enum(u1) {
                    /// Reset. The transmission start threshold is programmed in TFWR[TFWR].
                    STRFWD_0 = 0x0,
                    /// Enabled.
                    STRFWD_1 = 0x1,
                },
                padding: u23 = 0,
            }),
            reserved384: [56]u8,
            /// Receive Descriptor Ring Start Register
            RDSR: mmio.Mmio(packed struct(u32) {
                reserved3: u3 = 0,
                /// Pointer to the beginning of the receive buffer descriptor queue.
                R_DES_START: u29,
            }),
            /// Transmit Buffer Descriptor Ring Start Register
            TDSR: mmio.Mmio(packed struct(u32) {
                reserved3: u3 = 0,
                /// Pointer to the beginning of the transmit buffer descriptor queue.
                X_DES_START: u29,
            }),
            /// Maximum Receive Buffer Size Register
            MRBR: mmio.Mmio(packed struct(u32) {
                reserved4: u4 = 0,
                /// Receive buffer size in bytes
                R_BUF_SIZE: u10,
                padding: u18 = 0,
            }),
            reserved400: [4]u8,
            /// Receive FIFO Section Full Threshold
            RSFL: mmio.Mmio(packed struct(u32) {
                /// Value Of Receive FIFO Section Full Threshold
                RX_SECTION_FULL: u8,
                padding: u24 = 0,
            }),
            /// Receive FIFO Section Empty Threshold
            RSEM: mmio.Mmio(packed struct(u32) {
                /// Value Of The Receive FIFO Section Empty Threshold
                RX_SECTION_EMPTY: u8,
                reserved16: u8 = 0,
                /// RX Status FIFO Section Empty Threshold
                STAT_SECTION_EMPTY: u5,
                padding: u11 = 0,
            }),
            /// Receive FIFO Almost Empty Threshold
            RAEM: mmio.Mmio(packed struct(u32) {
                /// Value Of The Receive FIFO Almost Empty Threshold
                RX_ALMOST_EMPTY: u8,
                padding: u24 = 0,
            }),
            /// Receive FIFO Almost Full Threshold
            RAFL: mmio.Mmio(packed struct(u32) {
                /// Value Of The Receive FIFO Almost Full Threshold
                RX_ALMOST_FULL: u8,
                padding: u24 = 0,
            }),
            /// Transmit FIFO Section Empty Threshold
            TSEM: mmio.Mmio(packed struct(u32) {
                /// Value Of The Transmit FIFO Section Empty Threshold
                TX_SECTION_EMPTY: u8,
                padding: u24 = 0,
            }),
            /// Transmit FIFO Almost Empty Threshold
            TAEM: mmio.Mmio(packed struct(u32) {
                /// Value of Transmit FIFO Almost Empty Threshold
                TX_ALMOST_EMPTY: u8,
                padding: u24 = 0,
            }),
            /// Transmit FIFO Almost Full Threshold
            TAFL: mmio.Mmio(packed struct(u32) {
                /// Value Of The Transmit FIFO Almost Full Threshold
                TX_ALMOST_FULL: u8,
                padding: u24 = 0,
            }),
            /// Transmit Inter-Packet Gap
            TIPG: mmio.Mmio(packed struct(u32) {
                /// Transmit Inter-Packet Gap
                IPG: u5,
                padding: u27 = 0,
            }),
            /// Frame Truncation Length
            FTRL: mmio.Mmio(packed struct(u32) {
                /// Frame Truncation Length
                TRUNC_FL: u14,
                padding: u18 = 0,
            }),
            reserved448: [12]u8,
            /// Transmit Accelerator Function Configuration
            TACC: mmio.Mmio(packed struct(u32) {
                /// TX FIFO Shift-16
                SHIFT16: enum(u1) {
                    /// Disabled.
                    SHIFT16_0 = 0x0,
                    /// Indicates to the transmit data FIFO that the written frames contain two additional octets before the frame data. This means the actual frame begins at bit 16 of the first word written into the FIFO. This function allows putting the frame payload on a 32-bit boundary in memory, as the 14-byte Ethernet header is extended to a 16-byte header.
                    SHIFT16_1 = 0x1,
                },
                reserved3: u2 = 0,
                /// Enables insertion of IP header checksum.
                IPCHK: enum(u1) {
                    /// Checksum is not inserted.
                    IPCHK_0 = 0x0,
                    /// If an IP frame is transmitted, the checksum is inserted automatically. The IP header checksum field must be cleared. If a non-IP frame is transmitted the frame is not modified.
                    IPCHK_1 = 0x1,
                },
                /// Enables insertion of protocol checksum.
                PROCHK: enum(u1) {
                    /// Checksum not inserted.
                    PROCHK_0 = 0x0,
                    /// If an IP frame with a known protocol is transmitted, the checksum is inserted automatically into the frame. The checksum field must be cleared. The other frames are not modified.
                    PROCHK_1 = 0x1,
                },
                padding: u27 = 0,
            }),
            /// Receive Accelerator Function Configuration
            RACC: mmio.Mmio(packed struct(u32) {
                /// Enable Padding Removal For Short IP Frames
                PADREM: enum(u1) {
                    /// Padding not removed.
                    PADREM_0 = 0x0,
                    /// Any bytes following the IP payload section of the frame are removed from the frame.
                    PADREM_1 = 0x1,
                },
                /// Enable Discard Of Frames With Wrong IPv4 Header Checksum
                IPDIS: enum(u1) {
                    /// Frames with wrong IPv4 header checksum are not discarded.
                    IPDIS_0 = 0x0,
                    /// If an IPv4 frame is received with a mismatching header checksum, the frame is discarded. IPv6 has no header checksum and is not affected by this setting. Discarding is only available when the RX FIFO operates in store and forward mode (RSFL cleared).
                    IPDIS_1 = 0x1,
                },
                /// Enable Discard Of Frames With Wrong Protocol Checksum
                PRODIS: enum(u1) {
                    /// Frames with wrong checksum are not discarded.
                    PRODIS_0 = 0x0,
                    /// If a TCP/IP, UDP/IP, or ICMP/IP frame is received that has a wrong TCP, UDP, or ICMP checksum, the frame is discarded. Discarding is only available when the RX FIFO operates in store and forward mode (RSFL cleared).
                    PRODIS_1 = 0x1,
                },
                reserved6: u3 = 0,
                /// Enable Discard Of Frames With MAC Layer Errors
                LINEDIS: enum(u1) {
                    /// Frames with errors are not discarded.
                    LINEDIS_0 = 0x0,
                    /// Any frame received with a CRC, length, or PHY error is automatically discarded and not forwarded to the user application interface.
                    LINEDIS_1 = 0x1,
                },
                /// RX FIFO Shift-16
                SHIFT16: enum(u1) {
                    /// Disabled.
                    SHIFT16_0 = 0x0,
                    /// Instructs the MAC to write two additional bytes in front of each frame received into the RX FIFO.
                    SHIFT16_1 = 0x1,
                },
                padding: u24 = 0,
            }),
            reserved512: [56]u8,
            /// Reserved Statistic Register
            RMON_T_DROP: u32,
            /// Tx Packet Count Statistic Register
            RMON_T_PACKETS: mmio.Mmio(packed struct(u32) {
                /// Packet count
                TXPKTS: u16,
                padding: u16 = 0,
            }),
            /// Tx Broadcast Packets Statistic Register
            RMON_T_BC_PKT: mmio.Mmio(packed struct(u32) {
                /// Broadcast packets
                TXPKTS: u16,
                padding: u16 = 0,
            }),
            /// Tx Multicast Packets Statistic Register
            RMON_T_MC_PKT: mmio.Mmio(packed struct(u32) {
                /// Multicast packets
                TXPKTS: u16,
                padding: u16 = 0,
            }),
            /// Tx Packets with CRC/Align Error Statistic Register
            RMON_T_CRC_ALIGN: mmio.Mmio(packed struct(u32) {
                /// Packets with CRC/align error
                TXPKTS: u16,
                padding: u16 = 0,
            }),
            /// Tx Packets Less Than Bytes and Good CRC Statistic Register
            RMON_T_UNDERSIZE: mmio.Mmio(packed struct(u32) {
                /// Number of transmit packets less than 64 bytes with good CRC
                TXPKTS: u16,
                padding: u16 = 0,
            }),
            /// Tx Packets GT MAX_FL bytes and Good CRC Statistic Register
            RMON_T_OVERSIZE: mmio.Mmio(packed struct(u32) {
                /// Number of transmit packets greater than MAX_FL bytes with good CRC
                TXPKTS: u16,
                padding: u16 = 0,
            }),
            /// Tx Packets Less Than 64 Bytes and Bad CRC Statistic Register
            RMON_T_FRAG: mmio.Mmio(packed struct(u32) {
                /// Number of packets less than 64 bytes with bad CRC
                TXPKTS: u16,
                padding: u16 = 0,
            }),
            /// Tx Packets Greater Than MAX_FL bytes and Bad CRC Statistic Register
            RMON_T_JAB: mmio.Mmio(packed struct(u32) {
                /// Number of transmit packets greater than MAX_FL bytes and bad CRC
                TXPKTS: u16,
                padding: u16 = 0,
            }),
            /// Tx Collision Count Statistic Register
            RMON_T_COL: mmio.Mmio(packed struct(u32) {
                /// Number of transmit collisions
                TXPKTS: u16,
                padding: u16 = 0,
            }),
            /// Tx 64-Byte Packets Statistic Register
            RMON_T_P64: mmio.Mmio(packed struct(u32) {
                /// Number of 64-byte transmit packets
                TXPKTS: u16,
                padding: u16 = 0,
            }),
            /// Tx 65- to 127-byte Packets Statistic Register
            RMON_T_P65TO127: mmio.Mmio(packed struct(u32) {
                /// Number of 65- to 127-byte transmit packets
                TXPKTS: u16,
                padding: u16 = 0,
            }),
            /// Tx 128- to 255-byte Packets Statistic Register
            RMON_T_P128TO255: mmio.Mmio(packed struct(u32) {
                /// Number of 128- to 255-byte transmit packets
                TXPKTS: u16,
                padding: u16 = 0,
            }),
            /// Tx 256- to 511-byte Packets Statistic Register
            RMON_T_P256TO511: mmio.Mmio(packed struct(u32) {
                /// Number of 256- to 511-byte transmit packets
                TXPKTS: u16,
                padding: u16 = 0,
            }),
            /// Tx 512- to 1023-byte Packets Statistic Register
            RMON_T_P512TO1023: mmio.Mmio(packed struct(u32) {
                /// Number of 512- to 1023-byte transmit packets
                TXPKTS: u16,
                padding: u16 = 0,
            }),
            /// Tx 1024- to 2047-byte Packets Statistic Register
            RMON_T_P1024TO2047: mmio.Mmio(packed struct(u32) {
                /// Number of 1024- to 2047-byte transmit packets
                TXPKTS: u16,
                padding: u16 = 0,
            }),
            /// Tx Packets Greater Than 2048 Bytes Statistic Register
            RMON_T_P_GTE2048: mmio.Mmio(packed struct(u32) {
                /// Number of transmit packets greater than 2048 bytes
                TXPKTS: u16,
                padding: u16 = 0,
            }),
            /// Tx Octets Statistic Register
            RMON_T_OCTETS: mmio.Mmio(packed struct(u32) {
                /// Number of transmit octets
                TXOCTS: u32,
            }),
            /// Reserved Statistic Register
            IEEE_T_DROP: u32,
            /// Frames Transmitted OK Statistic Register
            IEEE_T_FRAME_OK: mmio.Mmio(packed struct(u32) {
                /// Number of frames transmitted OK
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Frames Transmitted with Single Collision Statistic Register
            IEEE_T_1COL: mmio.Mmio(packed struct(u32) {
                /// Number of frames transmitted with one collision
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Frames Transmitted with Multiple Collisions Statistic Register
            IEEE_T_MCOL: mmio.Mmio(packed struct(u32) {
                /// Number of frames transmitted with multiple collisions
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Frames Transmitted after Deferral Delay Statistic Register
            IEEE_T_DEF: mmio.Mmio(packed struct(u32) {
                /// Number of frames transmitted with deferral delay
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Frames Transmitted with Late Collision Statistic Register
            IEEE_T_LCOL: mmio.Mmio(packed struct(u32) {
                /// Number of frames transmitted with late collision
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Frames Transmitted with Excessive Collisions Statistic Register
            IEEE_T_EXCOL: mmio.Mmio(packed struct(u32) {
                /// Number of frames transmitted with excessive collisions
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Frames Transmitted with Tx FIFO Underrun Statistic Register
            IEEE_T_MACERR: mmio.Mmio(packed struct(u32) {
                /// Number of frames transmitted with transmit FIFO underrun
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Frames Transmitted with Carrier Sense Error Statistic Register
            IEEE_T_CSERR: mmio.Mmio(packed struct(u32) {
                /// Number of frames transmitted with carrier sense error
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Reserved Statistic Register
            IEEE_T_SQE: mmio.Mmio(packed struct(u32) {
                /// This read-only field is reserved and always has the value 0
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Flow Control Pause Frames Transmitted Statistic Register
            IEEE_T_FDXFC: mmio.Mmio(packed struct(u32) {
                /// Number of flow-control pause frames transmitted
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Octet Count for Frames Transmitted w/o Error Statistic Register
            IEEE_T_OCTETS_OK: mmio.Mmio(packed struct(u32) {
                /// Octet count for frames transmitted without error Counts total octets (includes header and FCS fields).
                COUNT: u32,
            }),
            reserved644: [12]u8,
            /// Rx Packet Count Statistic Register
            RMON_R_PACKETS: mmio.Mmio(packed struct(u32) {
                /// Number of packets received
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Rx Broadcast Packets Statistic Register
            RMON_R_BC_PKT: mmio.Mmio(packed struct(u32) {
                /// Number of receive broadcast packets
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Rx Multicast Packets Statistic Register
            RMON_R_MC_PKT: mmio.Mmio(packed struct(u32) {
                /// Number of receive multicast packets
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Rx Packets with CRC/Align Error Statistic Register
            RMON_R_CRC_ALIGN: mmio.Mmio(packed struct(u32) {
                /// Number of receive packets with CRC or align error
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Rx Packets with Less Than 64 Bytes and Good CRC Statistic Register
            RMON_R_UNDERSIZE: mmio.Mmio(packed struct(u32) {
                /// Number of receive packets with less than 64 bytes and good CRC
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Rx Packets Greater Than MAX_FL and Good CRC Statistic Register
            RMON_R_OVERSIZE: mmio.Mmio(packed struct(u32) {
                /// Number of receive packets greater than MAX_FL and good CRC
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Rx Packets Less Than 64 Bytes and Bad CRC Statistic Register
            RMON_R_FRAG: mmio.Mmio(packed struct(u32) {
                /// Number of receive packets with less than 64 bytes and bad CRC
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Rx Packets Greater Than MAX_FL Bytes and Bad CRC Statistic Register
            RMON_R_JAB: mmio.Mmio(packed struct(u32) {
                /// Number of receive packets greater than MAX_FL and bad CRC
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Reserved Statistic Register
            RMON_R_RESVD_0: u32,
            /// Rx 64-Byte Packets Statistic Register
            RMON_R_P64: mmio.Mmio(packed struct(u32) {
                /// Number of 64-byte receive packets
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Rx 65- to 127-Byte Packets Statistic Register
            RMON_R_P65TO127: mmio.Mmio(packed struct(u32) {
                /// Number of 65- to 127-byte recieve packets
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Rx 128- to 255-Byte Packets Statistic Register
            RMON_R_P128TO255: mmio.Mmio(packed struct(u32) {
                /// Number of 128- to 255-byte recieve packets
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Rx 256- to 511-Byte Packets Statistic Register
            RMON_R_P256TO511: mmio.Mmio(packed struct(u32) {
                /// Number of 256- to 511-byte recieve packets
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Rx 512- to 1023-Byte Packets Statistic Register
            RMON_R_P512TO1023: mmio.Mmio(packed struct(u32) {
                /// Number of 512- to 1023-byte recieve packets
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Rx 1024- to 2047-Byte Packets Statistic Register
            RMON_R_P1024TO2047: mmio.Mmio(packed struct(u32) {
                /// Number of 1024- to 2047-byte recieve packets
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Rx Packets Greater than 2048 Bytes Statistic Register
            RMON_R_P_GTE2048: mmio.Mmio(packed struct(u32) {
                /// Number of greater-than-2048-byte recieve packets
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Rx Octets Statistic Register
            RMON_R_OCTETS: mmio.Mmio(packed struct(u32) {
                /// Number of receive octets
                COUNT: u32,
            }),
            /// Frames not Counted Correctly Statistic Register
            IEEE_R_DROP: mmio.Mmio(packed struct(u32) {
                /// Frame count
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Frames Received OK Statistic Register
            IEEE_R_FRAME_OK: mmio.Mmio(packed struct(u32) {
                /// Number of frames received OK
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Frames Received with CRC Error Statistic Register
            IEEE_R_CRC: mmio.Mmio(packed struct(u32) {
                /// Number of frames received with CRC error
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Frames Received with Alignment Error Statistic Register
            IEEE_R_ALIGN: mmio.Mmio(packed struct(u32) {
                /// Number of frames received with alignment error
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Receive FIFO Overflow Count Statistic Register
            IEEE_R_MACERR: mmio.Mmio(packed struct(u32) {
                /// Receive FIFO overflow count
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Flow Control Pause Frames Received Statistic Register
            IEEE_R_FDXFC: mmio.Mmio(packed struct(u32) {
                /// Number of flow-control pause frames received
                COUNT: u16,
                padding: u16 = 0,
            }),
            /// Octet Count for Frames Received without Error Statistic Register
            IEEE_R_OCTETS_OK: mmio.Mmio(packed struct(u32) {
                /// Number of octets for frames received without error
                COUNT: u32,
            }),
            reserved1024: [284]u8,
            /// Adjustable Timer Control Register
            ATCR: mmio.Mmio(packed struct(u32) {
                /// Enable Timer
                EN: enum(u1) {
                    /// The timer stops at the current value.
                    EN_0 = 0x0,
                    /// The timer starts incrementing.
                    EN_1 = 0x1,
                },
                reserved2: u1 = 0,
                /// Enable One-Shot Offset Event
                OFFEN: enum(u1) {
                    /// Disable.
                    OFFEN_0 = 0x0,
                    /// The timer can be reset to zero when the given offset time is reached (offset event). The field is cleared when the offset event is reached, so no further event occurs until the field is set again. The timer offset value must be set before setting this field.
                    OFFEN_1 = 0x1,
                },
                /// Reset Timer On Offset Event
                OFFRST: enum(u1) {
                    /// The timer is not affected and no action occurs, besides clearing OFFEN, when the offset is reached.
                    OFFRST_0 = 0x0,
                    /// If OFFEN is set, the timer resets to zero when the offset setting is reached. The offset event does not cause a timer interrupt.
                    OFFRST_1 = 0x1,
                },
                /// Enable Periodical Event
                PEREN: enum(u1) {
                    /// Disable.
                    PEREN_0 = 0x0,
                    /// A period event interrupt can be generated (EIR[TS_TIMER]) and the event signal output is asserted when the timer wraps around according to the periodic setting ATPER. The timer period value must be set before setting this bit. Not all devices contain the event signal output. See the chip configuration details.
                    PEREN_1 = 0x1,
                },
                reserved7: u2 = 0,
                /// Enables event signal output assertion on period event
                PINPER: enum(u1) {
                    /// Disable.
                    PINPER_0 = 0x0,
                    /// Enable.
                    PINPER_1 = 0x1,
                },
                reserved9: u1 = 0,
                /// Reset Timer
                RESTART: u1,
                reserved11: u1 = 0,
                /// Capture Timer Value
                CAPTURE: enum(u1) {
                    /// No effect.
                    CAPTURE_0 = 0x0,
                    /// The current time is captured and can be read from the ATVR register.
                    CAPTURE_1 = 0x1,
                },
                reserved13: u1 = 0,
                /// Enable Timer Slave Mode
                SLAVE: enum(u1) {
                    /// The timer is active and all configuration fields in this register are relevant.
                    SLAVE_0 = 0x0,
                    /// The internal timer is disabled and the externally provided timer value is used. All other fields, except CAPTURE, in this register have no effect. CAPTURE can still be used to capture the current timer value.
                    SLAVE_1 = 0x1,
                },
                padding: u18 = 0,
            }),
            /// Timer Value Register
            ATVR: mmio.Mmio(packed struct(u32) {
                /// A write sets the timer
                ATIME: u32,
            }),
            /// Timer Offset Register
            ATOFF: mmio.Mmio(packed struct(u32) {
                /// Offset value for one-shot event generation
                OFFSET: u32,
            }),
            /// Timer Period Register
            ATPER: mmio.Mmio(packed struct(u32) {
                /// Value for generating periodic events
                PERIOD: u32,
            }),
            /// Timer Correction Register
            ATCOR: mmio.Mmio(packed struct(u32) {
                /// Correction Counter Wrap-Around Value
                COR: u31,
                padding: u1 = 0,
            }),
            /// Time-Stamping Clock Period Register
            ATINC: mmio.Mmio(packed struct(u32) {
                /// Clock Period Of The Timestamping Clock (ts_clk) In Nanoseconds
                INC: u7,
                reserved8: u1 = 0,
                /// Correction Increment Value
                INC_CORR: u7,
                padding: u17 = 0,
            }),
            /// Timestamp of Last Transmitted Frame
            ATSTMP: mmio.Mmio(packed struct(u32) {
                /// Timestamp of the last frame transmitted by the core that had TxBD[TS] set
                TIMESTAMP: u32,
            }),
            reserved1540: [488]u8,
            /// Timer Global Status Register
            TGSR: mmio.Mmio(packed struct(u32) {
                /// Copy Of Timer Flag For Channel 0
                TF0: enum(u1) {
                    /// Timer Flag for Channel 0 is clear
                    TF0_0 = 0x0,
                    /// Timer Flag for Channel 0 is set
                    TF0_1 = 0x1,
                },
                /// Copy Of Timer Flag For Channel 1
                TF1: enum(u1) {
                    /// Timer Flag for Channel 1 is clear
                    TF1_0 = 0x0,
                    /// Timer Flag for Channel 1 is set
                    TF1_1 = 0x1,
                },
                /// Copy Of Timer Flag For Channel 2
                TF2: enum(u1) {
                    /// Timer Flag for Channel 2 is clear
                    TF2_0 = 0x0,
                    /// Timer Flag for Channel 2 is set
                    TF2_1 = 0x1,
                },
                /// Copy Of Timer Flag For Channel 3
                TF3: enum(u1) {
                    /// Timer Flag for Channel 3 is clear
                    TF3_0 = 0x0,
                    /// Timer Flag for Channel 3 is set
                    TF3_1 = 0x1,
                },
                padding: u28 = 0,
            }),
        };

        /// EWM
        pub const EWM = extern struct {
            /// Control Register
            CTRL: mmio.Mmio(packed struct(u8) {
                /// EWM enable.
                EWMEN: u1,
                /// EWM_in's Assertion State Select.
                ASSIN: u1,
                /// Input Enable.
                INEN: u1,
                /// Interrupt Enable.
                INTEN: u1,
                padding: u4 = 0,
            }),
            /// Service Register
            SERV: mmio.Mmio(packed struct(u8) {
                /// SERVICE
                SERVICE: u8,
            }),
            /// Compare Low Register
            CMPL: mmio.Mmio(packed struct(u8) {
                /// COMPAREL
                COMPAREL: u8,
            }),
            /// Compare High Register
            CMPH: mmio.Mmio(packed struct(u8) {
                /// COMPAREH
                COMPAREH: u8,
            }),
            /// Clock Control Register
            CLKCTRL: mmio.Mmio(packed struct(u8) {
                /// CLKSEL
                CLKSEL: u2,
                padding: u6 = 0,
            }),
            /// Clock Prescaler Register
            CLKPRESCALER: mmio.Mmio(packed struct(u8) {
                /// CLK_DIV
                CLK_DIV: u8,
            }),
        };

        /// FLEXIO
        pub const FLEXIO1 = extern struct {
            /// Version ID Register
            VERID: mmio.Mmio(packed struct(u32) {
                /// Feature Specification Number
                FEATURE: enum(u16) {
                    /// Standard features implemented.
                    FEATURE_0 = 0x0,
                    /// Supports state, logic and parallel modes.
                    FEATURE_1 = 0x1,
                    _,
                },
                /// Minor Version Number
                MINOR: u8,
                /// Major Version Number
                MAJOR: u8,
            }),
            /// Parameter Register
            PARAM: mmio.Mmio(packed struct(u32) {
                /// Shifter Number
                SHIFTER: u8,
                /// Timer Number
                TIMER: u8,
                /// Pin Number
                PIN: u8,
                /// Trigger Number
                TRIGGER: u8,
            }),
            /// FlexIO Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                /// FlexIO Enable
                FLEXEN: enum(u1) {
                    /// FlexIO module is disabled.
                    FLEXEN_0 = 0x0,
                    /// FlexIO module is enabled.
                    FLEXEN_1 = 0x1,
                },
                /// Software Reset
                SWRST: enum(u1) {
                    /// Software reset is disabled
                    SWRST_0 = 0x0,
                    /// Software reset is enabled, all FlexIO registers except the Control Register are reset.
                    SWRST_1 = 0x1,
                },
                /// Fast Access
                FASTACC: enum(u1) {
                    /// Configures for normal register accesses to FlexIO
                    FASTACC_0 = 0x0,
                    /// Configures for fast register accesses to FlexIO
                    FASTACC_1 = 0x1,
                },
                reserved30: u27 = 0,
                /// Debug Enable
                DBGE: enum(u1) {
                    /// FlexIO is disabled in debug modes.
                    DBGE_0 = 0x0,
                    /// FlexIO is enabled in debug modes
                    DBGE_1 = 0x1,
                },
                /// Doze Enable
                DOZEN: enum(u1) {
                    /// FlexIO enabled in Doze modes.
                    DOZEN_0 = 0x0,
                    /// FlexIO disabled in Doze modes.
                    DOZEN_1 = 0x1,
                },
            }),
            /// Pin State Register
            PIN: mmio.Mmio(packed struct(u32) {
                /// Pin Data Input
                PDI: u16,
                padding: u16 = 0,
            }),
            /// Shifter Status Register
            SHIFTSTAT: mmio.Mmio(packed struct(u32) {
                /// Shifter Status Flag
                SSF: u4,
                padding: u28 = 0,
            }),
            /// Shifter Error Register
            SHIFTERR: mmio.Mmio(packed struct(u32) {
                /// Shifter Error Flags
                SEF: u4,
                padding: u28 = 0,
            }),
            /// Timer Status Register
            TIMSTAT: mmio.Mmio(packed struct(u32) {
                /// Timer Status Flags
                TSF: u4,
                padding: u28 = 0,
            }),
            reserved32: [4]u8,
            /// Shifter Status Interrupt Enable
            SHIFTSIEN: mmio.Mmio(packed struct(u32) {
                /// Shifter Status Interrupt Enable
                SSIE: u4,
                padding: u28 = 0,
            }),
            /// Shifter Error Interrupt Enable
            SHIFTEIEN: mmio.Mmio(packed struct(u32) {
                /// Shifter Error Interrupt Enable
                SEIE: u4,
                padding: u28 = 0,
            }),
            /// Timer Interrupt Enable Register
            TIMIEN: mmio.Mmio(packed struct(u32) {
                /// Timer Status Interrupt Enable
                TEIE: u4,
                padding: u28 = 0,
            }),
            reserved48: [4]u8,
            /// Shifter Status DMA Enable
            SHIFTSDEN: mmio.Mmio(packed struct(u32) {
                /// Shifter Status DMA Enable
                SSDE: u4,
                padding: u28 = 0,
            }),
            reserved64: [12]u8,
            /// Shifter State Register
            SHIFTSTATE: mmio.Mmio(packed struct(u32) {
                /// Current State Pointer
                STATE: u3,
                padding: u29 = 0,
            }),
            reserved128: [60]u8,
            /// Shifter Control N Register
            SHIFTCTL: [4]mmio.Mmio(packed struct(u32) {
                /// Shifter Mode
                SMOD: enum(u3) {
                    /// Disabled.
                    SMOD_0 = 0x0,
                    /// Receive mode. Captures the current Shifter content into the SHIFTBUF on expiration of the Timer.
                    SMOD_1 = 0x1,
                    /// Transmit mode. Load SHIFTBUF contents into the Shifter on expiration of the Timer.
                    SMOD_2 = 0x2,
                    /// Match Store mode. Shifter data is compared to SHIFTBUF content on expiration of the Timer.
                    SMOD_4 = 0x4,
                    /// Match Continuous mode. Shifter data is continuously compared to SHIFTBUF contents.
                    SMOD_5 = 0x5,
                    /// State mode. SHIFTBUF contents are used for storing programmable state attributes.
                    SMOD_6 = 0x6,
                    /// Logic mode. SHIFTBUF contents are used for implementing programmable logic look up table.
                    SMOD_7 = 0x7,
                    _,
                },
                reserved7: u4 = 0,
                /// Shifter Pin Polarity
                PINPOL: enum(u1) {
                    /// Pin is active high
                    PINPOL_0 = 0x0,
                    /// Pin is active low
                    PINPOL_1 = 0x1,
                },
                /// Shifter Pin Select
                PINSEL: u4,
                reserved16: u4 = 0,
                /// Shifter Pin Configuration
                PINCFG: enum(u2) {
                    /// Shifter pin output disabled
                    PINCFG_0 = 0x0,
                    /// Shifter pin open drain or bidirectional output enable
                    PINCFG_1 = 0x1,
                    /// Shifter pin bidirectional output data
                    PINCFG_2 = 0x2,
                    /// Shifter pin output
                    PINCFG_3 = 0x3,
                },
                reserved23: u5 = 0,
                /// Timer Polarity
                TIMPOL: enum(u1) {
                    /// Shift on posedge of Shift clock
                    TIMPOL_0 = 0x0,
                    /// Shift on negedge of Shift clock
                    TIMPOL_1 = 0x1,
                },
                /// Timer Select
                TIMSEL: u2,
                padding: u6 = 0,
            }),
            reserved256: [112]u8,
            /// Shifter Configuration N Register
            SHIFTCFG: [4]mmio.Mmio(packed struct(u32) {
                /// Shifter Start bit
                SSTART: enum(u2) {
                    /// Start bit disabled for transmitter/receiver/match store, transmitter loads data on enable
                    SSTART_0 = 0x0,
                    /// Start bit disabled for transmitter/receiver/match store, transmitter loads data on first shift
                    SSTART_1 = 0x1,
                    /// Transmitter outputs start bit value 0 before loading data on first shift, receiver/match store sets error flag if start bit is not 0
                    SSTART_2 = 0x2,
                    /// Transmitter outputs start bit value 1 before loading data on first shift, receiver/match store sets error flag if start bit is not 1
                    SSTART_3 = 0x3,
                },
                reserved4: u2 = 0,
                /// Shifter Stop bit
                SSTOP: enum(u2) {
                    /// Stop bit disabled for transmitter/receiver/match store
                    SSTOP_0 = 0x0,
                    /// Transmitter outputs stop bit value 0 on store, receiver/match store sets error flag if stop bit is not 0
                    SSTOP_2 = 0x2,
                    /// Transmitter outputs stop bit value 1 on store, receiver/match store sets error flag if stop bit is not 1
                    SSTOP_3 = 0x3,
                    _,
                },
                reserved8: u2 = 0,
                /// Input Source
                INSRC: enum(u1) {
                    /// Pin
                    INSRC_0 = 0x0,
                    /// Shifter N+1 Output
                    INSRC_1 = 0x1,
                },
                reserved16: u7 = 0,
                /// Parallel Width
                PWIDTH: u4,
                padding: u12 = 0,
            }),
            reserved512: [240]u8,
            /// Shifter Buffer N Register
            SHIFTBUF: [4]mmio.Mmio(packed struct(u32) {
                /// Shift Buffer
                SHIFTBUF: u32,
            }),
            reserved640: [112]u8,
            /// Shifter Buffer N Bit Swapped Register
            SHIFTBUFBIS: [4]mmio.Mmio(packed struct(u32) {
                /// Shift Buffer
                SHIFTBUFBIS: u32,
            }),
            reserved768: [112]u8,
            /// Shifter Buffer N Byte Swapped Register
            SHIFTBUFBYS: [4]mmio.Mmio(packed struct(u32) {
                /// Shift Buffer
                SHIFTBUFBYS: u32,
            }),
            reserved896: [112]u8,
            /// Shifter Buffer N Bit Byte Swapped Register
            SHIFTBUFBBS: [4]mmio.Mmio(packed struct(u32) {
                /// Shift Buffer
                SHIFTBUFBBS: u32,
            }),
            reserved1024: [112]u8,
            /// Timer Control N Register
            TIMCTL: [4]mmio.Mmio(packed struct(u32) {
                /// Timer Mode
                TIMOD: enum(u2) {
                    /// Timer Disabled.
                    TIMOD_0 = 0x0,
                    /// Dual 8-bit counters baud mode.
                    TIMOD_1 = 0x1,
                    /// Dual 8-bit counters PWM high mode.
                    TIMOD_2 = 0x2,
                    /// Single 16-bit counter mode.
                    TIMOD_3 = 0x3,
                },
                reserved7: u5 = 0,
                /// Timer Pin Polarity
                PINPOL: enum(u1) {
                    /// Pin is active high
                    PINPOL_0 = 0x0,
                    /// Pin is active low
                    PINPOL_1 = 0x1,
                },
                /// Timer Pin Select
                PINSEL: u4,
                reserved16: u4 = 0,
                /// Timer Pin Configuration
                PINCFG: enum(u2) {
                    /// Timer pin output disabled
                    PINCFG_0 = 0x0,
                    /// Timer pin open drain or bidirectional output enable
                    PINCFG_1 = 0x1,
                    /// Timer pin bidirectional output data
                    PINCFG_2 = 0x2,
                    /// Timer pin output
                    PINCFG_3 = 0x3,
                },
                reserved22: u4 = 0,
                /// Trigger Source
                TRGSRC: enum(u1) {
                    /// External trigger selected
                    TRGSRC_0 = 0x0,
                    /// Internal trigger selected
                    TRGSRC_1 = 0x1,
                },
                /// Trigger Polarity
                TRGPOL: enum(u1) {
                    /// Trigger active high
                    TRGPOL_0 = 0x0,
                    /// Trigger active low
                    TRGPOL_1 = 0x1,
                },
                /// Trigger Select
                TRGSEL: u5,
                padding: u3 = 0,
            }),
            reserved1152: [112]u8,
            /// Timer Configuration N Register
            TIMCFG: [4]mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// Timer Start Bit
                TSTART: enum(u1) {
                    /// Start bit disabled
                    TSTART_0 = 0x0,
                    /// Start bit enabled
                    TSTART_1 = 0x1,
                },
                reserved4: u2 = 0,
                /// Timer Stop Bit
                TSTOP: enum(u2) {
                    /// Stop bit disabled
                    TSTOP_0 = 0x0,
                    /// Stop bit is enabled on timer compare
                    TSTOP_1 = 0x1,
                    /// Stop bit is enabled on timer disable
                    TSTOP_2 = 0x2,
                    /// Stop bit is enabled on timer compare and timer disable
                    TSTOP_3 = 0x3,
                },
                reserved8: u2 = 0,
                /// Timer Enable
                TIMENA: enum(u3) {
                    /// Timer always enabled
                    TIMENA_0 = 0x0,
                    /// Timer enabled on Timer N-1 enable
                    TIMENA_1 = 0x1,
                    /// Timer enabled on Trigger high
                    TIMENA_2 = 0x2,
                    /// Timer enabled on Trigger high and Pin high
                    TIMENA_3 = 0x3,
                    /// Timer enabled on Pin rising edge
                    TIMENA_4 = 0x4,
                    /// Timer enabled on Pin rising edge and Trigger high
                    TIMENA_5 = 0x5,
                    /// Timer enabled on Trigger rising edge
                    TIMENA_6 = 0x6,
                    /// Timer enabled on Trigger rising or falling edge
                    TIMENA_7 = 0x7,
                },
                reserved12: u1 = 0,
                /// Timer Disable
                TIMDIS: enum(u3) {
                    /// Timer never disabled
                    TIMDIS_0 = 0x0,
                    /// Timer disabled on Timer N-1 disable
                    TIMDIS_1 = 0x1,
                    /// Timer disabled on Timer compare (upper 8-bits match and decrement)
                    TIMDIS_2 = 0x2,
                    /// Timer disabled on Timer compare (upper 8-bits match and decrement) and Trigger Low
                    TIMDIS_3 = 0x3,
                    /// Timer disabled on Pin rising or falling edge
                    TIMDIS_4 = 0x4,
                    /// Timer disabled on Pin rising or falling edge provided Trigger is high
                    TIMDIS_5 = 0x5,
                    /// Timer disabled on Trigger falling edge
                    TIMDIS_6 = 0x6,
                    _,
                },
                reserved16: u1 = 0,
                /// Timer Reset
                TIMRST: enum(u3) {
                    /// Timer never reset
                    TIMRST_0 = 0x0,
                    /// Timer reset on Timer Pin equal to Timer Output
                    TIMRST_2 = 0x2,
                    /// Timer reset on Timer Trigger equal to Timer Output
                    TIMRST_3 = 0x3,
                    /// Timer reset on Timer Pin rising edge
                    TIMRST_4 = 0x4,
                    /// Timer reset on Trigger rising edge
                    TIMRST_6 = 0x6,
                    /// Timer reset on Trigger rising or falling edge
                    TIMRST_7 = 0x7,
                    _,
                },
                reserved20: u1 = 0,
                /// Timer Decrement
                TIMDEC: enum(u2) {
                    /// Decrement counter on FlexIO clock, Shift clock equals Timer output.
                    TIMDEC_0 = 0x0,
                    /// Decrement counter on Trigger input (both edges), Shift clock equals Timer output.
                    TIMDEC_1 = 0x1,
                    /// Decrement counter on Pin input (both edges), Shift clock equals Pin input.
                    TIMDEC_2 = 0x2,
                    /// Decrement counter on Trigger input (both edges), Shift clock equals Trigger input.
                    TIMDEC_3 = 0x3,
                },
                reserved24: u2 = 0,
                /// Timer Output
                TIMOUT: enum(u2) {
                    /// Timer output is logic one when enabled and is not affected by timer reset
                    TIMOUT_0 = 0x0,
                    /// Timer output is logic zero when enabled and is not affected by timer reset
                    TIMOUT_1 = 0x1,
                    /// Timer output is logic one when enabled and on timer reset
                    TIMOUT_2 = 0x2,
                    /// Timer output is logic zero when enabled and on timer reset
                    TIMOUT_3 = 0x3,
                },
                padding: u6 = 0,
            }),
            reserved1280: [112]u8,
            /// Timer Compare N Register
            TIMCMP: [4]mmio.Mmio(packed struct(u32) {
                /// Timer Compare Value
                CMP: u16,
                padding: u16 = 0,
            }),
            reserved1664: [368]u8,
            /// Shifter Buffer N Nibble Byte Swapped Register
            SHIFTBUFNBS: [4]mmio.Mmio(packed struct(u32) {
                /// Shift Buffer
                SHIFTBUFNBS: u32,
            }),
            reserved1792: [112]u8,
            /// Shifter Buffer N Half Word Swapped Register
            SHIFTBUFHWS: [4]mmio.Mmio(packed struct(u32) {
                /// Shift Buffer
                SHIFTBUFHWS: u32,
            }),
            reserved1920: [112]u8,
            /// Shifter Buffer N Nibble Swapped Register
            SHIFTBUFNIS: [4]mmio.Mmio(packed struct(u32) {
                /// Shift Buffer
                SHIFTBUFNIS: u32,
            }),
        };

        /// FLEXRAM
        pub const FLEXRAM = extern struct {
            /// TCM CRTL Register
            TCM_CTRL: mmio.Mmio(packed struct(u32) {
                /// TCM Write Wait Mode Enable
                TCM_WWAIT_EN: enum(u1) {
                    /// TCM write fast mode: Write RAM accesses are expected to be finished in 1-cycle.
                    TCM_WWAIT_EN_0 = 0x0,
                    /// TCM write wait mode: Write RAM accesses are expected to be finished in 2-cycles.
                    TCM_WWAIT_EN_1 = 0x1,
                },
                /// TCM Read Wait Mode Enable
                TCM_RWAIT_EN: enum(u1) {
                    /// TCM read fast mode: Read RAM accesses are expected to be finished in 1-cycle.
                    TCM_RWAIT_EN_0 = 0x0,
                    /// TCM read wait mode: Read RAM accesses are expected to be finished in 2-cycles.
                    TCM_RWAIT_EN_1 = 0x1,
                },
                /// Force RAM Clock Always On
                FORCE_CLK_ON: u1,
                padding: u29 = 0,
            }),
            reserved16: [12]u8,
            /// Interrupt Status Register
            INT_STATUS: mmio.Mmio(packed struct(u32) {
                reserved3: u3 = 0,
                /// ITCM Access Error Status
                ITCM_ERR_STATUS: enum(u1) {
                    /// ITCM access error does not happen
                    ITCM_ERR_STATUS_0 = 0x0,
                    /// ITCM access error happens.
                    ITCM_ERR_STATUS_1 = 0x1,
                },
                /// DTCM Access Error Status
                DTCM_ERR_STATUS: enum(u1) {
                    /// DTCM access error does not happen
                    DTCM_ERR_STATUS_0 = 0x0,
                    /// DTCM access error happens.
                    DTCM_ERR_STATUS_1 = 0x1,
                },
                /// OCRAM Access Error Status
                OCRAM_ERR_STATUS: enum(u1) {
                    /// OCRAM access error does not happen
                    OCRAM_ERR_STATUS_0 = 0x0,
                    /// OCRAM access error happens.
                    OCRAM_ERR_STATUS_1 = 0x1,
                },
                padding: u26 = 0,
            }),
            /// Interrupt Status Enable Register
            INT_STAT_EN: mmio.Mmio(packed struct(u32) {
                reserved3: u3 = 0,
                /// ITCM Access Error Status Enable
                ITCM_ERR_STAT_EN: enum(u1) {
                    /// Masked
                    ITCM_ERR_STAT_EN_0 = 0x0,
                    /// Enabled
                    ITCM_ERR_STAT_EN_1 = 0x1,
                },
                /// DTCM Access Error Status Enable
                DTCM_ERR_STAT_EN: enum(u1) {
                    /// Masked
                    DTCM_ERR_STAT_EN_0 = 0x0,
                    /// Enabled
                    DTCM_ERR_STAT_EN_1 = 0x1,
                },
                /// OCRAM Access Error Status Enable
                OCRAM_ERR_STAT_EN: enum(u1) {
                    /// Masked
                    OCRAM_ERR_STAT_EN_0 = 0x0,
                    /// Enabled
                    OCRAM_ERR_STAT_EN_1 = 0x1,
                },
                padding: u26 = 0,
            }),
            /// Interrupt Enable Register
            INT_SIG_EN: mmio.Mmio(packed struct(u32) {
                reserved3: u3 = 0,
                /// ITCM Access Error Interrupt Enable
                ITCM_ERR_SIG_EN: enum(u1) {
                    /// Masked
                    ITCM_ERR_SIG_EN_0 = 0x0,
                    /// Enabled
                    ITCM_ERR_SIG_EN_1 = 0x1,
                },
                /// DTCM Access Error Interrupt Enable
                DTCM_ERR_SIG_EN: enum(u1) {
                    /// Masked
                    DTCM_ERR_SIG_EN_0 = 0x0,
                    /// Enabled
                    DTCM_ERR_SIG_EN_1 = 0x1,
                },
                /// OCRAM Access Error Interrupt Enable
                OCRAM_ERR_SIG_EN: enum(u1) {
                    /// Masked
                    OCRAM_ERR_SIG_EN_0 = 0x0,
                    /// Enabled
                    OCRAM_ERR_SIG_EN_1 = 0x1,
                },
                padding: u26 = 0,
            }),
        };

        /// FlexSPI
        pub const FLEXSPI = extern struct {
            /// Module Control Register 0
            MCR0: mmio.Mmio(packed struct(u32) {
                /// Software Reset
                SWRESET: u1,
                /// Module Disable
                MDIS: u1,
                reserved4: u2 = 0,
                /// Sample Clock source selection for Flash Reading
                RXCLKSRC: enum(u2) {
                    /// Dummy Read strobe generated by FlexSPI Controller and loopback internally.
                    RXCLKSRC_0 = 0x0,
                    /// Dummy Read strobe generated by FlexSPI Controller and loopback from DQS pad.
                    RXCLKSRC_1 = 0x1,
                    /// Flash provided Read strobe and input from DQS pad
                    RXCLKSRC_3 = 0x3,
                    _,
                },
                /// Enable AHB bus Read Access to IP RX FIFO.
                ARDFEN: enum(u1) {
                    /// IP RX FIFO should be read by IP Bus. AHB Bus read access to IP RX FIFO memory space will get bus error response.
                    ARDFEN_0 = 0x0,
                    /// IP RX FIFO should be read by AHB Bus. IP Bus read access to IP RX FIFO memory space will always return data zero but no bus error response.
                    ARDFEN_1 = 0x1,
                },
                /// Enable AHB bus Write Access to IP TX FIFO.
                ATDFEN: enum(u1) {
                    /// IP TX FIFO should be written by IP Bus. AHB Bus write access to IP TX FIFO memory space will get bus error response.
                    ATDFEN_0 = 0x0,
                    /// IP TX FIFO should be written by AHB Bus. IP Bus write access to IP TX FIFO memory space will be ignored but no bus error response.
                    ATDFEN_1 = 0x1,
                },
                reserved11: u3 = 0,
                /// Half Speed Serial Flash access Enable.
                HSEN: enum(u1) {
                    /// Disable divide by 2 of serial flash clock for half speed commands.
                    HSEN_0 = 0x0,
                    /// Enable divide by 2 of serial flash clock for half speed commands.
                    HSEN_1 = 0x1,
                },
                /// Doze mode enable bit
                DOZEEN: enum(u1) {
                    /// Doze mode support disabled. AHB clock and serial clock will not be gated off when there is doze mode request from system.
                    DOZEEN_0 = 0x0,
                    /// Doze mode support enabled. AHB clock and serial clock will be gated off when there is doze mode request from system.
                    DOZEEN_1 = 0x1,
                },
                /// This bit is to support Flash Octal mode access by combining Port A and B Data pins (SIOA[3:0] and SIOB[3:0]).
                COMBINATIONEN: enum(u1) {
                    /// Disable.
                    COMBINATIONEN_0 = 0x0,
                    /// Enable.
                    COMBINATIONEN_1 = 0x1,
                },
                /// This bit is used to force SCK output free-running. For FPGA applications, external device may use SCK clock as reference clock to its internal PLL. If SCK free-running is enabled, data sampling with loopback clock from SCK pad is not supported (MCR0[RXCLKSRC]=2).
                SCKFREERUNEN: enum(u1) {
                    /// Disable.
                    SCKFREERUNEN_0 = 0x0,
                    /// Enable.
                    SCKFREERUNEN_1 = 0x1,
                },
                reserved16: u1 = 0,
                /// Time out wait cycle for IP command grant.
                IPGRANTWAIT: u8,
                /// Timeout wait cycle for AHB command grant.
                AHBGRANTWAIT: u8,
            }),
            /// Module Control Register 1
            MCR1: mmio.Mmio(packed struct(u32) {
                /// AHB Read/Write access to Serial Flash Memory space will timeout if not data received from Flash or data not transmited after AHBBUSWAIT * 1024 ahb clock cycles, AHB Bus will get an error response
                AHBBUSWAIT: u16,
                /// Command Sequence Execution will timeout and abort after SEQWAIT * 1024 Serial Root Clock cycles
                SEQWAIT: u16,
            }),
            /// Module Control Register 2
            MCR2: mmio.Mmio(packed struct(u32) {
                reserved11: u11 = 0,
                /// This bit determines whether AHB RX Buffer and AHB TX Buffer will be cleaned automaticaly when FlexSPI returns STOP mode ACK. Software should set this bit if AHB RX Buffer or AHB TX Buffer will be powered off in STOP mode. Otherwise AHB read access after exiting STOP mode may hit AHB RX Buffer or AHB TX Buffer but their data entries are invalid.
                CLRAHBBUFOPT: enum(u1) {
                    /// AHB RX/TX Buffer will not be cleaned automatically when FlexSPI return Stop mode ACK.
                    CLRAHBBUFOPT_0 = 0x0,
                    /// AHB RX/TX Buffer will be cleaned automatically when FlexSPI return Stop mode ACK.
                    CLRAHBBUFOPT_1 = 0x1,
                },
                reserved14: u2 = 0,
                /// The sampling clock phase selection will be reset to phase 0 when this bit is written with 0x1. This bit will be auto-cleared immediately.
                CLRLEARNPHASE: u1,
                /// All external devices are same devices (both in types and size) for A1/A2/B1/B2.
                SAMEDEVICEEN: enum(u1) {
                    /// In Individual mode, FLSHA1CRx/FLSHA2CRx/FLSHB1CRx/FLSHB2CRx register setting will be applied to Flash A1/A2/B1/B2 seperately. In Parallel mode, FLSHA1CRx register setting will be applied to Flash A1 and B1, FLSHA2CRx register setting will be applied to Flash A2 and B2. FLSHB1CRx/FLSHB2CRx register settings will be ignored.
                    SAMEDEVICEEN_0 = 0x0,
                    /// FLSHA1CR0/FLSHA1CR1/FLSHA1CR2 register settings will be applied to Flash A1/A2/B1/B2. FLSHA2CRx/FLSHB1CRx/FLSHB2CRx will be ignored.
                    SAMEDEVICEEN_1 = 0x1,
                },
                reserved19: u3 = 0,
                /// SCKB pad can be used as SCKA differential clock output (inverted clock to SCKA). In this case, port B flash access is not available. After change the value of this feild, MCR0[SWRESET] should be set.
                SCKBDIFFOPT: enum(u1) {
                    /// SCKB pad is used as port B SCK clock output. Port B flash access is available.
                    SCKBDIFFOPT_0 = 0x0,
                    /// SCKB pad is used as port A SCK inverted clock output (Differential clock to SCKA). Port B flash access is not available.
                    SCKBDIFFOPT_1 = 0x1,
                },
                reserved24: u4 = 0,
                /// Wait cycle (in AHB clock cycle) for idle state before suspended command sequence resumed.
                RESUMEWAIT: u8,
            }),
            /// AHB Bus Control Register
            AHBCR: mmio.Mmio(packed struct(u32) {
                /// Parallel mode enabled for AHB triggered Command (both read and write) .
                APAREN: enum(u1) {
                    /// Flash will be accessed in Individual mode.
                    APAREN_0 = 0x0,
                    /// Flash will be accessed in Parallel mode.
                    APAREN_1 = 0x1,
                },
                reserved3: u2 = 0,
                /// Enable AHB bus cachable read access support.
                CACHABLEEN: enum(u1) {
                    /// Disabled. When there is AHB bus cachable read access, FlexSPI will not check whether it hit AHB TX Buffer.
                    CACHABLEEN_0 = 0x0,
                    /// Enabled. When there is AHB bus cachable read access, FlexSPI will check whether it hit AHB TX Buffer first.
                    CACHABLEEN_1 = 0x1,
                },
                /// Enable AHB bus bufferable write access support. This field affects the last beat of AHB write access, refer for more details about AHB bufferable write.
                BUFFERABLEEN: enum(u1) {
                    /// Disabled. For all AHB write access (no matter bufferable or non-bufferable ), FlexSPI will return AHB Bus ready after all data is transmitted to External device and AHB command finished.
                    BUFFERABLEEN_0 = 0x0,
                    /// Enabled. For AHB bufferable write access, FlexSPI will return AHB Bus ready when the AHB command is granted by arbitrator and will not wait for AHB command finished.
                    BUFFERABLEEN_1 = 0x1,
                },
                /// AHB Read Prefetch Enable.
                PREFETCHEN: u1,
                /// AHB Read Address option bit. This option bit is intend to remove AHB burst start address alignment limitation.
                READADDROPT: enum(u1) {
                    /// There is AHB read burst start address alignment limitation when flash is accessed in parallel mode or flash is wordaddressable.
                    READADDROPT_0 = 0x0,
                    /// There is no AHB read burst start address alignment limitation. FlexSPI will fetch more datas than AHB burst required to meet the alignment requirement.
                    READADDROPT_1 = 0x1,
                },
                padding: u25 = 0,
            }),
            /// Interrupt Enable Register
            INTEN: mmio.Mmio(packed struct(u32) {
                /// IP triggered Command Sequences Execution finished interrupt enable.
                IPCMDDONEEN: u1,
                /// IP triggered Command Sequences Grant Timeout interrupt enable.
                IPCMDGEEN: u1,
                /// AHB triggered Command Sequences Grant Timeout interrupt enable.
                AHBCMDGEEN: u1,
                /// IP triggered Command Sequences Error Detected interrupt enable.
                IPCMDERREN: u1,
                /// AHB triggered Command Sequences Error Detected interrupt enable.
                AHBCMDERREN: u1,
                /// IP RX FIFO WaterMark available interrupt enable.
                IPRXWAEN: u1,
                /// IP TX FIFO WaterMark empty interrupt enable.
                IPTXWEEN: u1,
                reserved8: u1 = 0,
                /// SCK is stopped during command sequence because Async RX FIFO full interrupt enable.
                SCKSTOPBYRDEN: u1,
                /// SCK is stopped during command sequence because Async TX FIFO empty interrupt enable.
                SCKSTOPBYWREN: u1,
                /// AHB Bus timeout interrupt.Refer Interrupts chapter for more details.
                AHBBUSTIMEOUTEN: u1,
                /// Sequence execution timeout interrupt enable.Refer Interrupts chapter for more details.
                SEQTIMEOUTEN: u1,
                padding: u20 = 0,
            }),
            /// Interrupt Register
            INTR: mmio.Mmio(packed struct(u32) {
                /// IP triggered Command Sequences Execution finished interrupt. This interrupt is also generated when there is IPCMDGE or IPCMDERR interrupt generated.
                IPCMDDONE: u1,
                /// IP triggered Command Sequences Grant Timeout interrupt.
                IPCMDGE: u1,
                /// AHB triggered Command Sequences Grant Timeout interrupt.
                AHBCMDGE: u1,
                /// IP triggered Command Sequences Error Detected interrupt. When an error detected for IP command, this command will be ignored and not executed at all.
                IPCMDERR: u1,
                /// AHB triggered Command Sequences Error Detected interrupt. When an error detected for AHB command, this command will be ignored and not executed at all.
                AHBCMDERR: u1,
                /// IP RX FIFO watermark available interrupt.
                IPRXWA: u1,
                /// IP TX FIFO watermark empty interrupt.
                IPTXWE: u1,
                reserved8: u1 = 0,
                /// SCK is stopped during command sequence because Async RX FIFO full interrupt.
                SCKSTOPBYRD: u1,
                /// SCK is stopped during command sequence because Async TX FIFO empty interrupt.
                SCKSTOPBYWR: u1,
                /// AHB Bus timeout interrupt.Refer Interrupts chapter for more details.
                AHBBUSTIMEOUT: u1,
                /// Sequence execution timeout interrupt.
                SEQTIMEOUT: u1,
                padding: u20 = 0,
            }),
            /// LUT Key Register
            LUTKEY: mmio.Mmio(packed struct(u32) {
                /// The Key to lock or unlock LUT.
                KEY: u32,
            }),
            /// LUT Control Register
            LUTCR: mmio.Mmio(packed struct(u32) {
                /// Lock LUT
                LOCK: u1,
                /// Unlock LUT
                UNLOCK: u1,
                padding: u30 = 0,
            }),
            /// AHB RX Buffer 0 Control Register 0
            AHBRXBUF0CR0: mmio.Mmio(packed struct(u32) {
                /// AHB RX Buffer Size in 64 bits.Refer AHB RX Buffer Management for more details.
                BUFSZ: u8,
                reserved16: u8 = 0,
                /// This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID). Please refer to for AHB RX Buffer allocation.
                MSTRID: u4,
                reserved24: u4 = 0,
                /// This priority for AHB Master Read which this AHB RX Buffer is assigned. Refer for more details.
                PRIORITY: u2,
                reserved31: u5 = 0,
                /// AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
                PREFETCHEN: u1,
            }),
            /// AHB RX Buffer 1 Control Register 0
            AHBRXBUF1CR0: mmio.Mmio(packed struct(u32) {
                /// AHB RX Buffer Size in 64 bits.Refer AHB RX Buffer Management for more details.
                BUFSZ: u8,
                reserved16: u8 = 0,
                /// This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID). Please refer to for AHB RX Buffer allocation.
                MSTRID: u4,
                reserved24: u4 = 0,
                /// This priority for AHB Master Read which this AHB RX Buffer is assigned. Refer for more details.
                PRIORITY: u2,
                reserved31: u5 = 0,
                /// AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
                PREFETCHEN: u1,
            }),
            /// AHB RX Buffer 2 Control Register 0
            AHBRXBUF2CR0: mmio.Mmio(packed struct(u32) {
                /// AHB RX Buffer Size in 64 bits.Refer AHB RX Buffer Management for more details.
                BUFSZ: u8,
                reserved16: u8 = 0,
                /// This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID). Please refer to for AHB RX Buffer allocation.
                MSTRID: u4,
                reserved24: u4 = 0,
                /// This priority for AHB Master Read which this AHB RX Buffer is assigned. Refer for more details.
                PRIORITY: u2,
                reserved31: u5 = 0,
                /// AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
                PREFETCHEN: u1,
            }),
            /// AHB RX Buffer 3 Control Register 0
            AHBRXBUF3CR0: mmio.Mmio(packed struct(u32) {
                /// AHB RX Buffer Size in 64 bits.Refer AHB RX Buffer Management for more details.
                BUFSZ: u8,
                reserved16: u8 = 0,
                /// This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID). Please refer to for AHB RX Buffer allocation.
                MSTRID: u4,
                reserved24: u4 = 0,
                /// This priority for AHB Master Read which this AHB RX Buffer is assigned. Refer for more details.
                PRIORITY: u2,
                reserved31: u5 = 0,
                /// AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
                PREFETCHEN: u1,
            }),
            reserved96: [48]u8,
            /// Flash A1 Control Register 0
            FLSHA1CR0: mmio.Mmio(packed struct(u32) {
                /// Flash Size in KByte.
                FLSHSZ: u23,
                padding: u9 = 0,
            }),
            /// Flash A2 Control Register 0
            FLSHA2CR0: mmio.Mmio(packed struct(u32) {
                /// Flash Size in KByte.
                FLSHSZ: u23,
                padding: u9 = 0,
            }),
            /// Flash B1 Control Register 0
            FLSHB1CR0: mmio.Mmio(packed struct(u32) {
                /// Flash Size in KByte.
                FLSHSZ: u23,
                padding: u9 = 0,
            }),
            /// Flash B2 Control Register 0
            FLSHB2CR0: mmio.Mmio(packed struct(u32) {
                /// Flash Size in KByte.
                FLSHSZ: u23,
                padding: u9 = 0,
            }),
            reserved148: [36]u8,
            /// Flash Control Register 4
            FLSHCR4: mmio.Mmio(packed struct(u32) {
                /// Write mask option bit 1. This option bit could be used to remove AHB write burst start address alignment limitation.
                WMOPT1: enum(u1) {
                    /// DQS pin will be used as Write Mask when writing to external device. There is no limitation on AHB write burst start address alignment when flash is accessed in individual mode.
                    WMOPT1_0 = 0x0,
                    /// DQS pin will not be used as Write Mask when writing to external device. There is limitation on AHB write burst start address alignment when flash is accessed in individual mode.
                    WMOPT1_1 = 0x1,
                },
                reserved2: u1 = 0,
                /// Write mask enable bit for flash device on port A. When write mask function is needed for memory device on port A, this bit must be set.
                WMENA: enum(u1) {
                    /// Write mask is disabled, DQS(RWDS) pin will be un-driven when writing to external device.
                    WMENA_0 = 0x0,
                    /// Write mask is enabled, DQS(RWDS) pin will be driven by FlexSPI as write mask output when writing to external device.
                    WMENA_1 = 0x1,
                },
                /// Write mask enable bit for flash device on port B. When write mask function is needed for memory device on port B, this bit must be set.
                WMENB: enum(u1) {
                    /// Write mask is disabled, DQS(RWDS) pin will be un-driven when writing to external device.
                    WMENB_0 = 0x0,
                    /// Write mask is enabled, DQS(RWDS) pin will be driven by FlexSPI as write mask output when writing to external device.
                    WMENB_1 = 0x1,
                },
                padding: u28 = 0,
            }),
            reserved160: [8]u8,
            /// IP Control Register 0
            IPCR0: mmio.Mmio(packed struct(u32) {
                /// Serial Flash Address for IP command.
                SFAR: u32,
            }),
            /// IP Control Register 1
            IPCR1: mmio.Mmio(packed struct(u32) {
                /// Flash Read/Program Data Size (in Bytes) for IP command.
                IDATSZ: u16,
                /// Sequence Index in LUT for IP command.
                ISEQID: u4,
                reserved24: u4 = 0,
                /// Sequence Number for IP command: ISEQNUM+1.
                ISEQNUM: u3,
                reserved31: u4 = 0,
                /// Parallel mode Enabled for IP command.
                IPAREN: enum(u1) {
                    /// Flash will be accessed in Individual mode.
                    IPAREN_0 = 0x0,
                    /// Flash will be accessed in Parallel mode.
                    IPAREN_1 = 0x1,
                },
            }),
            reserved176: [8]u8,
            /// IP Command Register
            IPCMD: mmio.Mmio(packed struct(u32) {
                /// Setting this bit will trigger an IP Command.
                TRG: u1,
                padding: u31 = 0,
            }),
            reserved184: [4]u8,
            /// IP RX FIFO Control Register
            IPRXFCR: mmio.Mmio(packed struct(u32) {
                /// Clear all valid data entries in IP RX FIFO.
                CLRIPRXF: u1,
                /// IP RX FIFO reading by DMA enabled.
                RXDMAEN: enum(u1) {
                    /// IP RX FIFO would be read by processor.
                    RXDMAEN_0 = 0x0,
                    /// IP RX FIFO would be read by DMA.
                    RXDMAEN_1 = 0x1,
                },
                /// Watermark level is (RXWMRK+1)*64 Bits.
                RXWMRK: u4,
                padding: u26 = 0,
            }),
            /// IP TX FIFO Control Register
            IPTXFCR: mmio.Mmio(packed struct(u32) {
                /// Clear all valid data entries in IP TX FIFO.
                CLRIPTXF: u1,
                /// IP TX FIFO filling by DMA enabled.
                TXDMAEN: enum(u1) {
                    /// IP TX FIFO would be filled by processor.
                    TXDMAEN_0 = 0x0,
                    /// IP TX FIFO would be filled by DMA.
                    TXDMAEN_1 = 0x1,
                },
                /// Watermark level is (TXWMRK+1)*64 Bits.
                TXWMRK: u4,
                padding: u26 = 0,
            }),
            reserved224: [32]u8,
            /// Status Register 0
            STS0: mmio.Mmio(packed struct(u32) {
                /// This status bit indicates the state machine in SEQ_CTL is idle and there is command sequence executing on FlexSPI interface.
                SEQIDLE: u1,
                /// This status bit indicates the state machine in ARB_CTL is busy and there is command sequence granted by arbitrator and not finished yet on FlexSPI interface. When ARB_CTL state (ARBIDLE=0x1) is idle, there will be no transaction on FlexSPI interface also (SEQIDLE=0x1). So this bit should be polled to wait for FlexSPI controller become idle instead of SEQIDLE.
                ARBIDLE: u1,
                /// This status field indicates the trigger source of current command sequence granted by arbitrator. This field value is meaningless when ARB_CTL is not busy (STS0[ARBIDLE]=0x1).
                ARBCMDSRC: enum(u2) {
                    /// Triggered by AHB read command (triggered by AHB read).
                    ARBCMDSRC_0 = 0x0,
                    /// Triggered by AHB write command (triggered by AHB Write).
                    ARBCMDSRC_1 = 0x1,
                    /// Triggered by IP command (triggered by setting register bit IPCMD.TRG).
                    ARBCMDSRC_2 = 0x2,
                    /// Triggered by suspended command (resumed).
                    ARBCMDSRC_3 = 0x3,
                },
                padding: u28 = 0,
            }),
            /// Status Register 1
            STS1: mmio.Mmio(packed struct(u32) {
                /// Indicates the sequence index when an AHB command error is detected. This field will be cleared when INTR[AHBCMDERR] is write-1-clear(w1c).
                AHBCMDERRID: u4,
                reserved8: u4 = 0,
                /// Indicates the Error Code when AHB command Error detected. This field will be cleared when INTR[AHBCMDERR] is write-1-clear(w1c).
                AHBCMDERRCODE: enum(u4) {
                    /// No error.
                    AHBCMDERRCODE_0 = 0x0,
                    /// AHB Write command with JMP_ON_CS instruction used in the sequence.
                    AHBCMDERRCODE_2 = 0x2,
                    /// There is unknown instruction opcode in the sequence.
                    AHBCMDERRCODE_3 = 0x3,
                    /// Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.
                    AHBCMDERRCODE_4 = 0x4,
                    /// Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.
                    AHBCMDERRCODE_5 = 0x5,
                    /// Sequence execution timeout.
                    AHBCMDERRCODE_14 = 0xe,
                    _,
                },
                reserved16: u4 = 0,
                /// Indicates the sequence Index when IP command error detected. This field will be cleared when INTR[IPCMDERR] is write-1-clear(w1c).
                IPCMDERRID: u4,
                reserved24: u4 = 0,
                /// Indicates the Error Code when IP command Error detected. This field will be cleared when INTR[IPCMDERR] is write-1-clear(w1c).
                IPCMDERRCODE: enum(u4) {
                    /// No error.
                    IPCMDERRCODE_0 = 0x0,
                    /// IP command with JMP_ON_CS instruction used in the sequence.
                    IPCMDERRCODE_2 = 0x2,
                    /// There is unknown instruction opcode in the sequence.
                    IPCMDERRCODE_3 = 0x3,
                    /// Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.
                    IPCMDERRCODE_4 = 0x4,
                    /// Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.
                    IPCMDERRCODE_5 = 0x5,
                    /// Flash access start address exceed the whole flash address range (A1/A2/B1/B2).
                    IPCMDERRCODE_6 = 0x6,
                    /// Sequence execution timeout.
                    IPCMDERRCODE_14 = 0xe,
                    /// Flash boundary crossed.
                    IPCMDERRCODE_15 = 0xf,
                    _,
                },
                padding: u4 = 0,
            }),
            /// Status Register 2
            STS2: mmio.Mmio(packed struct(u32) {
                /// Flash A sample clock slave delay line locked.
                ASLVLOCK: u1,
                /// Flash A sample clock reference delay line locked.
                AREFLOCK: u1,
                /// Flash A sample clock slave delay line delay cell number selection .
                ASLVSEL: u6,
                /// Flash A sample clock reference delay line delay cell number selection.
                AREFSEL: u6,
                reserved16: u2 = 0,
                /// Flash B sample clock slave delay line locked.
                BSLVLOCK: u1,
                /// Flash B sample clock reference delay line locked.
                BREFLOCK: u1,
                /// Flash B sample clock slave delay line delay cell number selection.
                BSLVSEL: u6,
                /// Flash B sample clock reference delay line delay cell number selection.
                BREFSEL: u6,
                padding: u2 = 0,
            }),
            /// AHB Suspend Status Register
            AHBSPNDSTS: mmio.Mmio(packed struct(u32) {
                /// Indicates if an AHB read prefetch command sequence has been suspended.
                ACTIVE: u1,
                /// AHB RX BUF ID for suspended command sequence.
                BUFID: u3,
                reserved16: u12 = 0,
                /// Left Data size for suspended command sequence (in byte).
                DATLFT: u16,
            }),
            /// IP RX FIFO Status Register
            IPRXFSTS: mmio.Mmio(packed struct(u32) {
                /// Fill level of IP RX FIFO.
                FILL: u8,
                reserved16: u8 = 0,
                /// Total Read Data Counter: RDCNTR * 64 Bits.
                RDCNTR: u16,
            }),
            /// IP TX FIFO Status Register
            IPTXFSTS: mmio.Mmio(packed struct(u32) {
                /// Fill level of IP TX FIFO.
                FILL: u8,
                reserved16: u8 = 0,
                /// Total Write Data Counter: WRCNTR * 64 Bits.
                WRCNTR: u16,
            }),
            reserved256: [8]u8,
            /// IP RX FIFO Data Register 0
            RFDR: [32]mmio.Mmio(packed struct(u32) {
                /// RX Data
                RXDATA: u32,
            }),
            /// IP TX FIFO Data Register 0
            TFDR: [32]mmio.Mmio(packed struct(u32) {
                /// TX Data
                TXDATA: u32,
            }),
            /// LUT 0
            LUT: [64]mmio.Mmio(packed struct(u32) {
                /// OPERAND0
                OPERAND0: u8,
                /// NUM_PADS0
                NUM_PADS0: u2,
                /// OPCODE
                OPCODE0: u6,
                /// OPERAND1
                OPERAND1: u8,
                /// NUM_PADS1
                NUM_PADS1: u2,
                /// OPCODE1
                OPCODE1: u6,
            }),
        };

        /// GPC
        pub const GPC = extern struct {
            /// GPC Interface control register
            CNTR: mmio.Mmio(packed struct(u32) {
                reserved2: u2 = 0,
                /// MEGA domain power down request
                MEGA_PDN_REQ: enum(u1) {
                    /// No Request
                    MEGA_PDN_REQ_0 = 0x0,
                    /// Request power down sequence
                    MEGA_PDN_REQ_1 = 0x1,
                },
                /// MEGA domain power up request
                MEGA_PUP_REQ: enum(u1) {
                    /// No Request
                    MEGA_PUP_REQ_0 = 0x0,
                    /// Request power up sequence
                    MEGA_PUP_REQ_1 = 0x1,
                },
                reserved22: u18 = 0,
                /// FlexRAM PDRAM0 Power Gate Enable
                PDRAM0_PGE: enum(u1) {
                    /// FlexRAM PDRAM0 domain will keep power on even if CPU core is power down.
                    PDRAM0_PGE_0 = 0x0,
                    /// FlexRAM PDRAM0 domain will be power down once when CPU core is power down.
                    PDRAM0_PGE_1 = 0x1,
                },
                padding: u9 = 0,
            }),
            reserved8: [4]u8,
            /// IRQ masking register 1
            IMR1: mmio.Mmio(packed struct(u32) {
                /// IRQ[31:0] masking bits: 1-irq masked, 0-irq is not masked
                IMR1: u32,
            }),
            /// IRQ masking register 2
            IMR2: mmio.Mmio(packed struct(u32) {
                /// IRQ[63:32] masking bits: 1-irq masked, 0-irq is not masked
                IMR2: u32,
            }),
            /// IRQ masking register 3
            IMR3: mmio.Mmio(packed struct(u32) {
                /// IRQ[95:64] masking bits: 1-irq masked, 0-irq is not masked
                IMR3: u32,
            }),
            /// IRQ masking register 4
            IMR4: mmio.Mmio(packed struct(u32) {
                /// IRQ[127:96] masking bits: 1-irq masked, 0-irq is not masked
                IMR4: u32,
            }),
            /// IRQ status resister 1
            ISR1: mmio.Mmio(packed struct(u32) {
                /// IRQ[31:0] status, read only
                ISR1: u32,
            }),
            /// IRQ status resister 2
            ISR2: mmio.Mmio(packed struct(u32) {
                /// IRQ[63:32] status, read only
                ISR2: u32,
            }),
            /// IRQ status resister 3
            ISR3: mmio.Mmio(packed struct(u32) {
                /// IRQ[95:64] status, read only
                ISR3: u32,
            }),
            /// IRQ status resister 4
            ISR4: mmio.Mmio(packed struct(u32) {
                /// IRQ[127:96] status, read only
                ISR4: u32,
            }),
            reserved52: [12]u8,
            /// IRQ masking register 5
            IMR5: mmio.Mmio(packed struct(u32) {
                /// IRQ[159:128] masking bits: 1-irq masked, 0-irq is not masked
                IMR5: u32,
            }),
            /// IRQ status resister 5
            ISR5: mmio.Mmio(packed struct(u32) {
                /// IRQ[159:128] status, read only
                ISR4: u32,
            }),
        };

        /// GPIO
        pub const GPIO1 = extern struct {
            /// GPIO data register
            DR: mmio.Mmio(packed struct(u32) {
                /// DR
                DR: u32,
            }),
            /// GPIO direction register
            GDIR: mmio.Mmio(packed struct(u32) {
                /// GDIR
                GDIR: u32,
            }),
            /// GPIO pad status register
            PSR: mmio.Mmio(packed struct(u32) {
                /// PSR
                PSR: u32,
            }),
            /// GPIO interrupt configuration register1
            ICR1: mmio.Mmio(packed struct(u32) {
                /// ICR0
                ICR0: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR1
                ICR1: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR2
                ICR2: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR3
                ICR3: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR4
                ICR4: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR5
                ICR5: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR6
                ICR6: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR7
                ICR7: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR8
                ICR8: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR9
                ICR9: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR10
                ICR10: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR11
                ICR11: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR12
                ICR12: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR13
                ICR13: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR14
                ICR14: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR15
                ICR15: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
            }),
            /// GPIO interrupt configuration register2
            ICR2: mmio.Mmio(packed struct(u32) {
                /// ICR16
                ICR16: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR17
                ICR17: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR18
                ICR18: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR19
                ICR19: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR20
                ICR20: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR21
                ICR21: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR22
                ICR22: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR23
                ICR23: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR24
                ICR24: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR25
                ICR25: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR26
                ICR26: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR27
                ICR27: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR28
                ICR28: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR29
                ICR29: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR30
                ICR30: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
                /// ICR31
                ICR31: enum(u2) {
                    /// Interrupt n is low-level sensitive.
                    LOW_LEVEL = 0x0,
                    /// Interrupt n is high-level sensitive.
                    HIGH_LEVEL = 0x1,
                    /// Interrupt n is rising-edge sensitive.
                    RISING_EDGE = 0x2,
                    /// Interrupt n is falling-edge sensitive.
                    FALLING_EDGE = 0x3,
                },
            }),
            /// GPIO interrupt mask register
            IMR: mmio.Mmio(packed struct(u32) {
                /// IMR
                IMR: u32,
            }),
            /// GPIO interrupt status register
            ISR: mmio.Mmio(packed struct(u32) {
                /// ISR
                ISR: u32,
            }),
            /// GPIO edge select register
            EDGE_SEL: mmio.Mmio(packed struct(u32) {
                /// GPIO_EDGE_SEL
                GPIO_EDGE_SEL: u32,
            }),
            reserved132: [100]u8,
            /// GPIO data register SET
            DR_SET: mmio.Mmio(packed struct(u32) {
                /// DR_SET
                DR_SET: u32,
            }),
            /// GPIO data register CLEAR
            DR_CLEAR: mmio.Mmio(packed struct(u32) {
                /// DR_CLEAR
                DR_CLEAR: u32,
            }),
            /// GPIO data register TOGGLE
            DR_TOGGLE: mmio.Mmio(packed struct(u32) {
                /// DR_TOGGLE
                DR_TOGGLE: u32,
            }),
        };

        /// GPT
        pub const GPT1 = extern struct {
            /// GPT Control Register
            CR: mmio.Mmio(packed struct(u32) {
                /// GPT Enable
                EN: enum(u1) {
                    /// GPT is disabled.
                    EN_0 = 0x0,
                    /// GPT is enabled.
                    EN_1 = 0x1,
                },
                /// GPT Enable mode
                ENMOD: enum(u1) {
                    /// GPT counter will retain its value when it is disabled.
                    ENMOD_0 = 0x0,
                    /// GPT counter value is reset to 0 when it is disabled.
                    ENMOD_1 = 0x1,
                },
                /// GPT debug mode enable
                DBGEN: enum(u1) {
                    /// GPT is disabled in debug mode.
                    DBGEN_0 = 0x0,
                    /// GPT is enabled in debug mode.
                    DBGEN_1 = 0x1,
                },
                /// GPT Wait Mode enable
                WAITEN: enum(u1) {
                    /// GPT is disabled in wait mode.
                    WAITEN_0 = 0x0,
                    /// GPT is enabled in wait mode.
                    WAITEN_1 = 0x1,
                },
                /// GPT Doze Mode Enable
                DOZEEN: enum(u1) {
                    /// GPT is disabled in doze mode.
                    DOZEEN_0 = 0x0,
                    /// GPT is enabled in doze mode.
                    DOZEEN_1 = 0x1,
                },
                /// GPT Stop Mode enable
                STOPEN: enum(u1) {
                    /// GPT is disabled in Stop mode.
                    STOPEN_0 = 0x0,
                    /// GPT is enabled in Stop mode.
                    STOPEN_1 = 0x1,
                },
                /// Clock Source select
                CLKSRC: enum(u3) {
                    /// No clock
                    CLKSRC_0 = 0x0,
                    /// Peripheral Clock (ipg_clk)
                    CLKSRC_1 = 0x1,
                    /// High Frequency Reference Clock (ipg_clk_highfreq)
                    CLKSRC_2 = 0x2,
                    /// External Clock
                    CLKSRC_3 = 0x3,
                    /// Low Frequency Reference Clock (ipg_clk_32k)
                    CLKSRC_4 = 0x4,
                    /// Crystal oscillator as Reference Clock (ipg_clk_24M)
                    CLKSRC_5 = 0x5,
                    _,
                },
                /// Free-Run or Restart mode
                FRR: enum(u1) {
                    /// Restart mode
                    FRR_0 = 0x0,
                    /// Free-Run mode
                    FRR_1 = 0x1,
                },
                /// Enable 24 MHz clock input from crystal
                EN_24M: enum(u1) {
                    /// 24M clock disabled
                    EN_24M_0 = 0x0,
                    /// 24M clock enabled
                    EN_24M_1 = 0x1,
                },
                reserved15: u4 = 0,
                /// Software reset
                SWR: enum(u1) {
                    /// GPT is not in reset state
                    SWR_0 = 0x0,
                    /// GPT is in reset state
                    SWR_1 = 0x1,
                },
                /// See IM2
                IM1: u2,
                /// IM2 (bits 19-18, Input Capture Channel 2 operating mode) IM1 (bits 17-16, Input Capture Channel 1 operating mode) The IMn bit field determines the transition on the input pin (for Input capture channel n), which will trigger a capture event
                IM2: enum(u2) {
                    /// capture disabled
                    IM2_0 = 0x0,
                    /// capture on rising edge only
                    IM2_1 = 0x1,
                    /// capture on falling edge only
                    IM2_2 = 0x2,
                    /// capture on both edges
                    IM2_3 = 0x3,
                },
                /// See OM3
                OM1: u3,
                /// See OM3
                OM2: u3,
                reserved29: u3 = 0,
                /// See F03
                FO1: u1,
                /// See F03
                FO2: u1,
                /// FO3 Force Output Compare Channel 3 FO2 Force Output Compare Channel 2 FO1 Force Output Compare Channel 1 The FOn bit causes the pin action programmed for the timer Output Compare n pin (according to the OMn bits in this register)
                FO3: enum(u1) {
                    /// Writing a 0 has no effect.
                    FO3_0 = 0x0,
                    /// Causes the programmed pin action on the timer Output Compare n pin; the OFn flag is not set.
                    FO3_1 = 0x1,
                },
            }),
            /// GPT Prescaler Register
            PR: mmio.Mmio(packed struct(u32) {
                /// Prescaler bits
                PRESCALER: enum(u12) {
                    /// Divide by 1
                    PRESCALER_0 = 0x0,
                    /// Divide by 2
                    PRESCALER_1 = 0x1,
                    /// Divide by 4096
                    PRESCALER_4095 = 0xfff,
                    _,
                },
                /// Prescaler bits
                PRESCALER24M: enum(u4) {
                    /// Divide by 1
                    PRESCALER24M_0 = 0x0,
                    /// Divide by 2
                    PRESCALER24M_1 = 0x1,
                    /// Divide by 16
                    PRESCALER24M_15 = 0xf,
                    _,
                },
                padding: u16 = 0,
            }),
            /// GPT Status Register
            SR: mmio.Mmio(packed struct(u32) {
                /// See OF3
                OF1: u1,
                /// See OF3
                OF2: u1,
                /// OF3 Output Compare 3 Flag OF2 Output Compare 2 Flag OF1 Output Compare 1 Flag The OFn bit indicates that a compare event has occurred on Output Compare channel n
                OF3: enum(u1) {
                    /// Compare event has not occurred.
                    OF3_0 = 0x0,
                    /// Compare event has occurred.
                    OF3_1 = 0x1,
                },
                /// See IF2
                IF1: u1,
                /// IF2 Input capture 2 Flag IF1 Input capture 1 Flag The IFn bit indicates that a capture event has occurred on Input Capture channel n
                IF2: enum(u1) {
                    /// Capture event has not occurred.
                    IF2_0 = 0x0,
                    /// Capture event has occurred.
                    IF2_1 = 0x1,
                },
                /// Rollover Flag
                ROV: enum(u1) {
                    /// Rollover has not occurred.
                    ROV_0 = 0x0,
                    /// Rollover has occurred.
                    ROV_1 = 0x1,
                },
                padding: u26 = 0,
            }),
            /// GPT Interrupt Register
            IR: mmio.Mmio(packed struct(u32) {
                /// See OF3IE
                OF1IE: u1,
                /// See OF3IE
                OF2IE: u1,
                /// OF3IE Output Compare 3 Interrupt Enable OF2IE Output Compare 2 Interrupt Enable OF1IE Output Compare 1 Interrupt Enable The OFnIE bit controls the Output Compare Channel n interrupt
                OF3IE: enum(u1) {
                    /// Output Compare Channel n interrupt is disabled.
                    OF3IE_0 = 0x0,
                    /// Output Compare Channel n interrupt is enabled.
                    OF3IE_1 = 0x1,
                },
                /// See IF2IE
                IF1IE: u1,
                /// IF2IE Input capture 2 Interrupt Enable IF1IE Input capture 1 Interrupt Enable The IFnIE bit controls the IFnIE Input Capture n Interrupt Enable
                IF2IE: enum(u1) {
                    /// IF2IE Input Capture n Interrupt Enable is disabled.
                    IF2IE_0 = 0x0,
                    /// IF2IE Input Capture n Interrupt Enable is enabled.
                    IF2IE_1 = 0x1,
                },
                /// Rollover Interrupt Enable. The ROVIE bit controls the Rollover interrupt.
                ROVIE: enum(u1) {
                    /// Rollover interrupt is disabled.
                    ROVIE_0 = 0x0,
                    /// Rollover interrupt enabled.
                    ROVIE_1 = 0x1,
                },
                padding: u26 = 0,
            }),
            /// GPT Output Compare Register 1
            OCR1: mmio.Mmio(packed struct(u32) {
                /// Compare Value
                COMP: u32,
            }),
            /// GPT Output Compare Register 2
            OCR2: mmio.Mmio(packed struct(u32) {
                /// Compare Value
                COMP: u32,
            }),
            /// GPT Output Compare Register 3
            OCR3: mmio.Mmio(packed struct(u32) {
                /// Compare Value
                COMP: u32,
            }),
            /// GPT Input Capture Register 1
            ICR1: mmio.Mmio(packed struct(u32) {
                /// Capture Value
                CAPT: u32,
            }),
            /// GPT Input Capture Register 2
            ICR2: mmio.Mmio(packed struct(u32) {
                /// Capture Value
                CAPT: u32,
            }),
            /// GPT Counter Register
            CNT: mmio.Mmio(packed struct(u32) {
                /// Counter Value. The COUNT bits show the current count value of the GPT counter.
                COUNT: u32,
            }),
        };

        /// IOMUXC
        pub const IOMUXC = extern struct {
            reserved20: [20]u8,
            /// SW_MUX_CTL_PAD_GPIO_EMC_00 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_00: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SEMC_DATA00 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM4_PWMA00 of instance: flexpwm4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPSPI2_SCK of instance: lpspi2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: XBAR1_XBAR_IN02 of instance: xbar1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO00 of instance: flexio1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO00 of instance: gpio4
                    ALT5 = 0x5,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_00
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_01 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_01: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SEMC_DATA01 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM4_PWMB00 of instance: flexpwm4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPSPI2_PCS0 of instance: lpspi2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: XBAR1_IN03 of instance: xbar1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO01 of instance: flexio1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO01 of instance: gpio4
                    ALT5 = 0x5,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_01
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_02 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_02: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SEMC_DATA02 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM4_PWMA01 of instance: flexpwm4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPSPI2_SDO of instance: lpspi2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: XBAR1_INOUT04 of instance: xbar1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO02 of instance: flexio1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO02 of instance: gpio4
                    ALT5 = 0x5,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_02
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_03 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_03: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SEMC_DATA03 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM4_PWMB01 of instance: flexpwm4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPSPI2_SDI of instance: lpspi2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: XBAR1_INOUT05 of instance: xbar1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO03 of instance: flexio1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO03 of instance: gpio4
                    ALT5 = 0x5,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_03
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_04 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_04: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SEMC_DATA04 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM4_PWMA02 of instance: flexpwm4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: SAI2_TX_DATA of instance: sai2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: XBAR1_INOUT06 of instance: xbar1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO04 of instance: flexio1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO04 of instance: gpio4
                    ALT5 = 0x5,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_04
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_05 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_05: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SEMC_DATA05 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM4_PWMB02 of instance: flexpwm4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: SAI2_TX_SYNC of instance: sai2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: XBAR1_INOUT07 of instance: xbar1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO05 of instance: flexio1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO05 of instance: gpio4
                    ALT5 = 0x5,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_05
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_06 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_06: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SEMC_DATA06 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM2_PWMA00 of instance: flexpwm2
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: SAI2_TX_BCLK of instance: sai2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: XBAR1_INOUT08 of instance: xbar1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO06 of instance: flexio1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO06 of instance: gpio4
                    ALT5 = 0x5,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_06
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_07 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_07: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SEMC_DATA07 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM2_PWMB00 of instance: flexpwm2
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: SAI2_MCLK of instance: sai2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: XBAR1_INOUT09 of instance: xbar1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO07 of instance: flexio1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO07 of instance: gpio4
                    ALT5 = 0x5,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_07
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_08 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_08: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SEMC_DM00 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM2_PWMA01 of instance: flexpwm2
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: SAI2_RX_DATA of instance: sai2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: XBAR1_INOUT17 of instance: xbar1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO08 of instance: flexio1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO08 of instance: gpio4
                    ALT5 = 0x5,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_08
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_09 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_09: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_ADDR00 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM2_PWMB01 of instance: flexpwm2
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: SAI2_RX_SYNC of instance: sai2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: FLEXCAN2_TX of instance: flexcan2
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO09 of instance: flexio1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO09 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: FLEXSPI2_B_SS1_B of instance: flexspi2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_09
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_10 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_10: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_ADDR01 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM2_PWMA02 of instance: flexpwm2
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: SAI2_RX_BCLK of instance: sai2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: FLEXCAN2_RX of instance: flexcan2
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO10 of instance: flexio1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO10 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: FLEXSPI2_B_SS0_B of instance: flexspi2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_10
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_11 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_11: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_ADDR02 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM2_PWMB02 of instance: flexpwm2
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPI2C4_SDA of instance: lpi2c4
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: USDHC2_RESET_B of instance: usdhc2
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO11 of instance: flexio1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO11 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: FLEXSPI2_B_DQS of instance: flexspi2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_11
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_12 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_12: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_ADDR03 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_IN24 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPI2C4_SCL of instance: lpi2c4
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: USDHC1_WP of instance: usdhc1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXPWM1_PWMA03 of instance: flexpwm1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO12 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: FLEXSPI2_B_SCLK of instance: flexspi2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_12
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_13 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_13: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_ADDR04 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_IN25 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART3_TX of instance: lpuart3
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: MQS_RIGHT of instance: mqs
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXPWM1_PWMB03 of instance: flexpwm1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO13 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: FLEXSPI2_B_DATA00 of instance: flexspi2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_13
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_14 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_14: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_ADDR05 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_INOUT19 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART3_RX of instance: lpuart3
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: MQS_LEFT of instance: mqs
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: LPSPI2_PCS1 of instance: lpspi2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO14 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: FLEXSPI2_B_DATA01 of instance: flexspi2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_14
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_15 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_15: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_ADDR06 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_IN20 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART3_CTS_B of instance: lpuart3
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SPDIF_OUT of instance: spdif
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: QTIMER3_TIMER0 of instance: qtimer3
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO15 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: FLEXSPI2_B_DATA02 of instance: flexspi2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_15
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_16 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_16: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_ADDR07 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_IN21 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART3_RTS_B of instance: lpuart3
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SPDIF_IN of instance: spdif
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: QTIMER3_TIMER1 of instance: qtimer3
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO16 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: FLEXSPI2_B_DATA03 of instance: flexspi2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_16
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_17 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_17: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SEMC_ADDR08 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM4_PWMA03 of instance: flexpwm4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART4_CTS_B of instance: lpuart4
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: FLEXCAN1_TX of instance: flexcan1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: QTIMER3_TIMER2 of instance: qtimer3
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO17 of instance: gpio4
                    ALT5 = 0x5,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_17
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_18 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_18: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SEMC_ADDR09 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM4_PWMB03 of instance: flexpwm4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART4_RTS_B of instance: lpuart4
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: FLEXCAN1_RX of instance: flexcan1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: QTIMER3_TIMER3 of instance: qtimer3
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO18 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: SNVS_VIO_5_CTL of instance: snvs_hp
                    ALT6 = 0x6,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_18
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_19 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_19: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SEMC_ADDR11 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM2_PWMA03 of instance: flexpwm2
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART4_TX of instance: lpuart4
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_RDATA01 of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: QTIMER2_TIMER0 of instance: qtimer2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO19 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: SNVS_VIO_5 of instance: snvs_hp
                    ALT6 = 0x6,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_19
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_20 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_20: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SEMC_ADDR12 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM2_PWMB03 of instance: flexpwm2
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART4_RX of instance: lpuart4
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_RDATA00 of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: QTIMER2_TIMER1 of instance: qtimer2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO20 of instance: gpio4
                    ALT5 = 0x5,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_20
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_21 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_21: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SEMC_BA0 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM3_PWMA03 of instance: flexpwm3
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPI2C3_SDA of instance: lpi2c3
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_TDATA01 of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: QTIMER2_TIMER2 of instance: qtimer2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO21 of instance: gpio4
                    ALT5 = 0x5,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_21
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_22 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_22: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_BA1 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM3_PWMB03 of instance: flexpwm3
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPI2C3_SCL of instance: lpi2c3
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_TDATA00 of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: QTIMER2_TIMER3 of instance: qtimer2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO22 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: FLEXSPI2_A_SS1_B of instance: flexspi2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_22
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_23 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_23: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_ADDR10 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM1_PWMA00 of instance: flexpwm1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART5_TX of instance: lpuart5
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_RX_EN of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: GPT1_CAPTURE2 of instance: gpt1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO23 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: FLEXSPI2_A_DQS of instance: flexspi2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_23
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_24 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_24: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_CAS of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM1_PWMB00 of instance: flexpwm1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART5_RX of instance: lpuart5
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_TX_EN of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: GPT1_CAPTURE1 of instance: gpt1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO24 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: FLEXSPI2_A_SS0_B of instance: flexspi2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_24
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_25 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_25: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_RAS of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM1_PWMA01 of instance: flexpwm1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART6_TX of instance: lpuart6
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_TX_CLK of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: ENET_REF_CLK of instance: enet
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO25 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: FLEXSPI2_A_SCLK of instance: flexspi2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_25
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_26 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_26: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_CLK of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM1_PWMB01 of instance: flexpwm1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART6_RX of instance: lpuart6
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_RX_ER of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO12 of instance: flexio1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO26 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: FLEXSPI2_A_DATA00 of instance: flexspi2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_26
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_27 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_27: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_CKE of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM1_PWMA02 of instance: flexpwm1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART5_RTS_B of instance: lpuart5
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: LPSPI1_SCK of instance: lpspi1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO13 of instance: flexio1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO27 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: FLEXSPI2_A_DATA01 of instance: flexspi2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_27
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_28 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_28: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_WE of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM1_PWMB02 of instance: flexpwm1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART5_CTS_B of instance: lpuart5
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: LPSPI1_SDO of instance: lpspi1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO14 of instance: flexio1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO28 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: FLEXSPI2_A_DATA02 of instance: flexspi2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_28
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_29 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_29: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_CS0 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM3_PWMA00 of instance: flexpwm3
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART6_RTS_B of instance: lpuart6
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: LPSPI1_SDI of instance: lpspi1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO15 of instance: flexio1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO29 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: FLEXSPI2_A_DATA03 of instance: flexspi2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_29
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_30 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_30: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_DATA08 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM3_PWMB00 of instance: flexpwm3
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART6_CTS_B of instance: lpuart6
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: LPSPI1_PCS0 of instance: lpspi1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA23 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO30 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: ENET2_TDATA00 of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_30
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_31 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_31: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_DATA09 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM3_PWMA01 of instance: flexpwm3
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART7_TX of instance: lpuart7
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: LPSPI1_PCS1 of instance: lpspi1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA22 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO4_IO31 of instance: gpio4
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: ENET2_TDATA01 of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_31
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_32 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_32: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_DATA10 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM3_PWMB01 of instance: flexpwm3
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART7_RX of instance: lpuart7
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: CCM_PMIC_RDY of instance: ccm
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA21 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO18 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: ENET2_TX_EN of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_32
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_33 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_33: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_DATA11 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM3_PWMA02 of instance: flexpwm3
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: USDHC1_RESET_B of instance: usdhc1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI3_RX_DATA of instance: sai3
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA20 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO19 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: ENET2_TX_CLK of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: ENET2_REF_CLK2 of instance: enet2
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_33
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_34 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_34: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_DATA12 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM3_PWMB02 of instance: flexpwm3
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: USDHC1_VSELECT of instance: usdhc1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI3_RX_SYNC of instance: sai3
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA19 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO20 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: ENET2_RX_ER of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_34
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_35 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_35: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_DATA13 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_INOUT18 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: GPT1_COMPARE1 of instance: gpt1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI3_RX_BCLK of instance: sai3
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA18 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO21 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC1_CD_B of instance: usdhc1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_RDATA00 of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_35
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_36 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_36: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_DATA14 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_IN22 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: GPT1_COMPARE2 of instance: gpt1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI3_TX_DATA of instance: sai3
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA17 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO22 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC1_WP of instance: usdhc1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_RDATA01 of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXCAN3_TX of instance: flexcan3/canfd
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_36
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_37 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_37: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_DATA15 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_IN23 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: GPT1_COMPARE3 of instance: gpt1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI3_MCLK of instance: sai3
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA16 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO23 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC2_WP of instance: usdhc2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_RX_EN of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXCAN3_RX of instance: flexcan3/canfd
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_37
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_38 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_38: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_DM01 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM1_PWMA03 of instance: flexpwm1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART8_TX of instance: lpuart8
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI3_TX_BCLK of instance: sai3
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_FIELD of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO24 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC2_VSELECT of instance: usdhc2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_MDC of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_38
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_39 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_39: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_DQS of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM1_PWMB03 of instance: flexpwm1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART8_RX of instance: lpuart8
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI3_TX_SYNC of instance: sai3
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: WDOG1_WDOG_B of instance: wdog1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO25 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC2_CD_B of instance: usdhc2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_MDIO of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: SEMC_DQS4 of instance: semc
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_39
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_40 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_40: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: SEMC_RDY of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: GPT2_CAPTURE2 of instance: gpt2
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPSPI1_PCS2 of instance: lpspi1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: USB_OTG2_OC of instance: usb
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: ENET_MDC of instance: enet
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO26 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC2_RESET_B of instance: usdhc2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT9 mux port: SEMC_CLK5 of instance: semc
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_40
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_EMC_41 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_EMC_41: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SEMC_CSX00 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: GPT2_CAPTURE1 of instance: gpt2
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPSPI1_PCS3 of instance: lpspi1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: USB_OTG2_PWR of instance: usb
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: ENET_MDIO of instance: enet
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO27 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC1_VSELECT of instance: usdhc1
                    ALT6 = 0x6,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_EMC_41
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B0_00 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B0_00: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXPWM2_PWMA03 of instance: flexpwm2
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_INOUT14 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: REF_CLK_32K of instance: xtalosc
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: USB_OTG2_ID of instance: usb
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: LPI2C1_SCLS of instance: lpi2c1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO00 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC1_RESET_B of instance: usdhc1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: LPSPI3_SCK of instance: lpspi3
                    ALT7 = 0x7,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B0_00
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B0_01 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B0_01: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXPWM2_PWMB03 of instance: flexpwm2
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_INOUT15 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: REF_CLK_24M of instance: anatop
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: USB_OTG1_ID of instance: anatop
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: LPI2C1_SDAS of instance: lpi2c1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO01 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: EWM_OUT_B of instance: ewm
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: LPSPI3_SDO of instance: lpspi3
                    ALT7 = 0x7,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B0_01
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B0_02 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B0_02: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXCAN2_TX of instance: flexcan2
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_INOUT16 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART6_TX of instance: lpuart6
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: USB_OTG1_PWR of instance: usb
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXPWM1_PWMX00 of instance: flexpwm1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO02 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: LPI2C1_HREQ of instance: lpi2c1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: LPSPI3_SDI of instance: lpspi3
                    ALT7 = 0x7,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B0_02
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B0_03 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B0_03: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXCAN2_RX of instance: flexcan2
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_INOUT17 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART6_RX of instance: lpuart6
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: USB_OTG1_OC of instance: usb
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXPWM1_PWMX01 of instance: flexpwm1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO03 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: REF_CLK_24M of instance: anatop
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: LPSPI3_PCS0 of instance: lpspi3
                    ALT7 = 0x7,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B0_03
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B0_04 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B0_04: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SRC_BOOT_MODE00 of instance: src
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: MQS_RIGHT of instance: mqs
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: ENET_TX_DATA03 of instance: enet
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI2_TX_SYNC of instance: sai2
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA09 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO04 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: PIT_TRIGGER00 of instance: pit
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: LPSPI3_PCS1 of instance: lpspi3
                    ALT7 = 0x7,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B0_04
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B0_05 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B0_05: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SRC_BOOT_MODE01 of instance: src
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: MQS_LEFT of instance: mqs
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: ENET_TX_DATA02 of instance: enet
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI2_TX_BCLK of instance: sai2
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA08 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO05 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: XBAR1_INOUT17 of instance: xbar1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: LPSPI3_PCS2 of instance: lpspi3
                    ALT7 = 0x7,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B0_05
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B0_06 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B0_06: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: JTAG_TMS of instance: jtag_mux
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: GPT2_COMPARE1 of instance: gpt2
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: ENET_RX_CLK of instance: enet
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI2_RX_BCLK of instance: sai2
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA07 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO06 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: XBAR1_INOUT18 of instance: xbar1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: LPSPI3_PCS3 of instance: lpspi3
                    ALT7 = 0x7,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B0_06
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B0_07 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B0_07: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: JTAG_TCK of instance: jtag_mux
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: GPT2_COMPARE2 of instance: gpt2
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: ENET_TX_ER of instance: enet
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI2_RX_SYNC of instance: sai2
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA06 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO07 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: XBAR1_INOUT19 of instance: xbar1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: ENET_1588_EVENT3_OUT of instance: enet
                    ALT7 = 0x7,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B0_07
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B0_08 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B0_08: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: JTAG_MOD of instance: jtag_mux
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: GPT2_COMPARE3 of instance: gpt2
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: ENET_RX_DATA03 of instance: enet
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI2_RX_DATA of instance: sai2
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA05 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO08 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: XBAR1_IN20 of instance: xbar1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: ENET_1588_EVENT3_IN of instance: enet
                    ALT7 = 0x7,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B0_08
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B0_09 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B0_09: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: JTAG_TDI of instance: jtag_mux
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM2_PWMA03 of instance: flexpwm2
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: ENET_RX_DATA02 of instance: enet
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI2_TX_DATA of instance: sai2
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA04 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO09 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: XBAR1_IN21 of instance: xbar1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: GPT2_CLK of instance: gpt2
                    ALT7 = 0x7,
                    /// Select mux mode: ALT9 mux port: SEMC_DQS4 of instance: semc
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B0_09
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B0_10 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B0_10: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: JTAG_TDO of instance: jtag_mux
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM1_PWMA03 of instance: flexpwm1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: ENET_CRS of instance: enet
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI2_MCLK of instance: sai2
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA03 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO10 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: XBAR1_IN22 of instance: xbar1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: ENET_1588_EVENT0_OUT of instance: enet
                    ALT7 = 0x7,
                    /// Select mux mode: ALT8 mux port: FLEXCAN3_TX of instance: flexcan3/canfd
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: ARM_TRACE_SWO of instance: cm7_mx6rt
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B0_10
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B0_11 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B0_11: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: JTAG_TRSTB of instance: jtag_mux
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM1_PWMB03 of instance: flexpwm1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: ENET_COL of instance: enet
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: WDOG1_WDOG_B of instance: wdog1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA02 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO11 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: XBAR1_IN23 of instance: xbar1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: ENET_1588_EVENT0_IN of instance: enet
                    ALT7 = 0x7,
                    /// Select mux mode: ALT8 mux port: FLEXCAN3_RX of instance: flexcan3/canfd
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: SEMC_CLK6 of instance: semc
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B0_11
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B0_12 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B0_12: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: LPI2C4_SCL of instance: lpi2c4
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: CCM_PMIC_READY of instance: ccm
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART1_TX of instance: lpuart1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: WDOG2_WDOG_B of instance: wdog2
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXPWM1_PWMX02 of instance: flexpwm1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO12 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: ENET_1588_EVENT1_OUT of instance: enet
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: NMI_GLUE_NMI of instance: nmi_glue
                    ALT7 = 0x7,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B0_12
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B0_13 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B0_13: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: LPI2C4_SDA of instance: lpi2c4
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: GPT1_CLK of instance: gpt1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART1_RX of instance: lpuart1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: EWM_OUT_B of instance: ewm
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXPWM1_PWMX03 of instance: flexpwm1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO13 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: ENET_1588_EVENT1_IN of instance: enet
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: REF_CLK_24M of instance: anatop
                    ALT7 = 0x7,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B0_13
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B0_14 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B0_14: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USB_OTG2_OC of instance: usb
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_IN24 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART1_CTS_B of instance: lpuart1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_1588_EVENT0_OUT of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_VSYNC of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO14 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: FLEXCAN2_TX of instance: flexcan2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: FLEXCAN3_TX of instance: flexcan3/canfd
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B0_14
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B0_15 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B0_15: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USB_OTG2_PWR of instance: usb
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_IN25 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART1_RTS_B of instance: lpuart1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_1588_EVENT0_IN of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_HSYNC of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO15 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: FLEXCAN2_RX of instance: flexcan2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: WDOG1_WDOG_RST_B_DEB of instance: wdog1
                    ALT7 = 0x7,
                    /// Select mux mode: ALT8 mux port: FLEXCAN3_RX of instance: flexcan3/canfd
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B0_15
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B1_00 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B1_00: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USB_OTG2_ID of instance: anatop
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER3_TIMER0 of instance: qtimer3
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART2_CTS_B of instance: lpuart2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: LPI2C1_SCL of instance: lpi2c1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: WDOG1_B of instance: wdog1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO16 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC1_WP of instance: usdhc1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: KPP_ROW07 of instance: kpp
                    ALT7 = 0x7,
                    /// Select mux mode: ALT8 mux port: ENET2_1588_EVENT0_OUT of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO00 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B1_00
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B1_01 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B1_01: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USB_OTG1_PWR of instance: usb
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER3_TIMER1 of instance: qtimer3
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART2_RTS_B of instance: lpuart2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: LPI2C1_SDA of instance: lpi2c1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CCM_PMIC_READY of instance: ccm
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO17 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC1_VSELECT of instance: usdhc1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: KPP_COL07 of instance: kpp
                    ALT7 = 0x7,
                    /// Select mux mode: ALT8 mux port: ENET2_1588_EVENT0_IN of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO01 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B1_01
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B1_02 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B1_02: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USB_OTG1_ID of instance: anatop
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER3_TIMER2 of instance: qtimer3
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART2_TX of instance: lpuart2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SPDIF_OUT of instance: spdif
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: ENET_1588_EVENT2_OUT of instance: enet
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO18 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC1_CD_B of instance: usdhc1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: KPP_ROW06 of instance: kpp
                    ALT7 = 0x7,
                    /// Select mux mode: ALT8 mux port: GPT2_CLK of instance: gpt2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO02 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B1_02
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B1_03 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B1_03: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USB_OTG1_OC of instance: usb
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER3_TIMER3 of instance: qtimer3
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART2_RX of instance: lpuart2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SPDIF_IN of instance: spdif
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: ENET_1588_EVENT2_IN of instance: enet
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO19 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC2_CD_B of instance: usdhc2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: KPP_COL06 of instance: kpp
                    ALT7 = 0x7,
                    /// Select mux mode: ALT8 mux port: GPT2_CAPTURE1 of instance: gpt2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO03 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B1_03
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B1_04 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B1_04: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: FLEXSPIB_DATA03 of instance: flexspi
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: ENET_MDC of instance: enet
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART3_CTS_B of instance: lpuart3
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SPDIF_SR_CLK of instance: spdif
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_PIXCLK of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO20 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC2_DATA0 of instance: usdhc2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: KPP_ROW05 of instance: kpp
                    ALT7 = 0x7,
                    /// Select mux mode: ALT8 mux port: GPT2_CAPTURE2 of instance: gpt2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO04 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B1_04
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B1_05 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B1_05: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: FLEXSPIB_DATA02 of instance: flexspi
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: ENET_MDIO of instance: enet
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART3_RTS_B of instance: lpuart3
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SPDIF_OUT of instance: spdif
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_MCLK of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO21 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC2_DATA1 of instance: usdhc2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: KPP_COL05 of instance: kpp
                    ALT7 = 0x7,
                    /// Select mux mode: ALT8 mux port: GPT2_COMPARE1 of instance: gpt2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO05 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B1_05
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B1_06 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B1_06: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: FLEXSPIB_DATA01 of instance: flexspi
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: LPI2C3_SDA of instance: lpi2c3
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART3_TX of instance: lpuart3
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SPDIF_LOCK of instance: spdif
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_VSYNC of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO22 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC2_DATA2 of instance: usdhc2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: KPP_ROW04 of instance: kpp
                    ALT7 = 0x7,
                    /// Select mux mode: ALT8 mux port: GPT2_COMPARE2 of instance: gpt2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO06 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B1_06
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B1_07 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B1_07: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: FLEXSPIB_DATA00 of instance: flexspi
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: LPI2C3_SCL of instance: lpi2c3
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART3_RX of instance: lpuart3
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SPDIF_EXT_CLK of instance: spdif
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_HSYNC of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO23 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC2_DATA3 of instance: usdhc2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: KPP_COL04 of instance: kpp
                    ALT7 = 0x7,
                    /// Select mux mode: ALT8 mux port: GPT2_COMPARE3 of instance: gpt2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO07 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B1_07
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B1_08 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B1_08: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: FLEXSPIA_SS1_B of instance: flexspi
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM4_PWMA00 of instance: flexpwm4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: FLEXCAN1_TX of instance: flexcan1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: CCM_PMIC_READY of instance: ccm
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA09 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO24 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC2_CMD of instance: usdhc2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: KPP_ROW03 of instance: kpp
                    ALT7 = 0x7,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO08 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B1_08
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B1_09 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B1_09: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: FLEXSPIA_DQS of instance: flexspi
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM4_PWMA01 of instance: flexpwm4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: FLEXCAN1_RX of instance: flexcan1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_MCLK of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA08 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO25 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC2_CLK of instance: usdhc2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: KPP_COL03 of instance: kpp
                    ALT7 = 0x7,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO09 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B1_09
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B1_10 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B1_10: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: FLEXSPIA_DATA03 of instance: flexspi
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: WDOG1_B of instance: wdog1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART8_TX of instance: lpuart8
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_RX_SYNC of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA07 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO26 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC2_WP of instance: usdhc2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: KPP_ROW02 of instance: kpp
                    ALT7 = 0x7,
                    /// Select mux mode: ALT8 mux port: ENET2_1588_EVENT1_OUT of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO10 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B1_10
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B1_11 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B1_11: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: FLEXSPIA_DATA02 of instance: flexspi
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: EWM_OUT_B of instance: ewm
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART8_RX of instance: lpuart8
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_RX_BCLK of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA06 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO27 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC2_RESET_B of instance: usdhc2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: KPP_COL02 of instance: kpp
                    ALT7 = 0x7,
                    /// Select mux mode: ALT8 mux port: ENET2_1588_EVENT1_IN of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO11 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B1_11
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B1_12 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B1_12: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: FLEXSPIA_DATA01 of instance: flexspi
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: ACMP_OUT00 of instance: acmp
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPSPI3_PCS0 of instance: lpspi3
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_RX_DATA00 of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA05 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO28 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC2_DATA4 of instance: usdhc2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: KPP_ROW01 of instance: kpp
                    ALT7 = 0x7,
                    /// Select mux mode: ALT8 mux port: ENET2_1588_EVENT2_OUT of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO12 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B1_12
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B1_13 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B1_13: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: FLEXSPIA_DATA00 of instance: flexspi
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: ACMP_OUT01 of instance: acmp
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPSPI3_SDI of instance: lpspi3
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_TX_DATA00 of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA04 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO29 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC2_DATA5 of instance: usdhc2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: KPP_COL01 of instance: kpp
                    ALT7 = 0x7,
                    /// Select mux mode: ALT8 mux port: ENET2_1588_EVENT2_IN of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO13 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B1_13
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B1_14 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B1_14: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: FLEXSPIA_SCLK of instance: flexspi
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: ACMP_OUT02 of instance: acmp
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPSPI3_SDO of instance: lpspi3
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_TX_BCLK of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA03 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO30 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC2_DATA6 of instance: usdhc2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: KPP_ROW00 of instance: kpp
                    ALT7 = 0x7,
                    /// Select mux mode: ALT8 mux port: ENET2_1588_EVENT3_OUT of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO14 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B1_14
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_AD_B1_15 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_AD_B1_15: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: FLEXSPIA_SS0_B of instance: flexspi
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: ACMP_OUT03 of instance: acmp
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPSPI3_SCK of instance: lpspi3
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_TX_SYNC of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: CSI_DATA02 of instance: csi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO1_IO31 of instance: gpio1
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC2_DATA7 of instance: usdhc2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT7 mux port: KPP_COL00 of instance: kpp
                    ALT7 = 0x7,
                    /// Select mux mode: ALT8 mux port: ENET2_1588_EVENT3_IN of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO15 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_AD_B1_15
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B0_00 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B0_00: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_CLK of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER1_TIMER0 of instance: qtimer1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: MQS_RIGHT of instance: mqs
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: LPSPI4_PCS0 of instance: lpspi4
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO00 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO00 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: SEMC_CSX01 of instance: semc
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_MDC of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B0_00
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B0_01 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B0_01: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_ENABLE of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER1_TIMER1 of instance: qtimer1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: MQS_LEFT of instance: mqs
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: LPSPI4_SDI of instance: lpspi4
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO01 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO01 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: SEMC_CSX02 of instance: semc
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_MDIO of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B0_01
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B0_02 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B0_02: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_HSYNC of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER1_TIMER2 of instance: qtimer1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: FLEXCAN1_TX of instance: flexcan1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: LPSPI4_SDO of instance: lpspi4
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO02 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO02 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: SEMC_CSX03 of instance: semc
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_1588_EVENT0_OUT of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B0_02
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B0_03 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B0_03: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_VSYNC of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER2_TIMER0 of instance: qtimer2
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: FLEXCAN1_RX of instance: flexcan1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: LPSPI4_SCK of instance: lpspi4
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO03 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO03 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: WDOG2_RESET_B_DEB of instance: wdog2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_1588_EVENT0_IN of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B0_03
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B0_04 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B0_04: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA00 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER2_TIMER1 of instance: qtimer2
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPI2C2_SCL of instance: lpi2c2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ARM_TRACE0 of instance: cm7_mx6rt
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO04 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO04 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: SRC_BOOT_CFG00 of instance: src
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_TDATA03 of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B0_04
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B0_05 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B0_05: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA01 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER2_TIMER2 of instance: qtimer2
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPI2C2_SDA of instance: lpi2c2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ARM_TRACE1 of instance: cm7_mx6rt
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO05 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO05 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: SRC_BOOT_CFG01 of instance: src
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_TDATA02 of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B0_05
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B0_06 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B0_06: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA02 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER3_TIMER0 of instance: qtimer3
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: FLEXPWM2_PWMA00 of instance: flexpwm2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ARM_TRACE2 of instance: cm7_mx6rt
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO06 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO06 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: SRC_BOOT_CFG02 of instance: src
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_RX_CLK of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B0_06
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B0_07 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B0_07: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA03 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER3_TIMER1 of instance: qtimer3
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: FLEXPWM2_PWMB00 of instance: flexpwm2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ARM_TRACE3 of instance: cm7_mx6rt
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO07 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO07 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: SRC_BOOT_CFG03 of instance: src
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_TX_ER of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B0_07
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B0_08 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B0_08: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA04 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER3_TIMER2 of instance: qtimer3
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: FLEXPWM2_PWMA01 of instance: flexpwm2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: LPUART3_TX of instance: lpuart3
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO08 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO08 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: SRC_BOOT_CFG04 of instance: src
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_RDATA03 of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B0_08
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B0_09 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B0_09: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA05 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER4_TIMER0 of instance: qtimer4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: FLEXPWM2_PWMB01 of instance: flexpwm2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: LPUART3_RX of instance: lpuart3
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO09 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO09 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: SRC_BOOT_CFG05 of instance: src
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_RDATA02 of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B0_09
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B0_10 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B0_10: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA06 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER4_TIMER1 of instance: qtimer4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: FLEXPWM2_PWMA02 of instance: flexpwm2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_TX_DATA03 of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO10 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO10 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: SRC_BOOT_CFG06 of instance: src
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_CRS of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B0_10
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B0_11 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B0_11: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA07 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER4_TIMER2 of instance: qtimer4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: FLEXPWM2_PWMB02 of instance: flexpwm2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_TX_DATA02 of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO11 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO11 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: SRC_BOOT_CFG07 of instance: src
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_COL of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B0_11
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B0_12 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B0_12: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA08 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_INOUT10 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: ARM_TRACE_CLK of instance: cm7_mx6rt
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_TX_DATA01 of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO12 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO12 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: SRC_BOOT_CFG08 of instance: src
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_TDATA00 of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B0_12
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B0_13 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B0_13: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA09 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_INOUT11 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: ARM_TRACE_SWO of instance: cm7_mx6rt
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_MCLK of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO13 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO13 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: SRC_BOOT_CFG09 of instance: src
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_TDATA01 of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B0_13
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B0_14 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B0_14: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA10 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_INOUT12 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: ARM_TXEV of instance: cm7_mx6rt
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_RX_SYNC of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO14 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO14 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: SRC_BOOT_CFG10 of instance: src
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_TX_EN of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B0_14
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B0_15 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B0_15: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA11 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_INOUT13 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: ARM_RXEV of instance: cm7_mx6rt
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_RX_BCLK of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO15 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO15 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: SRC_BOOT_CFG11 of instance: src
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_TX_CLK of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: ENET2_REF_CLK2 of instance: enet2
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B0_15
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B1_00 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B1_00: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA12 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_INOUT14 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART4_TX of instance: lpuart4
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_RX_DATA00 of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO16 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO16 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: FLEXPWM1_PWMA03 of instance: flexpwm1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_RX_ER of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO16 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B1_00
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B1_01 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B1_01: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA13 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_INOUT15 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART4_RX of instance: lpuart4
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_TX_DATA00 of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO17 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO17 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: FLEXPWM1_PWMB03 of instance: flexpwm1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_RDATA00 of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO17 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B1_01
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B1_02 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B1_02: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA14 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_INOUT16 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPSPI4_PCS2 of instance: lpspi4
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_TX_BCLK of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO18 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO18 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: FLEXPWM2_PWMA03 of instance: flexpwm2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_RDATA01 of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO18 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B1_02
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B1_03 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B1_03: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA15 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: XBAR1_INOUT17 of instance: xbar1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPSPI4_PCS1 of instance: lpspi4
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_TX_SYNC of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO19 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO19 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: FLEXPWM2_PWMB03 of instance: flexpwm2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_RX_EN of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO19 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B1_03
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B1_04 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B1_04: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA16 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: LPSPI4_PCS0 of instance: lpspi4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: CSI_DATA15 of instance: csi
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_RX_DATA00 of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO20 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO20 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: GPT1_CLK of instance: gpt1
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO20 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B1_04
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B1_05 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B1_05: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA17 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: LPSPI4_SDI of instance: lpspi4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: CSI_DATA14 of instance: csi
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_RX_DATA01 of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO21 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO21 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: GPT1_CAPTURE1 of instance: gpt1
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO21 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B1_05
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B1_06 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B1_06: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA18 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: LPSPI4_SDO of instance: lpspi4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: CSI_DATA13 of instance: csi
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_RX_EN of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO22 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO22 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: GPT1_CAPTURE2 of instance: gpt1
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO22 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B1_06
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B1_07 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B1_07: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA19 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: LPSPI4_SCK of instance: lpspi4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: CSI_DATA12 of instance: csi
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_TX_DATA00 of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO23 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO23 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: GPT1_COMPARE1 of instance: gpt1
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO23 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B1_07
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B1_08 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B1_08: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA20 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER1_TIMER3 of instance: qtimer1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: CSI_DATA11 of instance: csi
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_TX_DATA01 of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO24 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO24 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: FLEXCAN2_TX of instance: flexcan2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: GPT1_COMPARE2 of instance: gpt1
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO24 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B1_08
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B1_09 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B1_09: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA21 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER2_TIMER3 of instance: qtimer2
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: CSI_DATA10 of instance: csi
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_TX_EN of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO25 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO25 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: FLEXCAN2_RX of instance: flexcan2
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: GPT1_COMPARE3 of instance: gpt1
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO25 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B1_09
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B1_10 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B1_10: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA22 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER3_TIMER3 of instance: qtimer3
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: CSI_DATA00 of instance: csi
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_TX_CLK of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO26 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO26 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: ENET_REF_CLK of instance: enet
                    ALT6 = 0x6,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO26 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B1_10
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B1_11 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B1_11: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: LCD_DATA23 of instance: lcdif
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: QTIMER4_TIMER3 of instance: qtimer4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: CSI_DATA01 of instance: csi
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_RX_ER of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO27 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO27 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: LPSPI4_PCS3 of instance: lpspi4
                    ALT6 = 0x6,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO27 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B1_11
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B1_12 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B1_12: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT1 mux port: LPUART5_TX of instance: lpuart5
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: CSI_PIXCLK of instance: csi
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_1588_EVENT0_IN of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO28 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO28 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC1_CD_B of instance: usdhc1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO28 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B1_12
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B1_13 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B1_13: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: WDOG1_B of instance: wdog1
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: LPUART5_RX of instance: lpuart5
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: CSI_VSYNC of instance: csi
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: ENET_1588_EVENT0_OUT of instance: enet
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO29 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO29 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC1_WP of instance: usdhc1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: SEMC_DQS4 of instance: semc
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO29 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B1_13
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B1_14 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B1_14: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: ENET_MDC of instance: enet
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM4_PWMA02 of instance: flexpwm4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: CSI_HSYNC of instance: csi
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: XBAR1_IN02 of instance: xbar1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO30 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO30 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC1_VSELECT of instance: usdhc1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_TDATA00 of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO30 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B1_14
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_B1_15 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_B1_15: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: ENET_MDIO of instance: enet
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM4_PWMA03 of instance: flexpwm4
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: CSI_MCLK of instance: csi
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: XBAR1_IN03 of instance: xbar1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO31 of instance: flexio2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO2_IO31 of instance: gpio2
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: USDHC1_RESET_B of instance: usdhc1
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_TDATA01 of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO31 of instance: flexio3
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_B1_15
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SD_B0_00 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SD_B0_00: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USDHC1_CMD of instance: usdhc1
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM1_PWMA00 of instance: flexpwm1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPI2C3_SCL of instance: lpi2c3
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: XBAR1_INOUT04 of instance: xbar1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: LPSPI1_SCK of instance: lpspi1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO12 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: FLEXSPIA_SS1_B of instance: flexspi
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_TX_EN of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: SEMC_DQS4 of instance: semc
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SD_B0_00
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SD_B0_01 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SD_B0_01: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USDHC1_CLK of instance: usdhc1
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM1_PWMB00 of instance: flexpwm1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPI2C3_SDA of instance: lpi2c3
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: XBAR1_INOUT05 of instance: xbar1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: LPSPI1_PCS0 of instance: lpspi1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO13 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: FLEXSPIB_SS1_B of instance: flexspi
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_TX_CLK of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: ENET2_REF_CLK2 of instance: enet2
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SD_B0_01
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SD_B0_02 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SD_B0_02: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USDHC1_DATA0 of instance: usdhc1
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM1_PWMA01 of instance: flexpwm1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART8_CTS_B of instance: lpuart8
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: XBAR1_INOUT06 of instance: xbar1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: LPSPI1_SDO of instance: lpspi1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO14 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: ENET2_RX_ER of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: SEMC_CLK5 of instance: semc
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SD_B0_02
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SD_B0_03 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SD_B0_03: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USDHC1_DATA1 of instance: usdhc1
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM1_PWMB01 of instance: flexpwm1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART8_RTS_B of instance: lpuart8
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: XBAR1_INOUT07 of instance: xbar1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: LPSPI1_SDI of instance: lpspi1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO15 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: ENET2_RDATA00 of instance: enet2
                    ALT8 = 0x8,
                    /// Select mux mode: ALT9 mux port: SEMC_CLK6 of instance: semc
                    ALT9 = 0x9,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SD_B0_03
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SD_B0_04 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SD_B0_04: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USDHC1_DATA2 of instance: usdhc1
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM1_PWMA02 of instance: flexpwm1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART8_TX of instance: lpuart8
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: XBAR1_INOUT08 of instance: xbar1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXSPIB_SS0_B of instance: flexspi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO16 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: CCM_CLKO1 of instance: ccm
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_RDATA01 of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SD_B0_04
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SD_B0_05 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SD_B0_05: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USDHC1_DATA3 of instance: usdhc1
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXPWM1_PWMB02 of instance: flexpwm1
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART8_RX of instance: lpuart8
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: XBAR1_INOUT09 of instance: xbar1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXSPIB_DQS of instance: flexspi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO17 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: CCM_CLKO2 of instance: ccm
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: ENET2_RX_EN of instance: enet2
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SD_B0_05
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SD_B1_00 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SD_B1_00: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USDHC2_DATA3 of instance: usdhc2
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXSPIB_DATA03 of instance: flexspi
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: FLEXPWM1_PWMA03 of instance: flexpwm1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_TX_DATA03 of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: LPUART4_TX of instance: lpuart4
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO00 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: SAI3_RX_DATA of instance: sai3
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SD_B1_00
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SD_B1_01 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SD_B1_01: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USDHC2_DATA2 of instance: usdhc2
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXSPIB_DATA02 of instance: flexspi
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: FLEXPWM1_PWMB03 of instance: flexpwm1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_TX_DATA02 of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: LPUART4_RX of instance: lpuart4
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO01 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: SAI3_TX_DATA of instance: sai3
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SD_B1_01
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SD_B1_02 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SD_B1_02: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USDHC2_DATA1 of instance: usdhc2
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXSPIB_DATA01 of instance: flexspi
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: FLEXPWM2_PWMA03 of instance: flexpwm2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_TX_DATA01 of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXCAN1_TX of instance: flexcan1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO02 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: CCM_WAIT of instance: ccm
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: SAI3_TX_SYNC of instance: sai3
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SD_B1_02
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SD_B1_03 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SD_B1_03: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USDHC2_DATA0 of instance: usdhc2
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXSPIB_DATA00 of instance: flexspi
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: FLEXPWM2_PWMB03 of instance: flexpwm2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_MCLK of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXCAN1_RX of instance: flexcan1
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO03 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: CCM_PMIC_READY of instance: ccm
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: SAI3_TX_BCLK of instance: sai3
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SD_B1_03
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SD_B1_04 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SD_B1_04: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USDHC2_CLK of instance: usdhc2
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXSPIB_SCLK of instance: flexspi
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPI2C1_SCL of instance: lpi2c1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_RX_SYNC of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXSPIA_SS1_B of instance: flexspi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO04 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: CCM_STOP of instance: ccm
                    ALT6 = 0x6,
                    /// Select mux mode: ALT8 mux port: SAI3_MCLK of instance: sai3
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SD_B1_04
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SD_B1_05 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SD_B1_05: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USDHC2_CMD of instance: usdhc2
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXSPIA_DQS of instance: flexspi
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPI2C1_SDA of instance: lpi2c1
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_RX_BCLK of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: FLEXSPIB_SS0_B of instance: flexspi
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO05 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: SAI3_RX_SYNC of instance: sai3
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SD_B1_05
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SD_B1_06 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SD_B1_06: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u4) {
                    /// Select mux mode: ALT0 mux port: USDHC2_RESET_B of instance: usdhc2
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXSPIA_SS0_B of instance: flexspi
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART7_CTS_B of instance: lpuart7
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_RX_DATA00 of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: LPSPI2_PCS0 of instance: lpspi2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO06 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT8 mux port: SAI3_RX_BCLK of instance: sai3
                    ALT8 = 0x8,
                    _,
                },
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SD_B1_06
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SD_B1_07 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SD_B1_07: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SEMC_CSX01 of instance: semc
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXSPIA_SCLK of instance: flexspi
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART7_RTS_B of instance: lpuart7
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_TX_DATA00 of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: LPSPI2_SCK of instance: lpspi2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO07 of instance: gpio3
                    ALT5 = 0x5,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SD_B1_07
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SD_B1_08 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SD_B1_08: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: USDHC2_DATA4 of instance: usdhc2
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXSPIA_DATA00 of instance: flexspi
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART7_TX of instance: lpuart7
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_TX_BCLK of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: LPSPI2_SD0 of instance: lpspi2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO08 of instance: gpio3
                    ALT5 = 0x5,
                    /// Select mux mode: ALT6 mux port: SEMC_CSX02 of instance: semc
                    ALT6 = 0x6,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SD_B1_08
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SD_B1_09 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SD_B1_09: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: USDHC2_DATA5 of instance: usdhc2
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXSPIA_DATA01 of instance: flexspi
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART7_RX of instance: lpuart7
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: SAI1_TX_SYNC of instance: sai1
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: LPSPI2_SDI of instance: lpspi2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO09 of instance: gpio3
                    ALT5 = 0x5,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SD_B1_09
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SD_B1_10 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SD_B1_10: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: USDHC2_DATA6 of instance: usdhc2
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXSPIA_DATA02 of instance: flexspi
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART2_RX of instance: lpuart2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: LPI2C2_SDA of instance: lpi2c2
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: LPSPI2_PCS2 of instance: lpspi2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO10 of instance: gpio3
                    ALT5 = 0x5,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SD_B1_10
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SD_B1_11 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SD_B1_11: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: USDHC2_DATA7 of instance: usdhc2
                    ALT0 = 0x0,
                    /// Select mux mode: ALT1 mux port: FLEXSPIA_DATA03 of instance: flexspi
                    ALT1 = 0x1,
                    /// Select mux mode: ALT2 mux port: LPUART2_TX of instance: lpuart2
                    ALT2 = 0x2,
                    /// Select mux mode: ALT3 mux port: LPI2C2_SCL of instance: lpi2c2
                    ALT3 = 0x3,
                    /// Select mux mode: ALT4 mux port: LPSPI2_PCS3 of instance: lpspi2
                    ALT4 = 0x4,
                    /// Select mux mode: ALT5 mux port: GPIO3_IO11 of instance: gpio3
                    ALT5 = 0x5,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SD_B1_11
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_00 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_00: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_01 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_01: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_02 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_02: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_03 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_03: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_04 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_04: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_05 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_05: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_06 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_06: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_07 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_07: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_08 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_08: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_09 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_09: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_10 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_10: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_11 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_11: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_12 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_12: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_13 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_13: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_14 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_14: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_15 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_15: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_16 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_16: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_17 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_17: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_18 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_18: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_19 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_19: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_20 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_20: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_21 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_21: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_22 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_22: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_23 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_23: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_24 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_24: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_25 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_25: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_26 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_26: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_27 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_27: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_28 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_28: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_29 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_29: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_30 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_30: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_31 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_31: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_32 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_32: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_33 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_33: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_34 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_34: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_35 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_35: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_36 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_36: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_37 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_37: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_38 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_38: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_39 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_39: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_40 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_40: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_EMC_41 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_EMC_41: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B0_00 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B0_00: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B0_01 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B0_01: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B0_02 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B0_02: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B0_03 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B0_03: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B0_04 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B0_04: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B0_05 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B0_05: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B0_06 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B0_06: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B0_07 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B0_07: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B0_08 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B0_08: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B0_09 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B0_09: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B0_10 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B0_10: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B0_11 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B0_11: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B0_12 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B0_12: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B0_13 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B0_13: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B0_14 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B0_14: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B0_15 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B0_15: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B1_00 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B1_00: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B1_01 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B1_01: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B1_02 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B1_02: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B1_03 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B1_03: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B1_04 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B1_04: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B1_05 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B1_05: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B1_06 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B1_06: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B1_07 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B1_07: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B1_08 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B1_08: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B1_09 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B1_09: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B1_10 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B1_10: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B1_11 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B1_11: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B1_12 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B1_12: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B1_13 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B1_13: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B1_14 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B1_14: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_AD_B1_15 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_AD_B1_15: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B0_00 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B0_00: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B0_01 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B0_01: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B0_02 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B0_02: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B0_03 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B0_03: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B0_04 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B0_04: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B0_05 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B0_05: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B0_06 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B0_06: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B0_07 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B0_07: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B0_08 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B0_08: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B0_09 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B0_09: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B0_10 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B0_10: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B0_11 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B0_11: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B0_12 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B0_12: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B0_13 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B0_13: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B0_14 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B0_14: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B0_15 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B0_15: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B1_00 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B1_00: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B1_01 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B1_01: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B1_02 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B1_02: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B1_03 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B1_03: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B1_04 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B1_04: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B1_05 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B1_05: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B1_06 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B1_06: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B1_07 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B1_07: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B1_08 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B1_08: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B1_09 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B1_09: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B1_10 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B1_10: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B1_11 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B1_11: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B1_12 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B1_12: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B1_13 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B1_13: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B1_14 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B1_14: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_B1_15 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_B1_15: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SD_B0_00 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SD_B0_00: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SD_B0_01 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SD_B0_01: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SD_B0_02 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SD_B0_02: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SD_B0_03 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SD_B0_03: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SD_B0_04 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SD_B0_04: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SD_B0_05 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SD_B0_05: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SD_B1_00 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SD_B1_00: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SD_B1_01 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SD_B1_01: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SD_B1_02 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SD_B1_02: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SD_B1_03 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SD_B1_03: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SD_B1_04 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SD_B1_04: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SD_B1_05 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SD_B1_05: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SD_B1_06 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SD_B1_06: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SD_B1_07 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SD_B1_07: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SD_B1_08 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SD_B1_08: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SD_B1_09 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SD_B1_09: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SD_B1_10 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SD_B1_10: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SD_B1_11 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SD_B1_11: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// ANATOP_USB_OTG1_ID_SELECT_INPUT DAISY Register
            ANATOP_USB_OTG1_ID_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B0_01 for Mode: ALT3
                    GPIO_AD_B0_01_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_02 for Mode: ALT0
                    GPIO_AD_B1_02_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// ANATOP_USB_OTG2_ID_SELECT_INPUT DAISY Register
            ANATOP_USB_OTG2_ID_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B0_00 for Mode: ALT3
                    GPIO_AD_B0_00_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_00 for Mode: ALT0
                    GPIO_AD_B1_00_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// CCM_PMIC_READY_SELECT_INPUT DAISY Register
            CCM_PMIC_READY_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u3) {
                    /// Selecting Pad: GPIO_SD_B1_03 for Mode: ALT6
                    GPIO_SD_B1_03_ALT6 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_12 for Mode: ALT1
                    GPIO_AD_B0_12_ALT1 = 0x1,
                    /// Selecting Pad: GPIO_AD_B1_01 for Mode: ALT4
                    GPIO_AD_B1_01_ALT4 = 0x2,
                    /// Selecting Pad: GPIO_AD_B1_08 for Mode: ALT3
                    GPIO_AD_B1_08_ALT3 = 0x3,
                    /// Selecting Pad: GPIO_EMC_32 for Mode: ALT3
                    GPIO_EMC_32_ALT3 = 0x4,
                    _,
                },
                padding: u29 = 0,
            }),
            /// CSI_DATA02_SELECT_INPUT DAISY Register
            CSI_DATA02_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B1_15 for Mode: ALT4
                    GPIO_AD_B1_15_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_11 for Mode: ALT4
                    GPIO_AD_B0_11_ALT4 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// CSI_DATA03_SELECT_INPUT DAISY Register
            CSI_DATA03_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B1_14 for Mode: ALT4
                    GPIO_AD_B1_14_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_10 for Mode: ALT4
                    GPIO_AD_B0_10_ALT4 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// CSI_DATA04_SELECT_INPUT DAISY Register
            CSI_DATA04_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B1_13 for Mode: ALT4
                    GPIO_AD_B1_13_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_09 for Mode: ALT4
                    GPIO_AD_B0_09_ALT4 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// CSI_DATA05_SELECT_INPUT DAISY Register
            CSI_DATA05_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B1_12 for Mode: ALT4
                    GPIO_AD_B1_12_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_08 for Mode: ALT4
                    GPIO_AD_B0_08_ALT4 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// CSI_DATA06_SELECT_INPUT DAISY Register
            CSI_DATA06_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B1_11 for Mode: ALT4
                    GPIO_AD_B1_11_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_07 for Mode: ALT4
                    GPIO_AD_B0_07_ALT4 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// CSI_DATA07_SELECT_INPUT DAISY Register
            CSI_DATA07_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B1_10 for Mode: ALT4
                    GPIO_AD_B1_10_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_06 for Mode: ALT4
                    GPIO_AD_B0_06_ALT4 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// CSI_DATA08_SELECT_INPUT DAISY Register
            CSI_DATA08_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B1_09 for Mode: ALT4
                    GPIO_AD_B1_09_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_05 for Mode: ALT4
                    GPIO_AD_B0_05_ALT4 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// CSI_DATA09_SELECT_INPUT DAISY Register
            CSI_DATA09_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B1_08 for Mode: ALT4
                    GPIO_AD_B1_08_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_04 for Mode: ALT4
                    GPIO_AD_B0_04_ALT4 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// CSI_HSYNC_SELECT_INPUT DAISY Register
            CSI_HSYNC_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_AD_B0_15 for Mode: ALT4
                    GPIO_AD_B0_15_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_07 for Mode: ALT4
                    GPIO_AD_B1_07_ALT4 = 0x1,
                    /// Selecting Pad: GPIO_B1_14 for Mode: ALT2
                    GPIO_B1_14_ALT2 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// CSI_PIXCLK_SELECT_INPUT DAISY Register
            CSI_PIXCLK_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B1_04 for Mode: ALT4
                    GPIO_AD_B1_04_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_B1_12 for Mode: ALT2
                    GPIO_B1_12_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// CSI_VSYNC_SELECT_INPUT DAISY Register
            CSI_VSYNC_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_AD_B0_14 for Mode: ALT4
                    GPIO_AD_B0_14_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_06 for Mode: ALT4
                    GPIO_AD_B1_06_ALT4 = 0x1,
                    /// Selecting Pad: GPIO_B1_13 for Mode: ALT2
                    GPIO_B1_13_ALT2 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// ENET_IPG_CLK_RMII_SELECT_INPUT DAISY Register
            ENET_IPG_CLK_RMII_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_25 for Mode: ALT4
                    GPIO_EMC_25_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_B1_10 for Mode: ALT6
                    GPIO_B1_10_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// ENET_MDIO_SELECT_INPUT DAISY Register
            ENET_MDIO_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_AD_B1_05 for Mode: ALT1
                    GPIO_AD_B1_05_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_EMC_41 for Mode: ALT4
                    GPIO_EMC_41_ALT4 = 0x1,
                    /// Selecting Pad: GPIO_B1_15 for Mode: ALT0
                    GPIO_B1_15_ALT0 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// ENET0_RXDATA_SELECT_INPUT DAISY Register
            ENET0_RXDATA_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_20 for Mode: ALT3
                    GPIO_EMC_20_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_B1_04 for Mode: ALT3
                    GPIO_B1_04_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// ENET1_RXDATA_SELECT_INPUT DAISY Register
            ENET1_RXDATA_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_19 for Mode: ALT3
                    GPIO_EMC_19_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_B1_05 for Mode: ALT3
                    GPIO_B1_05_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// ENET_RXEN_SELECT_INPUT DAISY Register
            ENET_RXEN_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_23 for Mode: ALT3
                    GPIO_EMC_23_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_B1_06 for Mode: ALT3
                    GPIO_B1_06_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// ENET_RXERR_SELECT_INPUT DAISY Register
            ENET_RXERR_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_26 for Mode: ALT3
                    GPIO_EMC_26_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_B1_11 for Mode: ALT3
                    GPIO_B1_11_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// ENET0_TIMER_SELECT_INPUT DAISY Register
            ENET0_TIMER_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_AD_B0_15 for Mode: ALT3
                    GPIO_AD_B0_15_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_11 for Mode: ALT7
                    GPIO_AD_B0_11_ALT7 = 0x1,
                    /// Selecting Pad: GPIO_B1_12 for Mode: ALT3
                    GPIO_B1_12_ALT3 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// ENET_TXCLK_SELECT_INPUT DAISY Register
            ENET_TXCLK_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_25 for Mode: ALT3
                    GPIO_EMC_25_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_B1_10 for Mode: ALT3
                    GPIO_B1_10_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXCAN1_RX_SELECT_INPUT DAISY Register
            FLEXCAN1_RX_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SD_B1_03 for Mode: ALT4
                    GPIO_SD_B1_03_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_EMC_18 for Mode: ALT3
                    GPIO_EMC_18_ALT3 = 0x1,
                    /// Selecting Pad: GPIO_AD_B1_09 for Mode: ALT2
                    GPIO_AD_B1_09_ALT2 = 0x2,
                    /// Selecting Pad: GPIO_B0_03 for Mode: ALT2
                    GPIO_B0_03_ALT2 = 0x3,
                },
                padding: u30 = 0,
            }),
            /// FLEXCAN2_RX_SELECT_INPUT DAISY Register
            FLEXCAN2_RX_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_EMC_10 for Mode: ALT3
                    GPIO_EMC_10_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_03 for Mode: ALT0
                    GPIO_AD_B0_03_ALT0 = 0x1,
                    /// Selecting Pad: GPIO_AD_B0_15 for Mode: ALT6
                    GPIO_AD_B0_15_ALT6 = 0x2,
                    /// Selecting Pad: GPIO_B1_09 for Mode: ALT6
                    GPIO_B1_09_ALT6 = 0x3,
                },
                padding: u30 = 0,
            }),
            /// FLEXPWM1_PWMA3_SELECT_INPUT DAISY Register
            FLEXPWM1_PWMA3_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u3) {
                    /// Selecting Pad: GPIO_SD_B1_00 for Mode: ALT2
                    GPIO_SD_B1_00_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_EMC_12 for Mode: ALT4
                    GPIO_EMC_12_ALT4 = 0x1,
                    /// Selecting Pad: GPIO_EMC_38 for Mode: ALT1
                    GPIO_EMC_38_ALT1 = 0x2,
                    /// Selecting Pad: GPIO_AD_B0_10 for Mode: ALT1
                    GPIO_AD_B0_10_ALT1 = 0x3,
                    /// Selecting Pad: GPIO_B1_00 for Mode: ALT6
                    GPIO_B1_00_ALT6 = 0x4,
                    _,
                },
                padding: u29 = 0,
            }),
            /// FLEXPWM1_PWMA0_SELECT_INPUT DAISY Register
            FLEXPWM1_PWMA0_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_23 for Mode: ALT1
                    GPIO_EMC_23_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_00 for Mode: ALT1
                    GPIO_SD_B0_00_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXPWM1_PWMA1_SELECT_INPUT DAISY Register
            FLEXPWM1_PWMA1_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_25 for Mode: ALT1
                    GPIO_EMC_25_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_02 for Mode: ALT1
                    GPIO_SD_B0_02_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXPWM1_PWMA2_SELECT_INPUT DAISY Register
            FLEXPWM1_PWMA2_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_27 for Mode: ALT1
                    GPIO_EMC_27_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_04 for Mode: ALT1
                    GPIO_SD_B0_04_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXPWM1_PWMB3_SELECT_INPUT DAISY Register
            FLEXPWM1_PWMB3_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u3) {
                    /// Selecting Pad: GPIO_SD_B1_01 for Mode: ALT2
                    GPIO_SD_B1_01_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_EMC_13 for Mode: ALT4
                    GPIO_EMC_13_ALT4 = 0x1,
                    /// Selecting Pad: GPIO_EMC_39 for Mode: ALT1
                    GPIO_EMC_39_ALT1 = 0x2,
                    /// Selecting Pad: GPIO_AD_B0_11 for Mode: ALT1
                    GPIO_AD_B0_11_ALT1 = 0x3,
                    /// Selecting Pad: GPIO_B1_01 for Mode: ALT6
                    GPIO_B1_01_ALT6 = 0x4,
                    _,
                },
                padding: u29 = 0,
            }),
            /// FLEXPWM1_PWMB0_SELECT_INPUT DAISY Register
            FLEXPWM1_PWMB0_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_24 for Mode: ALT1
                    GPIO_EMC_24_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_01 for Mode: ALT1
                    GPIO_SD_B0_01_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXPWM1_PWMB1_SELECT_INPUT DAISY Register
            FLEXPWM1_PWMB1_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_26 for Mode: ALT1
                    GPIO_EMC_26_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_03 for Mode: ALT1
                    GPIO_SD_B0_03_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXPWM1_PWMB2_SELECT_INPUT DAISY Register
            FLEXPWM1_PWMB2_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_28 for Mode: ALT1
                    GPIO_EMC_28_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_05 for Mode: ALT1
                    GPIO_SD_B0_05_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXPWM2_PWMA3_SELECT_INPUT DAISY Register
            FLEXPWM2_PWMA3_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u3) {
                    /// Selecting Pad: GPIO_SD_B1_02 for Mode: ALT2
                    GPIO_SD_B1_02_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_EMC_19 for Mode: ALT1
                    GPIO_EMC_19_ALT1 = 0x1,
                    /// Selecting Pad: GPIO_AD_B0_00 for Mode: ALT0
                    GPIO_AD_B0_00_ALT0 = 0x2,
                    /// Selecting Pad: GPIO_AD_B0_09 for Mode: ALT1
                    GPIO_AD_B0_09_ALT1 = 0x3,
                    /// Selecting Pad: GPIO_B1_02 for Mode: ALT6
                    GPIO_B1_02_ALT6 = 0x4,
                    _,
                },
                padding: u29 = 0,
            }),
            /// FLEXPWM2_PWMA0_SELECT_INPUT DAISY Register
            FLEXPWM2_PWMA0_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_06 for Mode: ALT1
                    GPIO_EMC_06_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_B0_06 for Mode: ALT2
                    GPIO_B0_06_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXPWM2_PWMA1_SELECT_INPUT DAISY Register
            FLEXPWM2_PWMA1_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_08 for Mode: ALT1
                    GPIO_EMC_08_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_B0_08 for Mode: ALT2
                    GPIO_B0_08_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXPWM2_PWMA2_SELECT_INPUT DAISY Register
            FLEXPWM2_PWMA2_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_10 for Mode: ALT1
                    GPIO_EMC_10_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_B0_10 for Mode: ALT2
                    GPIO_B0_10_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXPWM2_PWMB3_SELECT_INPUT DAISY Register
            FLEXPWM2_PWMB3_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SD_B1_03 for Mode: ALT2
                    GPIO_SD_B1_03_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_EMC_20 for Mode: ALT1
                    GPIO_EMC_20_ALT1 = 0x1,
                    /// Selecting Pad: GPIO_AD_B0_01 for Mode: ALT0
                    GPIO_AD_B0_01_ALT0 = 0x2,
                    /// Selecting Pad: GPIO_B1_03 for Mode: ALT6
                    GPIO_B1_03_ALT6 = 0x3,
                },
                padding: u30 = 0,
            }),
            /// FLEXPWM2_PWMB0_SELECT_INPUT DAISY Register
            FLEXPWM2_PWMB0_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_07 for Mode: ALT1
                    GPIO_EMC_07_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_B0_07 for Mode: ALT2
                    GPIO_B0_07_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXPWM2_PWMB1_SELECT_INPUT DAISY Register
            FLEXPWM2_PWMB1_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_09 for Mode: ALT1
                    GPIO_EMC_09_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_B0_09 for Mode: ALT2
                    GPIO_B0_09_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXPWM2_PWMB2_SELECT_INPUT DAISY Register
            FLEXPWM2_PWMB2_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_11 for Mode: ALT1
                    GPIO_EMC_11_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_B0_11 for Mode: ALT2
                    GPIO_B0_11_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXPWM4_PWMA0_SELECT_INPUT DAISY Register
            FLEXPWM4_PWMA0_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_00 for Mode: ALT1
                    GPIO_EMC_00_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_08 for Mode: ALT1
                    GPIO_AD_B1_08_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXPWM4_PWMA1_SELECT_INPUT DAISY Register
            FLEXPWM4_PWMA1_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_02 for Mode: ALT1
                    GPIO_EMC_02_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_09 for Mode: ALT1
                    GPIO_AD_B1_09_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXPWM4_PWMA2_SELECT_INPUT DAISY Register
            FLEXPWM4_PWMA2_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_04 for Mode: ALT1
                    GPIO_EMC_04_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_B1_14 for Mode: ALT1
                    GPIO_B1_14_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXPWM4_PWMA3_SELECT_INPUT DAISY Register
            FLEXPWM4_PWMA3_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_17 for Mode: ALT1
                    GPIO_EMC_17_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_B1_15 for Mode: ALT1
                    GPIO_B1_15_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXSPIA_DQS_SELECT_INPUT DAISY Register
            FLEXSPIA_DQS_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_05 for Mode: ALT1
                    GPIO_SD_B1_05_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_09 for Mode: ALT0
                    GPIO_AD_B1_09_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXSPIA_DATA0_SELECT_INPUT DAISY Register
            FLEXSPIA_DATA0_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_08 for Mode: ALT1
                    GPIO_SD_B1_08_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_13 for Mode: ALT0
                    GPIO_AD_B1_13_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXSPIA_DATA1_SELECT_INPUT DAISY Register
            FLEXSPIA_DATA1_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_09 for Mode: ALT1
                    GPIO_SD_B1_09_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_12 for Mode: ALT0
                    GPIO_AD_B1_12_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXSPIA_DATA2_SELECT_INPUT DAISY Register
            FLEXSPIA_DATA2_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_10 for Mode: ALT1
                    GPIO_SD_B1_10_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_11 for Mode: ALT0
                    GPIO_AD_B1_11_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXSPIA_DATA3_SELECT_INPUT DAISY Register
            FLEXSPIA_DATA3_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_11 for Mode: ALT1
                    GPIO_SD_B1_11_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_10 for Mode: ALT0
                    GPIO_AD_B1_10_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXSPIB_DATA0_SELECT_INPUT DAISY Register
            FLEXSPIB_DATA0_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_03 for Mode: ALT1
                    GPIO_SD_B1_03_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_07 for Mode: ALT0
                    GPIO_AD_B1_07_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXSPIB_DATA1_SELECT_INPUT DAISY Register
            FLEXSPIB_DATA1_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_02 for Mode: ALT1
                    GPIO_SD_B1_02_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_06 for Mode: ALT0
                    GPIO_AD_B1_06_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXSPIB_DATA2_SELECT_INPUT DAISY Register
            FLEXSPIB_DATA2_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_01 for Mode: ALT1
                    GPIO_SD_B1_01_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_05 for Mode: ALT0
                    GPIO_AD_B1_05_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXSPIB_DATA3_SELECT_INPUT DAISY Register
            FLEXSPIB_DATA3_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_00 for Mode: ALT1
                    GPIO_SD_B1_00_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_04 for Mode: ALT0
                    GPIO_AD_B1_04_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXSPIA_SCK_SELECT_INPUT DAISY Register
            FLEXSPIA_SCK_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_07 for Mode: ALT1
                    GPIO_SD_B1_07_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_14 for Mode: ALT0
                    GPIO_AD_B1_14_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPI2C1_SCL_SELECT_INPUT DAISY Register
            LPI2C1_SCL_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_04 for Mode: ALT2
                    GPIO_SD_B1_04_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_00 for Mode: ALT3
                    GPIO_AD_B1_00_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPI2C1_SDA_SELECT_INPUT DAISY Register
            LPI2C1_SDA_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_05 for Mode: ALT2
                    GPIO_SD_B1_05_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_01 for Mode: ALT3
                    GPIO_AD_B1_01_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPI2C2_SCL_SELECT_INPUT DAISY Register
            LPI2C2_SCL_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_11 for Mode: ALT3
                    GPIO_SD_B1_11_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_B0_04 for Mode: ALT2
                    GPIO_B0_04_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPI2C2_SDA_SELECT_INPUT DAISY Register
            LPI2C2_SDA_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_10 for Mode: ALT3
                    GPIO_SD_B1_10_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_B0_05 for Mode: ALT2
                    GPIO_B0_05_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPI2C3_SCL_SELECT_INPUT DAISY Register
            LPI2C3_SCL_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_EMC_22 for Mode: ALT2
                    GPIO_EMC_22_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_00 for Mode: ALT2
                    GPIO_SD_B0_00_ALT2 = 0x1,
                    /// Selecting Pad: GPIO_AD_B1_07 for Mode: ALT1
                    GPIO_AD_B1_07_ALT1 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// LPI2C3_SDA_SELECT_INPUT DAISY Register
            LPI2C3_SDA_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_EMC_21 for Mode: ALT2
                    GPIO_EMC_21_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_01 for Mode: ALT2
                    GPIO_SD_B0_01_ALT2 = 0x1,
                    /// Selecting Pad: GPIO_AD_B1_06 for Mode: ALT1
                    GPIO_AD_B1_06_ALT1 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// LPI2C4_SCL_SELECT_INPUT DAISY Register
            LPI2C4_SCL_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_12 for Mode: ALT2
                    GPIO_EMC_12_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_12 for Mode: ALT0
                    GPIO_AD_B0_12_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPI2C4_SDA_SELECT_INPUT DAISY Register
            LPI2C4_SDA_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_11 for Mode: ALT2
                    GPIO_EMC_11_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_13 for Mode: ALT0
                    GPIO_AD_B0_13_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPSPI1_PCS0_SELECT_INPUT DAISY Register
            LPSPI1_PCS0_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B0_01 for Mode: ALT4
                    GPIO_SD_B0_01_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_EMC_30 for Mode: ALT3
                    GPIO_EMC_30_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPSPI1_SCK_SELECT_INPUT DAISY Register
            LPSPI1_SCK_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_27 for Mode: ALT3
                    GPIO_EMC_27_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_00 for Mode: ALT4
                    GPIO_SD_B0_00_ALT4 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPSPI1_SDI_SELECT_INPUT DAISY Register
            LPSPI1_SDI_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_29 for Mode: ALT3
                    GPIO_EMC_29_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_03 for Mode: ALT4
                    GPIO_SD_B0_03_ALT4 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPSPI1_SDO_SELECT_INPUT DAISY Register
            LPSPI1_SDO_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_28 for Mode: ALT3
                    GPIO_EMC_28_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_02 for Mode: ALT4
                    GPIO_SD_B0_02_ALT4 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPSPI2_PCS0_SELECT_INPUT DAISY Register
            LPSPI2_PCS0_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_06 for Mode: ALT4
                    GPIO_SD_B1_06_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_EMC_01 for Mode: ALT2
                    GPIO_EMC_01_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPSPI2_SCK_SELECT_INPUT DAISY Register
            LPSPI2_SCK_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_07 for Mode: ALT4
                    GPIO_SD_B1_07_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_EMC_00 for Mode: ALT2
                    GPIO_EMC_00_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPSPI2_SDI_SELECT_INPUT DAISY Register
            LPSPI2_SDI_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_09 for Mode: ALT4
                    GPIO_SD_B1_09_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_EMC_03 for Mode: ALT2
                    GPIO_EMC_03_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPSPI2_SDO_SELECT_INPUT DAISY Register
            LPSPI2_SDO_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_08 for Mode: ALT4
                    GPIO_SD_B1_08_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_EMC_02 for Mode: ALT2
                    GPIO_EMC_02_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPSPI3_PCS0_SELECT_INPUT DAISY Register
            LPSPI3_PCS0_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B0_03 for Mode: ALT7
                    GPIO_AD_B0_03_ALT7 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_12 for Mode: ALT2
                    GPIO_AD_B1_12_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPSPI3_SCK_SELECT_INPUT DAISY Register
            LPSPI3_SCK_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B0_00 for Mode: ALT7
                    GPIO_AD_B0_00_ALT7 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_15 for Mode: ALT2
                    GPIO_AD_B1_15 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPSPI3_SDI_SELECT_INPUT DAISY Register
            LPSPI3_SDI_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B0_02 for Mode: ALT7
                    GPIO_AD_B0_02_ALT7 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_13 for Mode: ALT2
                    GPIO_AD_B1_13_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPSPI3_SDO_SELECT_INPUT DAISY Register
            LPSPI3_SDO_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B0_01 for Mode: ALT7
                    GPIO_AD_B0_01_ALT7 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_14 for Mode: ALT2
                    GPIO_AD_B1_14_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPSPI4_PCS0_SELECT_INPUT DAISY Register
            LPSPI4_PCS0_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_B0_00 for Mode: ALT3
                    GPIO_B0_00_ALT3 = 0x0,
                    /// Selecting Pad:GPIO_B1_04 for Mode: ALT1
                    GPIO_B1_04_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPSPI4_SCK_SELECT_INPUT DAISY Register
            LPSPI4_SCK_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_B0_03 for Mode: ALT3
                    GPIO_B0_03_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_B1_07 for Mode: ALT1
                    GPIO_B1_07_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPSPI4_SDI_SELECT_INPUT DAISY Register
            LPSPI4_SDI_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_B0_01 for Mode: ALT3
                    GPIO_B0_01_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_B1_05 for Mode: ALT1
                    GPIO_B1_05_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPSPI4_SDO_SELECT_INPUT DAISY Register
            LPSPI4_SDO_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_B0_02 for Mode: ALT3
                    GPIO_B0_02_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_B1_06 for Mode: ALT1
                    GPIO_B1_06_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPUART2_RX_SELECT_INPUT DAISY Register
            LPUART2_RX_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_10 for Mode: ALT2
                    GPIO_SD_B1_10_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_03 for Mode: ALT2
                    GPIO_AD_B1_03_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPUART2_TX_SELECT_INPUT DAISY Register
            LPUART2_TX_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_11 for Mode: ALT2
                    GPIO_SD_B1_11_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_02 for Mode: ALT2
                    GPIO_AD_B1_02_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPUART3_CTS_B_SELECT_INPUT DAISY Register
            LPUART3_CTS_B_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_15 for Mode: ALT2
                    GPIO_EMC_15_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_04 for Mode: ALT2
                    GPIO_AD_B1_04_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPUART3_RX_SELECT_INPUT DAISY Register
            LPUART3_RX_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_AD_B1_07 for Mode: ALT2
                    GPIO_AD_B1_07_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_EMC_14 for Mode: ALT2
                    GPIO_EMC_14_ALT2 = 0x1,
                    /// Selecting Pad: GPIO_B0_09 for Mode: ALT3
                    GPIO_B0_09_ALT3 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// LPUART3_TX_SELECT_INPUT DAISY Register
            LPUART3_TX_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_AD_B1_06 for Mode: ALT2
                    GPIO_AD_B1_06_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_EMC_13 for Mode: ALT2
                    GPIO_EMC_13_ALT2 = 0x1,
                    /// Selecting Pad: GPIO_B0_08 for Mode: ALT3
                    GPIO_B0_08_ALT3 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// LPUART4_RX_SELECT_INPUT DAISY Register
            LPUART4_RX_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SD_B1_01 for Mode: ALT4
                    GPIO_SD_B1_01_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_EMC_20 for Mode: ALT2
                    GPIO_EMC_20_ALT2 = 0x1,
                    /// Selecting Pad: GPIO_B1_01 for Mode: ALT2
                    GPIO_B1_01_ALT2 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// LPUART4_TX_SELECT_INPUT DAISY Register
            LPUART4_TX_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SD_B1_00 for Mode: ALT4
                    GPIO_SD_B1_00_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_EMC_19 for Mode: ALT2
                    GPIO_EMC_19_ALT2 = 0x1,
                    /// Selecting Pad: GPIO_B1_00 for Mode: ALT2
                    GPIO_B1_00_ALT2 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// LPUART5_RX_SELECT_INPUT DAISY Register
            LPUART5_RX_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_24 for Mode: ALT2
                    GPIO_EMC_24_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_B1_13 for Mode: ALT1
                    GPIO_B1_13_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPUART5_TX_SELECT_INPUT DAISY Register
            LPUART5_TX_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_23 for Mode: ALT2
                    GPIO_EMC_23_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_B1_12 for Mode: ALT1
                    GPIO_B1_12_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPUART6_RX_SELECT_INPUT DAISY Register
            LPUART6_RX_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_26 for Mode: ALT2
                    GPIO_EMC_26_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_03 for Mode: ALT2
                    GPIO_AD_B0_03_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPUART6_TX_SELECT_INPUT DAISY Register
            LPUART6_TX_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_25 for Mode: ALT2
                    GPIO_EMC_25_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_02 for Mode: ALT2
                    GPIO_AD_B0_02_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPUART7_RX_SELECT_INPUT DAISY Register
            LPUART7_RX_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_09 for Mode: ALT2
                    GPIO_SD_B1_09_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_EMC_32 for Mode: ALT2
                    GPIO_EMC_32_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPUART7_TX_SELECT_INPUT DAISY Register
            LPUART7_TX_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_08 for Mode: ALT2
                    GPIO_SD_B1_08_ALT2 = 0x0,
                    /// Selecting Pad:GPIO_EMC_31 for Mode: ALT2
                    GPIO_EMC_31_ALT2 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// LPUART8_RX_SELECT_INPUT DAISY Register
            LPUART8_RX_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SD_B0_05 for Mode: ALT2
                    GPIO_SD_B0_05_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_11 for Mode: ALT2
                    GPIO_AD_B1_11_ALT2 = 0x1,
                    /// Selecting Pad: GPIO_EMC_39 for Mode: ALT2
                    GPIO_EMC_39_ALT2 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// LPUART8_TX_SELECT_INPUT DAISY Register
            LPUART8_TX_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SD_B0_04 for Mode: ALT2
                    GPIO_SD_B0_04_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_10 for Mode: ALT2
                    GPIO_AD_B1_10_ALT2 = 0x1,
                    /// Selecting Pad: GPIO_EMC_38 for Mode: ALT2
                    GPIO_EMC_38_ALT2 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// NMI_GLUE_NMI_SELECT_INPUT DAISY Register
            NMI_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B0_12 for Mode: ALT7
                    GPIO_AD_B0_12_ALT7 = 0x0,
                    /// Selecting Pad: WAKEUP for Mode: ALT7
                    WAKEUP_ALT7 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// QTIMER2_TIMER0_SELECT_INPUT DAISY Register
            QTIMER2_TIMER0_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_19 for Mode: ALT4
                    GPIO_EMC_19_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_B0_03 for Mode: ALT1
                    GPIO_B0_03_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// QTIMER2_TIMER1_SELECT_INPUT DAISY Register
            QTIMER2_TIMER1_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_20 for Mode: ALT4
                    GPIO_EMC_20_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_B0_04 for Mode: ALT1
                    GPIO_B0_04_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// QTIMER2_TIMER2_SELECT_INPUT DAISY Register
            QTIMER2_TIMER2_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_21 for Mode: ALT4
                    GPIO_EMC_21_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_B0_05 for Mode: ALT1
                    GPIO_B0_05_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// QTIMER2_TIMER3_SELECT_INPUT DAISY Register
            QTIMER2_TIMER3_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_22 for Mode: ALT4
                    GPIO_EMC_22_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_B1_09 for Mode: ALT1
                    GPIO_B1_09_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// QTIMER3_TIMER0_SELECT_INPUT DAISY Register
            QTIMER3_TIMER0_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_EMC_15 for Mode: ALT4
                    GPIO_EMC_15_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_00 for Mode: ALT1
                    GPIO_AD_B1_00_ALT1 = 0x1,
                    /// Selecting Pad: GPIO_B0_06 for Mode: ALT1
                    GPIO_B0_06_ALT1 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// QTIMER3_TIMER1_SELECT_INPUT DAISY Register
            QTIMER3_TIMER1_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_AD_B1_01 for Mode: ALT1
                    GPIO_AD_B1_01_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_EMC_16 for Mode: ALT4
                    GPIO_EMC_16_ALT4 = 0x1,
                    /// Selecting Pad: GPIO_B0_07 for Mode: ALT1
                    GPIO_B0_07_ALT1 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// QTIMER3_TIMER2_SELECT_INPUT DAISY Register
            QTIMER3_TIMER2_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_EMC_17 for Mode: ALT4
                    GPIO_EMC_17_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_02 for Mode: ALT1
                    GPIO_AD_B1_02_ALT1 = 0x1,
                    /// Selecting Pad: GPIO_B0_08 for Mode: ALT1
                    GPIO_B0_08_ALT1 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// QTIMER3_TIMER3_SELECT_INPUT DAISY Register
            QTIMER3_TIMER3_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_EMC_18 for Mode: ALT4
                    GPIO_EMC_18_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_03 for Mode: ALT1
                    GPIO_AD_B1_03_ALT1 = 0x1,
                    /// Selecting Pad: GPIO_B1_10 for Mode: ALT1
                    GPIO_B1_10_ALT1 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// SAI1_MCLK2_SELECT_INPUT DAISY Register
            SAI1_MCLK2_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SD_B1_03 for Mode: ALT3
                    GPIO_SD_B1_03_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_09 for Mode: ALT3
                    GPIO_AD_B1_09_ALT3 = 0x1,
                    /// Selecting Pad: GPIO_B0_13 for Mode: ALT3
                    GPIO_B0_13_ALT3 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// SAI1_RX_BCLK_SELECT_INPUT DAISY Register
            SAI1_RX_BCLK_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SD_B1_05 for Mode: ALT3
                    GPIO_SD_B1_05_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_11 for Mode: ALT3
                    GPIO_AD_B1_11_ALT3 = 0x1,
                    /// Selecting Pad: GPIO_B0_15 for Mode: ALT3
                    GPIO_B0_15_ALT3 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// SAI1_RX_DATA0_SELECT_INPUT DAISY Register
            SAI1_RX_DATA0_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SD_B1_06 for Mode: ALT3
                    GPIO_SD_B1_06_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_12 for Mode: ALT3
                    GPIO_AD_B1_12_ALT3 = 0x1,
                    /// Selecting Pad: GPIO_B1_00 for Mode: ALT3
                    GPIO_B1_00_ALT3 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// SAI1_RX_DATA1_SELECT_INPUT DAISY Register
            SAI1_RX_DATA1_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_00 for Mode: ALT3
                    GPIO_SD_B1_00_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_B0_10 for Mode: ALT3
                    GPIO_B0_10_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// SAI1_RX_DATA2_SELECT_INPUT DAISY Register
            SAI1_RX_DATA2_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_01 for Mode: ALT3
                    GPIO_SD_B1_01_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_B0_11 for Mode: ALT3
                    GPIO_B0_11_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// SAI1_RX_DATA3_SELECT_INPUT DAISY Register
            SAI1_RX_DATA3_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_02 for Mode: ALT3
                    GPIO_SD_B1_02_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_B0_12 for Mode: ALT3
                    GPIO_B0_12_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// SAI1_RX_SYNC_SELECT_INPUT DAISY Register
            SAI1_RX_SYNC_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SD_B1_04 for Mode: ALT3
                    GPIO_SD_B1_04_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_10 for Mode: ALT3
                    GPIO_AD_B1_10_ALT3 = 0x1,
                    /// Selecting Pad: GPIO_B0_14 for Mode: ALT3
                    GPIO_B0_14_ALT3 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// SAI1_TX_BCLK_SELECT_INPUT DAISY Register
            SAI1_TX_BCLK_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SD_B1_08 for Mode: ALT3
                    GPIO_SD_B1_08_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_14 for Mode: ALT3
                    GPIO_AD_B1_14_ALT3 = 0x1,
                    /// Selecting Pad: GPIO_B1_02 for Mode: ALT3
                    GPIO_B1_02_ALT3 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// SAI1_TX_SYNC_SELECT_INPUT DAISY Register
            SAI1_TX_SYNC_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SD_B1_09 for Mode: ALT3
                    GPIO_SD_B1_09_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_15 for Mode: ALT3
                    GPIO_AD_B1_15_ALT3 = 0x1,
                    /// Selecting Pad: GPIO_B1_03 for Mode: ALT3
                    GPIO_B1_03_ALT3 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// SAI2_MCLK2_SELECT_INPUT DAISY Register
            SAI2_MCLK2_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_07 for Mode: ALT2
                    GPIO_EMC_07_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_10 for Mode: ALT3
                    GPIO_AD_B0_10_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// SAI2_RX_BCLK_SELECT_INPUT DAISY Register
            SAI2_RX_BCLK_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_10 for Mode: ALT2
                    GPIO_EMC_10_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_06 for Mode: ALT3
                    GPIO_AD_B0_06_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// SAI2_RX_DATA0_SELECT_INPUT DAISY Register
            SAI2_RX_DATA0_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_08 for Mode: ALT2
                    GPIO_EMC_08_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_08 for Mode: ALT3
                    GPIO_AD_B0_08_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// SAI2_RX_SYNC_SELECT_INPUT DAISY Register
            SAI2_RX_SYNC_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_09 for Mode: ALT2
                    GPIO_EMC_09_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_07 for Mode: ALT3
                    GPIO_AD_B0_07_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// SAI2_TX_BCLK_SELECT_INPUT DAISY Register
            SAI2_TX_BCLK_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_06 for Mode: ALT2
                    GPIO_EMC_06_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_05 for Mode: ALT3
                    GPIO_AD_B0_05_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// SAI2_TX_SYNC_SELECT_INPUT DAISY Register
            SAI2_TX_SYNC_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_05 for Mode: ALT2
                    GPIO_EMC_05_ALT2 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_04 for Mode: ALT3
                    GPIO_AD_B0_04_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// SPDIF_IN_SELECT_INPUT DAISY Register
            SPDIF_IN_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B1_03 for Mode: ALT3
                    GPIO_AD_B1_03_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_EMC_16 for Mode: ALT3
                    GPIO_EMC_16_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// USB_OTG2_OC_SELECT_INPUT DAISY Register
            USB_OTG2_OC_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B0_14 for Mode: ALT0
                    GPIO_AD_B0_14_ALT0 = 0x0,
                    /// Selecting Pad: GPIO_EMC_40 for Mode: ALT3
                    GPIO_EMC_40_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// USB_OTG1_OC_SELECT_INPUT DAISY Register
            USB_OTG1_OC_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B0_03 for Mode: ALT3
                    GPIO_AD_B0_03_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_03 for Mode: ALT0
                    GPIO_AD_B1_03_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// USDHC1_CD_B_SELECT_INPUT DAISY Register
            USDHC1_CD_B_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_EMC_35 for Mode: ALT6
                    GPIO_EMC_35_ALT6 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_02 for Mode: ALT6
                    GPIO_AD_B1_02_ALT6 = 0x1,
                    /// Selecting Pad: GPIO_B1_12 for Mode: ALT6
                    GPIO_B1_12_ALT6 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// USDHC1_WP_SELECT_INPUT DAISY Register
            USDHC1_WP_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_EMC_12 for Mode: ALT3
                    GPIO_EMC_12_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_EMC_36for Mode: ALT6
                    GPIO_EMC_36_ALT6 = 0x1,
                    /// Selecting Pad:GPIO_AD_B1_00 for Mode: ALT6
                    GPIO_AD_B1_00_ALT6 = 0x2,
                    /// Selecting Pad: GPIO_B1_13 for Mode: ALT6
                    GPIO_B1_13_ALT6 = 0x3,
                },
                padding: u30 = 0,
            }),
            /// USDHC2_CLK_SELECT_INPUT DAISY Register
            USDHC2_CLK_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_04 for Mode: ALT0
                    GPIO_SD_B1_04_ALT0 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_09 for Mode: ALT6
                    GPIO_AD_B1_09_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// USDHC2_CD_B_SELECT_INPUT DAISY Register
            USDHC2_CD_B_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad:GPIO_AD_B1_03 for Mode: ALT6
                    GPIO_AD_B1_03_ALT6 = 0x0,
                    /// Selecting Pad: GPIO_EMC_39 for Mode: ALT6
                    GPIO_EMC_39_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// USDHC2_CMD_SELECT_INPUT DAISY Register
            USDHC2_CMD_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_05 for Mode: ALT0
                    GPIO_SD_B1_05_ALT0 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_08 for Mode: ALT6
                    GPIO_AD_B1_08_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// USDHC2_DATA0_SELECT_INPUT DAISY Register
            USDHC2_DATA0_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_03 for Mode: ALT0
                    GPIO_SD_B1_03_ALT0 = 0x0,
                    /// Selecting Pad:GPIO_AD_B1_04 for Mode: ALT6
                    GPIO_AD_B1_04_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// USDHC2_DATA1_SELECT_INPUT DAISY Register
            USDHC2_DATA1_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_02 for Mode: ALT0
                    GPIO_SD_B1_02_ALT0 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_05 for Mode: ALT6
                    GPIO_AD_B1_05_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// USDHC2_DATA2_SELECT_INPUT DAISY Register
            USDHC2_DATA2_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_01 for Mode: ALT0
                    GPIO_SD_B1_01_ALT0 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_06 for Mode: ALT6
                    GPIO_AD_B1_06_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// USDHC2_DATA3_SELECT_INPUT DAISY Register
            USDHC2_DATA3_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_00 for Mode: ALT0
                    GPIO_SD_B1_00_ALT0 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_07 for Mode: ALT6
                    GPIO_AD_B1_07_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// USDHC2_DATA4_SELECT_INPUT DAISY Register
            USDHC2_DATA4_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_08 for Mode: ALT0
                    GPIO_SD_B1_08_ALT0 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_12 for Mode: ALT6
                    GPIO_AD_B1_12_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// USDHC2_DATA5_SELECT_INPUT DAISY Register
            USDHC2_DATA5_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_09 for Mode: ALT0
                    GPIO_SD_B1_09_ALT0 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_13 for Mode: ALT6
                    GPIO_AD_B1_13_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// USDHC2_DATA6_SELECT_INPUT DAISY Register
            USDHC2_DATA6_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_10 for Mode: ALT0
                    GPIO_SD_B1_10_ALT0 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_14 for Mode: ALT6
                    GPIO_AD_B1_14_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// USDHC2_DATA7_SELECT_INPUT DAISY Register
            USDHC2_DATA7_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_SD_B1_11 for Mode: ALT0
                    GPIO_SD_B1_11_ALT0 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_15 for Mode: ALT6
                    GPIO_AD_B1_15_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// USDHC2_WP_SELECT_INPUT DAISY Register
            USDHC2_WP_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_37 for Mode: ALT6
                    GPIO_EMC_37_ALT6 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_10 for Mode: ALT6
                    GPIO_AD_B1_10_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN02_SELECT_INPUT DAISY Register
            XBAR1_IN02_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_00 for Mode: ALT3
                    GPIO_EMC_00_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_B1_14 for Mode: ALT3
                    GPIO_B1_14_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN03_SELECT_INPUT DAISY Register
            XBAR1_IN03_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_01 for Mode: ALT3
                    GPIO_EMC_01_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_B1_15 for Mode: ALT3
                    GPIO_B1_15_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN04_SELECT_INPUT DAISY Register
            XBAR1_IN04_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_02 for Mode: ALT3
                    GPIO_EMC_02_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_00 for Mode: ALT3
                    GPIO_SD_B0_00_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN05_SELECT_INPUT DAISY Register
            XBAR1_IN05_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_03 for Mode: ALT3
                    GPIO_EMC_03_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_01 for Mode: ALT3
                    GPIO_SD_B0_01_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN06_SELECT_INPUT DAISY Register
            XBAR1_IN06_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_04 for Mode: ALT3
                    GPIO_EMC_04_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_02 for Mode: ALT3
                    GPIO_SD_B0_02_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN07_SELECT_INPUT DAISY Register
            XBAR1_IN07_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_05 for Mode: ALT3
                    GPIO_EMC_05_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_03 for Mode: ALT3
                    GPIO_SD_B0_03_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN08_SELECT_INPUT DAISY Register
            XBAR1_IN08_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_06 for Mode: ALT3
                    GPIO_EMC_06_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_04 for Mode: ALT3
                    GPIO_SD_B0_04_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN09_SELECT_INPUT DAISY Register
            XBAR1_IN09_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_07 for Mode: ALT3
                    GPIO_EMC_07_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_05 for Mode: ALT3
                    GPIO_SD_B0_05_ALT3 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN17_SELECT_INPUT DAISY Register
            XBAR1_IN17_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_EMC_08 for Mode: ALT3
                    GPIO_EMC_08_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_03 for Mode: ALT1
                    GPIO_AD_B0_03_ALT1 = 0x1,
                    /// Selecting Pad: GPIO_AD_B0_05 for Mode: ALT6
                    GPIO_AD_B0_05_ALT6 = 0x2,
                    /// Selecting Pad: GPIO_B1_03 for Mode: ALT1
                    GPIO_B1_03_ALT1 = 0x3,
                },
                padding: u30 = 0,
            }),
            /// XBAR1_IN18_SELECT_INPUT DAISY Register
            XBAR1_IN18_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_35 for Mode: ALT1
                    GPIO_EMC_35_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_06 for Mode: ALT6
                    GPIO_AD_B0_06_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN20_SELECT_INPUT DAISY Register
            XBAR1_IN20_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_15 for Mode: ALT1
                    GPIO_EMC_15_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_08 for Mode: ALT6
                    GPIO_AD_B0_08_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN22_SELECT_INPUT DAISY Register
            XBAR1_IN22_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_36 for Mode: ALT1
                    GPIO_EMC_36_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_10 for Mode: ALT6
                    GPIO_AD_B0_10_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN23_SELECT_INPUT DAISY Register
            XBAR1_IN23_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_37 for Mode: ALT1
                    GPIO_EMC_37_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_11 for Mode: ALT6
                    GPIO_AD_B0_11_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN24_SELECT_INPUT DAISY Register
            XBAR1_IN24_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_12 for Mode: ALT1
                    GPIO_EMC_12_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_14 for Mode: ALT1
                    GPIO_AD_B0_14_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN14_SELECT_INPUT DAISY Register
            XBAR1_IN14_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B0_00 for Mode: ALT1
                    GPIO_AD_B0_00_ALT1 = 0x0,
                    /// Selecting Pad:GPIO_B1_00 for Mode: ALT1
                    GPIO_B1_00_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN15_SELECT_INPUT DAISY Register
            XBAR1_IN15_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B0_01 for Mode: ALT1
                    GPIO_AD_B0_01_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_B1_01 for Mode: ALT1
                    GPIO_B1_01_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN16_SELECT_INPUT DAISY Register
            XBAR1_IN16_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B0_02 for Mode: ALT1
                    GPIO_AD_B0_02_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_B1_02 for Mode: ALT1
                    GPIO_B1_02_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN25_SELECT_INPUT DAISY Register
            XBAR1_IN25_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B0_15 for Mode: ALT1
                    GPIO_AD_B0_15_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_EMC_13 for Mode: ALT1
                    GPIO_EMC_13_ALT1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN19_SELECT_INPUT DAISY Register
            XBAR1_IN19_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_14 for Mode: ALT1
                    GPIO_EMC_14_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_07 for Mode: ALT6
                    GPIO_AD_B0_07_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// XBAR1_IN23_SELECT_INPUT DAISY Register
            XBAR1_IN21_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_16 for Mode: ALT1
                    GPIO_EMC_16_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_09 for Mode: ALT6
                    GPIO_AD_B0_09_ALT6 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B0_00 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B0_00: mmio.Mmio(packed struct(u32) {
                reserved4: u4 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B0_00
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B0_01 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B0_01: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_B_SCLK of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B0_01
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B0_02 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B0_02: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_A_DATA00 of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B0_02
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B0_03 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B0_03: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_B_DATA02 of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B0_03
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B0_04 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B0_04: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_B_DATA03 of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B0_04
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B0_05 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B0_05: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_A_SS0_B of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B0_05
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B0_06 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B0_06: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_A_DATA02 of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B0_06
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B0_07 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B0_07: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_B_DATA01 of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B0_07
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B0_08 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B0_08: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_A_SCLK of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B0_08
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B0_09 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B0_09: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_A_DQS of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B0_09
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B0_10 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B0_10: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_A_DATA03 of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B0_10
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B0_11 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B0_11: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_B_DATA00 of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B0_11
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B0_12 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B0_12: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_A_DATA01 of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B0_12
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B0_13 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B0_13: mmio.Mmio(packed struct(u32) {
                reserved4: u4 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B0_13
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B1_00 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B1_00: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_A_DQS of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B1_00
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B1_01 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B1_01: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_A_DATA03 of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B1_01
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B1_02 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B1_02: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_A_DATA02 of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B1_02
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B1_03 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B1_03: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_A_DATA01 of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B1_03
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B1_04 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B1_04: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_A_DATA00 of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B1_04
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B1_05 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B1_05: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_A_SCLK of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B1_05
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B1_06 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B1_06: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: FLEXSPI2_A_SS0_B of instance: flexspi2
                    ALT0 = 0x0,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B1_06
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_GPIO_SPI_B1_07 SW MUX Control Register
            SW_MUX_CTL_PAD_GPIO_SPI_B1_07: mmio.Mmio(packed struct(u32) {
                reserved4: u4 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad GPIO_SPI_B1_07
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B0_00 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B0_00: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B0_01 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B0_01: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B0_02 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B0_02: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B0_03 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B0_03: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B0_04 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B0_04: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B0_05 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B0_05: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B0_06 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B0_06: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B0_07 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B0_07: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B0_08 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B0_08: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B0_09 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B0_09: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B0_10 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B0_10: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B0_11 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B0_11: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B0_12 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B0_12: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B0_13 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B0_13: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B1_00 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B1_00: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B1_01 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B1_01: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B1_02 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B1_02: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B1_03 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B1_03: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B1_04 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B1_04: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B1_05 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B1_05: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B1_06 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B1_06: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_GPIO_SPI_B1_07 SW PAD Control Register
            SW_PAD_CTL_PAD_GPIO_SPI_B1_07: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
                    DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// low(50MHz)
                    SPEED_0_low_50MHz_ = 0x0,
                    /// medium(100MHz)
                    SPEED_1_medium_100MHz_ = 0x1,
                    /// medium(100MHz)
                    SPEED_2_medium_100MHz_ = 0x2,
                    /// max(200MHz)
                    SPEED_3_max_200MHz_ = 0x3,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// ENET2_IPG_CLK_RMII_SELECT_INPUT DAISY Register
            ENET2_IPG_CLK_RMII_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_EMC_33 for Mode: ALT9
                    GPIO_EMC_33_ALT9 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_01 for Mode: ALT9
                    GPIO_SD_B0_01_ALT9 = 0x1,
                    /// Selecting Pad: GPIO_B0_15 for Mode: ALT9
                    GPIO_B0_15_ALT9 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// ENET2_IPP_IND_MAC0_MDIO_SELECT_INPUT DAISY Register
            ENET2_IPP_IND_MAC0_MDIO_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_39 for Mode: ALT8
                    GPIO_EMC_39_ALT8 = 0x0,
                    /// Selecting Pad: GPIO_B0_01 for Mode: ALT8
                    GPIO_B0_01_ALT8 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_0 DAISY Register
            ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_0: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_EMC_35 for Mode: ALT8
                    GPIO_EMC_35_ALT8 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_03 for Mode: ALT8
                    GPIO_SD_B0_03_ALT8 = 0x1,
                    /// Selecting Pad: GPIO_B1_01 for Mode: ALT8
                    GPIO_B1_01_ALT8 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_1 DAISY Register
            ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_1: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_EMC_36 for Mode: ALT8
                    GPIO_EMC_36_ALT8 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_04 for Mode: ALT8
                    GPIO_SD_B0_04_ALT8 = 0x1,
                    /// Selecting Pad: GPIO_B1_02 for Mode: ALT8
                    GPIO_B1_02_ALT8 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// ENET2_IPP_IND_MAC0_RXEN_SELECT_INPUT DAISY Register
            ENET2_IPP_IND_MAC0_RXEN_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_EMC_37 for Mode: ALT8
                    GPIO_EMC_37_ALT8 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_05 for Mode: ALT8
                    GPIO_SD_B0_05_ALT8 = 0x1,
                    /// Selecting Pad: GPIO_B1_03 for Mode: ALT8
                    GPIO_B1_03_ALT8 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// ENET2_IPP_IND_MAC0_RXERR_SELECT_INPUT DAISY Register
            ENET2_IPP_IND_MAC0_RXERR_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_EMC_34 for Mode: ALT8
                    GPIO_EMC_34_ALT8 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_02 for Mode: ALT8
                    GPIO_SD_B0_02_ALT8 = 0x1,
                    /// Selecting Pad: GPIO_B1_00 for Mode: ALT8
                    GPIO_B1_00_ALT8 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// ENET2_IPP_IND_MAC0_TIMER_SELECT_INPUT_0 DAISY Register
            ENET2_IPP_IND_MAC0_TIMER_SELECT_INPUT_0: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B1_01 for Mode: ALT8
                    GPIO_AD_B1_01_ALT8 = 0x0,
                    /// Selecting Pad: GPIO_B0_03 for Mode: ALT8
                    GPIO_B0_03_ALT8 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// ENET2_IPP_IND_MAC0_TXCLK_SELECT_INPUT DAISY Register
            ENET2_IPP_IND_MAC0_TXCLK_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_EMC_33 for Mode: ALT8
                    GPIO_EMC_33_ALT8 = 0x0,
                    /// Selecting Pad: GPIO_SD_B0_01 for Mode: ALT8
                    GPIO_SD_B0_01_ALT8 = 0x1,
                    /// Selecting Pad: GPIO_B0_15 for Mode: ALT8
                    GPIO_B0_15_ALT8 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT DAISY Register
            FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SPI_B1_00 for Mode: ALT0
                    GPIO_SPI_B1_00_ALT0 = 0x0,
                    /// Selecting Pad: GPIO_EMC_23 for Mode: ALT8
                    GPIO_EMC_23_ALT8 = 0x1,
                    /// Selecting Pad: GPIO_SPI_B0_09 for Mode: ALT0
                    GPIO_SPI_B0_09_ALT0 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// FLEXSPI2_IPP_IND_IO_FA_BIT0_SELECT_INPUT DAISY Register
            FLEXSPI2_IPP_IND_IO_FA_BIT0_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SPI_B1_04 for Mode: ALT0
                    GPIO_SPI_B1_04_ALT0 = 0x0,
                    /// Selecting Pad: GPIO_EMC_26 for Mode: ALT8
                    GPIO_EMC_26_ALT8 = 0x1,
                    /// Selecting Pad: GPIO_SPI_B0_02 for Mode: ALT0
                    GPIO_SPI_B0_02_ALT0 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// FLEXSPI2_IPP_IND_IO_FA_BIT1_SELECT_INPUT DAISY Register
            FLEXSPI2_IPP_IND_IO_FA_BIT1_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SPI_B1_03 for Mode: ALT0
                    GPIO_SPI_B1_03_ALT0 = 0x0,
                    /// Selecting Pad: GPIO_EMC_27 for Mode: ALT8
                    GPIO_EMC_27_ALT8 = 0x1,
                    /// Selecting Pad: GPIO_SPI_B0_12 for Mode: ALT0
                    GPIO_SPI_B0_12_ALT0 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT DAISY Register
            FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SPI_B1_02 for Mode: ALT0
                    GPIO_SPI_B1_02_ALT0 = 0x0,
                    /// Selecting Pad: GPIO_EMC_28 for Mode: ALT8
                    GPIO_EMC_28_ALT8 = 0x1,
                    /// Selecting Pad: GPIO_SPI_B0_06 for Mode: ALT0
                    GPIO_SPI_B0_06_ALT0 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT DAISY Register
            FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SPI_B1_01 for Mode: ALT0
                    GPIO_SPI_B1_01_ALT0 = 0x0,
                    /// Selecting Pad: GPIO_EMC_29 for Mode: ALT8
                    GPIO_EMC_29_ALT8 = 0x1,
                    /// Selecting Pad: GPIO_SPI_B0_10 for Mode: ALT0
                    GPIO_SPI_B0_10_ALT0 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// FLEXSPI2_IPP_IND_IO_FB_BIT0_SELECT_INPUT DAISY Register
            FLEXSPI2_IPP_IND_IO_FB_BIT0_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_13 for Mode: ALT8
                    GPIO_EMC_13_ALT8 = 0x0,
                    /// Selecting Pad: GPIO_SPI_B0_11 for Mode: ALT0
                    GPIO_SPI_B0_11_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXSPI2_IPP_IND_IO_FB_BIT1_SELECT_INPUT DAISY Register
            FLEXSPI2_IPP_IND_IO_FB_BIT1_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_14 for Mode: ALT8
                    GPIO_EMC_14_ALT8 = 0x0,
                    /// Selecting Pad: GPIO_SPI_B0_07 for Mode: ALT0
                    GPIO_SPI_B0_07_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXSPI2_IPP_IND_IO_FB_BIT2_SELECT_INPUT DAISY Register
            FLEXSPI2_IPP_IND_IO_FB_BIT2_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_15 for Mode: ALT8
                    GPIO_EMC_15_ALT8 = 0x0,
                    /// Selecting Pad: GPIO_SPI_B0_03 for Mode: ALT0
                    GPIO_SPI_B0_03_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXSPI2_IPP_IND_IO_FB_BIT3_SELECT_INPUT DAISY Register
            FLEXSPI2_IPP_IND_IO_FB_BIT3_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_16 for Mode: ALT8
                    GPIO_EMC_16_ALT8 = 0x0,
                    /// Selecting Pad: GPIO_SPI_B0_04 for Mode: ALT0
                    GPIO_SPI_B0_04_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT DAISY Register
            FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SPI_B1_05 for Mode: ALT0
                    GPIO_SPI_B1_05_ALT0 = 0x0,
                    /// Selecting Pad: GPIO_EMC_25 for Mode: ALT8
                    GPIO_EMC_25_ALT8 = 0x1,
                    /// Selecting Pad: GPIO_SPI_B0_08 for Mode: ALT0
                    GPIO_SPI_B0_08_ALT0 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
            /// FLEXSPI2_IPP_IND_SCK_FB_SELECT_INPUT DAISY Register
            FLEXSPI2_IPP_IND_SCK_FB_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_12 for Mode: ALT8
                    GPIO_EMC_12_ALT8 = 0x0,
                    /// Selecting Pad: GPIO_SPI_B0_01 for Mode: ALT0
                    GPIO_SPI_B0_01_ALT0 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// GPT1_IPP_IND_CAPIN1_SELECT_INPUT DAISY Register
            GPT1_IPP_IND_CAPIN1_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_24 for Mode: ALT4
                    GPIO_EMC_24_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_B1_05 for Mode: ALT8
                    GPIO_B1_05_ALT8 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// GPT1_IPP_IND_CAPIN2_SELECT_INPUT DAISY Register
            GPT1_IPP_IND_CAPIN2_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_23 for Mode: ALT4
                    GPIO_EMC_23_ALT4 = 0x0,
                    /// Selecting Pad: GPIO_B1_06 for Mode: ALT8
                    GPIO_B1_06_ALT8 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// GPT1_IPP_IND_CLKIN_SELECT_INPUT DAISY Register
            GPT1_IPP_IND_CLKIN_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B0_13 for Mode: ALT1
                    GPIO_AD_B0_13_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_B1_04 for Mode: ALT8
                    GPIO_B1_04_ALT8 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// GPT2_IPP_IND_CAPIN1_SELECT_INPUT DAISY Register
            GPT2_IPP_IND_CAPIN1_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_41 for Mode: ALT1
                    GPIO_EMC_41_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_03 for Mode: ALT8
                    GPIO_AD_B1_03_ALT8 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// GPT2_IPP_IND_CAPIN2_SELECT_INPUT DAISY Register
            GPT2_IPP_IND_CAPIN2_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_40 for Mode: ALT1
                    GPIO_EMC_40_ALT1 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_04 for Mode: ALT8
                    GPIO_AD_B1_04_ALT8 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// GPT2_IPP_IND_CLKIN_SELECT_INPUT DAISY Register
            GPT2_IPP_IND_CLKIN_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_AD_B0_09 for Mode: ALT7
                    GPIO_AD_B0_09_ALT7 = 0x0,
                    /// Selecting Pad: GPIO_AD_B1_02 for Mode: ALT8
                    GPIO_AD_B1_02_ALT8 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// SAI3_IPG_CLK_SAI_MCLK_SELECT_INPUT_2 DAISY Register
            SAI3_IPG_CLK_SAI_MCLK_SELECT_INPUT_2: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_37 for Mode: ALT3
                    GPIO_EMC_37_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_SD_B1_04 for Mode: ALT8
                    GPIO_SD_B1_04_ALT8 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// SAI3_IPP_IND_SAI_RXBCLK_SELECT_INPUT DAISY Register
            SAI3_IPP_IND_SAI_RXBCLK_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_35 for Mode: ALT3
                    GPIO_EMC_35_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_SD_B1_06 for Mode: ALT8
                    GPIO_SD_B1_06_ALT8 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// SAI3_IPP_IND_SAI_RXDATA_SELECT_INPUT_0 DAISY Register
            SAI3_IPP_IND_SAI_RXDATA_SELECT_INPUT_0: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_33 for Mode: ALT3
                    GPIO_EMC_33_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_SD_B1_00 for Mode: ALT8
                    GPIO_SD_B1_00_ALT8 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// SAI3_IPP_IND_SAI_RXSYNC_SELECT_INPUT DAISY Register
            SAI3_IPP_IND_SAI_RXSYNC_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_34 for Mode: ALT3
                    GPIO_EMC_34_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_SD_B1_05 for Mode: ALT8
                    GPIO_SD_B1_05_ALT8 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// SAI3_IPP_IND_SAI_TXBCLK_SELECT_INPUT DAISY Register
            SAI3_IPP_IND_SAI_TXBCLK_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_38 for Mode: ALT3
                    GPIO_EMC_38_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_SD_B1_03 for Mode: ALT8
                    GPIO_SD_B1_03_ALT8 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// SAI3_IPP_IND_SAI_TXSYNC_SELECT_INPUT DAISY Register
            SAI3_IPP_IND_SAI_TXSYNC_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u1) {
                    /// Selecting Pad: GPIO_EMC_39 for Mode: ALT3
                    GPIO_EMC_39_ALT3 = 0x0,
                    /// Selecting Pad: GPIO_SD_B1_02 for Mode: ALT8
                    GPIO_SD_B1_02_ALT8 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// SEMC_I_IPP_IND_DQS4_SELECT_INPUT DAISY Register
            SEMC_I_IPP_IND_DQS4_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_SD_B0_00 for Mode: ALT9
                    GPIO_SD_B0_00_ALT9 = 0x0,
                    /// Selecting Pad: GPIO_EMC_39 for Mode: ALT9
                    GPIO_EMC_39_ALT9 = 0x1,
                    /// Selecting Pad: GPIO_AD_B0_09 for Mode: ALT9
                    GPIO_AD_B0_09_ALT9 = 0x2,
                    /// Selecting Pad: GPIO_B1_13 for Mode: ALT8
                    GPIO_B1_13_ALT8 = 0x3,
                },
                padding: u30 = 0,
            }),
            /// CANFD_IPP_IND_CANRX_SELECT_INPUT DAISY Register
            CANFD_IPP_IND_CANRX_SELECT_INPUT: mmio.Mmio(packed struct(u32) {
                /// Selecting Pads Involved in Daisy Chain.
                DAISY: enum(u2) {
                    /// Selecting Pad: GPIO_EMC_37 for Mode: ALT9
                    GPIO_EMC_37_ALT9 = 0x0,
                    /// Selecting Pad: GPIO_AD_B0_15 for Mode: ALT8
                    GPIO_AD_B0_15_ALT8 = 0x1,
                    /// Selecting Pad: GPIO_AD_B0_11 for Mode: ALT8
                    GPIO_AD_B0_11_ALT8 = 0x2,
                    _,
                },
                padding: u30 = 0,
            }),
        };

        /// IOMUXC_GPR
        pub const IOMUXC_GPR = extern struct {
            /// GPR0 General Purpose Register
            GPR0: u32,
            /// GPR1 General Purpose Register
            GPR1: mmio.Mmio(packed struct(u32) {
                /// SAI1 MCLK1 source select
                SAI1_MCLK1_SEL: enum(u3) {
                    /// ccm.ssi1_clk_root
                    SAI1_MCLK1_SEL_0 = 0x0,
                    /// ccm.ssi2_clk_root
                    SAI1_MCLK1_SEL_1 = 0x1,
                    /// ccm.ssi3_clk_root
                    SAI1_MCLK1_SEL_2 = 0x2,
                    /// iomux.sai1_ipg_clk_sai_mclk
                    SAI1_MCLK1_SEL_3 = 0x3,
                    /// iomux.sai2_ipg_clk_sai_mclk
                    SAI1_MCLK1_SEL_4 = 0x4,
                    /// iomux.sai3_ipg_clk_sai_mclk
                    SAI1_MCLK1_SEL_5 = 0x5,
                    _,
                },
                /// SAI1 MCLK2 source select
                SAI1_MCLK2_SEL: enum(u3) {
                    /// ccm.ssi1_clk_root
                    SAI1_MCLK2_SEL_0 = 0x0,
                    /// ccm.ssi2_clk_root
                    SAI1_MCLK2_SEL_1 = 0x1,
                    /// ccm.ssi3_clk_root
                    SAI1_MCLK2_SEL_2 = 0x2,
                    /// iomux.sai1_ipg_clk_sai_mclk
                    SAI1_MCLK2_SEL_3 = 0x3,
                    /// iomux.sai2_ipg_clk_sai_mclk
                    SAI1_MCLK2_SEL_4 = 0x4,
                    /// iomux.sai3_ipg_clk_sai_mclk
                    SAI1_MCLK2_SEL_5 = 0x5,
                    _,
                },
                /// SAI1 MCLK3 source select
                SAI1_MCLK3_SEL: enum(u2) {
                    /// ccm.spdif0_clk_root
                    SAI1_MCLK3_SEL_0 = 0x0,
                    /// iomux.spdif_tx_clk2
                    SAI1_MCLK3_SEL_1 = 0x1,
                    /// spdif.spdif_srclk
                    SAI1_MCLK3_SEL_2 = 0x2,
                    /// spdif.spdif_outclock
                    SAI1_MCLK3_SEL_3 = 0x3,
                },
                /// SAI2 MCLK3 source select
                SAI2_MCLK3_SEL: enum(u2) {
                    /// ccm.spdif0_clk_root
                    SAI2_MCLK3_SEL_0 = 0x0,
                    /// iomux.spdif_tx_clk2
                    SAI2_MCLK3_SEL_1 = 0x1,
                    /// spdif.spdif_srclk
                    SAI2_MCLK3_SEL_2 = 0x2,
                    /// spdif.spdif_outclock
                    SAI2_MCLK3_SEL_3 = 0x3,
                },
                /// SAI3 MCLK3 source select
                SAI3_MCLK3_SEL: enum(u2) {
                    /// ccm.spdif0_clk_root
                    SAI3_MCLK3_SEL_0 = 0x0,
                    /// iomux.spdif_tx_clk2
                    SAI3_MCLK3_SEL_1 = 0x1,
                    /// spdif.spdif_srclk
                    SAI3_MCLK3_SEL_2 = 0x2,
                    /// spdif.spdif_outclock
                    SAI3_MCLK3_SEL_3 = 0x3,
                },
                /// Global interrupt "0" bit (connected to ARM M7 IRQ#0 and GPC)
                GINT: enum(u1) {
                    /// Global interrupt request is not asserted.
                    GINT_0 = 0x0,
                    /// Global interrupt request is asserted.
                    GINT_1 = 0x1,
                },
                /// ENET1 reference clock mode select.
                ENET1_CLK_SEL: enum(u1) {
                    /// ENET1 TX reference clock driven by ref_enetpll. This clock is also output to pins via the IOMUX. ENET_REF_CLK1 function.
                    ENET1_CLK_SEL_0 = 0x0,
                    /// Gets ENET1 TX reference clock from the ENET1_TX_CLK pin. In this use case, an external OSC provides the clock for both the external PHY and the internal controller.
                    ENET1_CLK_SEL_1 = 0x1,
                },
                /// ENET2 reference clock mode select.
                ENET2_CLK_SEL: enum(u1) {
                    /// ENET2 TX reference clock driven by ref_enetpll. This clock is also output to pins via the IOMUX. ENET2_REF_CLK function.
                    ENET2_CLK_SEL_0 = 0x0,
                    /// Gets ENET2 TX reference clock from the ENET2_TX_CLK pin. In this use case, an external OSC provides the clock for both the external PHY and the internal controller.
                    ENET2_CLK_SEL_1 = 0x1,
                },
                /// USB Exposure mode
                USB_EXP_MODE: enum(u1) {
                    /// Exposure mode is disabled.
                    USB_EXP_MODE_0 = 0x0,
                    /// Exposure mode is enabled.
                    USB_EXP_MODE_1 = 0x1,
                },
                reserved17: u1 = 0,
                /// ENET1_TX_CLK data direction control
                ENET1_TX_CLK_DIR: enum(u1) {
                    /// ENET1_TX_CLK output driver is disabled
                    ENET1_TX_CLK_DIR_0 = 0x0,
                    /// ENET1_TX_CLK output driver is enabled
                    ENET1_TX_CLK_DIR_1 = 0x1,
                },
                /// ENET2_TX_CLK data direction control
                ENET2_TX_CLK_DIR: enum(u1) {
                    /// ENET2_TX_CLK output driver is disabled
                    ENET2_TX_CLK_DIR_0 = 0x0,
                    /// ENET2_TX_CLK output driver is enabled
                    ENET2_TX_CLK_DIR_1 = 0x1,
                },
                /// sai1.MCLK signal direction control
                SAI1_MCLK_DIR: enum(u1) {
                    /// sai1.MCLK is input signal
                    SAI1_MCLK_DIR_0 = 0x0,
                    /// sai1.MCLK is output signal
                    SAI1_MCLK_DIR_1 = 0x1,
                },
                /// sai2.MCLK signal direction control
                SAI2_MCLK_DIR: enum(u1) {
                    /// sai2.MCLK is input signal
                    SAI2_MCLK_DIR_0 = 0x0,
                    /// sai2.MCLK is output signal
                    SAI2_MCLK_DIR_1 = 0x1,
                },
                /// sai3.MCLK signal direction control
                SAI3_MCLK_DIR: enum(u1) {
                    /// sai3.MCLK is input signal
                    SAI3_MCLK_DIR_0 = 0x0,
                    /// sai3.MCLK is output signal
                    SAI3_MCLK_DIR_1 = 0x1,
                },
                /// Exclusive monitor response select of illegal command
                EXC_MON: enum(u1) {
                    /// OKAY response
                    EXC_MON_0 = 0x0,
                    /// SLVError response (default)
                    EXC_MON_1 = 0x1,
                },
                /// ENET and ENET2 ipg_clk_s clock gating enable
                ENET_IPG_CLK_S_EN: enum(u1) {
                    /// ipg_clk_s is gated when there is no IPS access
                    ENET_IPG_CLK_S_EN_0 = 0x0,
                    /// ipg_clk_s is always on
                    ENET_IPG_CLK_S_EN_1 = 0x1,
                },
                reserved31: u7 = 0,
                /// ARM CM7 platform AHB clock enable
                CM7_FORCE_HCLK_EN: enum(u1) {
                    /// AHB clock is not running (gated)
                    CM7_FORCE_HCLK_EN_0 = 0x0,
                    /// AHB clock is running (enabled)
                    CM7_FORCE_HCLK_EN_1 = 0x1,
                },
            }),
            /// GPR2 General Purpose Register
            GPR2: mmio.Mmio(packed struct(u32) {
                /// AXBS_L AHBXL master has higher priority.Do not set both DMA and AHBXL to high priority.
                AXBS_L_AHBXL_HIGH_PRIORITY: enum(u1) {
                    /// AXBS_L AHBXL master does not have high priority
                    AXBS_L_AHBXL_HIGH_PRIORITY_0 = 0x0,
                    /// AXBS_P AHBXL master has high priority
                    AXBS_L_AHBXL_HIGH_PRIORITY_1 = 0x1,
                },
                /// AXBS_L DMA master has higher priority.Do not set both DMA and AHBXL to high priority.
                AXBS_L_DMA_HIGH_PRIORITY: enum(u1) {
                    /// AXBS_L DMA master does not have high priority
                    AXBS_L_DMA_HIGH_PRIORITY_0 = 0x0,
                    /// AXBS_L DMA master has high priority
                    AXBS_L_DMA_HIGH_PRIORITY_1 = 0x1,
                },
                /// Force Round Robin in AXBS_L
                AXBS_L_FORCE_ROUND_ROBIN: enum(u1) {
                    /// AXBS_L masters are not arbitored in round robin, depending on DMA and AHBXL master priority settings.
                    AXBS_L_FORCE_ROUND_ROBIN_0 = 0x0,
                    /// AXBS_L masters are arbitored in round robin
                    AXBS_L_FORCE_ROUND_ROBIN_1 = 0x1,
                },
                /// AXBS_P M0 master has higher priority.Do not set both M1 and M0 to high priority.
                AXBS_P_M0_HIGH_PRIORITY: enum(u1) {
                    /// AXBS_P M0 master doesn't have high priority
                    AXBS_P_M0_HIGH_PRIORITY_0 = 0x0,
                    /// AXBS_P M0 master has high priority
                    AXBS_P_M0_HIGH_PRIORITY_1 = 0x1,
                },
                /// AXBS_P M1 master has higher priority.Do not set both M1 and M0 to high priority.
                AXBS_P_M1_HIGH_PRIORITY: enum(u1) {
                    /// AXBS_P M1 master does not have high priority
                    AXBS_P_M1_HIGH_PRIORITY_0 = 0x0,
                    /// AXBS_P M1 master has high priority
                    AXBS_P_M1_HIGH_PRIORITY_1 = 0x1,
                },
                /// Force Round Robin in AXBS_P. This bit can override master M0 M1 high priority configuration.
                AXBS_P_FORCE_ROUND_ROBIN: enum(u1) {
                    /// AXBS_P masters are not arbitored in round robin, depending on M0/M1 master priority settings.
                    AXBS_P_FORCE_ROUND_ROBIN_0 = 0x0,
                    /// AXBS_P masters are arbitored in round robin
                    AXBS_P_FORCE_ROUND_ROBIN_1 = 0x1,
                },
                /// Disable CANFD filter
                CANFD_FILTER_BYPASS: enum(u1) {
                    /// enable CANFD filter
                    CANFD_FILTER_BYPASS_0 = 0x0,
                    /// disable CANFD filter
                    CANFD_FILTER_BYPASS_1 = 0x1,
                },
                reserved12: u5 = 0,
                /// enable power saving features on L2 memory
                L2_MEM_EN_POWERSAVING: enum(u1) {
                    /// none memory power saving features enabled, SHUTDOWN/DEEPSLEEP/LIGHTSLEEP will have no effect
                    L2_MEM_EN_POWERSAVING_0 = 0x0,
                    /// memory power saving features enabled, set SHUTDOWN/DEEPSLEEP/LIGHTSLEEP (priority high to low) to enable power saving levels
                    L2_MEM_EN_POWERSAVING_1 = 0x1,
                },
                /// Automatically gate off RAM clock when RAM is not accessed.
                RAM_AUTO_CLK_GATING_EN: enum(u1) {
                    /// disable automatically gate off RAM clock
                    RAM_AUTO_CLK_GATING_EN_0 = 0x0,
                    /// enable automatically gate off RAM clock
                    RAM_AUTO_CLK_GATING_EN_1 = 0x1,
                },
                /// control how memory enter Deep Sleep mode (shutdown periphery power, but maintain memory contents, outputs of memory are pulled low)
                L2_MEM_DEEPSLEEP: enum(u1) {
                    /// no force sleep control supported, memory deep sleep mode only entered when whole system in stop mode
                    L2_MEM_DEEPSLEEP_0 = 0x0,
                    /// force memory into deep sleep mode
                    L2_MEM_DEEPSLEEP_1 = 0x1,
                },
                reserved16: u1 = 0,
                /// Divider ratio control for mclk from hmclk. mclk frequency = 1/(n+1) * hmclk frequency.
                MQS_CLK_DIV: enum(u8) {
                    /// mclk frequency = 1/1 * hmclk frequency
                    DIVIDE_1 = 0x0,
                    /// mclk frequency = 1/2 * hmclk frequency
                    DIVIDE_2 = 0x1,
                    /// mclk frequency = 1/3 * hmclk frequency
                    DIVIDE_3 = 0x2,
                    /// mclk frequency = 1/4 * hmclk frequency
                    DIVIDE_4 = 0x3,
                    /// mclk frequency = 1/5 * hmclk frequency
                    DIVIDE_5 = 0x4,
                    /// mclk frequency = 1/6 * hmclk frequency
                    DIVIDE_6 = 0x5,
                    /// mclk frequency = 1/7 * hmclk frequency
                    DIVIDE_7 = 0x6,
                    /// mclk frequency = 1/8 * hmclk frequency
                    DIVIDE_8 = 0x7,
                    /// mclk frequency = 1/9 * hmclk frequency
                    DIVIDE_9 = 0x8,
                    /// mclk frequency = 1/10 * hmclk frequency
                    DIVIDE_10 = 0x9,
                    /// mclk frequency = 1/11 * hmclk frequency
                    DIVIDE_11 = 0xa,
                    /// mclk frequency = 1/12 * hmclk frequency
                    DIVIDE_12 = 0xb,
                    /// mclk frequency = 1/13 * hmclk frequency
                    DIVIDE_13 = 0xc,
                    /// mclk frequency = 1/14 * hmclk frequency
                    DIVIDE_14 = 0xd,
                    /// mclk frequency = 1/15 * hmclk frequency
                    DIVIDE_15 = 0xe,
                    /// mclk frequency = 1/16 * hmclk frequency
                    DIVIDE_16 = 0xf,
                    /// mclk frequency = 1/17 * hmclk frequency
                    DIVIDE_17 = 0x10,
                    /// mclk frequency = 1/18 * hmclk frequency
                    DIVIDE_18 = 0x11,
                    /// mclk frequency = 1/19 * hmclk frequency
                    DIVIDE_19 = 0x12,
                    /// mclk frequency = 1/20 * hmclk frequency
                    DIVIDE_20 = 0x13,
                    /// mclk frequency = 1/21 * hmclk frequency
                    DIVIDE_21 = 0x14,
                    /// mclk frequency = 1/22 * hmclk frequency
                    DIVIDE_22 = 0x15,
                    /// mclk frequency = 1/23 * hmclk frequency
                    DIVIDE_23 = 0x16,
                    /// mclk frequency = 1/24 * hmclk frequency
                    DIVIDE_24 = 0x17,
                    /// mclk frequency = 1/25 * hmclk frequency
                    DIVIDE_25 = 0x18,
                    /// mclk frequency = 1/26 * hmclk frequency
                    DIVIDE_26 = 0x19,
                    /// mclk frequency = 1/27 * hmclk frequency
                    DIVIDE_27 = 0x1a,
                    /// mclk frequency = 1/28 * hmclk frequency
                    DIVIDE_28 = 0x1b,
                    /// mclk frequency = 1/29 * hmclk frequency
                    DIVIDE_29 = 0x1c,
                    /// mclk frequency = 1/30 * hmclk frequency
                    DIVIDE_30 = 0x1d,
                    /// mclk frequency = 1/31 * hmclk frequency
                    DIVIDE_31 = 0x1e,
                    /// mclk frequency = 1/32 * hmclk frequency
                    DIVIDE_32 = 0x1f,
                    /// mclk frequency = 1/33 * hmclk frequency
                    DIVIDE_33 = 0x20,
                    /// mclk frequency = 1/34 * hmclk frequency
                    DIVIDE_34 = 0x21,
                    /// mclk frequency = 1/35 * hmclk frequency
                    DIVIDE_35 = 0x22,
                    /// mclk frequency = 1/36 * hmclk frequency
                    DIVIDE_36 = 0x23,
                    /// mclk frequency = 1/37 * hmclk frequency
                    DIVIDE_37 = 0x24,
                    /// mclk frequency = 1/38 * hmclk frequency
                    DIVIDE_38 = 0x25,
                    /// mclk frequency = 1/39 * hmclk frequency
                    DIVIDE_39 = 0x26,
                    /// mclk frequency = 1/40 * hmclk frequency
                    DIVIDE_40 = 0x27,
                    /// mclk frequency = 1/41 * hmclk frequency
                    DIVIDE_41 = 0x28,
                    /// mclk frequency = 1/42 * hmclk frequency
                    DIVIDE_42 = 0x29,
                    /// mclk frequency = 1/43 * hmclk frequency
                    DIVIDE_43 = 0x2a,
                    /// mclk frequency = 1/44 * hmclk frequency
                    DIVIDE_44 = 0x2b,
                    /// mclk frequency = 1/45 * hmclk frequency
                    DIVIDE_45 = 0x2c,
                    /// mclk frequency = 1/46 * hmclk frequency
                    DIVIDE_46 = 0x2d,
                    /// mclk frequency = 1/47 * hmclk frequency
                    DIVIDE_47 = 0x2e,
                    /// mclk frequency = 1/48 * hmclk frequency
                    DIVIDE_48 = 0x2f,
                    /// mclk frequency = 1/49 * hmclk frequency
                    DIVIDE_49 = 0x30,
                    /// mclk frequency = 1/50 * hmclk frequency
                    DIVIDE_50 = 0x31,
                    /// mclk frequency = 1/51 * hmclk frequency
                    DIVIDE_51 = 0x32,
                    /// mclk frequency = 1/52 * hmclk frequency
                    DIVIDE_52 = 0x33,
                    /// mclk frequency = 1/53 * hmclk frequency
                    DIVIDE_53 = 0x34,
                    /// mclk frequency = 1/54 * hmclk frequency
                    DIVIDE_54 = 0x35,
                    /// mclk frequency = 1/55 * hmclk frequency
                    DIVIDE_55 = 0x36,
                    /// mclk frequency = 1/56 * hmclk frequency
                    DIVIDE_56 = 0x37,
                    /// mclk frequency = 1/57 * hmclk frequency
                    DIVIDE_57 = 0x38,
                    /// mclk frequency = 1/58 * hmclk frequency
                    DIVIDE_58 = 0x39,
                    /// mclk frequency = 1/59 * hmclk frequency
                    DIVIDE_59 = 0x3a,
                    /// mclk frequency = 1/60 * hmclk frequency
                    DIVIDE_60 = 0x3b,
                    /// mclk frequency = 1/61 * hmclk frequency
                    DIVIDE_61 = 0x3c,
                    /// mclk frequency = 1/62 * hmclk frequency
                    DIVIDE_62 = 0x3d,
                    /// mclk frequency = 1/63 * hmclk frequency
                    DIVIDE_63 = 0x3e,
                    /// mclk frequency = 1/64 * hmclk frequency
                    DIVIDE_64 = 0x3f,
                    /// mclk frequency = 1/65 * hmclk frequency
                    DIVIDE_65 = 0x40,
                    /// mclk frequency = 1/66 * hmclk frequency
                    DIVIDE_66 = 0x41,
                    /// mclk frequency = 1/67 * hmclk frequency
                    DIVIDE_67 = 0x42,
                    /// mclk frequency = 1/68 * hmclk frequency
                    DIVIDE_68 = 0x43,
                    /// mclk frequency = 1/69 * hmclk frequency
                    DIVIDE_69 = 0x44,
                    /// mclk frequency = 1/70 * hmclk frequency
                    DIVIDE_70 = 0x45,
                    /// mclk frequency = 1/71 * hmclk frequency
                    DIVIDE_71 = 0x46,
                    /// mclk frequency = 1/72 * hmclk frequency
                    DIVIDE_72 = 0x47,
                    /// mclk frequency = 1/73 * hmclk frequency
                    DIVIDE_73 = 0x48,
                    /// mclk frequency = 1/74 * hmclk frequency
                    DIVIDE_74 = 0x49,
                    /// mclk frequency = 1/75 * hmclk frequency
                    DIVIDE_75 = 0x4a,
                    /// mclk frequency = 1/76 * hmclk frequency
                    DIVIDE_76 = 0x4b,
                    /// mclk frequency = 1/77 * hmclk frequency
                    DIVIDE_77 = 0x4c,
                    /// mclk frequency = 1/78 * hmclk frequency
                    DIVIDE_78 = 0x4d,
                    /// mclk frequency = 1/79 * hmclk frequency
                    DIVIDE_79 = 0x4e,
                    /// mclk frequency = 1/80 * hmclk frequency
                    DIVIDE_80 = 0x4f,
                    /// mclk frequency = 1/81 * hmclk frequency
                    DIVIDE_81 = 0x50,
                    /// mclk frequency = 1/82 * hmclk frequency
                    DIVIDE_82 = 0x51,
                    /// mclk frequency = 1/83 * hmclk frequency
                    DIVIDE_83 = 0x52,
                    /// mclk frequency = 1/84 * hmclk frequency
                    DIVIDE_84 = 0x53,
                    /// mclk frequency = 1/85 * hmclk frequency
                    DIVIDE_85 = 0x54,
                    /// mclk frequency = 1/86 * hmclk frequency
                    DIVIDE_86 = 0x55,
                    /// mclk frequency = 1/87 * hmclk frequency
                    DIVIDE_87 = 0x56,
                    /// mclk frequency = 1/88 * hmclk frequency
                    DIVIDE_88 = 0x57,
                    /// mclk frequency = 1/89 * hmclk frequency
                    DIVIDE_89 = 0x58,
                    /// mclk frequency = 1/90 * hmclk frequency
                    DIVIDE_90 = 0x59,
                    /// mclk frequency = 1/91 * hmclk frequency
                    DIVIDE_91 = 0x5a,
                    /// mclk frequency = 1/92 * hmclk frequency
                    DIVIDE_92 = 0x5b,
                    /// mclk frequency = 1/93 * hmclk frequency
                    DIVIDE_93 = 0x5c,
                    /// mclk frequency = 1/94 * hmclk frequency
                    DIVIDE_94 = 0x5d,
                    /// mclk frequency = 1/95 * hmclk frequency
                    DIVIDE_95 = 0x5e,
                    /// mclk frequency = 1/96 * hmclk frequency
                    DIVIDE_96 = 0x5f,
                    /// mclk frequency = 1/97 * hmclk frequency
                    DIVIDE_97 = 0x60,
                    /// mclk frequency = 1/98 * hmclk frequency
                    DIVIDE_98 = 0x61,
                    /// mclk frequency = 1/99 * hmclk frequency
                    DIVIDE_99 = 0x62,
                    /// mclk frequency = 1/100 * hmclk frequency
                    DIVIDE_100 = 0x63,
                    /// mclk frequency = 1/101 * hmclk frequency
                    DIVIDE_101 = 0x64,
                    /// mclk frequency = 1/102 * hmclk frequency
                    DIVIDE_102 = 0x65,
                    /// mclk frequency = 1/103 * hmclk frequency
                    DIVIDE_103 = 0x66,
                    /// mclk frequency = 1/104 * hmclk frequency
                    DIVIDE_104 = 0x67,
                    /// mclk frequency = 1/105 * hmclk frequency
                    DIVIDE_105 = 0x68,
                    /// mclk frequency = 1/106 * hmclk frequency
                    DIVIDE_106 = 0x69,
                    /// mclk frequency = 1/107 * hmclk frequency
                    DIVIDE_107 = 0x6a,
                    /// mclk frequency = 1/108 * hmclk frequency
                    DIVIDE_108 = 0x6b,
                    /// mclk frequency = 1/109 * hmclk frequency
                    DIVIDE_109 = 0x6c,
                    /// mclk frequency = 1/110 * hmclk frequency
                    DIVIDE_110 = 0x6d,
                    /// mclk frequency = 1/111 * hmclk frequency
                    DIVIDE_111 = 0x6e,
                    /// mclk frequency = 1/112 * hmclk frequency
                    DIVIDE_112 = 0x6f,
                    /// mclk frequency = 1/113 * hmclk frequency
                    DIVIDE_113 = 0x70,
                    /// mclk frequency = 1/114 * hmclk frequency
                    DIVIDE_114 = 0x71,
                    /// mclk frequency = 1/115 * hmclk frequency
                    DIVIDE_115 = 0x72,
                    /// mclk frequency = 1/116 * hmclk frequency
                    DIVIDE_116 = 0x73,
                    /// mclk frequency = 1/117 * hmclk frequency
                    DIVIDE_117 = 0x74,
                    /// mclk frequency = 1/118 * hmclk frequency
                    DIVIDE_118 = 0x75,
                    /// mclk frequency = 1/119 * hmclk frequency
                    DIVIDE_119 = 0x76,
                    /// mclk frequency = 1/120 * hmclk frequency
                    DIVIDE_120 = 0x77,
                    /// mclk frequency = 1/121 * hmclk frequency
                    DIVIDE_121 = 0x78,
                    /// mclk frequency = 1/122 * hmclk frequency
                    DIVIDE_122 = 0x79,
                    /// mclk frequency = 1/123 * hmclk frequency
                    DIVIDE_123 = 0x7a,
                    /// mclk frequency = 1/124 * hmclk frequency
                    DIVIDE_124 = 0x7b,
                    /// mclk frequency = 1/125 * hmclk frequency
                    DIVIDE_125 = 0x7c,
                    /// mclk frequency = 1/126 * hmclk frequency
                    DIVIDE_126 = 0x7d,
                    /// mclk frequency = 1/127 * hmclk frequency
                    DIVIDE_127 = 0x7e,
                    /// mclk frequency = 1/128 * hmclk frequency
                    DIVIDE_128 = 0x7f,
                    /// mclk frequency = 1/129 * hmclk frequency
                    DIVIDE_129 = 0x80,
                    /// mclk frequency = 1/130 * hmclk frequency
                    DIVIDE_130 = 0x81,
                    /// mclk frequency = 1/131 * hmclk frequency
                    DIVIDE_131 = 0x82,
                    /// mclk frequency = 1/132 * hmclk frequency
                    DIVIDE_132 = 0x83,
                    /// mclk frequency = 1/133 * hmclk frequency
                    DIVIDE_133 = 0x84,
                    /// mclk frequency = 1/134 * hmclk frequency
                    DIVIDE_134 = 0x85,
                    /// mclk frequency = 1/135 * hmclk frequency
                    DIVIDE_135 = 0x86,
                    /// mclk frequency = 1/136 * hmclk frequency
                    DIVIDE_136 = 0x87,
                    /// mclk frequency = 1/137 * hmclk frequency
                    DIVIDE_137 = 0x88,
                    /// mclk frequency = 1/138 * hmclk frequency
                    DIVIDE_138 = 0x89,
                    /// mclk frequency = 1/139 * hmclk frequency
                    DIVIDE_139 = 0x8a,
                    /// mclk frequency = 1/140 * hmclk frequency
                    DIVIDE_140 = 0x8b,
                    /// mclk frequency = 1/141 * hmclk frequency
                    DIVIDE_141 = 0x8c,
                    /// mclk frequency = 1/142 * hmclk frequency
                    DIVIDE_142 = 0x8d,
                    /// mclk frequency = 1/143 * hmclk frequency
                    DIVIDE_143 = 0x8e,
                    /// mclk frequency = 1/144 * hmclk frequency
                    DIVIDE_144 = 0x8f,
                    /// mclk frequency = 1/145 * hmclk frequency
                    DIVIDE_145 = 0x90,
                    /// mclk frequency = 1/146 * hmclk frequency
                    DIVIDE_146 = 0x91,
                    /// mclk frequency = 1/147 * hmclk frequency
                    DIVIDE_147 = 0x92,
                    /// mclk frequency = 1/148 * hmclk frequency
                    DIVIDE_148 = 0x93,
                    /// mclk frequency = 1/149 * hmclk frequency
                    DIVIDE_149 = 0x94,
                    /// mclk frequency = 1/150 * hmclk frequency
                    DIVIDE_150 = 0x95,
                    /// mclk frequency = 1/151 * hmclk frequency
                    DIVIDE_151 = 0x96,
                    /// mclk frequency = 1/152 * hmclk frequency
                    DIVIDE_152 = 0x97,
                    /// mclk frequency = 1/153 * hmclk frequency
                    DIVIDE_153 = 0x98,
                    /// mclk frequency = 1/154 * hmclk frequency
                    DIVIDE_154 = 0x99,
                    /// mclk frequency = 1/155 * hmclk frequency
                    DIVIDE_155 = 0x9a,
                    /// mclk frequency = 1/156 * hmclk frequency
                    DIVIDE_156 = 0x9b,
                    /// mclk frequency = 1/157 * hmclk frequency
                    DIVIDE_157 = 0x9c,
                    /// mclk frequency = 1/158 * hmclk frequency
                    DIVIDE_158 = 0x9d,
                    /// mclk frequency = 1/159 * hmclk frequency
                    DIVIDE_159 = 0x9e,
                    /// mclk frequency = 1/160 * hmclk frequency
                    DIVIDE_160 = 0x9f,
                    /// mclk frequency = 1/161 * hmclk frequency
                    DIVIDE_161 = 0xa0,
                    /// mclk frequency = 1/162 * hmclk frequency
                    DIVIDE_162 = 0xa1,
                    /// mclk frequency = 1/163 * hmclk frequency
                    DIVIDE_163 = 0xa2,
                    /// mclk frequency = 1/164 * hmclk frequency
                    DIVIDE_164 = 0xa3,
                    /// mclk frequency = 1/165 * hmclk frequency
                    DIVIDE_165 = 0xa4,
                    /// mclk frequency = 1/166 * hmclk frequency
                    DIVIDE_166 = 0xa5,
                    /// mclk frequency = 1/167 * hmclk frequency
                    DIVIDE_167 = 0xa6,
                    /// mclk frequency = 1/168 * hmclk frequency
                    DIVIDE_168 = 0xa7,
                    /// mclk frequency = 1/169 * hmclk frequency
                    DIVIDE_169 = 0xa8,
                    /// mclk frequency = 1/170 * hmclk frequency
                    DIVIDE_170 = 0xa9,
                    /// mclk frequency = 1/171 * hmclk frequency
                    DIVIDE_171 = 0xaa,
                    /// mclk frequency = 1/172 * hmclk frequency
                    DIVIDE_172 = 0xab,
                    /// mclk frequency = 1/173 * hmclk frequency
                    DIVIDE_173 = 0xac,
                    /// mclk frequency = 1/174 * hmclk frequency
                    DIVIDE_174 = 0xad,
                    /// mclk frequency = 1/175 * hmclk frequency
                    DIVIDE_175 = 0xae,
                    /// mclk frequency = 1/176 * hmclk frequency
                    DIVIDE_176 = 0xaf,
                    /// mclk frequency = 1/177 * hmclk frequency
                    DIVIDE_177 = 0xb0,
                    /// mclk frequency = 1/178 * hmclk frequency
                    DIVIDE_178 = 0xb1,
                    /// mclk frequency = 1/179 * hmclk frequency
                    DIVIDE_179 = 0xb2,
                    /// mclk frequency = 1/180 * hmclk frequency
                    DIVIDE_180 = 0xb3,
                    /// mclk frequency = 1/181 * hmclk frequency
                    DIVIDE_181 = 0xb4,
                    /// mclk frequency = 1/182 * hmclk frequency
                    DIVIDE_182 = 0xb5,
                    /// mclk frequency = 1/183 * hmclk frequency
                    DIVIDE_183 = 0xb6,
                    /// mclk frequency = 1/184 * hmclk frequency
                    DIVIDE_184 = 0xb7,
                    /// mclk frequency = 1/185 * hmclk frequency
                    DIVIDE_185 = 0xb8,
                    /// mclk frequency = 1/186 * hmclk frequency
                    DIVIDE_186 = 0xb9,
                    /// mclk frequency = 1/187 * hmclk frequency
                    DIVIDE_187 = 0xba,
                    /// mclk frequency = 1/188 * hmclk frequency
                    DIVIDE_188 = 0xbb,
                    /// mclk frequency = 1/189 * hmclk frequency
                    DIVIDE_189 = 0xbc,
                    /// mclk frequency = 1/190 * hmclk frequency
                    DIVIDE_190 = 0xbd,
                    /// mclk frequency = 1/191 * hmclk frequency
                    DIVIDE_191 = 0xbe,
                    /// mclk frequency = 1/192 * hmclk frequency
                    DIVIDE_192 = 0xbf,
                    /// mclk frequency = 1/193 * hmclk frequency
                    DIVIDE_193 = 0xc0,
                    /// mclk frequency = 1/194 * hmclk frequency
                    DIVIDE_194 = 0xc1,
                    /// mclk frequency = 1/195 * hmclk frequency
                    DIVIDE_195 = 0xc2,
                    /// mclk frequency = 1/196 * hmclk frequency
                    DIVIDE_196 = 0xc3,
                    /// mclk frequency = 1/197 * hmclk frequency
                    DIVIDE_197 = 0xc4,
                    /// mclk frequency = 1/198 * hmclk frequency
                    DIVIDE_198 = 0xc5,
                    /// mclk frequency = 1/199 * hmclk frequency
                    DIVIDE_199 = 0xc6,
                    /// mclk frequency = 1/200 * hmclk frequency
                    DIVIDE_200 = 0xc7,
                    /// mclk frequency = 1/201 * hmclk frequency
                    DIVIDE_201 = 0xc8,
                    /// mclk frequency = 1/202 * hmclk frequency
                    DIVIDE_202 = 0xc9,
                    /// mclk frequency = 1/203 * hmclk frequency
                    DIVIDE_203 = 0xca,
                    /// mclk frequency = 1/204 * hmclk frequency
                    DIVIDE_204 = 0xcb,
                    /// mclk frequency = 1/205 * hmclk frequency
                    DIVIDE_205 = 0xcc,
                    /// mclk frequency = 1/206 * hmclk frequency
                    DIVIDE_206 = 0xcd,
                    /// mclk frequency = 1/207 * hmclk frequency
                    DIVIDE_207 = 0xce,
                    /// mclk frequency = 1/208 * hmclk frequency
                    DIVIDE_208 = 0xcf,
                    /// mclk frequency = 1/209 * hmclk frequency
                    DIVIDE_209 = 0xd0,
                    /// mclk frequency = 1/210 * hmclk frequency
                    DIVIDE_210 = 0xd1,
                    /// mclk frequency = 1/211 * hmclk frequency
                    DIVIDE_211 = 0xd2,
                    /// mclk frequency = 1/212 * hmclk frequency
                    DIVIDE_212 = 0xd3,
                    /// mclk frequency = 1/213 * hmclk frequency
                    DIVIDE_213 = 0xd4,
                    /// mclk frequency = 1/214 * hmclk frequency
                    DIVIDE_214 = 0xd5,
                    /// mclk frequency = 1/215 * hmclk frequency
                    DIVIDE_215 = 0xd6,
                    /// mclk frequency = 1/216 * hmclk frequency
                    DIVIDE_216 = 0xd7,
                    /// mclk frequency = 1/217 * hmclk frequency
                    DIVIDE_217 = 0xd8,
                    /// mclk frequency = 1/218 * hmclk frequency
                    DIVIDE_218 = 0xd9,
                    /// mclk frequency = 1/219 * hmclk frequency
                    DIVIDE_219 = 0xda,
                    /// mclk frequency = 1/220 * hmclk frequency
                    DIVIDE_220 = 0xdb,
                    /// mclk frequency = 1/221 * hmclk frequency
                    DIVIDE_221 = 0xdc,
                    /// mclk frequency = 1/222 * hmclk frequency
                    DIVIDE_222 = 0xdd,
                    /// mclk frequency = 1/223 * hmclk frequency
                    DIVIDE_223 = 0xde,
                    /// mclk frequency = 1/224 * hmclk frequency
                    DIVIDE_224 = 0xdf,
                    /// mclk frequency = 1/225 * hmclk frequency
                    DIVIDE_225 = 0xe0,
                    /// mclk frequency = 1/226 * hmclk frequency
                    DIVIDE_226 = 0xe1,
                    /// mclk frequency = 1/227 * hmclk frequency
                    DIVIDE_227 = 0xe2,
                    /// mclk frequency = 1/228 * hmclk frequency
                    DIVIDE_228 = 0xe3,
                    /// mclk frequency = 1/229 * hmclk frequency
                    DIVIDE_229 = 0xe4,
                    /// mclk frequency = 1/230 * hmclk frequency
                    DIVIDE_230 = 0xe5,
                    /// mclk frequency = 1/231 * hmclk frequency
                    DIVIDE_231 = 0xe6,
                    /// mclk frequency = 1/232 * hmclk frequency
                    DIVIDE_232 = 0xe7,
                    /// mclk frequency = 1/233 * hmclk frequency
                    DIVIDE_233 = 0xe8,
                    /// mclk frequency = 1/234 * hmclk frequency
                    DIVIDE_234 = 0xe9,
                    /// mclk frequency = 1/235 * hmclk frequency
                    DIVIDE_235 = 0xea,
                    /// mclk frequency = 1/236 * hmclk frequency
                    DIVIDE_236 = 0xeb,
                    /// mclk frequency = 1/237 * hmclk frequency
                    DIVIDE_237 = 0xec,
                    /// mclk frequency = 1/238 * hmclk frequency
                    DIVIDE_238 = 0xed,
                    /// mclk frequency = 1/239 * hmclk frequency
                    DIVIDE_239 = 0xee,
                    /// mclk frequency = 1/240 * hmclk frequency
                    DIVIDE_240 = 0xef,
                    /// mclk frequency = 1/241 * hmclk frequency
                    DIVIDE_241 = 0xf0,
                    /// mclk frequency = 1/242 * hmclk frequency
                    DIVIDE_242 = 0xf1,
                    /// mclk frequency = 1/243 * hmclk frequency
                    DIVIDE_243 = 0xf2,
                    /// mclk frequency = 1/244 * hmclk frequency
                    DIVIDE_244 = 0xf3,
                    /// mclk frequency = 1/245 * hmclk frequency
                    DIVIDE_245 = 0xf4,
                    /// mclk frequency = 1/246 * hmclk frequency
                    DIVIDE_246 = 0xf5,
                    /// mclk frequency = 1/247 * hmclk frequency
                    DIVIDE_247 = 0xf6,
                    /// mclk frequency = 1/248 * hmclk frequency
                    DIVIDE_248 = 0xf7,
                    /// mclk frequency = 1/249 * hmclk frequency
                    DIVIDE_249 = 0xf8,
                    /// mclk frequency = 1/250 * hmclk frequency
                    DIVIDE_250 = 0xf9,
                    /// mclk frequency = 1/251 * hmclk frequency
                    DIVIDE_251 = 0xfa,
                    /// mclk frequency = 1/252 * hmclk frequency
                    DIVIDE_252 = 0xfb,
                    /// mclk frequency = 1/253 * hmclk frequency
                    DIVIDE_253 = 0xfc,
                    /// mclk frequency = 1/254 * hmclk frequency
                    DIVIDE_254 = 0xfd,
                    /// mclk frequency = 1/255 * hmclk frequency
                    DIVIDE_255 = 0xfe,
                    /// mclk frequency = 1/256 * hmclk frequency
                    DIVIDE_256 = 0xff,
                },
                /// MQS software reset
                MQS_SW_RST: enum(u1) {
                    /// Exit software reset for MQS
                    MQS_SW_RST_0 = 0x0,
                    /// Enable software reset for MQS
                    MQS_SW_RST_1 = 0x1,
                },
                /// MQS enable.
                MQS_EN: enum(u1) {
                    /// Disable MQS
                    MQS_EN_0 = 0x0,
                    /// Enable MQS
                    MQS_EN_1 = 0x1,
                },
                /// Used to control the PWM oversampling rate compared with mclk.
                MQS_OVERSAMPLE: enum(u1) {
                    /// 32
                    MQS_OVERSAMPLE_0 = 0x0,
                    /// 64
                    MQS_OVERSAMPLE_1 = 0x1,
                },
                reserved28: u1 = 0,
                /// QTIMER1 timer counter freeze
                QTIMER1_TMR_CNTS_FREEZE: enum(u1) {
                    /// timer counter work normally
                    QTIMER1_TMR_CNTS_FREEZE_0 = 0x0,
                    /// reset counter and ouput flags
                    QTIMER1_TMR_CNTS_FREEZE_1 = 0x1,
                },
                /// QTIMER2 timer counter freeze
                QTIMER2_TMR_CNTS_FREEZE: enum(u1) {
                    /// timer counter work normally
                    QTIMER2_TMR_CNTS_FREEZE_0 = 0x0,
                    /// reset counter and ouput flags
                    QTIMER2_TMR_CNTS_FREEZE_1 = 0x1,
                },
                /// QTIMER3 timer counter freeze
                QTIMER3_TMR_CNTS_FREEZE: enum(u1) {
                    /// timer counter work normally
                    QTIMER3_TMR_CNTS_FREEZE_0 = 0x0,
                    /// reset counter and ouput flags
                    QTIMER3_TMR_CNTS_FREEZE_1 = 0x1,
                },
                /// QTIMER4 timer counter freeze
                QTIMER4_TMR_CNTS_FREEZE: enum(u1) {
                    /// timer counter work normally
                    QTIMER4_TMR_CNTS_FREEZE_0 = 0x0,
                    /// reset counter and ouput flags
                    QTIMER4_TMR_CNTS_FREEZE_1 = 0x1,
                },
            }),
            /// GPR3 General Purpose Register
            GPR3: mmio.Mmio(packed struct(u32) {
                /// OCRAM_CTL[3] - write address pipeline control bit
                OCRAM_CTL: u4,
                /// Select 128-bit dcp key from 256-bit key from snvs/ocotp
                DCP_KEY_SEL: enum(u1) {
                    /// Select [127:0] from snvs/ocotp key as dcp key
                    DCP_KEY_SEL_0 = 0x0,
                    /// Select [255:128] from snvs/ocotp key as dcp key
                    DCP_KEY_SEL_1 = 0x1,
                },
                reserved8: u3 = 0,
                /// OCRAM2_CTL[3] - write address pipeline control bit
                OCRAM2_CTL: u4,
                reserved15: u3 = 0,
                /// Request to halt axbs_l
                AXBS_L_HALT_REQ: enum(u1) {
                    /// axbs_l normal run
                    AXBS_L_HALT_REQ_0 = 0x0,
                    /// request to halt axbs_l
                    AXBS_L_HALT_REQ_1 = 0x1,
                },
                /// This field shows the OCRAM pipeline settings status, controlled by OCRAM_CTL bits respectively
                OCRAM_STATUS: u4,
                reserved24: u4 = 0,
                /// This field shows the OCRAM2 pipeline settings status, controlled by OCRAM2_CTL bits respectively
                OCRAM2_STATUS: u4,
                reserved31: u3 = 0,
                /// This bit shows the status of axbs_l
                AXBS_L_HALTED: enum(u1) {
                    /// axbs_l is not halted
                    AXBS_L_HALTED_0 = 0x0,
                    /// axbs_l is in halted status
                    AXBS_L_HALTED_1 = 0x1,
                },
            }),
            /// GPR4 General Purpose Register
            GPR4: mmio.Mmio(packed struct(u32) {
                /// EDMA stop request.
                EDMA_STOP_REQ: enum(u1) {
                    /// stop request off
                    EDMA_STOP_REQ_0 = 0x0,
                    /// stop request on
                    EDMA_STOP_REQ_1 = 0x1,
                },
                /// CAN1 stop request.
                CAN1_STOP_REQ: enum(u1) {
                    /// stop request off
                    CAN1_STOP_REQ_0 = 0x0,
                    /// stop request on
                    CAN1_STOP_REQ_1 = 0x1,
                },
                /// CAN2 stop request.
                CAN2_STOP_REQ: enum(u1) {
                    /// stop request off
                    CAN2_STOP_REQ_0 = 0x0,
                    /// stop request on
                    CAN2_STOP_REQ_1 = 0x1,
                },
                /// TRNG stop request.
                TRNG_STOP_REQ: enum(u1) {
                    /// stop request off
                    TRNG_STOP_REQ_0 = 0x0,
                    /// stop request on
                    TRNG_STOP_REQ_1 = 0x1,
                },
                /// ENET stop request.
                ENET_STOP_REQ: enum(u1) {
                    /// stop request off
                    ENET_STOP_REQ_0 = 0x0,
                    /// stop request on
                    ENET_STOP_REQ_1 = 0x1,
                },
                /// SAI1 stop request.
                SAI1_STOP_REQ: enum(u1) {
                    /// stop request off
                    SAI1_STOP_REQ_0 = 0x0,
                    /// stop request on
                    SAI1_STOP_REQ_1 = 0x1,
                },
                /// SAI2 stop request.
                SAI2_STOP_REQ: enum(u1) {
                    /// stop request off
                    SAI2_STOP_REQ_0 = 0x0,
                    /// stop request on
                    SAI2_STOP_REQ_1 = 0x1,
                },
                /// SAI3 stop request.
                SAI3_STOP_REQ: enum(u1) {
                    /// stop request off
                    SAI3_STOP_REQ_0 = 0x0,
                    /// stop request on
                    SAI3_STOP_REQ_1 = 0x1,
                },
                /// ENET2 stop request.
                ENET2_STOP_REQ: enum(u1) {
                    /// stop request off
                    ENET2_STOP_REQ_0 = 0x0,
                    /// stop request on
                    ENET2_STOP_REQ_1 = 0x1,
                },
                /// SEMC stop request.
                SEMC_STOP_REQ: enum(u1) {
                    /// stop request off
                    SEMC_STOP_REQ_0 = 0x0,
                    /// stop request on
                    SEMC_STOP_REQ_1 = 0x1,
                },
                /// PIT stop request.
                PIT_STOP_REQ: enum(u1) {
                    /// stop request off
                    PIT_STOP_REQ_0 = 0x0,
                    /// stop request on
                    PIT_STOP_REQ_1 = 0x1,
                },
                /// FlexSPI stop request.
                FLEXSPI_STOP_REQ: enum(u1) {
                    /// stop request off
                    FLEXSPI_STOP_REQ_0 = 0x0,
                    /// stop request on
                    FLEXSPI_STOP_REQ_1 = 0x1,
                },
                /// FlexIO1 stop request.
                FLEXIO1_STOP_REQ: enum(u1) {
                    /// stop request off
                    FLEXIO1_STOP_REQ_0 = 0x0,
                    /// stop request on
                    FLEXIO1_STOP_REQ_1 = 0x1,
                },
                /// FlexIO2 stop request.
                FLEXIO2_STOP_REQ: enum(u1) {
                    /// stop request off
                    FLEXIO2_STOP_REQ_0 = 0x0,
                    /// stop request on
                    FLEXIO2_STOP_REQ_1 = 0x1,
                },
                /// On-platform flexio3 stop request.
                FLEXIO3_STOP_REQ: enum(u1) {
                    /// stop request off
                    FLEXIO3_STOP_REQ_0 = 0x0,
                    /// stop request on
                    FLEXIO3_STOP_REQ_1 = 0x1,
                },
                /// FlexSPI2 stop request.
                FLEXSPI2_STOP_REQ: enum(u1) {
                    /// stop request off
                    FLEXSPI2_STOP_REQ_0 = 0x0,
                    /// stop request on
                    FLEXSPI2_STOP_REQ_1 = 0x1,
                },
                /// EDMA stop acknowledge. This is a status (read-only) bit
                EDMA_STOP_ACK: enum(u1) {
                    /// EDMA stop acknowledge is not asserted
                    EDMA_STOP_ACK_0 = 0x0,
                    /// EDMA stop acknowledge is asserted (EDMA is in STOP mode).
                    EDMA_STOP_ACK_1 = 0x1,
                },
                /// CAN1 stop acknowledge.
                CAN1_STOP_ACK: enum(u1) {
                    /// CAN1 stop acknowledge is not asserted
                    CAN1_STOP_ACK_0 = 0x0,
                    /// CAN1 stop acknowledge is asserted
                    CAN1_STOP_ACK_1 = 0x1,
                },
                /// CAN2 stop acknowledge.
                CAN2_STOP_ACK: enum(u1) {
                    /// CAN2 stop acknowledge is not asserted
                    CAN2_STOP_ACK_0 = 0x0,
                    /// CAN2 stop acknowledge is asserted
                    CAN2_STOP_ACK_1 = 0x1,
                },
                /// TRNG stop acknowledge
                TRNG_STOP_ACK: enum(u1) {
                    /// TRNG stop acknowledge is not asserted
                    TRNG_STOP_ACK_0 = 0x0,
                    /// TRNG stop acknowledge is asserted
                    TRNG_STOP_ACK_1 = 0x1,
                },
                /// ENET stop acknowledge.
                ENET_STOP_ACK: enum(u1) {
                    /// ENET1 stop acknowledge is not asserted
                    ENET_STOP_ACK_0 = 0x0,
                    /// ENET1 stop acknowledge is asserted
                    ENET_STOP_ACK_1 = 0x1,
                },
                /// SAI1 stop acknowledge
                SAI1_STOP_ACK: enum(u1) {
                    /// SAI1 stop acknowledge is not asserted
                    SAI1_STOP_ACK_0 = 0x0,
                    /// SAI1 stop acknowledge is asserted
                    SAI1_STOP_ACK_1 = 0x1,
                },
                /// SAI2 stop acknowledge
                SAI2_STOP_ACK: enum(u1) {
                    /// SAI2 stop acknowledge is not asserted
                    SAI2_STOP_ACK_0 = 0x0,
                    /// SAI2 stop acknowledge is asserted
                    SAI2_STOP_ACK_1 = 0x1,
                },
                /// SAI3 stop acknowledge
                SAI3_STOP_ACK: enum(u1) {
                    /// SAI3 stop acknowledge is not asserted
                    SAI3_STOP_ACK_0 = 0x0,
                    /// SAI3 stop acknowledge is asserted
                    SAI3_STOP_ACK_1 = 0x1,
                },
                /// ENET2 stop acknowledge.
                ENET2_STOP_ACK: enum(u1) {
                    /// ENET2 stop acknowledge is not asserted
                    ENET2_STOP_ACK_0 = 0x0,
                    /// ENET2 stop acknowledge is asserted
                    ENET2_STOP_ACK_1 = 0x1,
                },
                /// SEMC stop acknowledge
                SEMC_STOP_ACK: enum(u1) {
                    /// SEMC stop acknowledge is not asserted
                    SEMC_STOP_ACK_0 = 0x0,
                    /// SEMC stop acknowledge is asserted
                    SEMC_STOP_ACK_1 = 0x1,
                },
                /// PIT stop acknowledge
                PIT_STOP_ACK: enum(u1) {
                    /// PIT stop acknowledge is not asserted
                    PIT_STOP_ACK_0 = 0x0,
                    /// PIT stop acknowledge is asserted
                    PIT_STOP_ACK_1 = 0x1,
                },
                /// FLEXSPI stop acknowledge
                FLEXSPI_STOP_ACK: enum(u1) {
                    /// FLEXSPI stop acknowledge is not asserted
                    FLEXSPI_STOP_ACK_0 = 0x0,
                    /// FLEXSPI stop acknowledge is asserted
                    FLEXSPI_STOP_ACK_1 = 0x1,
                },
                /// FLEXIO1 stop acknowledge
                FLEXIO1_STOP_ACK: enum(u1) {
                    /// FLEXIO1 stop acknowledge is not asserted
                    FLEXIO1_STOP_ACK_0 = 0x0,
                    /// FLEXIO1 stop acknowledge is asserted
                    FLEXIO1_STOP_ACK_1 = 0x1,
                },
                /// FLEXIO2 stop acknowledge
                FLEXIO2_STOP_ACK: enum(u1) {
                    /// FLEXIO2 stop acknowledge is not asserted
                    FLEXIO2_STOP_ACK_0 = 0x0,
                    /// FLEXIO2 stop acknowledge is asserted (FLEXIO2 is in STOP mode)
                    FLEXIO2_STOP_ACK_1 = 0x1,
                },
                /// On-platform FLEXIO3 stop acknowledge
                FLEXIO3_STOP_ACK: enum(u1) {
                    /// FLEXIO3 stop acknowledge is not asserted
                    FLEXIO3_STOP_ACK_0 = 0x0,
                    /// FLEXIO3 stop acknowledge is asserted
                    FLEXIO3_STOP_ACK_1 = 0x1,
                },
                /// FLEXSPI2 stop acknowledge
                FLEXSPI2_STOP_ACK: enum(u1) {
                    /// FLEXSPI2 stop acknowledge is not asserted
                    FLEXSPI2_STOP_ACK_0 = 0x0,
                    /// FLEXSPI2 stop acknowledge is asserted
                    FLEXSPI2_STOP_ACK_1 = 0x1,
                },
            }),
            /// GPR5 General Purpose Register
            GPR5: mmio.Mmio(packed struct(u32) {
                reserved6: u6 = 0,
                /// WDOG1 Timeout Mask
                WDOG1_MASK: enum(u1) {
                    /// WDOG1 Timeout behaves normally
                    WDOG1_MASK_0 = 0x0,
                    /// WDOG1 Timeout is masked
                    WDOG1_MASK_1 = 0x1,
                },
                /// WDOG2 Timeout Mask
                WDOG2_MASK: enum(u1) {
                    /// WDOG2 Timeout behaves normally
                    WDOG2_MASK_0 = 0x0,
                    /// WDOG2 Timeout is masked
                    WDOG2_MASK_1 = 0x1,
                },
                reserved23: u15 = 0,
                /// GPT2 input capture channel 1 source select
                GPT2_CAPIN1_SEL: enum(u1) {
                    /// source from GPT2_CAPTURE1
                    GPT2_CAPIN1_SEL_0 = 0x0,
                    /// source from ENET_1588_EVENT3_OUT (chnnal 3 of IEEE 1588 timer)
                    GPT2_CAPIN1_SEL_1 = 0x1,
                },
                /// GPT2 input capture channel 2 source select
                GPT2_CAPIN2_SEL: enum(u1) {
                    /// source from GPT2_CAPTURE2
                    GPT2_CAPIN2_SEL_0 = 0x0,
                    /// source from ENET2_1588_EVENT3_OUT (chnnal 3 of IEEE 1588 timer)
                    GPT2_CAPIN2_SEL_1 = 0x1,
                },
                /// ENET input timer event3 source select
                ENET_EVENT3IN_SEL: enum(u1) {
                    /// event3 source input from ENET_1588_EVENT3_IN
                    ENET_EVENT3IN_SEL_0 = 0x0,
                    /// event3 source input from GPT2.GPT_COMPARE1
                    ENET_EVENT3IN_SEL_1 = 0x1,
                },
                /// ENET2 input timer event3 source select
                ENET2_EVENT3IN_SEL: enum(u1) {
                    /// event3 source input from ENET2_1588_EVENT3_IN
                    ENET2_EVENT3IN_SEL_0 = 0x0,
                    /// event3 source input from GPT2.GPT_COMPARE2
                    ENET2_EVENT3IN_SEL_1 = 0x1,
                },
                reserved28: u1 = 0,
                /// GPT1 1 MHz clock source select
                VREF_1M_CLK_GPT1: enum(u1) {
                    /// GPT1 ipg_clk_highfreq driven by IPG_PERCLK
                    VREF_1M_CLK_GPT1_0 = 0x0,
                    /// GPT1 ipg_clk_highfreq driven by anatop 1 MHz clock
                    VREF_1M_CLK_GPT1_1 = 0x1,
                },
                /// GPT2 1 MHz clock source select
                VREF_1M_CLK_GPT2: enum(u1) {
                    /// GPT2 ipg_clk_highfreq driven by IPG_PERCLK
                    VREF_1M_CLK_GPT2_0 = 0x0,
                    /// GPT2 ipg_clk_highfreq driven by anatop 1 MHz clock
                    VREF_1M_CLK_GPT2_1 = 0x1,
                },
                padding: u2 = 0,
            }),
            /// GPR6 General Purpose Register
            GPR6: mmio.Mmio(packed struct(u32) {
                /// QTIMER1 TMR0 input select
                QTIMER1_TRM0_INPUT_SEL: enum(u1) {
                    /// input from IOMUX
                    QTIMER1_TRM0_INPUT_SEL_0 = 0x0,
                    /// input from XBAR
                    QTIMER1_TRM0_INPUT_SEL_1 = 0x1,
                },
                /// QTIMER1 TMR1 input select
                QTIMER1_TRM1_INPUT_SEL: enum(u1) {
                    /// input from IOMUX
                    QTIMER1_TRM1_INPUT_SEL_0 = 0x0,
                    /// input from XBAR
                    QTIMER1_TRM1_INPUT_SEL_1 = 0x1,
                },
                /// QTIMER1 TMR2 input select
                QTIMER1_TRM2_INPUT_SEL: enum(u1) {
                    /// input from IOMUX
                    QTIMER1_TRM2_INPUT_SEL_0 = 0x0,
                    /// input from XBAR
                    QTIMER1_TRM2_INPUT_SEL_1 = 0x1,
                },
                /// QTIMER1 TMR3 input select
                QTIMER1_TRM3_INPUT_SEL: enum(u1) {
                    /// input from IOMUX
                    QTIMER1_TRM3_INPUT_SEL_0 = 0x0,
                    /// input from XBAR
                    QTIMER1_TRM3_INPUT_SEL_1 = 0x1,
                },
                /// QTIMER2 TMR0 input select
                QTIMER2_TRM0_INPUT_SEL: enum(u1) {
                    /// input from IOMUX
                    QTIMER2_TRM0_INPUT_SEL_0 = 0x0,
                    /// input from XBAR
                    QTIMER2_TRM0_INPUT_SEL_1 = 0x1,
                },
                /// QTIMER2 TMR1 input select
                QTIMER2_TRM1_INPUT_SEL: enum(u1) {
                    /// input from IOMUX
                    QTIMER2_TRM1_INPUT_SEL_0 = 0x0,
                    /// input from XBAR
                    QTIMER2_TRM1_INPUT_SEL_1 = 0x1,
                },
                /// QTIMER2 TMR2 input select
                QTIMER2_TRM2_INPUT_SEL: enum(u1) {
                    /// input from IOMUX
                    QTIMER2_TRM2_INPUT_SEL_0 = 0x0,
                    /// input from XBAR
                    QTIMER2_TRM2_INPUT_SEL_1 = 0x1,
                },
                /// QTIMER2 TMR3 input select
                QTIMER2_TRM3_INPUT_SEL: enum(u1) {
                    /// input from IOMUX
                    QTIMER2_TRM3_INPUT_SEL_0 = 0x0,
                    /// input from XBAR
                    QTIMER2_TRM3_INPUT_SEL_1 = 0x1,
                },
                /// QTIMER3 TMR0 input select
                QTIMER3_TRM0_INPUT_SEL: enum(u1) {
                    /// input from IOMUX
                    QTIMER3_TRM0_INPUT_SEL_0 = 0x0,
                    /// input from XBAR
                    QTIMER3_TRM0_INPUT_SEL_1 = 0x1,
                },
                /// QTIMER3 TMR1 input select
                QTIMER3_TRM1_INPUT_SEL: enum(u1) {
                    /// input from IOMUX
                    QTIMER3_TRM1_INPUT_SEL_0 = 0x0,
                    /// input from XBAR
                    QTIMER3_TRM1_INPUT_SEL_1 = 0x1,
                },
                /// QTIMER3 TMR2 input select
                QTIMER3_TRM2_INPUT_SEL: enum(u1) {
                    /// input from IOMUX
                    QTIMER3_TRM2_INPUT_SEL_0 = 0x0,
                    /// input from XBAR
                    QTIMER3_TRM2_INPUT_SEL_1 = 0x1,
                },
                /// QTIMER3 TMR3 input select
                QTIMER3_TRM3_INPUT_SEL: enum(u1) {
                    /// input from IOMUX
                    QTIMER3_TRM3_INPUT_SEL_0 = 0x0,
                    /// input from XBAR
                    QTIMER3_TRM3_INPUT_SEL_1 = 0x1,
                },
                /// QTIMER4 TMR0 input select
                QTIMER4_TRM0_INPUT_SEL: enum(u1) {
                    /// input from IOMUX
                    QTIMER4_TRM0_INPUT_SEL_0 = 0x0,
                    /// input from XBAR
                    QTIMER4_TRM0_INPUT_SEL_1 = 0x1,
                },
                /// QTIMER4 TMR1 input select
                QTIMER4_TRM1_INPUT_SEL: enum(u1) {
                    /// input from IOMUX
                    QTIMER4_TRM1_INPUT_SEL_0 = 0x0,
                    /// input from XBAR
                    QTIMER4_TRM1_INPUT_SEL_1 = 0x1,
                },
                /// QTIMER4 TMR2 input select
                QTIMER4_TRM2_INPUT_SEL: enum(u1) {
                    /// input from IOMUX
                    QTIMER4_TRM2_INPUT_SEL_0 = 0x0,
                    /// input from XBAR
                    QTIMER4_TRM2_INPUT_SEL_1 = 0x1,
                },
                /// QTIMER4 TMR3 input select
                QTIMER4_TRM3_INPUT_SEL: enum(u1) {
                    /// input from IOMUX
                    QTIMER4_TRM3_INPUT_SEL_0 = 0x0,
                    /// input from XBAR
                    QTIMER4_TRM3_INPUT_SEL_1 = 0x1,
                },
                /// IOMUXC XBAR_INOUT4 function direction select
                IOMUXC_XBAR_DIR_SEL_4: enum(u1) {
                    /// XBAR_INOUT as input
                    IOMUXC_XBAR_DIR_SEL_4_0 = 0x0,
                    /// XBAR_INOUT as output
                    IOMUXC_XBAR_DIR_SEL_4_1 = 0x1,
                },
                /// IOMUXC XBAR_INOUT5 function direction select
                IOMUXC_XBAR_DIR_SEL_5: enum(u1) {
                    /// XBAR_INOUT as input
                    IOMUXC_XBAR_DIR_SEL_5_0 = 0x0,
                    /// XBAR_INOUT as output
                    IOMUXC_XBAR_DIR_SEL_5_1 = 0x1,
                },
                /// IOMUXC XBAR_INOUT6 function direction select
                IOMUXC_XBAR_DIR_SEL_6: enum(u1) {
                    /// XBAR_INOUT as input
                    IOMUXC_XBAR_DIR_SEL_6_0 = 0x0,
                    /// XBAR_INOUT as output
                    IOMUXC_XBAR_DIR_SEL_6_1 = 0x1,
                },
                /// IOMUXC XBAR_INOUT7 function direction select
                IOMUXC_XBAR_DIR_SEL_7: enum(u1) {
                    /// XBAR_INOUT as input
                    IOMUXC_XBAR_DIR_SEL_7_0 = 0x0,
                    /// XBAR_INOUT as output
                    IOMUXC_XBAR_DIR_SEL_7_1 = 0x1,
                },
                /// IOMUXC XBAR_INOUT8 function direction select
                IOMUXC_XBAR_DIR_SEL_8: enum(u1) {
                    /// XBAR_INOUT as input
                    IOMUXC_XBAR_DIR_SEL_8_0 = 0x0,
                    /// XBAR_INOUT as output
                    IOMUXC_XBAR_DIR_SEL_8_1 = 0x1,
                },
                /// IOMUXC XBAR_INOUT9 function direction select
                IOMUXC_XBAR_DIR_SEL_9: enum(u1) {
                    /// XBAR_INOUT as input
                    IOMUXC_XBAR_DIR_SEL_9_0 = 0x0,
                    /// XBAR_INOUT as output
                    IOMUXC_XBAR_DIR_SEL_9_1 = 0x1,
                },
                /// IOMUXC XBAR_INOUT10 function direction select
                IOMUXC_XBAR_DIR_SEL_10: enum(u1) {
                    /// XBAR_INOUT as input
                    IOMUXC_XBAR_DIR_SEL_10_0 = 0x0,
                    /// XBAR_INOUT as output
                    IOMUXC_XBAR_DIR_SEL_10_1 = 0x1,
                },
                /// IOMUXC XBAR_INOUT11 function direction select
                IOMUXC_XBAR_DIR_SEL_11: enum(u1) {
                    /// XBAR_INOUT as input
                    IOMUXC_XBAR_DIR_SEL_11_0 = 0x0,
                    /// XBAR_INOUT as output
                    IOMUXC_XBAR_DIR_SEL_11_1 = 0x1,
                },
                /// IOMUXC XBAR_INOUT12 function direction select
                IOMUXC_XBAR_DIR_SEL_12: enum(u1) {
                    /// XBAR_INOUT as input
                    IOMUXC_XBAR_DIR_SEL_12_0 = 0x0,
                    /// XBAR_INOUT as output
                    IOMUXC_XBAR_DIR_SEL_12_1 = 0x1,
                },
                /// IOMUXC XBAR_INOUT13 function direction select
                IOMUXC_XBAR_DIR_SEL_13: enum(u1) {
                    /// XBAR_INOUT as input
                    IOMUXC_XBAR_DIR_SEL_13_0 = 0x0,
                    /// XBAR_INOUT as output
                    IOMUXC_XBAR_DIR_SEL_13_1 = 0x1,
                },
                /// IOMUXC XBAR_INOUT14 function direction select
                IOMUXC_XBAR_DIR_SEL_14: enum(u1) {
                    /// XBAR_INOUT as input
                    IOMUXC_XBAR_DIR_SEL_14_0 = 0x0,
                    /// XBAR_INOUT as output
                    IOMUXC_XBAR_DIR_SEL_14_1 = 0x1,
                },
                /// IOMUXC XBAR_INOUT15 function direction select
                IOMUXC_XBAR_DIR_SEL_15: enum(u1) {
                    /// XBAR_INOUT as input
                    IOMUXC_XBAR_DIR_SEL_15_0 = 0x0,
                    /// XBAR_INOUT as output
                    IOMUXC_XBAR_DIR_SEL_15_1 = 0x1,
                },
                /// IOMUXC XBAR_INOUT16 function direction select
                IOMUXC_XBAR_DIR_SEL_16: enum(u1) {
                    /// XBAR_INOUT as input
                    IOMUXC_XBAR_DIR_SEL_16_0 = 0x0,
                    /// XBAR_INOUT as output
                    IOMUXC_XBAR_DIR_SEL_16_1 = 0x1,
                },
                /// IOMUXC XBAR_INOUT17 function direction select
                IOMUXC_XBAR_DIR_SEL_17: enum(u1) {
                    /// XBAR_INOUT as input
                    IOMUXC_XBAR_DIR_SEL_17_0 = 0x0,
                    /// XBAR_INOUT as output
                    IOMUXC_XBAR_DIR_SEL_17_1 = 0x1,
                },
                /// IOMUXC XBAR_INOUT18 function direction select
                IOMUXC_XBAR_DIR_SEL_18: enum(u1) {
                    /// XBAR_INOUT as input
                    IOMUXC_XBAR_DIR_SEL_18_0 = 0x0,
                    /// XBAR_INOUT as output
                    IOMUXC_XBAR_DIR_SEL_18_1 = 0x1,
                },
                /// IOMUXC XBAR_INOUT19 function direction select
                IOMUXC_XBAR_DIR_SEL_19: enum(u1) {
                    /// XBAR_INOUT as input
                    IOMUXC_XBAR_DIR_SEL_19_0 = 0x0,
                    /// XBAR_INOUT as output
                    IOMUXC_XBAR_DIR_SEL_19_1 = 0x1,
                },
            }),
            /// GPR7 General Purpose Register
            GPR7: mmio.Mmio(packed struct(u32) {
                /// LPI2C1 stop request
                LPI2C1_STOP_REQ: enum(u1) {
                    /// stop request off
                    LPI2C1_STOP_REQ_0 = 0x0,
                    /// stop request on
                    LPI2C1_STOP_REQ_1 = 0x1,
                },
                /// LPI2C2 stop request
                LPI2C2_STOP_REQ: enum(u1) {
                    /// stop request off
                    LPI2C2_STOP_REQ_0 = 0x0,
                    /// stop request on
                    LPI2C2_STOP_REQ_1 = 0x1,
                },
                /// LPI2C3 stop request
                LPI2C3_STOP_REQ: enum(u1) {
                    /// stop request off
                    LPI2C3_STOP_REQ_0 = 0x0,
                    /// stop request on
                    LPI2C3_STOP_REQ_1 = 0x1,
                },
                /// LPI2C4 stop request
                LPI2C4_STOP_REQ: enum(u1) {
                    /// stop request off
                    LPI2C4_STOP_REQ_0 = 0x0,
                    /// stop request on
                    LPI2C4_STOP_REQ_1 = 0x1,
                },
                /// LPSPI1 stop request
                LPSPI1_STOP_REQ: enum(u1) {
                    /// stop request off
                    LPSPI1_STOP_REQ_0 = 0x0,
                    /// stop request on
                    LPSPI1_STOP_REQ_1 = 0x1,
                },
                /// LPSPI2 stop request
                LPSPI2_STOP_REQ: enum(u1) {
                    /// stop request off
                    LPSPI2_STOP_REQ_0 = 0x0,
                    /// stop request on
                    LPSPI2_STOP_REQ_1 = 0x1,
                },
                /// LPSPI3 stop request
                LPSPI3_STOP_REQ: enum(u1) {
                    /// stop request off
                    LPSPI3_STOP_REQ_0 = 0x0,
                    /// stop request on
                    LPSPI3_STOP_REQ_1 = 0x1,
                },
                /// LPSPI4 stop request
                LPSPI4_STOP_REQ: enum(u1) {
                    /// stop request off
                    LPSPI4_STOP_REQ_0 = 0x0,
                    /// stop request on
                    LPSPI4_STOP_REQ_1 = 0x1,
                },
                /// LPUART1 stop request
                LPUART1_STOP_REQ: enum(u1) {
                    /// stop request off
                    LPUART1_STOP_REQ_0 = 0x0,
                    /// stop request on
                    LPUART1_STOP_REQ_1 = 0x1,
                },
                /// LPUART1 stop request
                LPUART2_STOP_REQ: enum(u1) {
                    /// stop request off
                    LPUART2_STOP_REQ_0 = 0x0,
                    /// stop request on
                    LPUART2_STOP_REQ_1 = 0x1,
                },
                /// LPUART3 stop request
                LPUART3_STOP_REQ: enum(u1) {
                    /// stop request off
                    LPUART3_STOP_REQ_0 = 0x0,
                    /// stop request on
                    LPUART3_STOP_REQ_1 = 0x1,
                },
                /// LPUART4 stop request
                LPUART4_STOP_REQ: enum(u1) {
                    /// stop request off
                    LPUART4_STOP_REQ_0 = 0x0,
                    /// stop request on
                    LPUART4_STOP_REQ_1 = 0x1,
                },
                /// LPUART5 stop request
                LPUART5_STOP_REQ: enum(u1) {
                    /// stop request off
                    LPUART5_STOP_REQ_0 = 0x0,
                    /// stop request on
                    LPUART5_STOP_REQ_1 = 0x1,
                },
                /// LPUART6 stop request
                LPUART6_STOP_REQ: enum(u1) {
                    /// stop request off
                    LPUART6_STOP_REQ_0 = 0x0,
                    /// stop request on
                    LPUART6_STOP_REQ_1 = 0x1,
                },
                /// LPUART7 stop request
                LPUART7_STOP_REQ: enum(u1) {
                    /// stop request off
                    LPUART7_STOP_REQ_0 = 0x0,
                    /// stop request on
                    LPUART7_STOP_REQ_1 = 0x1,
                },
                /// LPUART8 stop request
                LPUART8_STOP_REQ: enum(u1) {
                    /// stop request off
                    LPUART8_STOP_REQ_0 = 0x0,
                    /// stop request on
                    LPUART8_STOP_REQ_1 = 0x1,
                },
                /// LPI2C1 stop acknowledge
                LPI2C1_STOP_ACK: enum(u1) {
                    /// stop acknowledge is not asserted
                    LPI2C1_STOP_ACK_0 = 0x0,
                    /// stop acknowledge is asserted (the module is in Stop mode)
                    LPI2C1_STOP_ACK_1 = 0x1,
                },
                /// LPI2C2 stop acknowledge
                LPI2C2_STOP_ACK: enum(u1) {
                    /// stop acknowledge is not asserted
                    LPI2C2_STOP_ACK_0 = 0x0,
                    /// stop acknowledge is asserted
                    LPI2C2_STOP_ACK_1 = 0x1,
                },
                /// LPI2C3 stop acknowledge
                LPI2C3_STOP_ACK: enum(u1) {
                    /// stop acknowledge is not asserted
                    LPI2C3_STOP_ACK_0 = 0x0,
                    /// stop acknowledge is asserted
                    LPI2C3_STOP_ACK_1 = 0x1,
                },
                /// LPI2C4 stop acknowledge
                LPI2C4_STOP_ACK: enum(u1) {
                    /// stop acknowledge is not asserted
                    LPI2C4_STOP_ACK_0 = 0x0,
                    /// stop acknowledge is asserted
                    LPI2C4_STOP_ACK_1 = 0x1,
                },
                /// LPSPI1 stop acknowledge
                LPSPI1_STOP_ACK: enum(u1) {
                    /// stop acknowledge is not asserted
                    LPSPI1_STOP_ACK_0 = 0x0,
                    /// stop acknowledge is asserted
                    LPSPI1_STOP_ACK_1 = 0x1,
                },
                /// LPSPI2 stop acknowledge
                LPSPI2_STOP_ACK: enum(u1) {
                    /// stop acknowledge is not asserted
                    LPSPI2_STOP_ACK_0 = 0x0,
                    /// stop acknowledge is asserted
                    LPSPI2_STOP_ACK_1 = 0x1,
                },
                /// LPSPI3 stop acknowledge
                LPSPI3_STOP_ACK: enum(u1) {
                    /// stop acknowledge is not asserted
                    LPSPI3_STOP_ACK_0 = 0x0,
                    /// stop acknowledge is asserted
                    LPSPI3_STOP_ACK_1 = 0x1,
                },
                /// LPSPI4 stop acknowledge
                LPSPI4_STOP_ACK: enum(u1) {
                    /// stop acknowledge is not asserted
                    LPSPI4_STOP_ACK_0 = 0x0,
                    /// stop acknowledge is asserted
                    LPSPI4_STOP_ACK_1 = 0x1,
                },
                /// LPUART1 stop acknowledge
                LPUART1_STOP_ACK: enum(u1) {
                    /// stop acknowledge is not asserted
                    LPUART1_STOP_ACK_0 = 0x0,
                    /// stop acknowledge is asserted
                    LPUART1_STOP_ACK_1 = 0x1,
                },
                /// LPUART1 stop acknowledge
                LPUART2_STOP_ACK: enum(u1) {
                    /// stop acknowledge is not asserted
                    LPUART2_STOP_ACK_0 = 0x0,
                    /// stop acknowledge is asserted
                    LPUART2_STOP_ACK_1 = 0x1,
                },
                /// LPUART3 stop acknowledge
                LPUART3_STOP_ACK: enum(u1) {
                    /// stop acknowledge is not asserted
                    LPUART3_STOP_ACK_0 = 0x0,
                    /// stop acknowledge is asserted
                    LPUART3_STOP_ACK_1 = 0x1,
                },
                /// LPUART4 stop acknowledge
                LPUART4_STOP_ACK: enum(u1) {
                    /// stop acknowledge is not asserted
                    LPUART4_STOP_ACK_0 = 0x0,
                    /// stop acknowledge is asserted
                    LPUART4_STOP_ACK_1 = 0x1,
                },
                /// LPUART5 stop acknowledge
                LPUART5_STOP_ACK: enum(u1) {
                    /// stop acknowledge is not asserted
                    LPUART5_STOP_ACK_0 = 0x0,
                    /// stop acknowledge is asserted
                    LPUART5_STOP_ACK_1 = 0x1,
                },
                /// LPUART6 stop acknowledge
                LPUART6_STOP_ACK: enum(u1) {
                    /// stop acknowledge is not asserted
                    LPUART6_STOP_ACK_0 = 0x0,
                    /// stop acknowledge is asserted
                    LPUART6_STOP_ACK_1 = 0x1,
                },
                /// LPUART7 stop acknowledge
                LPUART7_STOP_ACK: enum(u1) {
                    /// stop acknowledge is not asserted
                    LPUART7_STOP_ACK_0 = 0x0,
                    /// stop acknowledge is asserted
                    LPUART7_STOP_ACK_1 = 0x1,
                },
                /// LPUART8 stop acknowledge
                LPUART8_STOP_ACK: enum(u1) {
                    /// stop acknowledge is not asserted
                    LPUART8_STOP_ACK_0 = 0x0,
                    /// stop acknowledge is asserted (the module is in Stop mode)
                    LPUART8_STOP_ACK_1 = 0x1,
                },
            }),
            /// GPR8 General Purpose Register
            GPR8: mmio.Mmio(packed struct(u32) {
                /// LPI2C1 stop mode selection, cannot change when ipg_stop is asserted.
                LPI2C1_IPG_STOP_MODE: enum(u1) {
                    /// the module is functional in Stop mode
                    LPI2C1_IPG_STOP_MODE_0 = 0x0,
                    /// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
                    LPI2C1_IPG_STOP_MODE_1 = 0x1,
                },
                /// LPI2C1 ipg_doze mode
                LPI2C1_IPG_DOZE: enum(u1) {
                    /// not in doze mode
                    LPI2C1_IPG_DOZE_0 = 0x0,
                    /// in doze mode
                    LPI2C1_IPG_DOZE_1 = 0x1,
                },
                /// LPI2C2 stop mode selection, cannot change when ipg_stop is asserted.
                LPI2C2_IPG_STOP_MODE: enum(u1) {
                    /// the module is functional in Stop mode
                    LPI2C2_IPG_STOP_MODE_0 = 0x0,
                    /// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
                    LPI2C2_IPG_STOP_MODE_1 = 0x1,
                },
                /// LPI2C2 ipg_doze mode
                LPI2C2_IPG_DOZE: enum(u1) {
                    /// not in doze mode
                    LPI2C2_IPG_DOZE_0 = 0x0,
                    /// in doze mode
                    LPI2C2_IPG_DOZE_1 = 0x1,
                },
                /// LPI2C3 stop mode selection, cannot change when ipg_stop is asserted.
                LPI2C3_IPG_STOP_MODE: enum(u1) {
                    /// the module is functional in Stop mode
                    LPI2C3_IPG_STOP_MODE_0 = 0x0,
                    /// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
                    LPI2C3_IPG_STOP_MODE_1 = 0x1,
                },
                /// LPI2C3 ipg_doze mode
                LPI2C3_IPG_DOZE: enum(u1) {
                    /// not in doze mode
                    LPI2C3_IPG_DOZE_0 = 0x0,
                    /// in doze mode
                    LPI2C3_IPG_DOZE_1 = 0x1,
                },
                /// LPI2C4 stop mode selection, cannot change when ipg_stop is asserted.
                LPI2C4_IPG_STOP_MODE: enum(u1) {
                    /// the module is functional in Stop mode
                    LPI2C4_IPG_STOP_MODE_0 = 0x0,
                    /// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
                    LPI2C4_IPG_STOP_MODE_1 = 0x1,
                },
                /// LPI2C4 ipg_doze mode
                LPI2C4_IPG_DOZE: enum(u1) {
                    /// not in doze mode
                    LPI2C4_IPG_DOZE_0 = 0x0,
                    /// in doze mode
                    LPI2C4_IPG_DOZE_1 = 0x1,
                },
                /// LPSPI1 stop mode selection, cannot change when ipg_stop is asserted.
                LPSPI1_IPG_STOP_MODE: enum(u1) {
                    /// the module is functional in Stop mode
                    LPSPI1_IPG_STOP_MODE_0 = 0x0,
                    /// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
                    LPSPI1_IPG_STOP_MODE_1 = 0x1,
                },
                /// LPSPI1 ipg_doze mode
                LPSPI1_IPG_DOZE: enum(u1) {
                    /// not in doze mode
                    LPSPI1_IPG_DOZE_0 = 0x0,
                    /// in doze mode
                    LPSPI1_IPG_DOZE_1 = 0x1,
                },
                /// LPSPI2 stop mode selection, cannot change when ipg_stop is asserted.
                LPSPI2_IPG_STOP_MODE: enum(u1) {
                    /// the module is functional in Stop mode
                    LPSPI2_IPG_STOP_MODE_0 = 0x0,
                    /// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
                    LPSPI2_IPG_STOP_MODE_1 = 0x1,
                },
                /// LPSPI2 ipg_doze mode
                LPSPI2_IPG_DOZE: enum(u1) {
                    /// not in doze mode
                    LPSPI2_IPG_DOZE_0 = 0x0,
                    /// in doze mode
                    LPSPI2_IPG_DOZE_1 = 0x1,
                },
                /// LPSPI3 stop mode selection, cannot change when ipg_stop is asserted.
                LPSPI3_IPG_STOP_MODE: enum(u1) {
                    /// the module is functional in Stop mode
                    LPSPI3_IPG_STOP_MODE_0 = 0x0,
                    /// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
                    LPSPI3_IPG_STOP_MODE_1 = 0x1,
                },
                /// LPSPI3 ipg_doze mode
                LPSPI3_IPG_DOZE: enum(u1) {
                    /// not in doze mode
                    LPSPI3_IPG_DOZE_0 = 0x0,
                    /// in doze mode
                    LPSPI3_IPG_DOZE_1 = 0x1,
                },
                /// LPSPI4 stop mode selection, cannot change when ipg_stop is asserted.
                LPSPI4_IPG_STOP_MODE: enum(u1) {
                    /// the module is functional in Stop mode
                    LPSPI4_IPG_STOP_MODE_0 = 0x0,
                    /// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
                    LPSPI4_IPG_STOP_MODE_1 = 0x1,
                },
                /// LPSPI4 ipg_doze mode
                LPSPI4_IPG_DOZE: enum(u1) {
                    /// not in doze mode
                    LPSPI4_IPG_DOZE_0 = 0x0,
                    /// in doze mode
                    LPSPI4_IPG_DOZE_1 = 0x1,
                },
                /// LPUART1 stop mode selection, cannot change when ipg_stop is asserted.
                LPUART1_IPG_STOP_MODE: enum(u1) {
                    /// the module is functional in Stop mode
                    LPUART1_IPG_STOP_MODE_0 = 0x0,
                    /// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
                    LPUART1_IPG_STOP_MODE_1 = 0x1,
                },
                /// LPUART1 ipg_doze mode
                LPUART1_IPG_DOZE: enum(u1) {
                    /// not in doze mode
                    LPUART1_IPG_DOZE_0 = 0x0,
                    /// in doze mode
                    LPUART1_IPG_DOZE_1 = 0x1,
                },
                /// LPUART2 stop mode selection, cannot change when ipg_stop is asserted.
                LPUART2_IPG_STOP_MODE: enum(u1) {
                    /// the module is functional in Stop mode
                    LPUART2_IPG_STOP_MODE_0 = 0x0,
                    /// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
                    LPUART2_IPG_STOP_MODE_1 = 0x1,
                },
                /// LPUART2 ipg_doze mode
                LPUART2_IPG_DOZE: enum(u1) {
                    /// not in doze mode
                    LPUART2_IPG_DOZE_0 = 0x0,
                    /// in doze mode
                    LPUART2_IPG_DOZE_1 = 0x1,
                },
                /// LPUART3 stop mode selection, cannot change when ipg_stop is asserted.
                LPUART3_IPG_STOP_MODE: enum(u1) {
                    /// the module is functional in Stop mode
                    LPUART3_IPG_STOP_MODE_0 = 0x0,
                    /// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
                    LPUART3_IPG_STOP_MODE_1 = 0x1,
                },
                /// LPUART3 ipg_doze mode
                LPUART3_IPG_DOZE: enum(u1) {
                    /// not in doze mode
                    LPUART3_IPG_DOZE_0 = 0x0,
                    /// in doze mode
                    LPUART3_IPG_DOZE_1 = 0x1,
                },
                /// LPUART4 stop mode selection, cannot change when ipg_stop is asserted.
                LPUART4_IPG_STOP_MODE: enum(u1) {
                    /// the module is functional in Stop mode
                    LPUART4_IPG_STOP_MODE_0 = 0x0,
                    /// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
                    LPUART4_IPG_STOP_MODE_1 = 0x1,
                },
                /// LPUART4 ipg_doze mode
                LPUART4_IPG_DOZE: enum(u1) {
                    /// not in doze mode
                    LPUART4_IPG_DOZE_0 = 0x0,
                    /// in doze mode
                    LPUART4_IPG_DOZE_1 = 0x1,
                },
                /// LPUART5 stop mode selection, cannot change when ipg_stop is asserted.
                LPUART5_IPG_STOP_MODE: enum(u1) {
                    /// the module is functional in Stop mode
                    LPUART5_IPG_STOP_MODE_0 = 0x0,
                    /// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
                    LPUART5_IPG_STOP_MODE_1 = 0x1,
                },
                /// LPUART5 ipg_doze mode
                LPUART5_IPG_DOZE: enum(u1) {
                    /// not in doze mode
                    LPUART5_IPG_DOZE_0 = 0x0,
                    /// in doze mode
                    LPUART5_IPG_DOZE_1 = 0x1,
                },
                /// LPUART6 stop mode selection, cannot change when ipg_stop is asserted.
                LPUART6_IPG_STOP_MODE: enum(u1) {
                    /// the module is functional in Stop mode
                    LPUART6_IPG_STOP_MODE_0 = 0x0,
                    /// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
                    LPUART6_IPG_STOP_MODE_1 = 0x1,
                },
                /// LPUART6 ipg_doze mode
                LPUART6_IPG_DOZE: enum(u1) {
                    /// not in doze mode
                    LPUART6_IPG_DOZE_0 = 0x0,
                    /// in doze mode
                    LPUART6_IPG_DOZE_1 = 0x1,
                },
                /// LPUART7 stop mode selection, cannot change when ipg_stop is asserted.
                LPUART7_IPG_STOP_MODE: enum(u1) {
                    /// the module is functional in Stop mode
                    LPUART7_IPG_STOP_MODE_0 = 0x0,
                    /// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
                    LPUART7_IPG_STOP_MODE_1 = 0x1,
                },
                /// LPUART7 ipg_doze mode
                LPUART7_IPG_DOZE: enum(u1) {
                    /// not in doze mode
                    LPUART7_IPG_DOZE_0 = 0x0,
                    /// in doze mode
                    LPUART7_IPG_DOZE_1 = 0x1,
                },
                /// LPUART8 stop mode selection, cannot change when ipg_stop is asserted.
                LPUART8_IPG_STOP_MODE: enum(u1) {
                    /// the module is functional in Stop mode
                    LPUART8_IPG_STOP_MODE_0 = 0x0,
                    /// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
                    LPUART8_IPG_STOP_MODE_1 = 0x1,
                },
                /// LPUART8 ipg_doze mode
                LPUART8_IPG_DOZE: enum(u1) {
                    /// not in doze mode
                    LPUART8_IPG_DOZE_0 = 0x0,
                    /// in doze mode
                    LPUART8_IPG_DOZE_1 = 0x1,
                },
            }),
            /// GPR9 General Purpose Register
            GPR9: u32,
            /// GPR10 General Purpose Register
            GPR10: mmio.Mmio(packed struct(u32) {
                /// ARM non-secure (non-invasive) debug enable
                NIDEN: enum(u1) {
                    /// Debug turned off.
                    NIDEN_0 = 0x0,
                    /// Debug enabled (default).
                    NIDEN_1 = 0x1,
                },
                /// ARM invasive debug enable
                DBG_EN: enum(u1) {
                    /// Debug turned off.
                    DBG_EN_0 = 0x0,
                    /// Debug enabled (default).
                    DBG_EN_1 = 0x1,
                },
                /// Security error response enable for all security gaskets (on both AHB and AXI buses)
                SEC_ERR_RESP: enum(u1) {
                    /// OKEY response
                    SEC_ERR_RESP_0 = 0x0,
                    /// SLVError (default)
                    SEC_ERR_RESP_1 = 0x1,
                },
                reserved4: u1 = 0,
                /// DCP Key selection bit.
                DCPKEY_OCOTP_OR_KEYMUX: enum(u1) {
                    /// Select key from Key MUX (SNVS/OTPMK).
                    DCPKEY_OCOTP_OR_KEYMUX_0 = 0x0,
                    /// Select key from OCOTP (SW_GP2).
                    DCPKEY_OCOTP_OR_KEYMUX_1 = 0x1,
                },
                reserved8: u3 = 0,
                /// OCRAM TrustZone (TZ) enable.
                OCRAM_TZ_EN: enum(u1) {
                    /// The TrustZone feature is disabled. Entire OCRAM space is available for all access types (secure/non-secure/user/supervisor).
                    OCRAM_TZ_EN_0 = 0x0,
                    /// The TrustZone feature is enabled. Access to address in the range specified by [ENDADDR:STARTADDR] follows the execution mode access policy described in CSU chapter.
                    OCRAM_TZ_EN_1 = 0x1,
                },
                /// OCRAM TrustZone (TZ) start address
                OCRAM_TZ_ADDR: u7,
                /// Lock NIDEN field for changes
                LOCK_NIDEN: enum(u1) {
                    /// Field is not locked
                    LOCK_NIDEN_0 = 0x0,
                    /// Field is locked (read access only)
                    LOCK_NIDEN_1 = 0x1,
                },
                /// Lock DBG_EN field for changes
                LOCK_DBG_EN: enum(u1) {
                    /// Field is not locked
                    LOCK_DBG_EN_0 = 0x0,
                    /// Field is locked (read access only)
                    LOCK_DBG_EN_1 = 0x1,
                },
                /// Lock SEC_ERR_RESP field for changes
                LOCK_SEC_ERR_RESP: enum(u1) {
                    /// Field is not locked
                    LOCK_SEC_ERR_RESP_0 = 0x0,
                    /// Field is locked (read access only)
                    LOCK_SEC_ERR_RESP_1 = 0x1,
                },
                reserved20: u1 = 0,
                /// Lock DCP Key OCOTP/Key MUX selection bit
                LOCK_DCPKEY_OCOTP_OR_KEYMUX: enum(u1) {
                    /// Field is not locked
                    LOCK_DCPKEY_OCOTP_OR_KEYMUX_0 = 0x0,
                    /// Field is locked (read access only)
                    LOCK_DCPKEY_OCOTP_OR_KEYMUX_1 = 0x1,
                },
                reserved24: u3 = 0,
                /// Lock OCRAM_TZ_EN field for changes
                LOCK_OCRAM_TZ_EN: enum(u1) {
                    /// Field is not locked
                    LOCK_OCRAM_TZ_EN_0 = 0x0,
                    /// Field is locked (read access only)
                    LOCK_OCRAM_TZ_EN_1 = 0x1,
                },
                /// Lock OCRAM_TZ_ADDR field for changes
                LOCK_OCRAM_TZ_ADDR: enum(u7) {
                    /// Field is not locked
                    LOCK_OCRAM_TZ_ADDR_0 = 0x0,
                    /// Field is locked (read access only)
                    LOCK_OCRAM_TZ_ADDR_1 = 0x1,
                    _,
                },
            }),
            /// GPR11 General Purpose Register
            GPR11: mmio.Mmio(packed struct(u32) {
                /// Access control of memory region-0
                M7_APC_AC_R0_CTRL: enum(u2) {
                    /// No access protection
                    M7_APC_AC_R0_CTRL_0 = 0x0,
                    /// M7 debug protection enabled
                    M7_APC_AC_R0_CTRL_1 = 0x1,
                    /// FlexSPI access protection
                    M7_APC_AC_R0_CTRL_2 = 0x2,
                    /// Both M7 debug and FlexSPI access are protected
                    M7_APC_AC_R0_CTRL_3 = 0x3,
                },
                /// Access control of memory region-1
                M7_APC_AC_R1_CTRL: enum(u2) {
                    /// No access protection
                    M7_APC_AC_R1_CTRL_0 = 0x0,
                    /// M7 debug protection enabled
                    M7_APC_AC_R1_CTRL_1 = 0x1,
                    /// FlexSPI access protection
                    M7_APC_AC_R1_CTRL_2 = 0x2,
                    /// Both M7 debug and FlexSPI access are protected
                    M7_APC_AC_R1_CTRL_3 = 0x3,
                },
                /// Access control of memory region-2
                M7_APC_AC_R2_CTRL: enum(u2) {
                    /// No access protection
                    M7_APC_AC_R2_CTRL_0 = 0x0,
                    /// M7 debug protection enabled
                    M7_APC_AC_R2_CTRL_1 = 0x1,
                    /// FlexSPI access protection
                    M7_APC_AC_R2_CTRL_2 = 0x2,
                    /// Both M7 debug and FlexSPI access are protected
                    M7_APC_AC_R2_CTRL_3 = 0x3,
                },
                /// Access control of memory region-3
                M7_APC_AC_R3_CTRL: enum(u2) {
                    /// No access protection
                    M7_APC_AC_R3_CTRL_0 = 0x0,
                    /// M7 debug protection enabled
                    M7_APC_AC_R3_CTRL_1 = 0x1,
                    /// FlexSPI access protection
                    M7_APC_AC_R3_CTRL_2 = 0x2,
                    /// Both M7 debug and FlexSPI access are protected
                    M7_APC_AC_R3_CTRL_3 = 0x3,
                },
                /// BEE data decryption of memory region-n (n = 3 to 0)
                BEE_DE_RX_EN: u4,
                padding: u20 = 0,
            }),
            /// GPR12 General Purpose Register
            GPR12: mmio.Mmio(packed struct(u32) {
                /// FlexIO1 stop mode selection. Cannot change when ipg_stop is asserted.
                FLEXIO1_IPG_STOP_MODE: enum(u1) {
                    /// FlexIO1 is functional in Stop mode.
                    FLEXIO1_IPG_STOP_MODE_0 = 0x0,
                    /// When this bit is equal to 1'b1 and ipg_stop is asserted, FlexIO1 is not functional in Stop mode.
                    FLEXIO1_IPG_STOP_MODE_1 = 0x1,
                },
                /// FLEXIO1 ipg_doze mode
                FLEXIO1_IPG_DOZE: enum(u1) {
                    /// FLEXIO1 is not in doze mode
                    FLEXIO1_IPG_DOZE_0 = 0x0,
                    /// FLEXIO1 is in doze mode
                    FLEXIO1_IPG_DOZE_1 = 0x1,
                },
                /// FlexIO2 stop mode selection. Cannot change when ipg_stop is asserted.
                FLEXIO2_IPG_STOP_MODE: enum(u1) {
                    /// FlexIO2 is functional in Stop mode.
                    FLEXIO2_IPG_STOP_MODE_0 = 0x0,
                    /// When this bit is equal to 1'b1 and ipg_stop is asserted, FlexIO2 is not functional in Stop mode.
                    FLEXIO2_IPG_STOP_MODE_1 = 0x1,
                },
                /// FLEXIO2 ipg_doze mode
                FLEXIO2_IPG_DOZE: enum(u1) {
                    /// FLEXIO2 is not in doze mode
                    FLEXIO2_IPG_DOZE_0 = 0x0,
                    /// FLEXIO2 is in doze mode
                    FLEXIO2_IPG_DOZE_1 = 0x1,
                },
                /// ACMP stop mode selection. Cannot change when ipg_stop is asserted.
                ACMP_IPG_STOP_MODE: enum(u1) {
                    /// ACMP is functional in Stop mode.
                    ACMP_IPG_STOP_MODE_0 = 0x0,
                    /// When this bit is equal to 1'b1 and ipg_stop is asserted, ACMP is not functional in Stop mode.
                    ACMP_IPG_STOP_MODE_1 = 0x1,
                },
                /// FlexIO3 stop mode selection. Cannot change when ipg_stop is asserted.
                FLEXIO3_IPG_STOP_MODE: enum(u1) {
                    /// FlexIO3 is functional in Stop mode.
                    FLEXIO3_IPG_STOP_MODE_0 = 0x0,
                    /// When this bit is equal to 1'b1 and ipg_stop is asserted, FlexIO3 is not functional in Stop mode.
                    FLEXIO3_IPG_STOP_MODE_1 = 0x1,
                },
                /// FLEXIO3 ipg_doze mode
                FLEXIO3_IPG_DOZE: enum(u1) {
                    /// FLEXIO3 is not in doze mode
                    FLEXIO3_IPG_DOZE_0 = 0x0,
                    /// FLEXIO3 is in doze mode
                    FLEXIO3_IPG_DOZE_1 = 0x1,
                },
                padding: u25 = 0,
            }),
            /// GPR13 General Purpose Register
            GPR13: mmio.Mmio(packed struct(u32) {
                /// uSDHC block cacheable attribute value of AXI read transactions
                ARCACHE_USDHC: enum(u1) {
                    /// Cacheable attribute is off for read transactions.
                    ARCACHE_USDHC_0 = 0x0,
                    /// Cacheable attribute is on for read transactions.
                    ARCACHE_USDHC_1 = 0x1,
                },
                /// uSDHC block cacheable attribute value of AXI write transactions
                AWCACHE_USDHC: enum(u1) {
                    /// Cacheable attribute is off for write transactions.
                    AWCACHE_USDHC_0 = 0x0,
                    /// Cacheable attribute is on for write transactions.
                    AWCACHE_USDHC_1 = 0x1,
                },
                reserved4: u2 = 0,
                /// CANFD stop request.
                CANFD_STOP_REQ: enum(u1) {
                    /// stop request off
                    CANFD_STOP_REQ_0 = 0x0,
                    /// stop request on
                    CANFD_STOP_REQ_1 = 0x1,
                },
                reserved7: u2 = 0,
                /// ENET block cacheable attribute value of AXI transactions
                CACHE_ENET: enum(u1) {
                    /// Cacheable attribute is off for read/write transactions.
                    CACHE_ENET_0 = 0x0,
                    /// Cacheable attribute is on for read/write transactions.
                    CACHE_ENET_1 = 0x1,
                },
                reserved13: u5 = 0,
                /// USB block cacheable attribute value of AXI transactions
                CACHE_USB: enum(u1) {
                    /// Cacheable attribute is off for read/write transactions.
                    CACHE_USB_0 = 0x0,
                    /// Cacheable attribute is on for read/write transactions.
                    CACHE_USB_1 = 0x1,
                },
                reserved20: u6 = 0,
                /// CANFD stop acknowledge.
                CANFD_STOP_ACK: enum(u1) {
                    /// CANFD stop acknowledge is not asserted
                    CANFD_STOP_ACK_0 = 0x0,
                    /// CANFD stop acknowledge is asserted
                    CANFD_STOP_ACK_1 = 0x1,
                },
                padding: u11 = 0,
            }),
            /// GPR14 General Purpose Register
            GPR14: mmio.Mmio(packed struct(u32) {
                /// reduces ACMP1 internal bias current by 30%
                ACMP1_CMP_IGEN_TRIM_DN: enum(u1) {
                    /// no reduce
                    ACMP1_CMP_IGEN_TRIM_DN_0 = 0x0,
                    /// reduces
                    ACMP1_CMP_IGEN_TRIM_DN_1 = 0x1,
                },
                /// reduces ACMP2 internal bias current by 30%
                ACMP2_CMP_IGEN_TRIM_DN: enum(u1) {
                    /// no reduce
                    ACMP2_CMP_IGEN_TRIM_DN_0 = 0x0,
                    /// reduces
                    ACMP2_CMP_IGEN_TRIM_DN_1 = 0x1,
                },
                /// reduces ACMP3 internal bias current by 30%
                ACMP3_CMP_IGEN_TRIM_DN: enum(u1) {
                    /// no reduce
                    ACMP3_CMP_IGEN_TRIM_DN_0 = 0x0,
                    /// reduces
                    ACMP3_CMP_IGEN_TRIM_DN_1 = 0x1,
                },
                /// reduces ACMP4 internal bias current by 30%
                ACMP4_CMP_IGEN_TRIM_DN: enum(u1) {
                    /// no reduce
                    ACMP4_CMP_IGEN_TRIM_DN_0 = 0x0,
                    /// reduces
                    ACMP4_CMP_IGEN_TRIM_DN_1 = 0x1,
                },
                /// increases ACMP1 internal bias current by 30%
                ACMP1_CMP_IGEN_TRIM_UP: enum(u1) {
                    /// no increase
                    ACMP1_CMP_IGEN_TRIM_UP_0 = 0x0,
                    /// increases
                    ACMP1_CMP_IGEN_TRIM_UP_1 = 0x1,
                },
                /// increases ACMP2 internal bias current by 30%
                ACMP2_CMP_IGEN_TRIM_UP: enum(u1) {
                    /// no increase
                    ACMP2_CMP_IGEN_TRIM_UP_0 = 0x0,
                    /// increases
                    ACMP2_CMP_IGEN_TRIM_UP_1 = 0x1,
                },
                /// increases ACMP3 internal bias current by 30%
                ACMP3_CMP_IGEN_TRIM_UP: enum(u1) {
                    /// no increase
                    ACMP3_CMP_IGEN_TRIM_UP_0 = 0x0,
                    /// increases
                    ACMP3_CMP_IGEN_TRIM_UP_1 = 0x1,
                },
                /// increases ACMP4 internal bias current by 30%
                ACMP4_CMP_IGEN_TRIM_UP: enum(u1) {
                    /// no increase
                    ACMP4_CMP_IGEN_TRIM_UP_0 = 0x0,
                    /// increases
                    ACMP4_CMP_IGEN_TRIM_UP_1 = 0x1,
                },
                /// ACMP1 sample_lv source select
                ACMP1_SAMPLE_SYNC_EN: enum(u1) {
                    /// select XBAR output
                    ACMP1_SAMPLE_SYNC_EN_0 = 0x0,
                    /// select synced sample_lv
                    ACMP1_SAMPLE_SYNC_EN_1 = 0x1,
                },
                /// ACMP2 sample_lv source select
                ACMP2_SAMPLE_SYNC_EN: enum(u1) {
                    /// select XBAR output
                    ACMP2_SAMPLE_SYNC_EN_0 = 0x0,
                    /// select synced sample_lv
                    ACMP2_SAMPLE_SYNC_EN_1 = 0x1,
                },
                /// ACMP3 sample_lv source select
                ACMP3_SAMPLE_SYNC_EN: enum(u1) {
                    /// select XBAR output
                    ACMP3_SAMPLE_SYNC_EN_0 = 0x0,
                    /// select synced sample_lv
                    ACMP3_SAMPLE_SYNC_EN_1 = 0x1,
                },
                /// ACMP4 sample_lv source select
                ACMP4_SAMPLE_SYNC_EN: enum(u1) {
                    /// select XBAR output
                    ACMP4_SAMPLE_SYNC_EN_0 = 0x0,
                    /// select synced sample_lv
                    ACMP4_SAMPLE_SYNC_EN_1 = 0x1,
                },
                reserved16: u4 = 0,
                /// ITCM total size configuration
                CM7_CFGITCMSZ: enum(u4) {
                    /// 0 KB (No ITCM)
                    CM7_CFGITCMSZ_0 = 0x0,
                    /// 4 KB
                    CM7_CFGITCMSZ_3 = 0x3,
                    /// 8 KB
                    CM7_CFGITCMSZ_4 = 0x4,
                    /// 16 KB
                    CM7_CFGITCMSZ_5 = 0x5,
                    /// 32 KB
                    CM7_CFGITCMSZ_6 = 0x6,
                    /// 64 KB
                    CM7_CFGITCMSZ_7 = 0x7,
                    /// 128 KB
                    CM7_CFGITCMSZ_8 = 0x8,
                    /// 256 KB
                    CM7_CFGITCMSZ_9 = 0x9,
                    /// 512 KB
                    CM7_CFGITCMSZ_10 = 0xa,
                    _,
                },
                /// DTCM total size configuration
                CM7_CFGDTCMSZ: enum(u4) {
                    /// 0 KB (No DTCM)
                    CM7_CFGDTCMSZ_0 = 0x0,
                    /// 4 KB
                    CM7_CFGDTCMSZ_3 = 0x3,
                    /// 8 KB
                    CM7_CFGDTCMSZ_4 = 0x4,
                    /// 16 KB
                    CM7_CFGDTCMSZ_5 = 0x5,
                    /// 32 KB
                    CM7_CFGDTCMSZ_6 = 0x6,
                    /// 64 KB
                    CM7_CFGDTCMSZ_7 = 0x7,
                    /// 128 KB
                    CM7_CFGDTCMSZ_8 = 0x8,
                    /// 256 KB
                    CM7_CFGDTCMSZ_9 = 0x9,
                    /// 512 KB
                    CM7_CFGDTCMSZ_10 = 0xa,
                    _,
                },
                padding: u8 = 0,
            }),
            /// GPR15 General Purpose Register
            GPR15: u32,
            /// GPR16 General Purpose Register
            GPR16: mmio.Mmio(packed struct(u32) {
                /// ITCM enable initialization out of reset
                INIT_ITCM_EN: enum(u1) {
                    /// ITCM is disabled
                    INIT_ITCM_EN_0 = 0x0,
                    /// ITCM is enabled
                    INIT_ITCM_EN_1 = 0x1,
                },
                /// DTCM enable initialization out of reset
                INIT_DTCM_EN: enum(u1) {
                    /// DTCM is disabled
                    INIT_DTCM_EN_0 = 0x0,
                    /// DTCM is enabled
                    INIT_DTCM_EN_1 = 0x1,
                },
                /// FlexRAM bank config source select
                FLEXRAM_BANK_CFG_SEL: enum(u1) {
                    /// use fuse value to config
                    FLEXRAM_BANK_CFG_SEL_0 = 0x0,
                    /// use FLEXRAM_BANK_CFG to config
                    FLEXRAM_BANK_CFG_SEL_1 = 0x1,
                },
                padding: u29 = 0,
            }),
            /// GPR17 General Purpose Register
            GPR17: mmio.Mmio(packed struct(u32) {
                /// FlexRAM bank config value
                FLEXRAM_BANK_CFG: u32,
            }),
            /// GPR18 General Purpose Register
            GPR18: mmio.Mmio(packed struct(u32) {
                /// lock M7_APC_AC_R0_BOT field for changes
                LOCK_M7_APC_AC_R0_BOT: enum(u1) {
                    /// Register field [31:1] is not locked
                    LOCK_M7_APC_AC_R0_BOT_0 = 0x0,
                    /// Register field [31:1] is locked (read access only)
                    LOCK_M7_APC_AC_R0_BOT_1 = 0x1,
                },
                reserved3: u2 = 0,
                /// APC end address of memory region-0
                M7_APC_AC_R0_BOT: u29,
            }),
            /// GPR19 General Purpose Register
            GPR19: mmio.Mmio(packed struct(u32) {
                /// lock M7_APC_AC_R0_TOP field for changes
                LOCK_M7_APC_AC_R0_TOP: enum(u1) {
                    /// Register field [31:1] is not locked
                    LOCK_M7_APC_AC_R0_TOP_0 = 0x0,
                    /// Register field [31:1] is locked (read access only)
                    LOCK_M7_APC_AC_R0_TOP_1 = 0x1,
                },
                reserved3: u2 = 0,
                /// APC start address of memory region-0
                M7_APC_AC_R0_TOP: u29,
            }),
            /// GPR20 General Purpose Register
            GPR20: mmio.Mmio(packed struct(u32) {
                /// lock M7_APC_AC_R1_BOT field for changes
                LOCK_M7_APC_AC_R1_BOT: enum(u1) {
                    /// Register field [31:1] is not locked
                    LOCK_M7_APC_AC_R1_BOT_0 = 0x0,
                    /// Register field [31:1] is locked (read access only)
                    LOCK_M7_APC_AC_R1_BOT_1 = 0x1,
                },
                reserved3: u2 = 0,
                /// APC end address of memory region-1
                M7_APC_AC_R1_BOT: u29,
            }),
            /// GPR21 General Purpose Register
            GPR21: mmio.Mmio(packed struct(u32) {
                /// lock M7_APC_AC_R1_TOP field for changes
                LOCK_M7_APC_AC_R1_TOP: enum(u1) {
                    /// Register field [31:1] is not locked
                    LOCK_M7_APC_AC_R1_TOP_0 = 0x0,
                    /// Register field [31:1] is locked (read access only)
                    LOCK_M7_APC_AC_R1_TOP_1 = 0x1,
                },
                reserved3: u2 = 0,
                /// APC start address of memory region-1
                M7_APC_AC_R1_TOP: u29,
            }),
            /// GPR22 General Purpose Register
            GPR22: mmio.Mmio(packed struct(u32) {
                /// lock M7_APC_AC_R2_BOT field for changes
                LOCK_M7_APC_AC_R2_BOT: enum(u1) {
                    /// Register field [31:1] is not locked
                    LOCK_M7_APC_AC_R2_BOT_0 = 0x0,
                    /// Register field [31:1] is locked (read access only)
                    LOCK_M7_APC_AC_R2_BOT_1 = 0x1,
                },
                reserved3: u2 = 0,
                /// APC end address of memory region-2
                M7_APC_AC_R2_BOT: u29,
            }),
            /// GPR23 General Purpose Register
            GPR23: mmio.Mmio(packed struct(u32) {
                /// lock M7_APC_AC_R2_TOP field for changes
                LOCK_M7_APC_AC_R2_TOP: enum(u1) {
                    /// Register field [31:1] is not locked
                    LOCK_M7_APC_AC_R2_TOP_0 = 0x0,
                    /// Register field [31:1] is locked (read access only)
                    LOCK_M7_APC_AC_R2_TOP_1 = 0x1,
                },
                reserved3: u2 = 0,
                /// APC start address of memory region-2
                M7_APC_AC_R2_TOP: u29,
            }),
            /// GPR24 General Purpose Register
            GPR24: mmio.Mmio(packed struct(u32) {
                /// lock M7_APC_AC_R3_BOT field for changes
                LOCK_M7_APC_AC_R3_BOT: enum(u1) {
                    /// Register field [31:1] is not locked
                    LOCK_M7_APC_AC_R3_BOT_0 = 0x0,
                    /// Register field [31:1] is locked (read access only)
                    LOCK_M7_APC_AC_R3_BOT_1 = 0x1,
                },
                reserved3: u2 = 0,
                /// APC end address of memory region-3
                M7_APC_AC_R3_BOT: u29,
            }),
            /// GPR25 General Purpose Register
            GPR25: mmio.Mmio(packed struct(u32) {
                /// lock M7_APC_AC_R3_TOP field for changes
                LOCK_M7_APC_AC_R3_TOP: enum(u1) {
                    /// Register field [31:1] is not locked
                    LOCK_M7_APC_AC_R3_TOP_0 = 0x0,
                    /// Register field [31:1] is locked (read access only)
                    LOCK_M7_APC_AC_R3_TOP_1 = 0x1,
                },
                reserved3: u2 = 0,
                /// APC start address of memory region-3
                M7_APC_AC_R3_TOP: u29,
            }),
            /// GPR26 General Purpose Register
            GPR26: mmio.Mmio(packed struct(u32) {
                /// GPIO1 and GPIO6 share same IO MUX function, GPIO_MUX1 selects one GPIO function.
                GPIO_MUX1_GPIO_SEL: u32,
            }),
            /// GPR27 General Purpose Register
            GPR27: mmio.Mmio(packed struct(u32) {
                /// GPIO2 and GPIO7 share same IO MUX function, GPIO_MUX2 selects one GPIO function.
                GPIO_MUX2_GPIO_SEL: u32,
            }),
            /// GPR28 General Purpose Register
            GPR28: mmio.Mmio(packed struct(u32) {
                /// GPIO3 and GPIO8 share same IO MUX function, GPIO_MUX3 selects one GPIO function.
                GPIO_MUX3_GPIO_SEL: u32,
            }),
            /// GPR29 General Purpose Register
            GPR29: mmio.Mmio(packed struct(u32) {
                /// GPIO4 and GPIO9 share same IO MUX function, GPIO_MUX4 selects one GPIO function.
                GPIO_MUX4_GPIO_SEL: u32,
            }),
            /// GPR30 General Purpose Register
            GPR30: mmio.Mmio(packed struct(u32) {
                reserved12: u12 = 0,
                /// Start address of flexspi1 and flexspi2
                FLEXSPI_REMAP_ADDR_START: u20,
            }),
            /// GPR31 General Purpose Register
            GPR31: mmio.Mmio(packed struct(u32) {
                reserved12: u12 = 0,
                /// End address of flexspi1 and flexspi2
                FLEXSPI_REMAP_ADDR_END: u20,
            }),
            /// GPR32 General Purpose Register
            GPR32: mmio.Mmio(packed struct(u32) {
                reserved12: u12 = 0,
                /// Offset address of flexspi1 and flexspi2
                FLEXSPI_REMAP_ADDR_OFFSET: u20,
            }),
            /// GPR33 General Purpose Register
            GPR33: mmio.Mmio(packed struct(u32) {
                /// OCRAM2 TrustZone (TZ) enable.
                OCRAM2_TZ_EN: enum(u1) {
                    /// The TrustZone feature is disabled. Entire OCRAM2 space is available for all access types (secure/non-secure/user/supervisor).
                    OCRAM2_TZ_EN_0 = 0x0,
                    /// The TrustZone feature is enabled. Access to address in the range specified by [ENDADDR:STARTADDR] follows the execution mode access policy described in CSU chapter.
                    OCRAM2_TZ_EN_1 = 0x1,
                },
                /// OCRAM2 TrustZone (TZ) start address
                OCRAM2_TZ_ADDR: u7,
                reserved16: u8 = 0,
                /// Lock OCRAM2_TZ_EN field for changes
                LOCK_OCRAM2_TZ_EN: enum(u1) {
                    /// Field is not locked
                    LOCK_OCRAM2_TZ_EN_0 = 0x0,
                    /// Field is locked (read access only)
                    LOCK_OCRAM2_TZ_EN_1 = 0x1,
                },
                /// Lock OCRAM2_TZ_ADDR field for changes
                LOCK_OCRAM2_TZ_ADDR: enum(u7) {
                    /// Field is not locked
                    LOCK_OCRAM2_TZ_ADDR_0 = 0x0,
                    /// Field is locked (read access only)
                    LOCK_OCRAM2_TZ_ADDR_1 = 0x1,
                    _,
                },
                padding: u8 = 0,
            }),
            /// GPR34 General Purpose Register
            GPR34: mmio.Mmio(packed struct(u32) {
                /// Boot Pin select in SIP_TEST_MUX
                SIP_TEST_MUX_BOOT_PIN_SEL: u8,
                /// Enable SIP_TEST_MUX
                SIP_TEST_MUX_QSPI_SIP_EN: enum(u1) {
                    /// SIP_TEST_MUX is disabled
                    SIP_TEST_MUX_QSPI_SIP_EN_0 = 0x0,
                    /// SIP_TEST_MUX is enabled
                    SIP_TEST_MUX_QSPI_SIP_EN_1 = 0x1,
                },
                padding: u23 = 0,
            }),
        };

        /// IOMUXC_SNVS
        pub const IOMUXC_SNVS = extern struct {
            /// SW_MUX_CTL_PAD_WAKEUP SW MUX Control Register
            SW_MUX_CTL_PAD_WAKEUP: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT5 mux port: GPIO5_IO00 of instance: gpio5
                    ALT5 = 0x5,
                    /// Select mux mode: ALT7 mux port: NMI_GLUE_NMI of instance: nmi_glue
                    ALT7 = 0x7,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad WAKEUP
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_PMIC_ON_REQ SW MUX Control Register
            SW_MUX_CTL_PAD_PMIC_ON_REQ: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: SNVS_LP_PMIC_ON_REQ of instance: snvs_lp
                    ALT0 = 0x0,
                    /// Select mux mode: ALT5 mux port: GPIO5_IO01 of instance: gpio5
                    ALT5 = 0x5,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad PMIC_ON_REQ
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_MUX_CTL_PAD_PMIC_STBY_REQ SW MUX Control Register
            SW_MUX_CTL_PAD_PMIC_STBY_REQ: mmio.Mmio(packed struct(u32) {
                /// MUX Mode Select Field.
                MUX_MODE: enum(u3) {
                    /// Select mux mode: ALT0 mux port: CCM_PMIC_VSTBY_REQ of instance: ccm
                    ALT0 = 0x0,
                    /// Select mux mode: ALT5 mux port: GPIO5_IO02 of instance: gpio5
                    ALT5 = 0x5,
                    _,
                },
                reserved4: u1 = 0,
                /// Software Input On Field.
                SION: enum(u1) {
                    /// Input Path is determined by functionality
                    DISABLED = 0x0,
                    /// Force input path of pad PMIC_STBY_REQ
                    ENABLED = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SW_PAD_CTL_PAD_TEST_MODE SW PAD Control Register
            SW_PAD_CTL_PAD_TEST_MODE: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(260 Ohm @ 3.3V, 150 Ohm@1.8V, 240 Ohm for DDR)
                    DSE_1_R0_260_Ohm___3_3V__150_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// medium(100MHz)
                    SPEED = 0x2,
                    _,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_POR_B SW PAD Control Register
            SW_PAD_CTL_PAD_POR_B: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(260 Ohm @ 3.3V, 150 Ohm@1.8V, 240 Ohm for DDR)
                    DSE_1_R0_260_Ohm___3_3V__150_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// medium(100MHz)
                    SPEED = 0x2,
                    _,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_ONOFF SW PAD Control Register
            SW_PAD_CTL_PAD_ONOFF: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(260 Ohm @ 3.3V, 150 Ohm@1.8V, 240 Ohm for DDR)
                    DSE_1_R0_260_Ohm___3_3V__150_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// medium(100MHz)
                    SPEED = 0x2,
                    _,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_WAKEUP SW PAD Control Register
            SW_PAD_CTL_PAD_WAKEUP: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(260 Ohm @ 3.3V, 150 Ohm@1.8V, 240 Ohm for DDR)
                    DSE_1_R0_260_Ohm___3_3V__150_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// medium(100MHz)
                    SPEED = 0x2,
                    _,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_PMIC_ON_REQ SW PAD Control Register
            SW_PAD_CTL_PAD_PMIC_ON_REQ: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(260 Ohm @ 3.3V, 150 Ohm@1.8V, 240 Ohm for DDR)
                    DSE_1_R0_260_Ohm___3_3V__150_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// medium(100MHz)
                    SPEED = 0x2,
                    _,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
            /// SW_PAD_CTL_PAD_PMIC_STBY_REQ SW PAD Control Register
            SW_PAD_CTL_PAD_PMIC_STBY_REQ: mmio.Mmio(packed struct(u32) {
                /// Slew Rate Field
                SRE: enum(u1) {
                    /// Slow Slew Rate
                    SRE_0_Slow_Slew_Rate = 0x0,
                    /// Fast Slew Rate
                    SRE_1_Fast_Slew_Rate = 0x1,
                },
                reserved3: u2 = 0,
                /// Drive Strength Field
                DSE: enum(u3) {
                    /// output driver disabled;
                    DSE_0_output_driver_disabled_ = 0x0,
                    /// R0(260 Ohm @ 3.3V, 150 Ohm@1.8V, 240 Ohm for DDR)
                    DSE_1_R0_260_Ohm___3_3V__150_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1,
                    /// R0/2
                    DSE_2_R0_2 = 0x2,
                    /// R0/3
                    DSE_3_R0_3 = 0x3,
                    /// R0/4
                    DSE_4_R0_4 = 0x4,
                    /// R0/5
                    DSE_5_R0_5 = 0x5,
                    /// R0/6
                    DSE_6_R0_6 = 0x6,
                    /// R0/7
                    DSE_7_R0_7 = 0x7,
                },
                /// Speed Field
                SPEED: enum(u2) {
                    /// medium(100MHz)
                    SPEED = 0x2,
                    _,
                },
                reserved11: u3 = 0,
                /// Open Drain Enable Field
                ODE: enum(u1) {
                    /// Open Drain Disabled
                    ODE_0_Open_Drain_Disabled = 0x0,
                    /// Open Drain Enabled
                    ODE_1_Open_Drain_Enabled = 0x1,
                },
                /// Pull / Keep Enable Field
                PKE: enum(u1) {
                    /// Pull/Keeper Disabled
                    PKE_0_Pull_Keeper_Disabled = 0x0,
                    /// Pull/Keeper Enabled
                    PKE_1_Pull_Keeper_Enabled = 0x1,
                },
                /// Pull / Keep Select Field
                PUE: enum(u1) {
                    /// Keeper
                    PUE_0_Keeper = 0x0,
                    /// Pull
                    PUE_1_Pull = 0x1,
                },
                /// Pull Up / Down Config. Field
                PUS: enum(u2) {
                    /// 100K Ohm Pull Down
                    PUS_0_100K_Ohm_Pull_Down = 0x0,
                    /// 47K Ohm Pull Up
                    PUS_1_47K_Ohm_Pull_Up = 0x1,
                    /// 100K Ohm Pull Up
                    PUS_2_100K_Ohm_Pull_Up = 0x2,
                    /// 22K Ohm Pull Up
                    PUS_3_22K_Ohm_Pull_Up = 0x3,
                },
                /// Hyst. Enable Field
                HYS: enum(u1) {
                    /// Hysteresis Disabled
                    HYS_0_Hysteresis_Disabled = 0x0,
                    /// Hysteresis Enabled
                    HYS_1_Hysteresis_Enabled = 0x1,
                },
                padding: u15 = 0,
            }),
        };

        /// IOMUXC
        pub const IOMUXC_SNVS_GPR = extern struct {
            /// GPR0 General Purpose Register
            GPR0: u32,
            /// GPR1 General Purpose Register
            GPR1: u32,
            /// GPR2 General Purpose Register
            GPR2: u32,
            /// GPR3 General Purpose Register
            GPR3: mmio.Mmio(packed struct(u32) {
                /// Set to enable LPSR mode.
                LPSR_MODE_ENABLE: u1,
                /// DCDC captured status clear
                DCDC_STATUS_CAPT_CLR: u1,
                /// POR_B pad control
                POR_PULL_TYPE: u2,
                reserved16: u12 = 0,
                /// DCDC_IN low voltage detect.
                DCDC_IN_LOW_VOL: u1,
                /// DCDC output over current alert
                DCDC_OVER_CUR: u1,
                /// DCDC output over voltage alert
                DCDC_OVER_VOL: u1,
                /// DCDC status OK
                DCDC_STS_DC_OK: u1,
                padding: u12 = 0,
            }),
        };

        /// KPP Registers
        pub const KPP = extern struct {
            /// Keypad Control Register
            KPCR: mmio.Mmio(packed struct(u16) {
                /// Keypad Row Enable
                KRE: enum(u8) {
                    /// Row is not included in the keypad key press detect.
                    KRE_0 = 0x0,
                    /// Row is included in the keypad key press detect.
                    KRE_1 = 0x1,
                    _,
                },
                /// Keypad Column Strobe Open-Drain Enable
                KCO: enum(u8) {
                    /// Column strobe output is totem pole drive.
                    TOTEM_POLE = 0x0,
                    /// Column strobe output is open drain.
                    OPEN_DRAIN = 0x1,
                    _,
                },
            }),
            /// Keypad Status Register
            KPSR: mmio.Mmio(packed struct(u16) {
                /// Keypad Key Depress
                KPKD: enum(u1) {
                    /// No key presses detected
                    KPKD_0 = 0x0,
                    /// A key has been depressed
                    KPKD_1 = 0x1,
                },
                /// Keypad Key Release
                KPKR: enum(u1) {
                    /// No key release detected
                    KPKR_0 = 0x0,
                    /// All keys have been released
                    KPKR_1 = 0x1,
                },
                /// Key Depress Synchronizer Clear
                KDSC: enum(u1) {
                    /// No effect
                    KDSC_0 = 0x0,
                    /// Set bits that clear the keypad depress synchronizer chain
                    KDSC_1 = 0x1,
                },
                /// Key Release Synchronizer Set
                KRSS: enum(u1) {
                    /// No effect
                    KRSS_0 = 0x0,
                    /// Set bits which sets keypad release synchronizer chain
                    KRSS_1 = 0x1,
                },
                reserved8: u4 = 0,
                /// Keypad Key Depress Interrupt Enable
                KDIE: enum(u1) {
                    /// No interrupt request is generated when KPKD is set.
                    KDIE_0 = 0x0,
                    /// An interrupt request is generated when KPKD is set.
                    KDIE_1 = 0x1,
                },
                /// Keypad Release Interrupt Enable
                KRIE: enum(u1) {
                    /// No interrupt request is generated when KPKR is set.
                    KRIE_0 = 0x0,
                    /// An interrupt request is generated when KPKR is set.
                    KRIE_1 = 0x1,
                },
                padding: u6 = 0,
            }),
            /// Keypad Data Direction Register
            KDDR: mmio.Mmio(packed struct(u16) {
                /// Keypad Row Data Direction
                KRDD: enum(u8) {
                    /// ROWn pin configured as an input.
                    INPUT = 0x0,
                    /// ROWn pin configured as an output.
                    OUTPUT = 0x1,
                    _,
                },
                /// Keypad Column Data Direction Register
                KCDD: enum(u8) {
                    /// COLn pin is configured as an input.
                    INPUT = 0x0,
                    /// COLn pin is configured as an output.
                    OUTPUT = 0x1,
                    _,
                },
            }),
            /// Keypad Data Register
            KPDR: mmio.Mmio(packed struct(u16) {
                /// Keypad Row Data
                KRD: u8,
                /// Keypad Column Data
                KCD: u8,
            }),
        };

        /// LCDIF Register Reference Index
        pub const LCDIF = extern struct {
            /// LCDIF General Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                /// When this bit is set by software, the LCDIF will begin transferring data between the SoC and the display
                RUN: u1,
                /// Used only when WORD_LENGTH = 3, i
                DATA_FORMAT_24_BIT: enum(u1) {
                    /// Data input to the block is in 24 bpp format, such that all RGB 888 data is contained in 24 bits.
                    ALL_24_BITS_VALID = 0x0,
                    /// Data input to the block is actually RGB 18 bpp, but there is 1 color per byte, hence the upper 2 bits in each byte do not contain any useful data, and should be dropped.
                    DROP_UPPER_2_BITS_PER_BYTE = 0x1,
                },
                /// Used only when WORD_LENGTH = 2, i.e. 18-bit.
                DATA_FORMAT_18_BIT: enum(u1) {
                    /// Data input to the block is in 18 bpp format, such that lower 18 bits contain RGB 666 and upper 14 bits do not contain any useful data.
                    LOWER_18_BITS_VALID = 0x0,
                    /// Data input to the block is in 18 bpp format, such that upper 18 bits contain RGB 666 and lower 14 bits do not contain any useful data.
                    UPPER_18_BITS_VALID = 0x1,
                },
                /// When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data is in ARGB555 format
                DATA_FORMAT_16_BIT: u1,
                reserved5: u1 = 0,
                /// Set this bit to make the LCDIF act as a bus master
                MASTER: u1,
                /// If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as bus master and the handshake mechanism between LCDIF and PXP will be turned on
                ENABLE_PXP_HANDSHAKE: u1,
                reserved8: u1 = 0,
                /// Input data format.
                WORD_LENGTH: enum(u2) {
                    /// Input data is 16 bits per pixel.
                    @"16_BIT" = 0x0,
                    /// Input data is 8 bits wide.
                    @"8_BIT" = 0x1,
                    /// Input data is 18 bits per pixel.
                    @"18_BIT" = 0x2,
                    /// Input data is 24 bits per pixel.
                    @"24_BIT" = 0x3,
                },
                /// LCD Data bus transfer width.
                LCD_DATABUS_WIDTH: enum(u2) {
                    /// 16-bit data bus mode.
                    @"16_BIT" = 0x0,
                    /// 8-bit data bus mode.
                    @"8_BIT" = 0x1,
                    /// 18-bit data bus mode.
                    @"18_BIT" = 0x2,
                    /// 24-bit data bus mode.
                    @"24_BIT" = 0x3,
                },
                /// This field specifies how to swap the bytes after the data has been converted into an internal representation of 24 bits per pixel and before it is transmitted over the LCD interface bus
                CSC_DATA_SWIZZLE: enum(u2) {
                    /// No byte swapping.(Little endian)
                    NO_SWAP = 0x0,
                    /// Big Endian swap (swap bytes 0,3 and 1,2).
                    BIG_ENDIAN_SWAP = 0x1,
                    /// Swap half-words.
                    HWD_SWAP = 0x2,
                    /// Swap bytes within each half-word.
                    HWD_BYTE_SWAP = 0x3,
                },
                /// This field specifies how to swap the bytes fetched by the bus master interface
                INPUT_DATA_SWIZZLE: enum(u2) {
                    /// No byte swapping.(Little endian)
                    NO_SWAP = 0x0,
                    /// Big Endian swap (swap bytes 0,3 and 1,2).
                    BIG_ENDIAN_SWAP = 0x1,
                    /// Swap half-words.
                    HWD_SWAP = 0x2,
                    /// Swap bytes within each half-word.
                    HWD_BYTE_SWAP = 0x3,
                },
                reserved17: u1 = 0,
                /// Set this bit to 1 to make the hardware go into the DOTCLK mode, i
                DOTCLK_MODE: u1,
                reserved19: u1 = 0,
                /// When this bit is 0, it means that LCDIF will stop the block operation and turn off the RUN bit after the amount of data indicated by the LCDIF_TRANSFER_COUNT register has been transferred out
                BYPASS_COUNT: u1,
                reserved21: u1 = 0,
                /// The data to be transmitted is shifted left or right by this number of bits.
                SHIFT_NUM_BITS: u5,
                /// Use this bit to determine the direction of shift of transmit data.
                DATA_SHIFT_DIR: enum(u1) {
                    /// Data to be transmitted is shifted LEFT by SHIFT_NUM_BITS bits.
                    TXDATA_SHIFT_LEFT = 0x0,
                    /// Data to be transmitted is shifted RIGHT by SHIFT_NUM_BITS bits.
                    TXDATA_SHIFT_RIGHT = 0x1,
                },
                reserved30: u3 = 0,
                /// This bit must be set to zero for normal operation
                CLKGATE: u1,
                /// This bit must be set to zero to enable normal operation of the LCDIF
                SFTRST: u1,
            }),
            /// LCDIF General Control Register
            CTRL_SET: mmio.Mmio(packed struct(u32) {
                /// When this bit is set by software, the LCDIF will begin transferring data between the SoC and the display
                RUN: u1,
                /// Used only when WORD_LENGTH = 3, i
                DATA_FORMAT_24_BIT: enum(u1) {
                    /// Data input to the block is in 24 bpp format, such that all RGB 888 data is contained in 24 bits.
                    ALL_24_BITS_VALID = 0x0,
                    /// Data input to the block is actually RGB 18 bpp, but there is 1 color per byte, hence the upper 2 bits in each byte do not contain any useful data, and should be dropped.
                    DROP_UPPER_2_BITS_PER_BYTE = 0x1,
                },
                /// Used only when WORD_LENGTH = 2, i.e. 18-bit.
                DATA_FORMAT_18_BIT: enum(u1) {
                    /// Data input to the block is in 18 bpp format, such that lower 18 bits contain RGB 666 and upper 14 bits do not contain any useful data.
                    LOWER_18_BITS_VALID = 0x0,
                    /// Data input to the block is in 18 bpp format, such that upper 18 bits contain RGB 666 and lower 14 bits do not contain any useful data.
                    UPPER_18_BITS_VALID = 0x1,
                },
                /// When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data is in ARGB555 format
                DATA_FORMAT_16_BIT: u1,
                reserved5: u1 = 0,
                /// Set this bit to make the LCDIF act as a bus master
                MASTER: u1,
                /// If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as bus master and the handshake mechanism between LCDIF and PXP will be turned on
                ENABLE_PXP_HANDSHAKE: u1,
                reserved8: u1 = 0,
                /// Input data format.
                WORD_LENGTH: enum(u2) {
                    /// Input data is 16 bits per pixel.
                    @"16_BIT" = 0x0,
                    /// Input data is 8 bits wide.
                    @"8_BIT" = 0x1,
                    /// Input data is 18 bits per pixel.
                    @"18_BIT" = 0x2,
                    /// Input data is 24 bits per pixel.
                    @"24_BIT" = 0x3,
                },
                /// LCD Data bus transfer width.
                LCD_DATABUS_WIDTH: enum(u2) {
                    /// 16-bit data bus mode.
                    @"16_BIT" = 0x0,
                    /// 8-bit data bus mode.
                    @"8_BIT" = 0x1,
                    /// 18-bit data bus mode.
                    @"18_BIT" = 0x2,
                    /// 24-bit data bus mode.
                    @"24_BIT" = 0x3,
                },
                /// This field specifies how to swap the bytes after the data has been converted into an internal representation of 24 bits per pixel and before it is transmitted over the LCD interface bus
                CSC_DATA_SWIZZLE: enum(u2) {
                    /// No byte swapping.(Little endian)
                    NO_SWAP = 0x0,
                    /// Big Endian swap (swap bytes 0,3 and 1,2).
                    BIG_ENDIAN_SWAP = 0x1,
                    /// Swap half-words.
                    HWD_SWAP = 0x2,
                    /// Swap bytes within each half-word.
                    HWD_BYTE_SWAP = 0x3,
                },
                /// This field specifies how to swap the bytes fetched by the bus master interface
                INPUT_DATA_SWIZZLE: enum(u2) {
                    /// No byte swapping.(Little endian)
                    NO_SWAP = 0x0,
                    /// Big Endian swap (swap bytes 0,3 and 1,2).
                    BIG_ENDIAN_SWAP = 0x1,
                    /// Swap half-words.
                    HWD_SWAP = 0x2,
                    /// Swap bytes within each half-word.
                    HWD_BYTE_SWAP = 0x3,
                },
                reserved17: u1 = 0,
                /// Set this bit to 1 to make the hardware go into the DOTCLK mode, i
                DOTCLK_MODE: u1,
                reserved19: u1 = 0,
                /// When this bit is 0, it means that LCDIF will stop the block operation and turn off the RUN bit after the amount of data indicated by the LCDIF_TRANSFER_COUNT register has been transferred out
                BYPASS_COUNT: u1,
                reserved21: u1 = 0,
                /// The data to be transmitted is shifted left or right by this number of bits.
                SHIFT_NUM_BITS: u5,
                /// Use this bit to determine the direction of shift of transmit data.
                DATA_SHIFT_DIR: enum(u1) {
                    /// Data to be transmitted is shifted LEFT by SHIFT_NUM_BITS bits.
                    TXDATA_SHIFT_LEFT = 0x0,
                    /// Data to be transmitted is shifted RIGHT by SHIFT_NUM_BITS bits.
                    TXDATA_SHIFT_RIGHT = 0x1,
                },
                reserved30: u3 = 0,
                /// This bit must be set to zero for normal operation
                CLKGATE: u1,
                /// This bit must be set to zero to enable normal operation of the LCDIF
                SFTRST: u1,
            }),
            /// LCDIF General Control Register
            CTRL_CLR: mmio.Mmio(packed struct(u32) {
                /// When this bit is set by software, the LCDIF will begin transferring data between the SoC and the display
                RUN: u1,
                /// Used only when WORD_LENGTH = 3, i
                DATA_FORMAT_24_BIT: enum(u1) {
                    /// Data input to the block is in 24 bpp format, such that all RGB 888 data is contained in 24 bits.
                    ALL_24_BITS_VALID = 0x0,
                    /// Data input to the block is actually RGB 18 bpp, but there is 1 color per byte, hence the upper 2 bits in each byte do not contain any useful data, and should be dropped.
                    DROP_UPPER_2_BITS_PER_BYTE = 0x1,
                },
                /// Used only when WORD_LENGTH = 2, i.e. 18-bit.
                DATA_FORMAT_18_BIT: enum(u1) {
                    /// Data input to the block is in 18 bpp format, such that lower 18 bits contain RGB 666 and upper 14 bits do not contain any useful data.
                    LOWER_18_BITS_VALID = 0x0,
                    /// Data input to the block is in 18 bpp format, such that upper 18 bits contain RGB 666 and lower 14 bits do not contain any useful data.
                    UPPER_18_BITS_VALID = 0x1,
                },
                /// When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data is in ARGB555 format
                DATA_FORMAT_16_BIT: u1,
                reserved5: u1 = 0,
                /// Set this bit to make the LCDIF act as a bus master
                MASTER: u1,
                /// If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as bus master and the handshake mechanism between LCDIF and PXP will be turned on
                ENABLE_PXP_HANDSHAKE: u1,
                reserved8: u1 = 0,
                /// Input data format.
                WORD_LENGTH: enum(u2) {
                    /// Input data is 16 bits per pixel.
                    @"16_BIT" = 0x0,
                    /// Input data is 8 bits wide.
                    @"8_BIT" = 0x1,
                    /// Input data is 18 bits per pixel.
                    @"18_BIT" = 0x2,
                    /// Input data is 24 bits per pixel.
                    @"24_BIT" = 0x3,
                },
                /// LCD Data bus transfer width.
                LCD_DATABUS_WIDTH: enum(u2) {
                    /// 16-bit data bus mode.
                    @"16_BIT" = 0x0,
                    /// 8-bit data bus mode.
                    @"8_BIT" = 0x1,
                    /// 18-bit data bus mode.
                    @"18_BIT" = 0x2,
                    /// 24-bit data bus mode.
                    @"24_BIT" = 0x3,
                },
                /// This field specifies how to swap the bytes after the data has been converted into an internal representation of 24 bits per pixel and before it is transmitted over the LCD interface bus
                CSC_DATA_SWIZZLE: enum(u2) {
                    /// No byte swapping.(Little endian)
                    NO_SWAP = 0x0,
                    /// Big Endian swap (swap bytes 0,3 and 1,2).
                    BIG_ENDIAN_SWAP = 0x1,
                    /// Swap half-words.
                    HWD_SWAP = 0x2,
                    /// Swap bytes within each half-word.
                    HWD_BYTE_SWAP = 0x3,
                },
                /// This field specifies how to swap the bytes fetched by the bus master interface
                INPUT_DATA_SWIZZLE: enum(u2) {
                    /// No byte swapping.(Little endian)
                    NO_SWAP = 0x0,
                    /// Big Endian swap (swap bytes 0,3 and 1,2).
                    BIG_ENDIAN_SWAP = 0x1,
                    /// Swap half-words.
                    HWD_SWAP = 0x2,
                    /// Swap bytes within each half-word.
                    HWD_BYTE_SWAP = 0x3,
                },
                reserved17: u1 = 0,
                /// Set this bit to 1 to make the hardware go into the DOTCLK mode, i
                DOTCLK_MODE: u1,
                reserved19: u1 = 0,
                /// When this bit is 0, it means that LCDIF will stop the block operation and turn off the RUN bit after the amount of data indicated by the LCDIF_TRANSFER_COUNT register has been transferred out
                BYPASS_COUNT: u1,
                reserved21: u1 = 0,
                /// The data to be transmitted is shifted left or right by this number of bits.
                SHIFT_NUM_BITS: u5,
                /// Use this bit to determine the direction of shift of transmit data.
                DATA_SHIFT_DIR: enum(u1) {
                    /// Data to be transmitted is shifted LEFT by SHIFT_NUM_BITS bits.
                    TXDATA_SHIFT_LEFT = 0x0,
                    /// Data to be transmitted is shifted RIGHT by SHIFT_NUM_BITS bits.
                    TXDATA_SHIFT_RIGHT = 0x1,
                },
                reserved30: u3 = 0,
                /// This bit must be set to zero for normal operation
                CLKGATE: u1,
                /// This bit must be set to zero to enable normal operation of the LCDIF
                SFTRST: u1,
            }),
            /// LCDIF General Control Register
            CTRL_TOG: mmio.Mmio(packed struct(u32) {
                /// When this bit is set by software, the LCDIF will begin transferring data between the SoC and the display
                RUN: u1,
                /// Used only when WORD_LENGTH = 3, i
                DATA_FORMAT_24_BIT: enum(u1) {
                    /// Data input to the block is in 24 bpp format, such that all RGB 888 data is contained in 24 bits.
                    ALL_24_BITS_VALID = 0x0,
                    /// Data input to the block is actually RGB 18 bpp, but there is 1 color per byte, hence the upper 2 bits in each byte do not contain any useful data, and should be dropped.
                    DROP_UPPER_2_BITS_PER_BYTE = 0x1,
                },
                /// Used only when WORD_LENGTH = 2, i.e. 18-bit.
                DATA_FORMAT_18_BIT: enum(u1) {
                    /// Data input to the block is in 18 bpp format, such that lower 18 bits contain RGB 666 and upper 14 bits do not contain any useful data.
                    LOWER_18_BITS_VALID = 0x0,
                    /// Data input to the block is in 18 bpp format, such that upper 18 bits contain RGB 666 and lower 14 bits do not contain any useful data.
                    UPPER_18_BITS_VALID = 0x1,
                },
                /// When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data is in ARGB555 format
                DATA_FORMAT_16_BIT: u1,
                reserved5: u1 = 0,
                /// Set this bit to make the LCDIF act as a bus master
                MASTER: u1,
                /// If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as bus master and the handshake mechanism between LCDIF and PXP will be turned on
                ENABLE_PXP_HANDSHAKE: u1,
                reserved8: u1 = 0,
                /// Input data format.
                WORD_LENGTH: enum(u2) {
                    /// Input data is 16 bits per pixel.
                    @"16_BIT" = 0x0,
                    /// Input data is 8 bits wide.
                    @"8_BIT" = 0x1,
                    /// Input data is 18 bits per pixel.
                    @"18_BIT" = 0x2,
                    /// Input data is 24 bits per pixel.
                    @"24_BIT" = 0x3,
                },
                /// LCD Data bus transfer width.
                LCD_DATABUS_WIDTH: enum(u2) {
                    /// 16-bit data bus mode.
                    @"16_BIT" = 0x0,
                    /// 8-bit data bus mode.
                    @"8_BIT" = 0x1,
                    /// 18-bit data bus mode.
                    @"18_BIT" = 0x2,
                    /// 24-bit data bus mode.
                    @"24_BIT" = 0x3,
                },
                /// This field specifies how to swap the bytes after the data has been converted into an internal representation of 24 bits per pixel and before it is transmitted over the LCD interface bus
                CSC_DATA_SWIZZLE: enum(u2) {
                    /// No byte swapping.(Little endian)
                    NO_SWAP = 0x0,
                    /// Big Endian swap (swap bytes 0,3 and 1,2).
                    BIG_ENDIAN_SWAP = 0x1,
                    /// Swap half-words.
                    HWD_SWAP = 0x2,
                    /// Swap bytes within each half-word.
                    HWD_BYTE_SWAP = 0x3,
                },
                /// This field specifies how to swap the bytes fetched by the bus master interface
                INPUT_DATA_SWIZZLE: enum(u2) {
                    /// No byte swapping.(Little endian)
                    NO_SWAP = 0x0,
                    /// Big Endian swap (swap bytes 0,3 and 1,2).
                    BIG_ENDIAN_SWAP = 0x1,
                    /// Swap half-words.
                    HWD_SWAP = 0x2,
                    /// Swap bytes within each half-word.
                    HWD_BYTE_SWAP = 0x3,
                },
                reserved17: u1 = 0,
                /// Set this bit to 1 to make the hardware go into the DOTCLK mode, i
                DOTCLK_MODE: u1,
                reserved19: u1 = 0,
                /// When this bit is 0, it means that LCDIF will stop the block operation and turn off the RUN bit after the amount of data indicated by the LCDIF_TRANSFER_COUNT register has been transferred out
                BYPASS_COUNT: u1,
                reserved21: u1 = 0,
                /// The data to be transmitted is shifted left or right by this number of bits.
                SHIFT_NUM_BITS: u5,
                /// Use this bit to determine the direction of shift of transmit data.
                DATA_SHIFT_DIR: enum(u1) {
                    /// Data to be transmitted is shifted LEFT by SHIFT_NUM_BITS bits.
                    TXDATA_SHIFT_LEFT = 0x0,
                    /// Data to be transmitted is shifted RIGHT by SHIFT_NUM_BITS bits.
                    TXDATA_SHIFT_RIGHT = 0x1,
                },
                reserved30: u3 = 0,
                /// This bit must be set to zero for normal operation
                CLKGATE: u1,
                /// This bit must be set to zero to enable normal operation of the LCDIF
                SFTRST: u1,
            }),
            /// LCDIF General Control1 Register
            CTRL1: mmio.Mmio(packed struct(u32) {
                reserved8: u8 = 0,
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                VSYNC_EDGE_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                CUR_FRAME_DONE_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                UNDERFLOW_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                OVERFLOW_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to enable an interrupt every time the hardware encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the beginning of every field in DVI mode
                VSYNC_EDGE_IRQ_EN: u1,
                /// This bit is set to 1 enable an interrupt every time the hardware enters in the vertical blanking state
                CUR_FRAME_DONE_IRQ_EN: u1,
                /// This bit is set to enable an underflow interrupt in the TXFIFO in the write mode.
                UNDERFLOW_IRQ_EN: u1,
                /// This bit is set to enable an overflow interrupt in the TXFIFO in the write mode.
                OVERFLOW_IRQ_EN: u1,
                /// This bitfield is used to show which data bytes in a 32-bit word are valid
                BYTE_PACKING_FORMAT: u4,
                /// If this bit is set, the LCDIF block will assert the cur_frame_done interrupt only on alternate fields, otherwise it will issue the interrupt on both odd and even field
                IRQ_ON_ALTERNATE_FIELDS: u1,
                /// Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO and the RXFIFO.
                FIFO_CLEAR: u1,
                /// The default is to grab the odd lines first and then the even lines
                START_INTERLACE_FROM_SECOND_FIELD: u1,
                /// Set this bit if it is required that the LCDIF block fetches odd lines in one field and even lines in the other field
                INTERLACE_FIELDS: u1,
                /// Set this bit to enable the LCDIF block to recover in the next field/frame if there was an underflow in the current field/frame
                RECOVER_ON_UNDERFLOW: u1,
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                BM_ERROR_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to enable bus master error interrupt in the LCDIF master mode.
                BM_ERROR_IRQ_EN: u1,
                reserved30: u3 = 0,
                /// This bit is CS0/CS1 valid select signals
                CS_OUT_SELECT: u1,
                /// Command Mode MIPI image data select bit
                IMAGE_DATA_SELECT: u1,
            }),
            /// LCDIF General Control1 Register
            CTRL1_SET: mmio.Mmio(packed struct(u32) {
                reserved8: u8 = 0,
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                VSYNC_EDGE_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                CUR_FRAME_DONE_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                UNDERFLOW_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                OVERFLOW_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to enable an interrupt every time the hardware encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the beginning of every field in DVI mode
                VSYNC_EDGE_IRQ_EN: u1,
                /// This bit is set to 1 enable an interrupt every time the hardware enters in the vertical blanking state
                CUR_FRAME_DONE_IRQ_EN: u1,
                /// This bit is set to enable an underflow interrupt in the TXFIFO in the write mode.
                UNDERFLOW_IRQ_EN: u1,
                /// This bit is set to enable an overflow interrupt in the TXFIFO in the write mode.
                OVERFLOW_IRQ_EN: u1,
                /// This bitfield is used to show which data bytes in a 32-bit word are valid
                BYTE_PACKING_FORMAT: u4,
                /// If this bit is set, the LCDIF block will assert the cur_frame_done interrupt only on alternate fields, otherwise it will issue the interrupt on both odd and even field
                IRQ_ON_ALTERNATE_FIELDS: u1,
                /// Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO and the RXFIFO.
                FIFO_CLEAR: u1,
                /// The default is to grab the odd lines first and then the even lines
                START_INTERLACE_FROM_SECOND_FIELD: u1,
                /// Set this bit if it is required that the LCDIF block fetches odd lines in one field and even lines in the other field
                INTERLACE_FIELDS: u1,
                /// Set this bit to enable the LCDIF block to recover in the next field/frame if there was an underflow in the current field/frame
                RECOVER_ON_UNDERFLOW: u1,
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                BM_ERROR_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to enable bus master error interrupt in the LCDIF master mode.
                BM_ERROR_IRQ_EN: u1,
                reserved30: u3 = 0,
                /// This bit is CS0/CS1 valid select signals
                CS_OUT_SELECT: u1,
                /// Command Mode MIPI image data select bit
                IMAGE_DATA_SELECT: u1,
            }),
            /// LCDIF General Control1 Register
            CTRL1_CLR: mmio.Mmio(packed struct(u32) {
                reserved8: u8 = 0,
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                VSYNC_EDGE_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                CUR_FRAME_DONE_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                UNDERFLOW_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                OVERFLOW_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to enable an interrupt every time the hardware encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the beginning of every field in DVI mode
                VSYNC_EDGE_IRQ_EN: u1,
                /// This bit is set to 1 enable an interrupt every time the hardware enters in the vertical blanking state
                CUR_FRAME_DONE_IRQ_EN: u1,
                /// This bit is set to enable an underflow interrupt in the TXFIFO in the write mode.
                UNDERFLOW_IRQ_EN: u1,
                /// This bit is set to enable an overflow interrupt in the TXFIFO in the write mode.
                OVERFLOW_IRQ_EN: u1,
                /// This bitfield is used to show which data bytes in a 32-bit word are valid
                BYTE_PACKING_FORMAT: u4,
                /// If this bit is set, the LCDIF block will assert the cur_frame_done interrupt only on alternate fields, otherwise it will issue the interrupt on both odd and even field
                IRQ_ON_ALTERNATE_FIELDS: u1,
                /// Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO and the RXFIFO.
                FIFO_CLEAR: u1,
                /// The default is to grab the odd lines first and then the even lines
                START_INTERLACE_FROM_SECOND_FIELD: u1,
                /// Set this bit if it is required that the LCDIF block fetches odd lines in one field and even lines in the other field
                INTERLACE_FIELDS: u1,
                /// Set this bit to enable the LCDIF block to recover in the next field/frame if there was an underflow in the current field/frame
                RECOVER_ON_UNDERFLOW: u1,
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                BM_ERROR_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to enable bus master error interrupt in the LCDIF master mode.
                BM_ERROR_IRQ_EN: u1,
                reserved30: u3 = 0,
                /// This bit is CS0/CS1 valid select signals
                CS_OUT_SELECT: u1,
                /// Command Mode MIPI image data select bit
                IMAGE_DATA_SELECT: u1,
            }),
            /// LCDIF General Control1 Register
            CTRL1_TOG: mmio.Mmio(packed struct(u32) {
                reserved8: u8 = 0,
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                VSYNC_EDGE_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                CUR_FRAME_DONE_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                UNDERFLOW_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                OVERFLOW_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to enable an interrupt every time the hardware encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the beginning of every field in DVI mode
                VSYNC_EDGE_IRQ_EN: u1,
                /// This bit is set to 1 enable an interrupt every time the hardware enters in the vertical blanking state
                CUR_FRAME_DONE_IRQ_EN: u1,
                /// This bit is set to enable an underflow interrupt in the TXFIFO in the write mode.
                UNDERFLOW_IRQ_EN: u1,
                /// This bit is set to enable an overflow interrupt in the TXFIFO in the write mode.
                OVERFLOW_IRQ_EN: u1,
                /// This bitfield is used to show which data bytes in a 32-bit word are valid
                BYTE_PACKING_FORMAT: u4,
                /// If this bit is set, the LCDIF block will assert the cur_frame_done interrupt only on alternate fields, otherwise it will issue the interrupt on both odd and even field
                IRQ_ON_ALTERNATE_FIELDS: u1,
                /// Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO and the RXFIFO.
                FIFO_CLEAR: u1,
                /// The default is to grab the odd lines first and then the even lines
                START_INTERLACE_FROM_SECOND_FIELD: u1,
                /// Set this bit if it is required that the LCDIF block fetches odd lines in one field and even lines in the other field
                INTERLACE_FIELDS: u1,
                /// Set this bit to enable the LCDIF block to recover in the next field/frame if there was an underflow in the current field/frame
                RECOVER_ON_UNDERFLOW: u1,
                /// This bit is set to indicate that an interrupt is requested by the LCDIF block
                BM_ERROR_IRQ: enum(u1) {
                    /// No Interrupt Request Pending.
                    NO_REQUEST = 0x0,
                    /// Interrupt Request Pending.
                    REQUEST = 0x1,
                },
                /// This bit is set to enable bus master error interrupt in the LCDIF master mode.
                BM_ERROR_IRQ_EN: u1,
                reserved30: u3 = 0,
                /// This bit is CS0/CS1 valid select signals
                CS_OUT_SELECT: u1,
                /// Command Mode MIPI image data select bit
                IMAGE_DATA_SELECT: u1,
            }),
            /// LCDIF General Control2 Register
            CTRL2: mmio.Mmio(packed struct(u32) {
                reserved12: u12 = 0,
                /// This field determines the order of the RGB components of each pixel in EVEN lines (line numbers 2,4,6,
                EVEN_LINE_PATTERN: enum(u3) {
                    /// RGB
                    RGB = 0x0,
                    /// RBG
                    RBG = 0x1,
                    /// GBR
                    GBR = 0x2,
                    /// GRB
                    GRB = 0x3,
                    /// BRG
                    BRG = 0x4,
                    /// BGR
                    BGR = 0x5,
                    _,
                },
                reserved16: u1 = 0,
                /// This field determines the order of the RGB components of each pixel in ODD lines (line numbers 1,3,5,
                ODD_LINE_PATTERN: enum(u3) {
                    /// RGB
                    RGB = 0x0,
                    /// RBG
                    RBG = 0x1,
                    /// GBR
                    GBR = 0x2,
                    /// GRB
                    GRB = 0x3,
                    /// BRG
                    BRG = 0x4,
                    /// BGR
                    BGR = 0x5,
                    _,
                },
                reserved20: u1 = 0,
                /// By default, when the LCDIF is in the bus master mode, it will issue AXI bursts of length 16 (except when in packed 24 bpp mode, it will issue bursts of length 15)
                BURST_LEN_8: u1,
                /// This bitfield indicates the maximum number of outstanding transactions that LCDIF should request when it is acting as a bus master
                OUTSTANDING_REQS: enum(u3) {
                    /// REQ_1
                    REQ_1 = 0x0,
                    /// REQ_2
                    REQ_2 = 0x1,
                    /// REQ_4
                    REQ_4 = 0x2,
                    /// REQ_8
                    REQ_8 = 0x3,
                    /// REQ_16
                    REQ_16 = 0x4,
                    _,
                },
                padding: u8 = 0,
            }),
            /// LCDIF General Control2 Register
            CTRL2_SET: mmio.Mmio(packed struct(u32) {
                reserved12: u12 = 0,
                /// This field determines the order of the RGB components of each pixel in EVEN lines (line numbers 2,4,6,
                EVEN_LINE_PATTERN: enum(u3) {
                    /// RGB
                    RGB = 0x0,
                    /// RBG
                    RBG = 0x1,
                    /// GBR
                    GBR = 0x2,
                    /// GRB
                    GRB = 0x3,
                    /// BRG
                    BRG = 0x4,
                    /// BGR
                    BGR = 0x5,
                    _,
                },
                reserved16: u1 = 0,
                /// This field determines the order of the RGB components of each pixel in ODD lines (line numbers 1,3,5,
                ODD_LINE_PATTERN: enum(u3) {
                    /// RGB
                    RGB = 0x0,
                    /// RBG
                    RBG = 0x1,
                    /// GBR
                    GBR = 0x2,
                    /// GRB
                    GRB = 0x3,
                    /// BRG
                    BRG = 0x4,
                    /// BGR
                    BGR = 0x5,
                    _,
                },
                reserved20: u1 = 0,
                /// By default, when the LCDIF is in the bus master mode, it will issue AXI bursts of length 16 (except when in packed 24 bpp mode, it will issue bursts of length 15)
                BURST_LEN_8: u1,
                /// This bitfield indicates the maximum number of outstanding transactions that LCDIF should request when it is acting as a bus master
                OUTSTANDING_REQS: enum(u3) {
                    /// REQ_1
                    REQ_1 = 0x0,
                    /// REQ_2
                    REQ_2 = 0x1,
                    /// REQ_4
                    REQ_4 = 0x2,
                    /// REQ_8
                    REQ_8 = 0x3,
                    /// REQ_16
                    REQ_16 = 0x4,
                    _,
                },
                padding: u8 = 0,
            }),
            /// LCDIF General Control2 Register
            CTRL2_CLR: mmio.Mmio(packed struct(u32) {
                reserved12: u12 = 0,
                /// This field determines the order of the RGB components of each pixel in EVEN lines (line numbers 2,4,6,
                EVEN_LINE_PATTERN: enum(u3) {
                    /// RGB
                    RGB = 0x0,
                    /// RBG
                    RBG = 0x1,
                    /// GBR
                    GBR = 0x2,
                    /// GRB
                    GRB = 0x3,
                    /// BRG
                    BRG = 0x4,
                    /// BGR
                    BGR = 0x5,
                    _,
                },
                reserved16: u1 = 0,
                /// This field determines the order of the RGB components of each pixel in ODD lines (line numbers 1,3,5,
                ODD_LINE_PATTERN: enum(u3) {
                    /// RGB
                    RGB = 0x0,
                    /// RBG
                    RBG = 0x1,
                    /// GBR
                    GBR = 0x2,
                    /// GRB
                    GRB = 0x3,
                    /// BRG
                    BRG = 0x4,
                    /// BGR
                    BGR = 0x5,
                    _,
                },
                reserved20: u1 = 0,
                /// By default, when the LCDIF is in the bus master mode, it will issue AXI bursts of length 16 (except when in packed 24 bpp mode, it will issue bursts of length 15)
                BURST_LEN_8: u1,
                /// This bitfield indicates the maximum number of outstanding transactions that LCDIF should request when it is acting as a bus master
                OUTSTANDING_REQS: enum(u3) {
                    /// REQ_1
                    REQ_1 = 0x0,
                    /// REQ_2
                    REQ_2 = 0x1,
                    /// REQ_4
                    REQ_4 = 0x2,
                    /// REQ_8
                    REQ_8 = 0x3,
                    /// REQ_16
                    REQ_16 = 0x4,
                    _,
                },
                padding: u8 = 0,
            }),
            /// LCDIF General Control2 Register
            CTRL2_TOG: mmio.Mmio(packed struct(u32) {
                reserved12: u12 = 0,
                /// This field determines the order of the RGB components of each pixel in EVEN lines (line numbers 2,4,6,
                EVEN_LINE_PATTERN: enum(u3) {
                    /// RGB
                    RGB = 0x0,
                    /// RBG
                    RBG = 0x1,
                    /// GBR
                    GBR = 0x2,
                    /// GRB
                    GRB = 0x3,
                    /// BRG
                    BRG = 0x4,
                    /// BGR
                    BGR = 0x5,
                    _,
                },
                reserved16: u1 = 0,
                /// This field determines the order of the RGB components of each pixel in ODD lines (line numbers 1,3,5,
                ODD_LINE_PATTERN: enum(u3) {
                    /// RGB
                    RGB = 0x0,
                    /// RBG
                    RBG = 0x1,
                    /// GBR
                    GBR = 0x2,
                    /// GRB
                    GRB = 0x3,
                    /// BRG
                    BRG = 0x4,
                    /// BGR
                    BGR = 0x5,
                    _,
                },
                reserved20: u1 = 0,
                /// By default, when the LCDIF is in the bus master mode, it will issue AXI bursts of length 16 (except when in packed 24 bpp mode, it will issue bursts of length 15)
                BURST_LEN_8: u1,
                /// This bitfield indicates the maximum number of outstanding transactions that LCDIF should request when it is acting as a bus master
                OUTSTANDING_REQS: enum(u3) {
                    /// REQ_1
                    REQ_1 = 0x0,
                    /// REQ_2
                    REQ_2 = 0x1,
                    /// REQ_4
                    REQ_4 = 0x2,
                    /// REQ_8
                    REQ_8 = 0x3,
                    /// REQ_16
                    REQ_16 = 0x4,
                    _,
                },
                padding: u8 = 0,
            }),
            /// LCDIF Horizontal and Vertical Valid Data Count Register
            TRANSFER_COUNT: mmio.Mmio(packed struct(u32) {
                /// Total valid data (pixels) in each horizontal line
                H_COUNT: u16,
                /// Number of horizontal lines per frame which contain valid data
                V_COUNT: u16,
            }),
            reserved64: [12]u8,
            /// LCD Interface Current Buffer Address Register
            CUR_BUF: mmio.Mmio(packed struct(u32) {
                /// Address of the current frame being transmitted by LCDIF.
                ADDR: u32,
            }),
            reserved80: [12]u8,
            /// LCD Interface Next Buffer Address Register
            NEXT_BUF: mmio.Mmio(packed struct(u32) {
                /// Address of the next frame that will be transmitted by LCDIF.
                ADDR: u32,
            }),
            reserved112: [28]u8,
            /// LCDIF VSYNC Mode and Dotclk Mode Control Register0
            VDCTRL0: mmio.Mmio(packed struct(u32) {
                /// Number of units for which VSYNC signal is active
                VSYNC_PULSE_WIDTH: u18,
                /// When this bit is 0, the first field (VSYNC period) will end in half a horizontal line and the second field will begin with half a horizontal line
                HALF_LINE_MODE: u1,
                /// Setting this bit to 1 will make the total VSYNC period equal to the VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
                HALF_LINE: u1,
                /// Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK (pix_clk) cycles
                VSYNC_PULSE_WIDTH_UNIT: u1,
                /// Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk) cycles
                VSYNC_PERIOD_UNIT: u1,
                reserved24: u2 = 0,
                /// Default 0 active low during valid data transfer on each horizontal line.
                ENABLE_POL: u1,
                /// Default is data launched at negative edge of DOTCLK and captured at positive edge
                DOTCLK_POL: u1,
                /// Default 0 active low during HSYNC_PULSE_WIDTH time and will be high during the rest of the HSYNC period
                HSYNC_POL: u1,
                /// Default 0 active low during VSYNC_PULSE_WIDTH time and will be high during the rest of the VSYNC period
                VSYNC_POL: u1,
                /// Setting this bit to 1 will make the hardware generate the ENABLE signal in the DOTCLK mode, thereby making it the true RGB interface along with the remaining three signals VSYNC, HSYNC and DOTCLK
                ENABLE_PRESENT: u1,
                padding: u3 = 0,
            }),
            /// LCDIF VSYNC Mode and Dotclk Mode Control Register0
            VDCTRL0_SET: mmio.Mmio(packed struct(u32) {
                /// Number of units for which VSYNC signal is active
                VSYNC_PULSE_WIDTH: u18,
                /// When this bit is 0, the first field (VSYNC period) will end in half a horizontal line and the second field will begin with half a horizontal line
                HALF_LINE_MODE: u1,
                /// Setting this bit to 1 will make the total VSYNC period equal to the VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
                HALF_LINE: u1,
                /// Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK (pix_clk) cycles
                VSYNC_PULSE_WIDTH_UNIT: u1,
                /// Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk) cycles
                VSYNC_PERIOD_UNIT: u1,
                reserved24: u2 = 0,
                /// Default 0 active low during valid data transfer on each horizontal line.
                ENABLE_POL: u1,
                /// Default is data launched at negative edge of DOTCLK and captured at positive edge
                DOTCLK_POL: u1,
                /// Default 0 active low during HSYNC_PULSE_WIDTH time and will be high during the rest of the HSYNC period
                HSYNC_POL: u1,
                /// Default 0 active low during VSYNC_PULSE_WIDTH time and will be high during the rest of the VSYNC period
                VSYNC_POL: u1,
                /// Setting this bit to 1 will make the hardware generate the ENABLE signal in the DOTCLK mode, thereby making it the true RGB interface along with the remaining three signals VSYNC, HSYNC and DOTCLK
                ENABLE_PRESENT: u1,
                padding: u3 = 0,
            }),
            /// LCDIF VSYNC Mode and Dotclk Mode Control Register0
            VDCTRL0_CLR: mmio.Mmio(packed struct(u32) {
                /// Number of units for which VSYNC signal is active
                VSYNC_PULSE_WIDTH: u18,
                /// When this bit is 0, the first field (VSYNC period) will end in half a horizontal line and the second field will begin with half a horizontal line
                HALF_LINE_MODE: u1,
                /// Setting this bit to 1 will make the total VSYNC period equal to the VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
                HALF_LINE: u1,
                /// Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK (pix_clk) cycles
                VSYNC_PULSE_WIDTH_UNIT: u1,
                /// Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk) cycles
                VSYNC_PERIOD_UNIT: u1,
                reserved24: u2 = 0,
                /// Default 0 active low during valid data transfer on each horizontal line.
                ENABLE_POL: u1,
                /// Default is data launched at negative edge of DOTCLK and captured at positive edge
                DOTCLK_POL: u1,
                /// Default 0 active low during HSYNC_PULSE_WIDTH time and will be high during the rest of the HSYNC period
                HSYNC_POL: u1,
                /// Default 0 active low during VSYNC_PULSE_WIDTH time and will be high during the rest of the VSYNC period
                VSYNC_POL: u1,
                /// Setting this bit to 1 will make the hardware generate the ENABLE signal in the DOTCLK mode, thereby making it the true RGB interface along with the remaining three signals VSYNC, HSYNC and DOTCLK
                ENABLE_PRESENT: u1,
                padding: u3 = 0,
            }),
            /// LCDIF VSYNC Mode and Dotclk Mode Control Register0
            VDCTRL0_TOG: mmio.Mmio(packed struct(u32) {
                /// Number of units for which VSYNC signal is active
                VSYNC_PULSE_WIDTH: u18,
                /// When this bit is 0, the first field (VSYNC period) will end in half a horizontal line and the second field will begin with half a horizontal line
                HALF_LINE_MODE: u1,
                /// Setting this bit to 1 will make the total VSYNC period equal to the VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
                HALF_LINE: u1,
                /// Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK (pix_clk) cycles
                VSYNC_PULSE_WIDTH_UNIT: u1,
                /// Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk) cycles
                VSYNC_PERIOD_UNIT: u1,
                reserved24: u2 = 0,
                /// Default 0 active low during valid data transfer on each horizontal line.
                ENABLE_POL: u1,
                /// Default is data launched at negative edge of DOTCLK and captured at positive edge
                DOTCLK_POL: u1,
                /// Default 0 active low during HSYNC_PULSE_WIDTH time and will be high during the rest of the HSYNC period
                HSYNC_POL: u1,
                /// Default 0 active low during VSYNC_PULSE_WIDTH time and will be high during the rest of the VSYNC period
                VSYNC_POL: u1,
                /// Setting this bit to 1 will make the hardware generate the ENABLE signal in the DOTCLK mode, thereby making it the true RGB interface along with the remaining three signals VSYNC, HSYNC and DOTCLK
                ENABLE_PRESENT: u1,
                padding: u3 = 0,
            }),
            /// LCDIF VSYNC Mode and Dotclk Mode Control Register1
            VDCTRL1: mmio.Mmio(packed struct(u32) {
                /// Total number of units between two positive or two negative edges of the VSYNC signal
                VSYNC_PERIOD: u32,
            }),
            reserved144: [12]u8,
            /// LCDIF VSYNC Mode and Dotclk Mode Control Register2
            VDCTRL2: mmio.Mmio(packed struct(u32) {
                /// Total number of DISPLAY CLOCK (pix_clk) cycles between two positive or two negative edges of the HSYNC signal
                HSYNC_PERIOD: u18,
                /// Number of DISPLAY CLOCK (pix_clk) cycles for which HSYNC signal is active.
                HSYNC_PULSE_WIDTH: u14,
            }),
            reserved160: [12]u8,
            /// LCDIF VSYNC Mode and Dotclk Mode Control Register3
            VDCTRL3: mmio.Mmio(packed struct(u32) {
                /// In the VSYNC interface mode, wait for this number of DISPLAY CLOCK (pix_clk) cycles from the falling VSYNC edge (or rising if VSYNC_POL is 1) before starting LCD transactions and is applicable only if WAIT_FOR_VSYNC_EDGE is set
                VERTICAL_WAIT_CNT: u16,
                /// In the DOTCLK mode, wait for this number of clocks from falling edge (or rising if HSYNC_POL is 1) of HSYNC signal to account for horizontal back porch plus the number of DOTCLKs before the moving picture information begins
                HORIZONTAL_WAIT_CNT: u12,
                /// This bit must be set to 1 in the VSYNC mode of operation, and 0 in the DOTCLK mode of operation.
                VSYNC_ONLY: u1,
                /// When this bit is set, the LCDIF block will internally mux HSYNC with LCD_D14, DOTCLK with LCD_D13 and ENABLE with LCD_D12, otherwise these signals will go out on separate pins
                MUX_SYNC_SIGNALS: u1,
                padding: u2 = 0,
            }),
            reserved176: [12]u8,
            /// LCDIF VSYNC Mode and Dotclk Mode Control Register4
            VDCTRL4: mmio.Mmio(packed struct(u32) {
                /// Total number of DISPLAY CLOCK (pix_clk) cycles on each horizontal line that carry valid data in DOTCLK mode
                DOTCLK_H_VALID_DATA_CNT: u18,
                /// Set this field to 1 if the LCD controller requires that the VSYNC or VSYNC/HSYNC/DOTCLK control signals should be active at least one frame before the data transfers actually start and remain active at least one frame after the data transfers end
                SYNC_SIGNALS_ON: u1,
                reserved29: u10 = 0,
                /// This bitfield selects the amount of time by which the DOTCLK signal should be delayed before coming out of the LCD_DOTCK pin
                DOTCLK_DLY_SEL: u3,
            }),
            reserved400: [220]u8,
            /// Bus Master Error Status Register
            BM_ERROR_STAT: mmio.Mmio(packed struct(u32) {
                /// Virtual address at which bus master error occurred.
                ADDR: u32,
            }),
            reserved416: [12]u8,
            /// CRC Status Register
            CRC_STAT: mmio.Mmio(packed struct(u32) {
                /// Calculated CRC value.
                CRC_VALUE: u32,
            }),
            reserved432: [12]u8,
            /// LCD Interface Status Register
            STAT: mmio.Mmio(packed struct(u32) {
                /// Read only view of the current count in Latency buffer (LFIFO).
                LFIFO_COUNT: u9,
                reserved26: u17 = 0,
                /// Read only view of the signals that indicates LCD TXFIFO is empty.
                TXFIFO_EMPTY: u1,
                /// Read only view of the signals that indicates LCD TXFIFO is full.
                TXFIFO_FULL: u1,
                /// Read only view of the signals that indicates LCD LFIFO is empty.
                LFIFO_EMPTY: u1,
                /// Read only view of the signals that indicates LCD LFIFO is full.
                LFIFO_FULL: u1,
                /// Reflects the current state of the DMA Request line for the LCDIF
                DMA_REQ: u1,
                /// 0: LCDIF not present on this product 1: LCDIF is present.
                PRESENT: u1,
            }),
            reserved896: [460]u8,
            /// LCDIF Pigeon Mode Control0 Register
            PIGEONCTRL0: mmio.Mmio(packed struct(u32) {
                /// Period of line counter during FD phase
                FD_PERIOD: u12,
                reserved16: u4 = 0,
                /// Period of pclk counter during LD phase
                LD_PERIOD: u12,
                padding: u4 = 0,
            }),
            /// LCDIF Pigeon Mode Control0 Register
            PIGEONCTRL0_SET: mmio.Mmio(packed struct(u32) {
                /// Period of line counter during FD phase
                FD_PERIOD: u12,
                reserved16: u4 = 0,
                /// Period of pclk counter during LD phase
                LD_PERIOD: u12,
                padding: u4 = 0,
            }),
            /// LCDIF Pigeon Mode Control0 Register
            PIGEONCTRL0_CLR: mmio.Mmio(packed struct(u32) {
                /// Period of line counter during FD phase
                FD_PERIOD: u12,
                reserved16: u4 = 0,
                /// Period of pclk counter during LD phase
                LD_PERIOD: u12,
                padding: u4 = 0,
            }),
            /// LCDIF Pigeon Mode Control0 Register
            PIGEONCTRL0_TOG: mmio.Mmio(packed struct(u32) {
                /// Period of line counter during FD phase
                FD_PERIOD: u12,
                reserved16: u4 = 0,
                /// Period of pclk counter during LD phase
                LD_PERIOD: u12,
                padding: u4 = 0,
            }),
            /// LCDIF Pigeon Mode Control1 Register
            PIGEONCTRL1: mmio.Mmio(packed struct(u32) {
                /// Period of frame counter
                FRAME_CNT_PERIOD: u12,
                reserved16: u4 = 0,
                /// Max cycles of frame counter
                FRAME_CNT_CYCLES: u12,
                padding: u4 = 0,
            }),
            /// LCDIF Pigeon Mode Control1 Register
            PIGEONCTRL1_SET: mmio.Mmio(packed struct(u32) {
                /// Period of frame counter
                FRAME_CNT_PERIOD: u12,
                reserved16: u4 = 0,
                /// Max cycles of frame counter
                FRAME_CNT_CYCLES: u12,
                padding: u4 = 0,
            }),
            /// LCDIF Pigeon Mode Control1 Register
            PIGEONCTRL1_CLR: mmio.Mmio(packed struct(u32) {
                /// Period of frame counter
                FRAME_CNT_PERIOD: u12,
                reserved16: u4 = 0,
                /// Max cycles of frame counter
                FRAME_CNT_CYCLES: u12,
                padding: u4 = 0,
            }),
            /// LCDIF Pigeon Mode Control1 Register
            PIGEONCTRL1_TOG: mmio.Mmio(packed struct(u32) {
                /// Period of frame counter
                FRAME_CNT_PERIOD: u12,
                reserved16: u4 = 0,
                /// Max cycles of frame counter
                FRAME_CNT_CYCLES: u12,
                padding: u4 = 0,
            }),
            /// LCDIF Pigeon Mode Control2 Register
            PIGEONCTRL2: mmio.Mmio(packed struct(u32) {
                /// Pigeon mode data enable
                PIGEON_DATA_EN: u1,
                /// Pigeon mode dot clock gate enable
                PIGEON_CLK_GATE: u1,
                padding: u30 = 0,
            }),
            /// LCDIF Pigeon Mode Control2 Register
            PIGEONCTRL2_SET: mmio.Mmio(packed struct(u32) {
                /// Pigeon mode data enable
                PIGEON_DATA_EN: u1,
                /// Pigeon mode dot clock gate enable
                PIGEON_CLK_GATE: u1,
                padding: u30 = 0,
            }),
            /// LCDIF Pigeon Mode Control2 Register
            PIGEONCTRL2_CLR: mmio.Mmio(packed struct(u32) {
                /// Pigeon mode data enable
                PIGEON_DATA_EN: u1,
                /// Pigeon mode dot clock gate enable
                PIGEON_CLK_GATE: u1,
                padding: u30 = 0,
            }),
            /// LCDIF Pigeon Mode Control2 Register
            PIGEONCTRL2_TOG: mmio.Mmio(packed struct(u32) {
                /// Pigeon mode data enable
                PIGEON_DATA_EN: u1,
                /// Pigeon mode dot clock gate enable
                PIGEON_CLK_GATE: u1,
                padding: u30 = 0,
            }),
            reserved2048: [1104]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_0_0: mmio.Mmio(packed struct(u32) {
                /// Enable pigeon Mode on this signal
                EN: u1,
                /// Polarity of signal output
                POL: enum(u1) {
                    /// Normal Signal (Active high)
                    ACTIVE_HIGH = 0x0,
                    /// Inverted signal (Active low)
                    ACTIVE_LOW = 0x1,
                },
                /// Event to incrment local counter
                INC_SEL: enum(u2) {
                    /// pclk
                    PCLK = 0x0,
                    /// Line start pulse
                    LINE = 0x1,
                    /// Frame start pulse
                    FRAME = 0x2,
                    /// Use another signal as tick event
                    SIG_ANOTHER = 0x3,
                },
                /// offset on pclk unit
                OFFSET: u4,
                /// select global counters as mask condition, use together with MASK_CNT
                MASK_CNT_SEL: enum(u4) {
                    /// pclk counter within one hscan state
                    HSTATE_CNT = 0x0,
                    /// pclk cycle within one hscan state
                    HSTATE_CYCLE = 0x1,
                    /// line counter within one vscan state
                    VSTATE_CNT = 0x2,
                    /// line cycle within one vscan state
                    VSTATE_CYCLE = 0x3,
                    /// frame counter
                    FRAME_CNT = 0x4,
                    /// frame cycle
                    FRAME_CYCLE = 0x5,
                    /// horizontal counter (pclk counter within one line )
                    HCNT = 0x6,
                    /// vertical counter (line counter within one frame)
                    VCNT = 0x7,
                    _,
                },
                /// When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
                MASK_CNT: u12,
                /// state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
                STATE_MASK: enum(u8) {
                    /// FRAME SYNC
                    FS = 0x1,
                    /// FRAME BEGIN
                    FB = 0x2,
                    /// FRAME DATA
                    FD = 0x4,
                    /// FRAME END
                    FE = 0x8,
                    /// LINE SYNC
                    LS = 0x10,
                    /// LINE BEGIN
                    LB = 0x20,
                    /// LINE DATA
                    LD = 0x40,
                    /// LINE END
                    LE = 0x80,
                    _,
                },
            }),
            reserved2064: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_0_1: mmio.Mmio(packed struct(u32) {
                /// Assert signal output when counter match this value
                SET_CNT: enum(u16) {
                    /// Start as active
                    START_ACTIVE = 0x0,
                    _,
                },
                /// Deassert signal output when counter match this value
                CLR_CNT: enum(u16) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
            }),
            reserved2080: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_0_2: mmio.Mmio(packed struct(u32) {
                /// Logic operation with another signal: DIS/AND/OR/COND
                SIG_LOGIC: enum(u4) {
                    /// No logic operation
                    DIS = 0x0,
                    /// sigout = sig_another AND this_sig
                    AND = 0x1,
                    /// sigout = sig_another OR this_sig
                    OR = 0x2,
                    /// mask = sig_another AND other_masks
                    MASK = 0x3,
                    _,
                },
                /// Select another signal for logic operation or as mask or counter tick event
                SIG_ANOTHER: enum(u5) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
                padding: u23 = 0,
            }),
            reserved2112: [28]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_1_0: mmio.Mmio(packed struct(u32) {
                /// Enable pigeon Mode on this signal
                EN: u1,
                /// Polarity of signal output
                POL: enum(u1) {
                    /// Normal Signal (Active high)
                    ACTIVE_HIGH = 0x0,
                    /// Inverted signal (Active low)
                    ACTIVE_LOW = 0x1,
                },
                /// Event to incrment local counter
                INC_SEL: enum(u2) {
                    /// pclk
                    PCLK = 0x0,
                    /// Line start pulse
                    LINE = 0x1,
                    /// Frame start pulse
                    FRAME = 0x2,
                    /// Use another signal as tick event
                    SIG_ANOTHER = 0x3,
                },
                /// offset on pclk unit
                OFFSET: u4,
                /// select global counters as mask condition, use together with MASK_CNT
                MASK_CNT_SEL: enum(u4) {
                    /// pclk counter within one hscan state
                    HSTATE_CNT = 0x0,
                    /// pclk cycle within one hscan state
                    HSTATE_CYCLE = 0x1,
                    /// line counter within one vscan state
                    VSTATE_CNT = 0x2,
                    /// line cycle within one vscan state
                    VSTATE_CYCLE = 0x3,
                    /// frame counter
                    FRAME_CNT = 0x4,
                    /// frame cycle
                    FRAME_CYCLE = 0x5,
                    /// horizontal counter (pclk counter within one line )
                    HCNT = 0x6,
                    /// vertical counter (line counter within one frame)
                    VCNT = 0x7,
                    _,
                },
                /// When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
                MASK_CNT: u12,
                /// state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
                STATE_MASK: enum(u8) {
                    /// FRAME SYNC
                    FS = 0x1,
                    /// FRAME BEGIN
                    FB = 0x2,
                    /// FRAME DATA
                    FD = 0x4,
                    /// FRAME END
                    FE = 0x8,
                    /// LINE SYNC
                    LS = 0x10,
                    /// LINE BEGIN
                    LB = 0x20,
                    /// LINE DATA
                    LD = 0x40,
                    /// LINE END
                    LE = 0x80,
                    _,
                },
            }),
            reserved2128: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_1_1: mmio.Mmio(packed struct(u32) {
                /// Assert signal output when counter match this value
                SET_CNT: enum(u16) {
                    /// Start as active
                    START_ACTIVE = 0x0,
                    _,
                },
                /// Deassert signal output when counter match this value
                CLR_CNT: enum(u16) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
            }),
            reserved2144: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_1_2: mmio.Mmio(packed struct(u32) {
                /// Logic operation with another signal: DIS/AND/OR/COND
                SIG_LOGIC: enum(u4) {
                    /// No logic operation
                    DIS = 0x0,
                    /// sigout = sig_another AND this_sig
                    AND = 0x1,
                    /// sigout = sig_another OR this_sig
                    OR = 0x2,
                    /// mask = sig_another AND other_masks
                    MASK = 0x3,
                    _,
                },
                /// Select another signal for logic operation or as mask or counter tick event
                SIG_ANOTHER: enum(u5) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
                padding: u23 = 0,
            }),
            reserved2176: [28]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_2_0: mmio.Mmio(packed struct(u32) {
                /// Enable pigeon Mode on this signal
                EN: u1,
                /// Polarity of signal output
                POL: enum(u1) {
                    /// Normal Signal (Active high)
                    ACTIVE_HIGH = 0x0,
                    /// Inverted signal (Active low)
                    ACTIVE_LOW = 0x1,
                },
                /// Event to incrment local counter
                INC_SEL: enum(u2) {
                    /// pclk
                    PCLK = 0x0,
                    /// Line start pulse
                    LINE = 0x1,
                    /// Frame start pulse
                    FRAME = 0x2,
                    /// Use another signal as tick event
                    SIG_ANOTHER = 0x3,
                },
                /// offset on pclk unit
                OFFSET: u4,
                /// select global counters as mask condition, use together with MASK_CNT
                MASK_CNT_SEL: enum(u4) {
                    /// pclk counter within one hscan state
                    HSTATE_CNT = 0x0,
                    /// pclk cycle within one hscan state
                    HSTATE_CYCLE = 0x1,
                    /// line counter within one vscan state
                    VSTATE_CNT = 0x2,
                    /// line cycle within one vscan state
                    VSTATE_CYCLE = 0x3,
                    /// frame counter
                    FRAME_CNT = 0x4,
                    /// frame cycle
                    FRAME_CYCLE = 0x5,
                    /// horizontal counter (pclk counter within one line )
                    HCNT = 0x6,
                    /// vertical counter (line counter within one frame)
                    VCNT = 0x7,
                    _,
                },
                /// When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
                MASK_CNT: u12,
                /// state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
                STATE_MASK: enum(u8) {
                    /// FRAME SYNC
                    FS = 0x1,
                    /// FRAME BEGIN
                    FB = 0x2,
                    /// FRAME DATA
                    FD = 0x4,
                    /// FRAME END
                    FE = 0x8,
                    /// LINE SYNC
                    LS = 0x10,
                    /// LINE BEGIN
                    LB = 0x20,
                    /// LINE DATA
                    LD = 0x40,
                    /// LINE END
                    LE = 0x80,
                    _,
                },
            }),
            reserved2192: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_2_1: mmio.Mmio(packed struct(u32) {
                /// Assert signal output when counter match this value
                SET_CNT: enum(u16) {
                    /// Start as active
                    START_ACTIVE = 0x0,
                    _,
                },
                /// Deassert signal output when counter match this value
                CLR_CNT: enum(u16) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
            }),
            reserved2208: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_2_2: mmio.Mmio(packed struct(u32) {
                /// Logic operation with another signal: DIS/AND/OR/COND
                SIG_LOGIC: enum(u4) {
                    /// No logic operation
                    DIS = 0x0,
                    /// sigout = sig_another AND this_sig
                    AND = 0x1,
                    /// sigout = sig_another OR this_sig
                    OR = 0x2,
                    /// mask = sig_another AND other_masks
                    MASK = 0x3,
                    _,
                },
                /// Select another signal for logic operation or as mask or counter tick event
                SIG_ANOTHER: enum(u5) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
                padding: u23 = 0,
            }),
            reserved2240: [28]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_3_0: mmio.Mmio(packed struct(u32) {
                /// Enable pigeon Mode on this signal
                EN: u1,
                /// Polarity of signal output
                POL: enum(u1) {
                    /// Normal Signal (Active high)
                    ACTIVE_HIGH = 0x0,
                    /// Inverted signal (Active low)
                    ACTIVE_LOW = 0x1,
                },
                /// Event to incrment local counter
                INC_SEL: enum(u2) {
                    /// pclk
                    PCLK = 0x0,
                    /// Line start pulse
                    LINE = 0x1,
                    /// Frame start pulse
                    FRAME = 0x2,
                    /// Use another signal as tick event
                    SIG_ANOTHER = 0x3,
                },
                /// offset on pclk unit
                OFFSET: u4,
                /// select global counters as mask condition, use together with MASK_CNT
                MASK_CNT_SEL: enum(u4) {
                    /// pclk counter within one hscan state
                    HSTATE_CNT = 0x0,
                    /// pclk cycle within one hscan state
                    HSTATE_CYCLE = 0x1,
                    /// line counter within one vscan state
                    VSTATE_CNT = 0x2,
                    /// line cycle within one vscan state
                    VSTATE_CYCLE = 0x3,
                    /// frame counter
                    FRAME_CNT = 0x4,
                    /// frame cycle
                    FRAME_CYCLE = 0x5,
                    /// horizontal counter (pclk counter within one line )
                    HCNT = 0x6,
                    /// vertical counter (line counter within one frame)
                    VCNT = 0x7,
                    _,
                },
                /// When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
                MASK_CNT: u12,
                /// state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
                STATE_MASK: enum(u8) {
                    /// FRAME SYNC
                    FS = 0x1,
                    /// FRAME BEGIN
                    FB = 0x2,
                    /// FRAME DATA
                    FD = 0x4,
                    /// FRAME END
                    FE = 0x8,
                    /// LINE SYNC
                    LS = 0x10,
                    /// LINE BEGIN
                    LB = 0x20,
                    /// LINE DATA
                    LD = 0x40,
                    /// LINE END
                    LE = 0x80,
                    _,
                },
            }),
            reserved2256: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_3_1: mmio.Mmio(packed struct(u32) {
                /// Assert signal output when counter match this value
                SET_CNT: enum(u16) {
                    /// Start as active
                    START_ACTIVE = 0x0,
                    _,
                },
                /// Deassert signal output when counter match this value
                CLR_CNT: enum(u16) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
            }),
            reserved2272: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_3_2: mmio.Mmio(packed struct(u32) {
                /// Logic operation with another signal: DIS/AND/OR/COND
                SIG_LOGIC: enum(u4) {
                    /// No logic operation
                    DIS = 0x0,
                    /// sigout = sig_another AND this_sig
                    AND = 0x1,
                    /// sigout = sig_another OR this_sig
                    OR = 0x2,
                    /// mask = sig_another AND other_masks
                    MASK = 0x3,
                    _,
                },
                /// Select another signal for logic operation or as mask or counter tick event
                SIG_ANOTHER: enum(u5) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
                padding: u23 = 0,
            }),
            reserved2304: [28]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_4_0: mmio.Mmio(packed struct(u32) {
                /// Enable pigeon Mode on this signal
                EN: u1,
                /// Polarity of signal output
                POL: enum(u1) {
                    /// Normal Signal (Active high)
                    ACTIVE_HIGH = 0x0,
                    /// Inverted signal (Active low)
                    ACTIVE_LOW = 0x1,
                },
                /// Event to incrment local counter
                INC_SEL: enum(u2) {
                    /// pclk
                    PCLK = 0x0,
                    /// Line start pulse
                    LINE = 0x1,
                    /// Frame start pulse
                    FRAME = 0x2,
                    /// Use another signal as tick event
                    SIG_ANOTHER = 0x3,
                },
                /// offset on pclk unit
                OFFSET: u4,
                /// select global counters as mask condition, use together with MASK_CNT
                MASK_CNT_SEL: enum(u4) {
                    /// pclk counter within one hscan state
                    HSTATE_CNT = 0x0,
                    /// pclk cycle within one hscan state
                    HSTATE_CYCLE = 0x1,
                    /// line counter within one vscan state
                    VSTATE_CNT = 0x2,
                    /// line cycle within one vscan state
                    VSTATE_CYCLE = 0x3,
                    /// frame counter
                    FRAME_CNT = 0x4,
                    /// frame cycle
                    FRAME_CYCLE = 0x5,
                    /// horizontal counter (pclk counter within one line )
                    HCNT = 0x6,
                    /// vertical counter (line counter within one frame)
                    VCNT = 0x7,
                    _,
                },
                /// When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
                MASK_CNT: u12,
                /// state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
                STATE_MASK: enum(u8) {
                    /// FRAME SYNC
                    FS = 0x1,
                    /// FRAME BEGIN
                    FB = 0x2,
                    /// FRAME DATA
                    FD = 0x4,
                    /// FRAME END
                    FE = 0x8,
                    /// LINE SYNC
                    LS = 0x10,
                    /// LINE BEGIN
                    LB = 0x20,
                    /// LINE DATA
                    LD = 0x40,
                    /// LINE END
                    LE = 0x80,
                    _,
                },
            }),
            reserved2320: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_4_1: mmio.Mmio(packed struct(u32) {
                /// Assert signal output when counter match this value
                SET_CNT: enum(u16) {
                    /// Start as active
                    START_ACTIVE = 0x0,
                    _,
                },
                /// Deassert signal output when counter match this value
                CLR_CNT: enum(u16) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
            }),
            reserved2336: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_4_2: mmio.Mmio(packed struct(u32) {
                /// Logic operation with another signal: DIS/AND/OR/COND
                SIG_LOGIC: enum(u4) {
                    /// No logic operation
                    DIS = 0x0,
                    /// sigout = sig_another AND this_sig
                    AND = 0x1,
                    /// sigout = sig_another OR this_sig
                    OR = 0x2,
                    /// mask = sig_another AND other_masks
                    MASK = 0x3,
                    _,
                },
                /// Select another signal for logic operation or as mask or counter tick event
                SIG_ANOTHER: enum(u5) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
                padding: u23 = 0,
            }),
            reserved2368: [28]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_5_0: mmio.Mmio(packed struct(u32) {
                /// Enable pigeon Mode on this signal
                EN: u1,
                /// Polarity of signal output
                POL: enum(u1) {
                    /// Normal Signal (Active high)
                    ACTIVE_HIGH = 0x0,
                    /// Inverted signal (Active low)
                    ACTIVE_LOW = 0x1,
                },
                /// Event to incrment local counter
                INC_SEL: enum(u2) {
                    /// pclk
                    PCLK = 0x0,
                    /// Line start pulse
                    LINE = 0x1,
                    /// Frame start pulse
                    FRAME = 0x2,
                    /// Use another signal as tick event
                    SIG_ANOTHER = 0x3,
                },
                /// offset on pclk unit
                OFFSET: u4,
                /// select global counters as mask condition, use together with MASK_CNT
                MASK_CNT_SEL: enum(u4) {
                    /// pclk counter within one hscan state
                    HSTATE_CNT = 0x0,
                    /// pclk cycle within one hscan state
                    HSTATE_CYCLE = 0x1,
                    /// line counter within one vscan state
                    VSTATE_CNT = 0x2,
                    /// line cycle within one vscan state
                    VSTATE_CYCLE = 0x3,
                    /// frame counter
                    FRAME_CNT = 0x4,
                    /// frame cycle
                    FRAME_CYCLE = 0x5,
                    /// horizontal counter (pclk counter within one line )
                    HCNT = 0x6,
                    /// vertical counter (line counter within one frame)
                    VCNT = 0x7,
                    _,
                },
                /// When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
                MASK_CNT: u12,
                /// state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
                STATE_MASK: enum(u8) {
                    /// FRAME SYNC
                    FS = 0x1,
                    /// FRAME BEGIN
                    FB = 0x2,
                    /// FRAME DATA
                    FD = 0x4,
                    /// FRAME END
                    FE = 0x8,
                    /// LINE SYNC
                    LS = 0x10,
                    /// LINE BEGIN
                    LB = 0x20,
                    /// LINE DATA
                    LD = 0x40,
                    /// LINE END
                    LE = 0x80,
                    _,
                },
            }),
            reserved2384: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_5_1: mmio.Mmio(packed struct(u32) {
                /// Assert signal output when counter match this value
                SET_CNT: enum(u16) {
                    /// Start as active
                    START_ACTIVE = 0x0,
                    _,
                },
                /// Deassert signal output when counter match this value
                CLR_CNT: enum(u16) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
            }),
            reserved2400: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_5_2: mmio.Mmio(packed struct(u32) {
                /// Logic operation with another signal: DIS/AND/OR/COND
                SIG_LOGIC: enum(u4) {
                    /// No logic operation
                    DIS = 0x0,
                    /// sigout = sig_another AND this_sig
                    AND = 0x1,
                    /// sigout = sig_another OR this_sig
                    OR = 0x2,
                    /// mask = sig_another AND other_masks
                    MASK = 0x3,
                    _,
                },
                /// Select another signal for logic operation or as mask or counter tick event
                SIG_ANOTHER: enum(u5) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
                padding: u23 = 0,
            }),
            reserved2432: [28]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_6_0: mmio.Mmio(packed struct(u32) {
                /// Enable pigeon Mode on this signal
                EN: u1,
                /// Polarity of signal output
                POL: enum(u1) {
                    /// Normal Signal (Active high)
                    ACTIVE_HIGH = 0x0,
                    /// Inverted signal (Active low)
                    ACTIVE_LOW = 0x1,
                },
                /// Event to incrment local counter
                INC_SEL: enum(u2) {
                    /// pclk
                    PCLK = 0x0,
                    /// Line start pulse
                    LINE = 0x1,
                    /// Frame start pulse
                    FRAME = 0x2,
                    /// Use another signal as tick event
                    SIG_ANOTHER = 0x3,
                },
                /// offset on pclk unit
                OFFSET: u4,
                /// select global counters as mask condition, use together with MASK_CNT
                MASK_CNT_SEL: enum(u4) {
                    /// pclk counter within one hscan state
                    HSTATE_CNT = 0x0,
                    /// pclk cycle within one hscan state
                    HSTATE_CYCLE = 0x1,
                    /// line counter within one vscan state
                    VSTATE_CNT = 0x2,
                    /// line cycle within one vscan state
                    VSTATE_CYCLE = 0x3,
                    /// frame counter
                    FRAME_CNT = 0x4,
                    /// frame cycle
                    FRAME_CYCLE = 0x5,
                    /// horizontal counter (pclk counter within one line )
                    HCNT = 0x6,
                    /// vertical counter (line counter within one frame)
                    VCNT = 0x7,
                    _,
                },
                /// When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
                MASK_CNT: u12,
                /// state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
                STATE_MASK: enum(u8) {
                    /// FRAME SYNC
                    FS = 0x1,
                    /// FRAME BEGIN
                    FB = 0x2,
                    /// FRAME DATA
                    FD = 0x4,
                    /// FRAME END
                    FE = 0x8,
                    /// LINE SYNC
                    LS = 0x10,
                    /// LINE BEGIN
                    LB = 0x20,
                    /// LINE DATA
                    LD = 0x40,
                    /// LINE END
                    LE = 0x80,
                    _,
                },
            }),
            reserved2448: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_6_1: mmio.Mmio(packed struct(u32) {
                /// Assert signal output when counter match this value
                SET_CNT: enum(u16) {
                    /// Start as active
                    START_ACTIVE = 0x0,
                    _,
                },
                /// Deassert signal output when counter match this value
                CLR_CNT: enum(u16) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
            }),
            reserved2464: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_6_2: mmio.Mmio(packed struct(u32) {
                /// Logic operation with another signal: DIS/AND/OR/COND
                SIG_LOGIC: enum(u4) {
                    /// No logic operation
                    DIS = 0x0,
                    /// sigout = sig_another AND this_sig
                    AND = 0x1,
                    /// sigout = sig_another OR this_sig
                    OR = 0x2,
                    /// mask = sig_another AND other_masks
                    MASK = 0x3,
                    _,
                },
                /// Select another signal for logic operation or as mask or counter tick event
                SIG_ANOTHER: enum(u5) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
                padding: u23 = 0,
            }),
            reserved2496: [28]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_7_0: mmio.Mmio(packed struct(u32) {
                /// Enable pigeon Mode on this signal
                EN: u1,
                /// Polarity of signal output
                POL: enum(u1) {
                    /// Normal Signal (Active high)
                    ACTIVE_HIGH = 0x0,
                    /// Inverted signal (Active low)
                    ACTIVE_LOW = 0x1,
                },
                /// Event to incrment local counter
                INC_SEL: enum(u2) {
                    /// pclk
                    PCLK = 0x0,
                    /// Line start pulse
                    LINE = 0x1,
                    /// Frame start pulse
                    FRAME = 0x2,
                    /// Use another signal as tick event
                    SIG_ANOTHER = 0x3,
                },
                /// offset on pclk unit
                OFFSET: u4,
                /// select global counters as mask condition, use together with MASK_CNT
                MASK_CNT_SEL: enum(u4) {
                    /// pclk counter within one hscan state
                    HSTATE_CNT = 0x0,
                    /// pclk cycle within one hscan state
                    HSTATE_CYCLE = 0x1,
                    /// line counter within one vscan state
                    VSTATE_CNT = 0x2,
                    /// line cycle within one vscan state
                    VSTATE_CYCLE = 0x3,
                    /// frame counter
                    FRAME_CNT = 0x4,
                    /// frame cycle
                    FRAME_CYCLE = 0x5,
                    /// horizontal counter (pclk counter within one line )
                    HCNT = 0x6,
                    /// vertical counter (line counter within one frame)
                    VCNT = 0x7,
                    _,
                },
                /// When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
                MASK_CNT: u12,
                /// state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
                STATE_MASK: enum(u8) {
                    /// FRAME SYNC
                    FS = 0x1,
                    /// FRAME BEGIN
                    FB = 0x2,
                    /// FRAME DATA
                    FD = 0x4,
                    /// FRAME END
                    FE = 0x8,
                    /// LINE SYNC
                    LS = 0x10,
                    /// LINE BEGIN
                    LB = 0x20,
                    /// LINE DATA
                    LD = 0x40,
                    /// LINE END
                    LE = 0x80,
                    _,
                },
            }),
            reserved2512: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_7_1: mmio.Mmio(packed struct(u32) {
                /// Assert signal output when counter match this value
                SET_CNT: enum(u16) {
                    /// Start as active
                    START_ACTIVE = 0x0,
                    _,
                },
                /// Deassert signal output when counter match this value
                CLR_CNT: enum(u16) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
            }),
            reserved2528: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_7_2: mmio.Mmio(packed struct(u32) {
                /// Logic operation with another signal: DIS/AND/OR/COND
                SIG_LOGIC: enum(u4) {
                    /// No logic operation
                    DIS = 0x0,
                    /// sigout = sig_another AND this_sig
                    AND = 0x1,
                    /// sigout = sig_another OR this_sig
                    OR = 0x2,
                    /// mask = sig_another AND other_masks
                    MASK = 0x3,
                    _,
                },
                /// Select another signal for logic operation or as mask or counter tick event
                SIG_ANOTHER: enum(u5) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
                padding: u23 = 0,
            }),
            reserved2560: [28]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_8_0: mmio.Mmio(packed struct(u32) {
                /// Enable pigeon Mode on this signal
                EN: u1,
                /// Polarity of signal output
                POL: enum(u1) {
                    /// Normal Signal (Active high)
                    ACTIVE_HIGH = 0x0,
                    /// Inverted signal (Active low)
                    ACTIVE_LOW = 0x1,
                },
                /// Event to incrment local counter
                INC_SEL: enum(u2) {
                    /// pclk
                    PCLK = 0x0,
                    /// Line start pulse
                    LINE = 0x1,
                    /// Frame start pulse
                    FRAME = 0x2,
                    /// Use another signal as tick event
                    SIG_ANOTHER = 0x3,
                },
                /// offset on pclk unit
                OFFSET: u4,
                /// select global counters as mask condition, use together with MASK_CNT
                MASK_CNT_SEL: enum(u4) {
                    /// pclk counter within one hscan state
                    HSTATE_CNT = 0x0,
                    /// pclk cycle within one hscan state
                    HSTATE_CYCLE = 0x1,
                    /// line counter within one vscan state
                    VSTATE_CNT = 0x2,
                    /// line cycle within one vscan state
                    VSTATE_CYCLE = 0x3,
                    /// frame counter
                    FRAME_CNT = 0x4,
                    /// frame cycle
                    FRAME_CYCLE = 0x5,
                    /// horizontal counter (pclk counter within one line )
                    HCNT = 0x6,
                    /// vertical counter (line counter within one frame)
                    VCNT = 0x7,
                    _,
                },
                /// When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
                MASK_CNT: u12,
                /// state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
                STATE_MASK: enum(u8) {
                    /// FRAME SYNC
                    FS = 0x1,
                    /// FRAME BEGIN
                    FB = 0x2,
                    /// FRAME DATA
                    FD = 0x4,
                    /// FRAME END
                    FE = 0x8,
                    /// LINE SYNC
                    LS = 0x10,
                    /// LINE BEGIN
                    LB = 0x20,
                    /// LINE DATA
                    LD = 0x40,
                    /// LINE END
                    LE = 0x80,
                    _,
                },
            }),
            reserved2576: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_8_1: mmio.Mmio(packed struct(u32) {
                /// Assert signal output when counter match this value
                SET_CNT: enum(u16) {
                    /// Start as active
                    START_ACTIVE = 0x0,
                    _,
                },
                /// Deassert signal output when counter match this value
                CLR_CNT: enum(u16) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
            }),
            reserved2592: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_8_2: mmio.Mmio(packed struct(u32) {
                /// Logic operation with another signal: DIS/AND/OR/COND
                SIG_LOGIC: enum(u4) {
                    /// No logic operation
                    DIS = 0x0,
                    /// sigout = sig_another AND this_sig
                    AND = 0x1,
                    /// sigout = sig_another OR this_sig
                    OR = 0x2,
                    /// mask = sig_another AND other_masks
                    MASK = 0x3,
                    _,
                },
                /// Select another signal for logic operation or as mask or counter tick event
                SIG_ANOTHER: enum(u5) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
                padding: u23 = 0,
            }),
            reserved2624: [28]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_9_0: mmio.Mmio(packed struct(u32) {
                /// Enable pigeon Mode on this signal
                EN: u1,
                /// Polarity of signal output
                POL: enum(u1) {
                    /// Normal Signal (Active high)
                    ACTIVE_HIGH = 0x0,
                    /// Inverted signal (Active low)
                    ACTIVE_LOW = 0x1,
                },
                /// Event to incrment local counter
                INC_SEL: enum(u2) {
                    /// pclk
                    PCLK = 0x0,
                    /// Line start pulse
                    LINE = 0x1,
                    /// Frame start pulse
                    FRAME = 0x2,
                    /// Use another signal as tick event
                    SIG_ANOTHER = 0x3,
                },
                /// offset on pclk unit
                OFFSET: u4,
                /// select global counters as mask condition, use together with MASK_CNT
                MASK_CNT_SEL: enum(u4) {
                    /// pclk counter within one hscan state
                    HSTATE_CNT = 0x0,
                    /// pclk cycle within one hscan state
                    HSTATE_CYCLE = 0x1,
                    /// line counter within one vscan state
                    VSTATE_CNT = 0x2,
                    /// line cycle within one vscan state
                    VSTATE_CYCLE = 0x3,
                    /// frame counter
                    FRAME_CNT = 0x4,
                    /// frame cycle
                    FRAME_CYCLE = 0x5,
                    /// horizontal counter (pclk counter within one line )
                    HCNT = 0x6,
                    /// vertical counter (line counter within one frame)
                    VCNT = 0x7,
                    _,
                },
                /// When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
                MASK_CNT: u12,
                /// state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
                STATE_MASK: enum(u8) {
                    /// FRAME SYNC
                    FS = 0x1,
                    /// FRAME BEGIN
                    FB = 0x2,
                    /// FRAME DATA
                    FD = 0x4,
                    /// FRAME END
                    FE = 0x8,
                    /// LINE SYNC
                    LS = 0x10,
                    /// LINE BEGIN
                    LB = 0x20,
                    /// LINE DATA
                    LD = 0x40,
                    /// LINE END
                    LE = 0x80,
                    _,
                },
            }),
            reserved2640: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_9_1: mmio.Mmio(packed struct(u32) {
                /// Assert signal output when counter match this value
                SET_CNT: enum(u16) {
                    /// Start as active
                    START_ACTIVE = 0x0,
                    _,
                },
                /// Deassert signal output when counter match this value
                CLR_CNT: enum(u16) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
            }),
            reserved2656: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_9_2: mmio.Mmio(packed struct(u32) {
                /// Logic operation with another signal: DIS/AND/OR/COND
                SIG_LOGIC: enum(u4) {
                    /// No logic operation
                    DIS = 0x0,
                    /// sigout = sig_another AND this_sig
                    AND = 0x1,
                    /// sigout = sig_another OR this_sig
                    OR = 0x2,
                    /// mask = sig_another AND other_masks
                    MASK = 0x3,
                    _,
                },
                /// Select another signal for logic operation or as mask or counter tick event
                SIG_ANOTHER: enum(u5) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
                padding: u23 = 0,
            }),
            reserved2688: [28]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_10_0: mmio.Mmio(packed struct(u32) {
                /// Enable pigeon Mode on this signal
                EN: u1,
                /// Polarity of signal output
                POL: enum(u1) {
                    /// Normal Signal (Active high)
                    ACTIVE_HIGH = 0x0,
                    /// Inverted signal (Active low)
                    ACTIVE_LOW = 0x1,
                },
                /// Event to incrment local counter
                INC_SEL: enum(u2) {
                    /// pclk
                    PCLK = 0x0,
                    /// Line start pulse
                    LINE = 0x1,
                    /// Frame start pulse
                    FRAME = 0x2,
                    /// Use another signal as tick event
                    SIG_ANOTHER = 0x3,
                },
                /// offset on pclk unit
                OFFSET: u4,
                /// select global counters as mask condition, use together with MASK_CNT
                MASK_CNT_SEL: enum(u4) {
                    /// pclk counter within one hscan state
                    HSTATE_CNT = 0x0,
                    /// pclk cycle within one hscan state
                    HSTATE_CYCLE = 0x1,
                    /// line counter within one vscan state
                    VSTATE_CNT = 0x2,
                    /// line cycle within one vscan state
                    VSTATE_CYCLE = 0x3,
                    /// frame counter
                    FRAME_CNT = 0x4,
                    /// frame cycle
                    FRAME_CYCLE = 0x5,
                    /// horizontal counter (pclk counter within one line )
                    HCNT = 0x6,
                    /// vertical counter (line counter within one frame)
                    VCNT = 0x7,
                    _,
                },
                /// When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
                MASK_CNT: u12,
                /// state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
                STATE_MASK: enum(u8) {
                    /// FRAME SYNC
                    FS = 0x1,
                    /// FRAME BEGIN
                    FB = 0x2,
                    /// FRAME DATA
                    FD = 0x4,
                    /// FRAME END
                    FE = 0x8,
                    /// LINE SYNC
                    LS = 0x10,
                    /// LINE BEGIN
                    LB = 0x20,
                    /// LINE DATA
                    LD = 0x40,
                    /// LINE END
                    LE = 0x80,
                    _,
                },
            }),
            reserved2704: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_10_1: mmio.Mmio(packed struct(u32) {
                /// Assert signal output when counter match this value
                SET_CNT: enum(u16) {
                    /// Start as active
                    START_ACTIVE = 0x0,
                    _,
                },
                /// Deassert signal output when counter match this value
                CLR_CNT: enum(u16) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
            }),
            reserved2720: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_10_2: mmio.Mmio(packed struct(u32) {
                /// Logic operation with another signal: DIS/AND/OR/COND
                SIG_LOGIC: enum(u4) {
                    /// No logic operation
                    DIS = 0x0,
                    /// sigout = sig_another AND this_sig
                    AND = 0x1,
                    /// sigout = sig_another OR this_sig
                    OR = 0x2,
                    /// mask = sig_another AND other_masks
                    MASK = 0x3,
                    _,
                },
                /// Select another signal for logic operation or as mask or counter tick event
                SIG_ANOTHER: enum(u5) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
                padding: u23 = 0,
            }),
            reserved2752: [28]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_11_0: mmio.Mmio(packed struct(u32) {
                /// Enable pigeon Mode on this signal
                EN: u1,
                /// Polarity of signal output
                POL: enum(u1) {
                    /// Normal Signal (Active high)
                    ACTIVE_HIGH = 0x0,
                    /// Inverted signal (Active low)
                    ACTIVE_LOW = 0x1,
                },
                /// Event to incrment local counter
                INC_SEL: enum(u2) {
                    /// pclk
                    PCLK = 0x0,
                    /// Line start pulse
                    LINE = 0x1,
                    /// Frame start pulse
                    FRAME = 0x2,
                    /// Use another signal as tick event
                    SIG_ANOTHER = 0x3,
                },
                /// offset on pclk unit
                OFFSET: u4,
                /// select global counters as mask condition, use together with MASK_CNT
                MASK_CNT_SEL: enum(u4) {
                    /// pclk counter within one hscan state
                    HSTATE_CNT = 0x0,
                    /// pclk cycle within one hscan state
                    HSTATE_CYCLE = 0x1,
                    /// line counter within one vscan state
                    VSTATE_CNT = 0x2,
                    /// line cycle within one vscan state
                    VSTATE_CYCLE = 0x3,
                    /// frame counter
                    FRAME_CNT = 0x4,
                    /// frame cycle
                    FRAME_CYCLE = 0x5,
                    /// horizontal counter (pclk counter within one line )
                    HCNT = 0x6,
                    /// vertical counter (line counter within one frame)
                    VCNT = 0x7,
                    _,
                },
                /// When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking
                MASK_CNT: u12,
                /// state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking
                STATE_MASK: enum(u8) {
                    /// FRAME SYNC
                    FS = 0x1,
                    /// FRAME BEGIN
                    FB = 0x2,
                    /// FRAME DATA
                    FD = 0x4,
                    /// FRAME END
                    FE = 0x8,
                    /// LINE SYNC
                    LS = 0x10,
                    /// LINE BEGIN
                    LB = 0x20,
                    /// LINE DATA
                    LD = 0x40,
                    /// LINE END
                    LE = 0x80,
                    _,
                },
            }),
            reserved2768: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_11_1: mmio.Mmio(packed struct(u32) {
                /// Assert signal output when counter match this value
                SET_CNT: enum(u16) {
                    /// Start as active
                    START_ACTIVE = 0x0,
                    _,
                },
                /// Deassert signal output when counter match this value
                CLR_CNT: enum(u16) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
            }),
            reserved2784: [12]u8,
            /// Panel Interface Signal Generator Register
            PIGEON_11_2: mmio.Mmio(packed struct(u32) {
                /// Logic operation with another signal: DIS/AND/OR/COND
                SIG_LOGIC: enum(u4) {
                    /// No logic operation
                    DIS = 0x0,
                    /// sigout = sig_another AND this_sig
                    AND = 0x1,
                    /// sigout = sig_another OR this_sig
                    OR = 0x2,
                    /// mask = sig_another AND other_masks
                    MASK = 0x3,
                    _,
                },
                /// Select another signal for logic operation or as mask or counter tick event
                SIG_ANOTHER: enum(u5) {
                    /// Keep active until mask off
                    CLEAR_USING_MASK = 0x0,
                    _,
                },
                padding: u23 = 0,
            }),
            reserved2816: [28]u8,
            /// Lookup Table Data Register.
            LUT_CTRL: mmio.Mmio(packed struct(u32) {
                /// Setting this bit will bypass the LUT memory resource completely
                LUT_BYPASS: u1,
                padding: u31 = 0,
            }),
            reserved2832: [12]u8,
            /// Lookup Table Control Register.
            LUT0_ADDR: mmio.Mmio(packed struct(u32) {
                /// LUT indexed address pointer
                ADDR: u8,
                padding: u24 = 0,
            }),
            reserved2848: [12]u8,
            /// Lookup Table Data Register.
            LUT0_DATA: mmio.Mmio(packed struct(u32) {
                /// Writing this field will load 4 bytes, aligned to four byte boundaries, of data indexed by the ADDR field of the REG_LUT_CTRL register
                DATA: u32,
            }),
            reserved2864: [12]u8,
            /// Lookup Table Control Register.
            LUT1_ADDR: mmio.Mmio(packed struct(u32) {
                /// LUT indexed address pointer
                ADDR: u8,
                padding: u24 = 0,
            }),
            reserved2880: [12]u8,
            /// Lookup Table Data Register.
            LUT1_DATA: mmio.Mmio(packed struct(u32) {
                /// Writing this field will load 4 bytes, aligned to four byte boundaries, of data indexed by the ADDR field of the REG_LUT_CTRL register
                DATA: u32,
            }),
        };

        /// LPI2C
        pub const LPI2C1 = extern struct {
            /// Version ID Register
            VERID: mmio.Mmio(packed struct(u32) {
                /// Feature Specification Number
                FEATURE: enum(u16) {
                    /// Master only, with standard feature set
                    FEATURE_2 = 0x2,
                    /// Master and slave, with standard feature set
                    FEATURE_3 = 0x3,
                    _,
                },
                /// Minor Version Number
                MINOR: u8,
                /// Major Version Number
                MAJOR: u8,
            }),
            /// Parameter Register
            PARAM: mmio.Mmio(packed struct(u32) {
                /// Master Transmit FIFO Size
                MTXFIFO: u4,
                reserved8: u4 = 0,
                /// Master Receive FIFO Size
                MRXFIFO: u4,
                padding: u20 = 0,
            }),
            reserved16: [8]u8,
            /// Master Control Register
            MCR: mmio.Mmio(packed struct(u32) {
                /// Master Enable
                MEN: enum(u1) {
                    /// Master logic is disabled
                    MEN_0 = 0x0,
                    /// Master logic is enabled
                    MEN_1 = 0x1,
                },
                /// Software Reset
                RST: enum(u1) {
                    /// Master logic is not reset
                    RST_0 = 0x0,
                    /// Master logic is reset
                    RST_1 = 0x1,
                },
                /// Doze mode enable
                DOZEN: enum(u1) {
                    /// Master is enabled in Doze mode
                    DOZEN_0 = 0x0,
                    /// Master is disabled in Doze mode
                    DOZEN_1 = 0x1,
                },
                /// Debug Enable
                DBGEN: enum(u1) {
                    /// Master is disabled in debug mode
                    DBGEN_0 = 0x0,
                    /// Master is enabled in debug mode
                    DBGEN_1 = 0x1,
                },
                reserved8: u4 = 0,
                /// Reset Transmit FIFO
                RTF: enum(u1) {
                    /// No effect
                    RTF_0 = 0x0,
                    /// Transmit FIFO is reset
                    RTF_1 = 0x1,
                },
                /// Reset Receive FIFO
                RRF: enum(u1) {
                    /// No effect
                    RRF_0 = 0x0,
                    /// Receive FIFO is reset
                    RRF_1 = 0x1,
                },
                padding: u22 = 0,
            }),
            /// Master Status Register
            MSR: mmio.Mmio(packed struct(u32) {
                /// Transmit Data Flag
                TDF: enum(u1) {
                    /// Transmit data is not requested
                    TDF_0 = 0x0,
                    /// Transmit data is requested
                    TDF_1 = 0x1,
                },
                /// Receive Data Flag
                RDF: enum(u1) {
                    /// Receive Data is not ready
                    RDF_0 = 0x0,
                    /// Receive data is ready
                    RDF_1 = 0x1,
                },
                reserved8: u6 = 0,
                /// End Packet Flag
                EPF: enum(u1) {
                    /// Master has not generated a STOP or Repeated START condition
                    EPF_0 = 0x0,
                    /// Master has generated a STOP or Repeated START condition
                    EPF_1 = 0x1,
                },
                /// STOP Detect Flag
                SDF: enum(u1) {
                    /// Master has not generated a STOP condition
                    SDF_0 = 0x0,
                    /// Master has generated a STOP condition
                    SDF_1 = 0x1,
                },
                /// NACK Detect Flag
                NDF: enum(u1) {
                    /// Unexpected NACK was not detected
                    NDF_0 = 0x0,
                    /// Unexpected NACK was detected
                    NDF_1 = 0x1,
                },
                /// Arbitration Lost Flag
                ALF: enum(u1) {
                    /// Master has not lost arbitration
                    ALF_0 = 0x0,
                    /// Master has lost arbitration
                    ALF_1 = 0x1,
                },
                /// FIFO Error Flag
                FEF: enum(u1) {
                    /// No error
                    FEF_0 = 0x0,
                    /// Master sending or receiving data without a START condition
                    FEF_1 = 0x1,
                },
                /// Pin Low Timeout Flag
                PLTF: enum(u1) {
                    /// Pin low timeout has not occurred or is disabled
                    PLTF_0 = 0x0,
                    /// Pin low timeout has occurred
                    PLTF_1 = 0x1,
                },
                /// Data Match Flag
                DMF: enum(u1) {
                    /// Have not received matching data
                    DMF_0 = 0x0,
                    /// Have received matching data
                    DMF_1 = 0x1,
                },
                reserved24: u9 = 0,
                /// Master Busy Flag
                MBF: enum(u1) {
                    /// I2C Master is idle
                    MBF_0 = 0x0,
                    /// I2C Master is busy
                    MBF_1 = 0x1,
                },
                /// Bus Busy Flag
                BBF: enum(u1) {
                    /// I2C Bus is idle
                    BBF_0 = 0x0,
                    /// I2C Bus is busy
                    BBF_1 = 0x1,
                },
                padding: u6 = 0,
            }),
            /// Master Interrupt Enable Register
            MIER: mmio.Mmio(packed struct(u32) {
                /// Transmit Data Interrupt Enable
                TDIE: enum(u1) {
                    /// Disabled
                    TDIE_0 = 0x0,
                    /// Enabled
                    TDIE_1 = 0x1,
                },
                /// Receive Data Interrupt Enable
                RDIE: enum(u1) {
                    /// Disabled
                    RDIE_0 = 0x0,
                    /// Enabled
                    RDIE_1 = 0x1,
                },
                reserved8: u6 = 0,
                /// End Packet Interrupt Enable
                EPIE: enum(u1) {
                    /// Disabled
                    EPIE_0 = 0x0,
                    /// Enabled
                    EPIE_1 = 0x1,
                },
                /// STOP Detect Interrupt Enable
                SDIE: enum(u1) {
                    /// Disabled
                    SDIE_0 = 0x0,
                    /// Enabled
                    SDIE_1 = 0x1,
                },
                /// NACK Detect Interrupt Enable
                NDIE: enum(u1) {
                    /// Disabled
                    NDIE_0 = 0x0,
                    /// Enabled
                    NDIE_1 = 0x1,
                },
                /// Arbitration Lost Interrupt Enable
                ALIE: enum(u1) {
                    /// Disabled
                    ALIE_0 = 0x0,
                    /// Enabled
                    ALIE_1 = 0x1,
                },
                /// FIFO Error Interrupt Enable
                FEIE: enum(u1) {
                    /// Enabled
                    FEIE_0 = 0x0,
                    /// Disabled
                    FEIE_1 = 0x1,
                },
                /// Pin Low Timeout Interrupt Enable
                PLTIE: enum(u1) {
                    /// Disabled
                    PLTIE_0 = 0x0,
                    /// Enabled
                    PLTIE_1 = 0x1,
                },
                /// Data Match Interrupt Enable
                DMIE: enum(u1) {
                    /// Disabled
                    DMIE_0 = 0x0,
                    /// Enabled
                    DMIE_1 = 0x1,
                },
                padding: u17 = 0,
            }),
            /// Master DMA Enable Register
            MDER: mmio.Mmio(packed struct(u32) {
                /// Transmit Data DMA Enable
                TDDE: enum(u1) {
                    /// DMA request is disabled
                    TDDE_0 = 0x0,
                    /// DMA request is enabled
                    TDDE_1 = 0x1,
                },
                /// Receive Data DMA Enable
                RDDE: enum(u1) {
                    /// DMA request is disabled
                    RDDE_0 = 0x0,
                    /// DMA request is enabled
                    RDDE_1 = 0x1,
                },
                padding: u30 = 0,
            }),
            /// Master Configuration Register 0
            MCFGR0: mmio.Mmio(packed struct(u32) {
                /// Host Request Enable
                HREN: enum(u1) {
                    /// Host request input is disabled
                    HREN_0 = 0x0,
                    /// Host request input is enabled
                    HREN_1 = 0x1,
                },
                /// Host Request Polarity
                HRPOL: enum(u1) {
                    /// Active low
                    HRPOL_0 = 0x0,
                    /// Active high
                    HRPOL_1 = 0x1,
                },
                /// Host Request Select
                HRSEL: enum(u1) {
                    /// Host request input is pin HREQ
                    HRSEL_0 = 0x0,
                    /// Host request input is input trigger
                    HRSEL_1 = 0x1,
                },
                reserved8: u5 = 0,
                /// Circular FIFO Enable
                CIRFIFO: enum(u1) {
                    /// Circular FIFO is disabled
                    CIRFIFO_0 = 0x0,
                    /// Circular FIFO is enabled
                    CIRFIFO_1 = 0x1,
                },
                /// Receive Data Match Only
                RDMO: enum(u1) {
                    /// Received data is stored in the receive FIFO
                    RDMO_0 = 0x0,
                    /// Received data is discarded unless the the Data Match Flag (MSR[DMF]) is set
                    RDMO_1 = 0x1,
                },
                padding: u22 = 0,
            }),
            /// Master Configuration Register 1
            MCFGR1: mmio.Mmio(packed struct(u32) {
                /// Prescaler
                PRESCALE: enum(u3) {
                    /// Divide by 1
                    PRESCALE_0 = 0x0,
                    /// Divide by 2
                    PRESCALE_1 = 0x1,
                    /// Divide by 4
                    PRESCALE_2 = 0x2,
                    /// Divide by 8
                    PRESCALE_3 = 0x3,
                    /// Divide by 16
                    PRESCALE_4 = 0x4,
                    /// Divide by 32
                    PRESCALE_5 = 0x5,
                    /// Divide by 64
                    PRESCALE_6 = 0x6,
                    /// Divide by 128
                    PRESCALE_7 = 0x7,
                },
                reserved8: u5 = 0,
                /// Automatic STOP Generation
                AUTOSTOP: enum(u1) {
                    /// No effect
                    AUTOSTOP_0 = 0x0,
                    /// STOP condition is automatically generated whenever the transmit FIFO is empty and the LPI2C master is busy
                    AUTOSTOP_1 = 0x1,
                },
                /// IGNACK
                IGNACK: enum(u1) {
                    /// LPI2C Master will receive ACK and NACK normally
                    IGNACK_0 = 0x0,
                    /// LPI2C Master will treat a received NACK as if it (NACK) was an ACK
                    IGNACK_1 = 0x1,
                },
                /// Timeout Configuration
                TIMECFG: enum(u1) {
                    /// Pin Low Timeout Flag will set if SCL is low for longer than the configured timeout
                    TIMECFG_0 = 0x0,
                    /// Pin Low Timeout Flag will set if either SCL or SDA is low for longer than the configured timeout
                    TIMECFG_1 = 0x1,
                },
                reserved16: u5 = 0,
                /// Match Configuration
                MATCFG: enum(u3) {
                    /// Match is disabled
                    MATCFG_0 = 0x0,
                    /// Match is enabled (1st data word equals MATCH0 OR MATCH1)
                    MATCFG_2 = 0x2,
                    /// Match is enabled (any data word equals MATCH0 OR MATCH1)
                    MATCFG_3 = 0x3,
                    /// Match is enabled (1st data word equals MATCH0 AND 2nd data word equals MATCH1)
                    MATCFG_4 = 0x4,
                    /// Match is enabled (any data word equals MATCH0 AND next data word equals MATCH1)
                    MATCFG_5 = 0x5,
                    /// Match is enabled (1st data word AND MATCH1 equals MATCH0 AND MATCH1)
                    MATCFG_6 = 0x6,
                    /// Match is enabled (any data word AND MATCH1 equals MATCH0 AND MATCH1)
                    MATCFG_7 = 0x7,
                    _,
                },
                reserved24: u5 = 0,
                /// Pin Configuration
                PINCFG: enum(u3) {
                    /// 2-pin open drain mode
                    PINCFG_0 = 0x0,
                    /// 2-pin output only mode (ultra-fast mode)
                    PINCFG_1 = 0x1,
                    /// 2-pin push-pull mode
                    PINCFG_2 = 0x2,
                    /// 4-pin push-pull mode
                    PINCFG_3 = 0x3,
                    /// 2-pin open drain mode with separate LPI2C slave
                    PINCFG_4 = 0x4,
                    /// 2-pin output only mode (ultra-fast mode) with separate LPI2C slave
                    PINCFG_5 = 0x5,
                    /// 2-pin push-pull mode with separate LPI2C slave
                    PINCFG_6 = 0x6,
                    /// 4-pin push-pull mode (inverted outputs)
                    PINCFG_7 = 0x7,
                },
                padding: u5 = 0,
            }),
            /// Master Configuration Register 2
            MCFGR2: mmio.Mmio(packed struct(u32) {
                /// Bus Idle Timeout
                BUSIDLE: u12,
                reserved16: u4 = 0,
                /// Glitch Filter SCL
                FILTSCL: u4,
                reserved24: u4 = 0,
                /// Glitch Filter SDA
                FILTSDA: u4,
                padding: u4 = 0,
            }),
            /// Master Configuration Register 3
            MCFGR3: mmio.Mmio(packed struct(u32) {
                reserved8: u8 = 0,
                /// Pin Low Timeout
                PINLOW: u12,
                padding: u12 = 0,
            }),
            reserved64: [16]u8,
            /// Master Data Match Register
            MDMR: mmio.Mmio(packed struct(u32) {
                /// Match 0 Value
                MATCH0: u8,
                reserved16: u8 = 0,
                /// Match 1 Value
                MATCH1: u8,
                padding: u8 = 0,
            }),
            reserved72: [4]u8,
            /// Master Clock Configuration Register 0
            MCCR0: mmio.Mmio(packed struct(u32) {
                /// Clock Low Period
                CLKLO: u6,
                reserved8: u2 = 0,
                /// Clock High Period
                CLKHI: u6,
                reserved16: u2 = 0,
                /// Setup Hold Delay
                SETHOLD: u6,
                reserved24: u2 = 0,
                /// Data Valid Delay
                DATAVD: u6,
                padding: u2 = 0,
            }),
            reserved80: [4]u8,
            /// Master Clock Configuration Register 1
            MCCR1: mmio.Mmio(packed struct(u32) {
                /// Clock Low Period
                CLKLO: u6,
                reserved8: u2 = 0,
                /// Clock High Period
                CLKHI: u6,
                reserved16: u2 = 0,
                /// Setup Hold Delay
                SETHOLD: u6,
                reserved24: u2 = 0,
                /// Data Valid Delay
                DATAVD: u6,
                padding: u2 = 0,
            }),
            reserved88: [4]u8,
            /// Master FIFO Control Register
            MFCR: mmio.Mmio(packed struct(u32) {
                /// Transmit FIFO Watermark
                TXWATER: u2,
                reserved16: u14 = 0,
                /// Receive FIFO Watermark
                RXWATER: u2,
                padding: u14 = 0,
            }),
            /// Master FIFO Status Register
            MFSR: mmio.Mmio(packed struct(u32) {
                /// Transmit FIFO Count
                TXCOUNT: u3,
                reserved16: u13 = 0,
                /// Receive FIFO Count
                RXCOUNT: u3,
                padding: u13 = 0,
            }),
            /// Master Transmit Data Register
            MTDR: mmio.Mmio(packed struct(u32) {
                /// Transmit Data
                DATA: u8,
                /// Command Data
                CMD: enum(u3) {
                    /// Transmit DATA[7:0]
                    CMD_0 = 0x0,
                    /// Receive (DATA[7:0] + 1) bytes
                    CMD_1 = 0x1,
                    /// Generate STOP condition
                    CMD_2 = 0x2,
                    /// Receive and discard (DATA[7:0] + 1) bytes
                    CMD_3 = 0x3,
                    /// Generate (repeated) START and transmit address in DATA[7:0]
                    CMD_4 = 0x4,
                    /// Generate (repeated) START and transmit address in DATA[7:0]. This transfer expects a NACK to be returned.
                    CMD_5 = 0x5,
                    /// Generate (repeated) START and transmit address in DATA[7:0] using high speed mode
                    CMD_6 = 0x6,
                    /// Generate (repeated) START and transmit address in DATA[7:0] using high speed mode. This transfer expects a NACK to be returned.
                    CMD_7 = 0x7,
                },
                padding: u21 = 0,
            }),
            reserved112: [12]u8,
            /// Master Receive Data Register
            MRDR: mmio.Mmio(packed struct(u32) {
                /// Receive Data
                DATA: u8,
                reserved14: u6 = 0,
                /// RX Empty
                RXEMPTY: enum(u1) {
                    /// Receive FIFO is not empty
                    RXEMPTY_0 = 0x0,
                    /// Receive FIFO is empty
                    RXEMPTY_1 = 0x1,
                },
                padding: u17 = 0,
            }),
            reserved272: [156]u8,
            /// Slave Control Register
            SCR: mmio.Mmio(packed struct(u32) {
                /// Slave Enable
                SEN: enum(u1) {
                    /// I2C Slave mode is disabled
                    SEN_0 = 0x0,
                    /// I2C Slave mode is enabled
                    SEN_1 = 0x1,
                },
                /// Software Reset
                RST: enum(u1) {
                    /// Slave mode logic is not reset
                    RST_0 = 0x0,
                    /// Slave mode logic is reset
                    RST_1 = 0x1,
                },
                reserved4: u2 = 0,
                /// Filter Enable
                FILTEN: enum(u1) {
                    /// Disable digital filter and output delay counter for slave mode
                    FILTEN_0 = 0x0,
                    /// Enable digital filter and output delay counter for slave mode
                    FILTEN_1 = 0x1,
                },
                /// Filter Doze Enable
                FILTDZ: enum(u1) {
                    /// Filter remains enabled in Doze mode
                    FILTDZ_0 = 0x0,
                    /// Filter is disabled in Doze mode
                    FILTDZ_1 = 0x1,
                },
                reserved8: u2 = 0,
                /// Reset Transmit FIFO
                RTF: enum(u1) {
                    /// No effect
                    RTF_0 = 0x0,
                    /// Transmit Data Register is now empty
                    RTF_1 = 0x1,
                },
                /// Reset Receive FIFO
                RRF: enum(u1) {
                    /// No effect
                    RRF_0 = 0x0,
                    /// Receive Data Register is now empty
                    RRF_1 = 0x1,
                },
                padding: u22 = 0,
            }),
            /// Slave Status Register
            SSR: mmio.Mmio(packed struct(u32) {
                /// Transmit Data Flag
                TDF: enum(u1) {
                    /// Transmit data not requested
                    TDF_0 = 0x0,
                    /// Transmit data is requested
                    TDF_1 = 0x1,
                },
                /// Receive Data Flag
                RDF: enum(u1) {
                    /// Receive data is not ready
                    RDF_0 = 0x0,
                    /// Receive data is ready
                    RDF_1 = 0x1,
                },
                /// Address Valid Flag
                AVF: enum(u1) {
                    /// Address Status Register is not valid
                    AVF_0 = 0x0,
                    /// Address Status Register is valid
                    AVF_1 = 0x1,
                },
                /// Transmit ACK Flag
                TAF: enum(u1) {
                    /// Transmit ACK/NACK is not required
                    TAF_0 = 0x0,
                    /// Transmit ACK/NACK is required
                    TAF_1 = 0x1,
                },
                reserved8: u4 = 0,
                /// Repeated Start Flag
                RSF: enum(u1) {
                    /// Slave has not detected a Repeated START condition
                    RSF_0 = 0x0,
                    /// Slave has detected a Repeated START condition
                    RSF_1 = 0x1,
                },
                /// STOP Detect Flag
                SDF: enum(u1) {
                    /// Slave has not detected a STOP condition
                    SDF_0 = 0x0,
                    /// Slave has detected a STOP condition
                    SDF_1 = 0x1,
                },
                /// Bit Error Flag
                BEF: enum(u1) {
                    /// Slave has not detected a bit error
                    BEF_0 = 0x0,
                    /// Slave has detected a bit error
                    BEF_1 = 0x1,
                },
                /// FIFO Error Flag
                FEF: enum(u1) {
                    /// FIFO underflow or overflow was not detected
                    FEF_0 = 0x0,
                    /// FIFO underflow or overflow was detected
                    FEF_1 = 0x1,
                },
                /// Address Match 0 Flag
                AM0F: enum(u1) {
                    /// Have not received an ADDR0 matching address
                    AM0F_0 = 0x0,
                    /// Have received an ADDR0 matching address
                    AM0F_1 = 0x1,
                },
                /// Address Match 1 Flag
                AM1F: enum(u1) {
                    /// Have not received an ADDR1 or ADDR0/ADDR1 range matching address
                    AM1F_0 = 0x0,
                    /// Have received an ADDR1 or ADDR0/ADDR1 range matching address
                    AM1F_1 = 0x1,
                },
                /// General Call Flag
                GCF: enum(u1) {
                    /// Slave has not detected the General Call Address or the General Call Address is disabled
                    GCF_0 = 0x0,
                    /// Slave has detected the General Call Address
                    GCF_1 = 0x1,
                },
                /// SMBus Alert Response Flag
                SARF: enum(u1) {
                    /// SMBus Alert Response is disabled or not detected
                    SARF_0 = 0x0,
                    /// SMBus Alert Response is enabled and detected
                    SARF_1 = 0x1,
                },
                reserved24: u8 = 0,
                /// Slave Busy Flag
                SBF: enum(u1) {
                    /// I2C Slave is idle
                    SBF_0 = 0x0,
                    /// I2C Slave is busy
                    SBF_1 = 0x1,
                },
                /// Bus Busy Flag
                BBF: enum(u1) {
                    /// I2C Bus is idle
                    BBF_0 = 0x0,
                    /// I2C Bus is busy
                    BBF_1 = 0x1,
                },
                padding: u6 = 0,
            }),
            /// Slave Interrupt Enable Register
            SIER: mmio.Mmio(packed struct(u32) {
                /// Transmit Data Interrupt Enable
                TDIE: enum(u1) {
                    /// Disabled
                    TDIE_0 = 0x0,
                    /// Enabled
                    TDIE_1 = 0x1,
                },
                /// Receive Data Interrupt Enable
                RDIE: enum(u1) {
                    /// Disabled
                    RDIE_0 = 0x0,
                    /// Enabled
                    RDIE_1 = 0x1,
                },
                /// Address Valid Interrupt Enable
                AVIE: enum(u1) {
                    /// Disabled
                    AVIE_0 = 0x0,
                    /// Enabled
                    AVIE_1 = 0x1,
                },
                /// Transmit ACK Interrupt Enable
                TAIE: enum(u1) {
                    /// Disabled
                    TAIE_0 = 0x0,
                    /// Enabled
                    TAIE_1 = 0x1,
                },
                reserved8: u4 = 0,
                /// Repeated Start Interrupt Enable
                RSIE: enum(u1) {
                    /// Disabled
                    RSIE_0 = 0x0,
                    /// Enabled
                    RSIE_1 = 0x1,
                },
                /// STOP Detect Interrupt Enable
                SDIE: enum(u1) {
                    /// Disabled
                    SDIE_0 = 0x0,
                    /// Enabled
                    SDIE_1 = 0x1,
                },
                /// Bit Error Interrupt Enable
                BEIE: enum(u1) {
                    /// Disabled
                    BEIE_0 = 0x0,
                    /// Enabled
                    BEIE_1 = 0x1,
                },
                /// FIFO Error Interrupt Enable
                FEIE: enum(u1) {
                    /// Disabled
                    FEIE_0 = 0x0,
                    /// Enabled
                    FEIE_1 = 0x1,
                },
                /// Address Match 0 Interrupt Enable
                AM0IE: enum(u1) {
                    /// Enabled
                    AM0IE_0 = 0x0,
                    /// Disabled
                    AM0IE_1 = 0x1,
                },
                /// Address Match 1 Interrupt Enable
                AM1F: enum(u1) {
                    /// Disabled
                    AM1F_0 = 0x0,
                    /// Enabled
                    AM1F_1 = 0x1,
                },
                /// General Call Interrupt Enable
                GCIE: enum(u1) {
                    /// Disabled
                    GCIE_0 = 0x0,
                    /// Enabled
                    GCIE_1 = 0x1,
                },
                /// SMBus Alert Response Interrupt Enable
                SARIE: enum(u1) {
                    /// Disabled
                    SARIE_0 = 0x0,
                    /// Enabled
                    SARIE_1 = 0x1,
                },
                padding: u16 = 0,
            }),
            /// Slave DMA Enable Register
            SDER: mmio.Mmio(packed struct(u32) {
                /// Transmit Data DMA Enable
                TDDE: enum(u1) {
                    /// DMA request is disabled
                    TDDE_0 = 0x0,
                    /// DMA request is enabled
                    TDDE_1 = 0x1,
                },
                /// Receive Data DMA Enable
                RDDE: enum(u1) {
                    /// DMA request is disabled
                    RDDE_0 = 0x0,
                    /// DMA request is enabled
                    RDDE_1 = 0x1,
                },
                /// Address Valid DMA Enable
                AVDE: enum(u1) {
                    /// DMA request is disabled
                    AVDE_0 = 0x0,
                    /// DMA request is enabled
                    AVDE_1 = 0x1,
                },
                padding: u29 = 0,
            }),
            reserved292: [4]u8,
            /// Slave Configuration Register 1
            SCFGR1: mmio.Mmio(packed struct(u32) {
                /// Address SCL Stall
                ADRSTALL: enum(u1) {
                    /// Clock stretching is disabled
                    ADRSTALL_0 = 0x0,
                    /// Clock stretching is enabled
                    ADRSTALL_1 = 0x1,
                },
                /// RX SCL Stall
                RXSTALL: enum(u1) {
                    /// Clock stretching is disabled
                    RXSTALL_0 = 0x0,
                    /// Clock stretching is enabled
                    RXSTALL_1 = 0x1,
                },
                /// TX Data SCL Stall
                TXDSTALL: enum(u1) {
                    /// Clock stretching is disabled
                    TXDSTALL_0 = 0x0,
                    /// Clock stretching is enabled
                    TXDSTALL_1 = 0x1,
                },
                /// ACK SCL Stall
                ACKSTALL: enum(u1) {
                    /// Clock stretching is disabled
                    ACKSTALL_0 = 0x0,
                    /// Clock stretching is enabled
                    ACKSTALL_1 = 0x1,
                },
                reserved8: u4 = 0,
                /// General Call Enable
                GCEN: enum(u1) {
                    /// General Call address is disabled
                    GCEN_0 = 0x0,
                    /// General Call address is enabled
                    GCEN_1 = 0x1,
                },
                /// SMBus Alert Enable
                SAEN: enum(u1) {
                    /// Disables match on SMBus Alert
                    SAEN_0 = 0x0,
                    /// Enables match on SMBus Alert
                    SAEN_1 = 0x1,
                },
                /// Transmit Flag Configuration
                TXCFG: enum(u1) {
                    /// Transmit Data Flag will only assert during a slave-transmit transfer when the Transmit Data register is empty
                    TXCFG_0 = 0x0,
                    /// Transmit Data Flag will assert whenever the Transmit Data register is empty
                    TXCFG_1 = 0x1,
                },
                /// Receive Data Configuration
                RXCFG: enum(u1) {
                    /// Reading the Receive Data register will return received data and clear the Receive Data flag (MSR[RDF]).
                    RXCFG_0 = 0x0,
                    /// Reading the Receive Data register when the Address Valid flag (SSR[AVF])is set, will return the Address Status register and clear the Address Valid flag. Reading the Receive Data register when the Address Valid flag is clear, will return received data and clear the Receive Data flag (MSR[RDF]).
                    RXCFG_1 = 0x1,
                },
                /// Ignore NACK
                IGNACK: enum(u1) {
                    /// Slave will end transfer when NACK is detected
                    IGNACK_0 = 0x0,
                    /// Slave will not end transfer when NACK detected
                    IGNACK_1 = 0x1,
                },
                /// High Speed Mode Enable
                HSMEN: enum(u1) {
                    /// Disables detection of HS-mode master code
                    HSMEN_0 = 0x0,
                    /// Enables detection of HS-mode master code
                    HSMEN_1 = 0x1,
                },
                reserved16: u2 = 0,
                /// Address Configuration
                ADDRCFG: enum(u3) {
                    /// Address match 0 (7-bit)
                    ADDRCFG_0 = 0x0,
                    /// Address match 0 (10-bit)
                    ADDRCFG_1 = 0x1,
                    /// Address match 0 (7-bit) or Address match 1 (7-bit)
                    ADDRCFG_2 = 0x2,
                    /// Address match 0 (10-bit) or Address match 1 (10-bit)
                    ADDRCFG_3 = 0x3,
                    /// Address match 0 (7-bit) or Address match 1 (10-bit)
                    ADDRCFG_4 = 0x4,
                    /// Address match 0 (10-bit) or Address match 1 (7-bit)
                    ADDRCFG_5 = 0x5,
                    /// From Address match 0 (7-bit) to Address match 1 (7-bit)
                    ADDRCFG_6 = 0x6,
                    /// From Address match 0 (10-bit) to Address match 1 (10-bit)
                    ADDRCFG_7 = 0x7,
                },
                padding: u13 = 0,
            }),
            /// Slave Configuration Register 2
            SCFGR2: mmio.Mmio(packed struct(u32) {
                /// Clock Hold Time
                CLKHOLD: u4,
                reserved8: u4 = 0,
                /// Data Valid Delay
                DATAVD: u6,
                reserved16: u2 = 0,
                /// Glitch Filter SCL
                FILTSCL: u4,
                reserved24: u4 = 0,
                /// Glitch Filter SDA
                FILTSDA: u4,
                padding: u4 = 0,
            }),
            reserved320: [20]u8,
            /// Slave Address Match Register
            SAMR: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// Address 0 Value
                ADDR0: u10,
                reserved17: u6 = 0,
                /// Address 1 Value
                ADDR1: u10,
                padding: u5 = 0,
            }),
            reserved336: [12]u8,
            /// Slave Address Status Register
            SASR: mmio.Mmio(packed struct(u32) {
                /// Received Address
                RADDR: u11,
                reserved14: u3 = 0,
                /// Address Not Valid
                ANV: enum(u1) {
                    /// Received Address (RADDR) is valid
                    ANV_0 = 0x0,
                    /// Received Address (RADDR) is not valid
                    ANV_1 = 0x1,
                },
                padding: u17 = 0,
            }),
            /// Slave Transmit ACK Register
            STAR: mmio.Mmio(packed struct(u32) {
                /// Transmit NACK
                TXNACK: enum(u1) {
                    /// Write a Transmit ACK for each received word
                    TXNACK_0 = 0x0,
                    /// Write a Transmit NACK for each received word
                    TXNACK_1 = 0x1,
                },
                padding: u31 = 0,
            }),
            reserved352: [8]u8,
            /// Slave Transmit Data Register
            STDR: mmio.Mmio(packed struct(u32) {
                /// Transmit Data
                DATA: u8,
                padding: u24 = 0,
            }),
            reserved368: [12]u8,
            /// Slave Receive Data Register
            SRDR: mmio.Mmio(packed struct(u32) {
                /// Receive Data
                DATA: u8,
                reserved14: u6 = 0,
                /// RX Empty
                RXEMPTY: enum(u1) {
                    /// The Receive Data Register is not empty
                    RXEMPTY_0 = 0x0,
                    /// The Receive Data Register is empty
                    RXEMPTY_1 = 0x1,
                },
                /// Start Of Frame
                SOF: enum(u1) {
                    /// Indicates this is not the first data word since a (repeated) START or STOP condition
                    SOF_0 = 0x0,
                    /// Indicates this is the first data word since a (repeated) START or STOP condition
                    SOF_1 = 0x1,
                },
                padding: u16 = 0,
            }),
        };

        /// LPSPI
        pub const LPSPI1 = extern struct {
            /// Version ID Register
            VERID: mmio.Mmio(packed struct(u32) {
                /// Module Identification Number
                FEATURE: enum(u16) {
                    /// Standard feature set supporting a 32-bit shift register.
                    FEATURE_4 = 0x4,
                    _,
                },
                /// Minor Version Number
                MINOR: u8,
                /// Major Version Number
                MAJOR: u8,
            }),
            /// Parameter Register
            PARAM: mmio.Mmio(packed struct(u32) {
                /// Transmit FIFO Size
                TXFIFO: u8,
                /// Receive FIFO Size
                RXFIFO: u8,
                /// PCS Number
                PCSNUM: u8,
                padding: u8 = 0,
            }),
            reserved16: [8]u8,
            /// Control Register
            CR: mmio.Mmio(packed struct(u32) {
                /// Module Enable
                MEN: enum(u1) {
                    /// Module is disabled
                    MEN_0 = 0x0,
                    /// Module is enabled
                    MEN_1 = 0x1,
                },
                /// Software Reset
                RST: enum(u1) {
                    /// Module is not reset
                    RST_0 = 0x0,
                    /// Module is reset
                    RST_1 = 0x1,
                },
                /// Doze mode enable
                DOZEN: enum(u1) {
                    /// Module is enabled in Doze mode
                    DOZEN_0 = 0x0,
                    /// Module is disabled in Doze mode
                    DOZEN_1 = 0x1,
                },
                /// Debug Enable
                DBGEN: enum(u1) {
                    /// Module is disabled in debug mode
                    DBGEN_0 = 0x0,
                    /// Module is enabled in debug mode
                    DBGEN_1 = 0x1,
                },
                reserved8: u4 = 0,
                /// Reset Transmit FIFO
                RTF: enum(u1) {
                    /// No effect
                    RTF_0 = 0x0,
                    /// Transmit FIFO is reset
                    RTF_1 = 0x1,
                },
                /// Reset Receive FIFO
                RRF: enum(u1) {
                    /// No effect
                    RRF_0 = 0x0,
                    /// Receive FIFO is reset
                    RRF_1 = 0x1,
                },
                padding: u22 = 0,
            }),
            /// Status Register
            SR: mmio.Mmio(packed struct(u32) {
                /// Transmit Data Flag
                TDF: enum(u1) {
                    /// Transmit data not requested
                    TDF_0 = 0x0,
                    /// Transmit data is requested
                    TDF_1 = 0x1,
                },
                /// Receive Data Flag
                RDF: enum(u1) {
                    /// Receive Data is not ready
                    RDF_0 = 0x0,
                    /// Receive data is ready
                    RDF_1 = 0x1,
                },
                reserved8: u6 = 0,
                /// Word Complete Flag
                WCF: enum(u1) {
                    /// Transfer of a received word has not yet completed
                    WCF_0 = 0x0,
                    /// Transfer of a received word has completed
                    WCF_1 = 0x1,
                },
                /// Frame Complete Flag
                FCF: enum(u1) {
                    /// Frame transfer has not completed
                    FCF_0 = 0x0,
                    /// Frame transfer has completed
                    FCF_1 = 0x1,
                },
                /// Transfer Complete Flag
                TCF: enum(u1) {
                    /// All transfers have not completed
                    TCF_0 = 0x0,
                    /// All transfers have completed
                    TCF_1 = 0x1,
                },
                /// Transmit Error Flag
                TEF: enum(u1) {
                    /// Transmit FIFO underrun has not occurred
                    TEF_0 = 0x0,
                    /// Transmit FIFO underrun has occurred
                    TEF_1 = 0x1,
                },
                /// Receive Error Flag
                REF: enum(u1) {
                    /// Receive FIFO has not overflowed
                    REF_0 = 0x0,
                    /// Receive FIFO has overflowed
                    REF_1 = 0x1,
                },
                /// Data Match Flag
                DMF: enum(u1) {
                    /// Have not received matching data
                    DMF_0 = 0x0,
                    /// Have received matching data
                    DMF_1 = 0x1,
                },
                reserved24: u10 = 0,
                /// Module Busy Flag
                MBF: enum(u1) {
                    /// LPSPI is idle
                    MBF_0 = 0x0,
                    /// LPSPI is busy
                    MBF_1 = 0x1,
                },
                padding: u7 = 0,
            }),
            /// Interrupt Enable Register
            IER: mmio.Mmio(packed struct(u32) {
                /// Transmit Data Interrupt Enable
                TDIE: enum(u1) {
                    /// Disabled
                    TDIE_0 = 0x0,
                    /// Enabled
                    TDIE_1 = 0x1,
                },
                /// Receive Data Interrupt Enable
                RDIE: enum(u1) {
                    /// Disabled
                    RDIE_0 = 0x0,
                    /// Enabled
                    RDIE_1 = 0x1,
                },
                reserved8: u6 = 0,
                /// Word Complete Interrupt Enable
                WCIE: enum(u1) {
                    /// Disabled
                    WCIE_0 = 0x0,
                    /// Enabled
                    WCIE_1 = 0x1,
                },
                /// Frame Complete Interrupt Enable
                FCIE: enum(u1) {
                    /// Disabled
                    FCIE_0 = 0x0,
                    /// Enabled
                    FCIE_1 = 0x1,
                },
                /// Transfer Complete Interrupt Enable
                TCIE: enum(u1) {
                    /// Disabled
                    TCIE_0 = 0x0,
                    /// Enabled
                    TCIE_1 = 0x1,
                },
                /// Transmit Error Interrupt Enable
                TEIE: enum(u1) {
                    /// Disabled
                    TEIE_0 = 0x0,
                    /// Enabled
                    TEIE_1 = 0x1,
                },
                /// Receive Error Interrupt Enable
                REIE: enum(u1) {
                    /// Disabled
                    REIE_0 = 0x0,
                    /// Enabled
                    REIE_1 = 0x1,
                },
                /// Data Match Interrupt Enable
                DMIE: enum(u1) {
                    /// Disabled
                    DMIE_0 = 0x0,
                    /// Enabled
                    DMIE_1 = 0x1,
                },
                padding: u18 = 0,
            }),
            /// DMA Enable Register
            DER: mmio.Mmio(packed struct(u32) {
                /// Transmit Data DMA Enable
                TDDE: enum(u1) {
                    /// DMA request is disabled
                    TDDE_0 = 0x0,
                    /// DMA request is enabled
                    TDDE_1 = 0x1,
                },
                /// Receive Data DMA Enable
                RDDE: enum(u1) {
                    /// DMA request is disabled
                    RDDE_0 = 0x0,
                    /// DMA request is enabled
                    RDDE_1 = 0x1,
                },
                padding: u30 = 0,
            }),
            /// Configuration Register 0
            CFGR0: mmio.Mmio(packed struct(u32) {
                /// Host Request Enable
                HREN: enum(u1) {
                    /// Host request is disabled
                    HREN_0 = 0x0,
                    /// Host request is enabled
                    HREN_1 = 0x1,
                },
                /// Host Request Polarity
                HRPOL: enum(u1) {
                    /// Active low
                    HRPOL_0 = 0x0,
                    /// Active high
                    HRPOL_1 = 0x1,
                },
                /// Host Request Select
                HRSEL: enum(u1) {
                    /// Host request input is the LPSPI_HREQ pin
                    HRSEL_0 = 0x0,
                    /// Host request input is the input trigger
                    HRSEL_1 = 0x1,
                },
                reserved8: u5 = 0,
                /// Circular FIFO Enable
                CIRFIFO: enum(u1) {
                    /// Circular FIFO is disabled
                    CIRFIFO_0 = 0x0,
                    /// Circular FIFO is enabled
                    CIRFIFO_1 = 0x1,
                },
                /// Receive Data Match Only
                RDMO: enum(u1) {
                    /// Received data is stored in the receive FIFO as in normal operations
                    RDMO_0 = 0x0,
                    /// Received data is discarded unless the Data Match Flag (DMF) is set
                    RDMO_1 = 0x1,
                },
                padding: u22 = 0,
            }),
            /// Configuration Register 1
            CFGR1: mmio.Mmio(packed struct(u32) {
                /// Master Mode
                MASTER: enum(u1) {
                    /// Slave mode
                    MASTER_0 = 0x0,
                    /// Master mode
                    MASTER_1 = 0x1,
                },
                /// Sample Point
                SAMPLE: enum(u1) {
                    /// Input data is sampled on SCK edge
                    SAMPLE_0 = 0x0,
                    /// Input data is sampled on delayed SCK edge
                    SAMPLE_1 = 0x1,
                },
                /// Automatic PCS
                AUTOPCS: enum(u1) {
                    /// Automatic PCS generation is disabled
                    AUTOPCS_0 = 0x0,
                    /// Automatic PCS generation is enabled
                    AUTOPCS_1 = 0x1,
                },
                /// No Stall
                NOSTALL: enum(u1) {
                    /// Transfers will stall when the transmit FIFO is empty or the receive FIFO is full
                    NOSTALL_0 = 0x0,
                    /// Transfers will not stall, allowing transmit FIFO underruns or receive FIFO overruns to occur
                    NOSTALL_1 = 0x1,
                },
                reserved8: u4 = 0,
                /// Peripheral Chip Select Polarity
                PCSPOL: enum(u4) {
                    /// The Peripheral Chip Select pin PCSx is active low
                    PCSPOL_0 = 0x0,
                    /// The Peripheral Chip Select pin PCSx is active high
                    PCSPOL_1 = 0x1,
                    _,
                },
                reserved16: u4 = 0,
                /// Match Configuration
                MATCFG: enum(u3) {
                    /// Match is disabled
                    MATCFG_0 = 0x0,
                    /// 010b - Match is enabled, if 1st data word equals MATCH0 OR MATCH1, i.e., (1st data word = MATCH0 + MATCH1)
                    MATCFG_2 = 0x2,
                    /// 011b - Match is enabled, if any data word equals MATCH0 OR MATCH1, i.e., (any data word = MATCH0 + MATCH1)
                    MATCFG_3 = 0x3,
                    /// 100b - Match is enabled, if 1st data word equals MATCH0 AND 2nd data word equals MATCH1, i.e., [(1st data word = MATCH0) * (2nd data word = MATCH1)]
                    MATCFG_4 = 0x4,
                    /// 101b - Match is enabled, if any data word equals MATCH0 AND the next data word equals MATCH1, i.e., [(any data word = MATCH0) * (next data word = MATCH1)]
                    MATCFG_5 = 0x5,
                    /// 110b - Match is enabled, if (1st data word AND MATCH1) equals (MATCH0 AND MATCH1), i.e., [(1st data word * MATCH1) = (MATCH0 * MATCH1)]
                    MATCFG_6 = 0x6,
                    /// 111b - Match is enabled, if (any data word AND MATCH1) equals (MATCH0 AND MATCH1), i.e., [(any data word * MATCH1) = (MATCH0 * MATCH1)]
                    MATCFG_7 = 0x7,
                    _,
                },
                reserved24: u5 = 0,
                /// Pin Configuration
                PINCFG: enum(u2) {
                    /// SIN is used for input data and SOUT is used for output data
                    PINCFG_0 = 0x0,
                    /// SIN is used for both input and output data
                    PINCFG_1 = 0x1,
                    /// SOUT is used for both input and output data
                    PINCFG_2 = 0x2,
                    /// SOUT is used for input data and SIN is used for output data
                    PINCFG_3 = 0x3,
                },
                /// Output Config
                OUTCFG: enum(u1) {
                    /// Output data retains last value when chip select is negated
                    OUTCFG_0 = 0x0,
                    /// Output data is tristated when chip select is negated
                    OUTCFG_1 = 0x1,
                },
                /// Peripheral Chip Select Configuration
                PCSCFG: enum(u1) {
                    /// PCS[3:2] are enabled
                    PCSCFG_0 = 0x0,
                    /// PCS[3:2] are disabled
                    PCSCFG_1 = 0x1,
                },
                padding: u4 = 0,
            }),
            reserved48: [8]u8,
            /// Data Match Register 0
            DMR0: mmio.Mmio(packed struct(u32) {
                /// Match 0 Value
                MATCH0: u32,
            }),
            /// Data Match Register 1
            DMR1: mmio.Mmio(packed struct(u32) {
                /// Match 1 Value
                MATCH1: u32,
            }),
            reserved64: [8]u8,
            /// Clock Configuration Register
            CCR: mmio.Mmio(packed struct(u32) {
                /// SCK Divider
                SCKDIV: u8,
                /// Delay Between Transfers
                DBT: u8,
                /// PCS-to-SCK Delay
                PCSSCK: u8,
                /// SCK-to-PCS Delay
                SCKPCS: u8,
            }),
            reserved88: [20]u8,
            /// FIFO Control Register
            FCR: mmio.Mmio(packed struct(u32) {
                /// Transmit FIFO Watermark
                TXWATER: u4,
                reserved16: u12 = 0,
                /// Receive FIFO Watermark
                RXWATER: u4,
                padding: u12 = 0,
            }),
            /// FIFO Status Register
            FSR: mmio.Mmio(packed struct(u32) {
                /// Transmit FIFO Count
                TXCOUNT: u5,
                reserved16: u11 = 0,
                /// Receive FIFO Count
                RXCOUNT: u5,
                padding: u11 = 0,
            }),
            /// Transmit Command Register
            TCR: mmio.Mmio(packed struct(u32) {
                /// Frame Size
                FRAMESZ: u12,
                reserved16: u4 = 0,
                /// Transfer Width
                WIDTH: enum(u2) {
                    /// 1 bit transfer
                    WIDTH_0 = 0x0,
                    /// 2 bit transfer
                    WIDTH_1 = 0x1,
                    /// 4 bit transfer
                    WIDTH_2 = 0x2,
                    _,
                },
                /// Transmit Data Mask
                TXMSK: enum(u1) {
                    /// Normal transfer
                    TXMSK_0 = 0x0,
                    /// Mask transmit data
                    TXMSK_1 = 0x1,
                },
                /// Receive Data Mask
                RXMSK: enum(u1) {
                    /// Normal transfer
                    RXMSK_0 = 0x0,
                    /// Receive data is masked
                    RXMSK_1 = 0x1,
                },
                /// Continuing Command
                CONTC: enum(u1) {
                    /// Command word for start of new transfer
                    CONTC_0 = 0x0,
                    /// Command word for continuing transfer
                    CONTC_1 = 0x1,
                },
                /// Continuous Transfer
                CONT: enum(u1) {
                    /// Continuous transfer is disabled
                    CONT_0 = 0x0,
                    /// Continuous transfer is enabled
                    CONT_1 = 0x1,
                },
                /// Byte Swap
                BYSW: enum(u1) {
                    /// Byte swap is disabled
                    BYSW_0 = 0x0,
                    /// Byte swap is enabled
                    BYSW_1 = 0x1,
                },
                /// LSB First
                LSBF: enum(u1) {
                    /// Data is transferred MSB first
                    LSBF_0 = 0x0,
                    /// Data is transferred LSB first
                    LSBF_1 = 0x1,
                },
                /// Peripheral Chip Select
                PCS: enum(u2) {
                    /// Transfer using LPSPI_PCS[0]
                    PCS_0 = 0x0,
                    /// Transfer using LPSPI_PCS[1]
                    PCS_1 = 0x1,
                    /// Transfer using LPSPI_PCS[2]
                    PCS_2 = 0x2,
                    /// Transfer using LPSPI_PCS[3]
                    PCS_3 = 0x3,
                },
                reserved27: u1 = 0,
                /// Prescaler Value
                PRESCALE: enum(u3) {
                    /// Divide by 1
                    PRESCALE_0 = 0x0,
                    /// Divide by 2
                    PRESCALE_1 = 0x1,
                    /// Divide by 4
                    PRESCALE_2 = 0x2,
                    /// Divide by 8
                    PRESCALE_3 = 0x3,
                    /// Divide by 16
                    PRESCALE_4 = 0x4,
                    /// Divide by 32
                    PRESCALE_5 = 0x5,
                    /// Divide by 64
                    PRESCALE_6 = 0x6,
                    /// Divide by 128
                    PRESCALE_7 = 0x7,
                },
                /// Clock Phase
                CPHA: enum(u1) {
                    /// Data is captured on the leading edge of SCK and changed on the following edge of SCK
                    CPHA_0 = 0x0,
                    /// Data is changed on the leading edge of SCK and captured on the following edge of SCK
                    CPHA_1 = 0x1,
                },
                /// Clock Polarity
                CPOL: enum(u1) {
                    /// The inactive state value of SCK is low
                    CPOL_0 = 0x0,
                    /// The inactive state value of SCK is high
                    CPOL_1 = 0x1,
                },
            }),
            /// Transmit Data Register
            TDR: mmio.Mmio(packed struct(u32) {
                /// Transmit Data
                DATA: u32,
            }),
            reserved112: [8]u8,
            /// Receive Status Register
            RSR: mmio.Mmio(packed struct(u32) {
                /// Start Of Frame
                SOF: enum(u1) {
                    /// Subsequent data word received after LPSPI_PCS assertion
                    SOF_0 = 0x0,
                    /// First data word received after LPSPI_PCS assertion
                    SOF_1 = 0x1,
                },
                /// RX FIFO Empty
                RXEMPTY: enum(u1) {
                    /// RX FIFO is not empty
                    RXEMPTY_0 = 0x0,
                    /// RX FIFO is empty
                    RXEMPTY_1 = 0x1,
                },
                padding: u30 = 0,
            }),
            /// Receive Data Register
            RDR: mmio.Mmio(packed struct(u32) {
                /// Receive Data
                DATA: u32,
            }),
        };

        /// LPUART
        pub const LPUART1 = extern struct {
            /// Version ID Register
            VERID: mmio.Mmio(packed struct(u32) {
                /// Feature Identification Number
                FEATURE: enum(u16) {
                    /// Standard feature set.
                    FEATURE_1 = 0x1,
                    /// Standard feature set with MODEM/IrDA support.
                    FEATURE_3 = 0x3,
                    _,
                },
                /// Minor Version Number
                MINOR: u8,
                /// Major Version Number
                MAJOR: u8,
            }),
            /// Parameter Register
            PARAM: mmio.Mmio(packed struct(u32) {
                /// Transmit FIFO Size
                TXFIFO: u8,
                /// Receive FIFO Size
                RXFIFO: u8,
                padding: u16 = 0,
            }),
            /// LPUART Global Register
            GLOBAL: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// Software Reset
                RST: enum(u1) {
                    /// Module is not reset.
                    RST_0 = 0x0,
                    /// Module is reset.
                    RST_1 = 0x1,
                },
                padding: u30 = 0,
            }),
            /// LPUART Pin Configuration Register
            PINCFG: mmio.Mmio(packed struct(u32) {
                /// Trigger Select
                TRGSEL: enum(u2) {
                    /// Input trigger is disabled.
                    TRGSEL_0 = 0x0,
                    /// Input trigger is used instead of RXD pin input.
                    TRGSEL_1 = 0x1,
                    /// Input trigger is used instead of CTS_B pin input.
                    TRGSEL_2 = 0x2,
                    /// Input trigger is used to modulate the TXD pin output. The TXD pin output (after TXINV configuration) is ANDed with the input trigger.
                    TRGSEL_3 = 0x3,
                },
                padding: u30 = 0,
            }),
            /// LPUART Baud Rate Register
            BAUD: mmio.Mmio(packed struct(u32) {
                /// Baud Rate Modulo Divisor.
                SBR: u13,
                /// Stop Bit Number Select
                SBNS: enum(u1) {
                    /// One stop bit.
                    SBNS_0 = 0x0,
                    /// Two stop bits.
                    SBNS_1 = 0x1,
                },
                /// RX Input Active Edge Interrupt Enable
                RXEDGIE: enum(u1) {
                    /// Hardware interrupts from STAT[RXEDGIF] are disabled.
                    RXEDGIE_0 = 0x0,
                    /// Hardware interrupt is requested when STAT[RXEDGIF] flag is 1.
                    RXEDGIE_1 = 0x1,
                },
                /// LIN Break Detect Interrupt Enable
                LBKDIE: enum(u1) {
                    /// Hardware interrupts from STAT[LBKDIF] flag are disabled (use polling).
                    LBKDIE_0 = 0x0,
                    /// Hardware interrupt requested when STAT[LBKDIF] flag is 1.
                    LBKDIE_1 = 0x1,
                },
                /// Resynchronization Disable
                RESYNCDIS: enum(u1) {
                    /// Resynchronization during received data word is supported
                    RESYNCDIS_0 = 0x0,
                    /// Resynchronization during received data word is disabled
                    RESYNCDIS_1 = 0x1,
                },
                /// Both Edge Sampling
                BOTHEDGE: enum(u1) {
                    /// Receiver samples input data using the rising edge of the baud rate clock.
                    BOTHEDGE_0 = 0x0,
                    /// Receiver samples input data using the rising and falling edge of the baud rate clock.
                    BOTHEDGE_1 = 0x1,
                },
                /// Match Configuration
                MATCFG: enum(u2) {
                    /// Address Match Wakeup
                    MATCFG_0 = 0x0,
                    /// Idle Match Wakeup
                    MATCFG_1 = 0x1,
                    /// Match On and Match Off
                    MATCFG_2 = 0x2,
                    /// Enables RWU on Data Match and Match On/Off for transmitter CTS input
                    MATCFG_3 = 0x3,
                },
                /// Receiver Idle DMA Enable
                RIDMAE: enum(u1) {
                    /// DMA request disabled.
                    RIDMAE_0 = 0x0,
                    /// DMA request enabled.
                    RIDMAE_1 = 0x1,
                },
                /// Receiver Full DMA Enable
                RDMAE: enum(u1) {
                    /// DMA request disabled.
                    RDMAE_0 = 0x0,
                    /// DMA request enabled.
                    RDMAE_1 = 0x1,
                },
                reserved23: u1 = 0,
                /// Transmitter DMA Enable
                TDMAE: enum(u1) {
                    /// DMA request disabled.
                    TDMAE_0 = 0x0,
                    /// DMA request enabled.
                    TDMAE_1 = 0x1,
                },
                /// Oversampling Ratio
                OSR: enum(u5) {
                    /// Writing 0 to this field will result in an oversampling ratio of 16
                    OSR_0 = 0x0,
                    /// Oversampling ratio of 4, requires BOTHEDGE to be set.
                    OSR_3 = 0x3,
                    /// Oversampling ratio of 5, requires BOTHEDGE to be set.
                    OSR_4 = 0x4,
                    /// Oversampling ratio of 6, requires BOTHEDGE to be set.
                    OSR_5 = 0x5,
                    /// Oversampling ratio of 7, requires BOTHEDGE to be set.
                    OSR_6 = 0x6,
                    /// Oversampling ratio of 8.
                    OSR_7 = 0x7,
                    /// Oversampling ratio of 9.
                    OSR_8 = 0x8,
                    /// Oversampling ratio of 10.
                    OSR_9 = 0x9,
                    /// Oversampling ratio of 11.
                    OSR_10 = 0xa,
                    /// Oversampling ratio of 12.
                    OSR_11 = 0xb,
                    /// Oversampling ratio of 13.
                    OSR_12 = 0xc,
                    /// Oversampling ratio of 14.
                    OSR_13 = 0xd,
                    /// Oversampling ratio of 15.
                    OSR_14 = 0xe,
                    /// Oversampling ratio of 16.
                    OSR_15 = 0xf,
                    /// Oversampling ratio of 17.
                    OSR_16 = 0x10,
                    /// Oversampling ratio of 18.
                    OSR_17 = 0x11,
                    /// Oversampling ratio of 19.
                    OSR_18 = 0x12,
                    /// Oversampling ratio of 20.
                    OSR_19 = 0x13,
                    /// Oversampling ratio of 21.
                    OSR_20 = 0x14,
                    /// Oversampling ratio of 22.
                    OSR_21 = 0x15,
                    /// Oversampling ratio of 23.
                    OSR_22 = 0x16,
                    /// Oversampling ratio of 24.
                    OSR_23 = 0x17,
                    /// Oversampling ratio of 25.
                    OSR_24 = 0x18,
                    /// Oversampling ratio of 26.
                    OSR_25 = 0x19,
                    /// Oversampling ratio of 27.
                    OSR_26 = 0x1a,
                    /// Oversampling ratio of 28.
                    OSR_27 = 0x1b,
                    /// Oversampling ratio of 29.
                    OSR_28 = 0x1c,
                    /// Oversampling ratio of 30.
                    OSR_29 = 0x1d,
                    /// Oversampling ratio of 31.
                    OSR_30 = 0x1e,
                    /// Oversampling ratio of 32.
                    OSR_31 = 0x1f,
                    _,
                },
                /// 10-bit Mode select
                M10: enum(u1) {
                    /// Receiver and transmitter use 7-bit to 9-bit data characters.
                    M10_0 = 0x0,
                    /// Receiver and transmitter use 10-bit data characters.
                    M10_1 = 0x1,
                },
                /// Match Address Mode Enable 2
                MAEN2: enum(u1) {
                    /// Normal operation.
                    MAEN2_0 = 0x0,
                    /// Enables automatic address matching or data matching mode for MATCH[MA2].
                    MAEN2_1 = 0x1,
                },
                /// Match Address Mode Enable 1
                MAEN1: enum(u1) {
                    /// Normal operation.
                    MAEN1_0 = 0x0,
                    /// Enables automatic address matching or data matching mode for MATCH[MA1].
                    MAEN1_1 = 0x1,
                },
            }),
            /// LPUART Status Register
            STAT: mmio.Mmio(packed struct(u32) {
                reserved14: u14 = 0,
                /// Match 2 Flag
                MA2F: enum(u1) {
                    /// Received data is not equal to MA2
                    MA2F_0 = 0x0,
                    /// Received data is equal to MA2
                    MA2F_1 = 0x1,
                },
                /// Match 1 Flag
                MA1F: enum(u1) {
                    /// Received data is not equal to MA1
                    MA1F_0 = 0x0,
                    /// Received data is equal to MA1
                    MA1F_1 = 0x1,
                },
                /// Parity Error Flag
                PF: enum(u1) {
                    /// No parity error.
                    PF_0 = 0x0,
                    /// Parity error.
                    PF_1 = 0x1,
                },
                /// Framing Error Flag
                FE: enum(u1) {
                    /// No framing error detected. This does not guarantee the framing is correct.
                    FE_0 = 0x0,
                    /// Framing error.
                    FE_1 = 0x1,
                },
                /// Noise Flag
                NF: enum(u1) {
                    /// No noise detected.
                    NF_0 = 0x0,
                    /// Noise detected in the received character in the DATA register.
                    NF_1 = 0x1,
                },
                /// Receiver Overrun Flag
                OR: enum(u1) {
                    /// No overrun.
                    OR_0 = 0x0,
                    /// Receive overrun (new LPUART data lost).
                    OR_1 = 0x1,
                },
                /// Idle Line Flag
                IDLE: enum(u1) {
                    /// No idle line detected.
                    IDLE_0 = 0x0,
                    /// Idle line was detected.
                    IDLE_1 = 0x1,
                },
                /// Receive Data Register Full Flag
                RDRF: enum(u1) {
                    /// Receive data buffer empty.
                    RDRF_0 = 0x0,
                    /// Receive data buffer full.
                    RDRF_1 = 0x1,
                },
                /// Transmission Complete Flag
                TC: enum(u1) {
                    /// Transmitter active (sending data, a preamble, or a break).
                    TC_0 = 0x0,
                    /// Transmitter idle (transmission activity complete).
                    TC_1 = 0x1,
                },
                /// Transmit Data Register Empty Flag
                TDRE: enum(u1) {
                    /// Transmit data buffer full.
                    TDRE_0 = 0x0,
                    /// Transmit data buffer empty.
                    TDRE_1 = 0x1,
                },
                /// Receiver Active Flag
                RAF: enum(u1) {
                    /// LPUART receiver idle waiting for a start bit.
                    RAF_0 = 0x0,
                    /// LPUART receiver active (RXD input not idle).
                    RAF_1 = 0x1,
                },
                /// LIN Break Detection Enable
                LBKDE: enum(u1) {
                    /// LIN break detect is disabled, normal break character can be detected.
                    LBKDE_0 = 0x0,
                    /// LIN break detect is enabled. LIN break character is detected at length of 11 bit times (if M = 0) or 12 (if M = 1) or 13 (M10 = 1).
                    LBKDE_1 = 0x1,
                },
                /// Break Character Generation Length
                BRK13: enum(u1) {
                    /// Break character is transmitted with length of 9 to 13 bit times.
                    BRK13_0 = 0x0,
                    /// Break character is transmitted with length of 12 to 15 bit times.
                    BRK13_1 = 0x1,
                },
                /// Receive Wake Up Idle Detect
                RWUID: enum(u1) {
                    /// During receive standby state (RWU = 1), the IDLE bit does not get set upon detection of an idle character. During address match wakeup, the IDLE bit does not set when an address does not match.
                    RWUID_0 = 0x0,
                    /// During receive standby state (RWU = 1), the IDLE bit gets set upon detection of an idle character. During address match wakeup, the IDLE bit does set when an address does not match.
                    RWUID_1 = 0x1,
                },
                /// Receive Data Inversion
                RXINV: enum(u1) {
                    /// Receive data not inverted.
                    RXINV_0 = 0x0,
                    /// Receive data inverted.
                    RXINV_1 = 0x1,
                },
                /// MSB First
                MSBF: enum(u1) {
                    /// LSB (bit0) is the first bit that is transmitted following the start bit. Further, the first bit received after the start bit is identified as bit0.
                    MSBF_0 = 0x0,
                    /// MSB (bit9, bit8, bit7 or bit6) is the first bit that is transmitted following the start bit depending on the setting of CTRL[M], CTRL[PE] and BAUD[M10]. Further, the first bit received after the start bit is identified as bit9, bit8, bit7 or bit6 depending on the setting of CTRL[M] and CTRL[PE].
                    MSBF_1 = 0x1,
                },
                /// RXD Pin Active Edge Interrupt Flag
                RXEDGIF: enum(u1) {
                    /// No active edge on the receive pin has occurred.
                    RXEDGIF_0 = 0x0,
                    /// An active edge on the receive pin has occurred.
                    RXEDGIF_1 = 0x1,
                },
                /// LIN Break Detect Interrupt Flag
                LBKDIF: enum(u1) {
                    /// No LIN break character has been detected.
                    LBKDIF_0 = 0x0,
                    /// LIN break character has been detected.
                    LBKDIF_1 = 0x1,
                },
            }),
            /// LPUART Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                /// Parity Type
                PT: enum(u1) {
                    /// Even parity.
                    PT_0 = 0x0,
                    /// Odd parity.
                    PT_1 = 0x1,
                },
                /// Parity Enable
                PE: enum(u1) {
                    /// No hardware parity generation or checking.
                    PE_0 = 0x0,
                    /// Parity enabled.
                    PE_1 = 0x1,
                },
                /// Idle Line Type Select
                ILT: enum(u1) {
                    /// Idle character bit count starts after start bit.
                    ILT_0 = 0x0,
                    /// Idle character bit count starts after stop bit.
                    ILT_1 = 0x1,
                },
                /// Receiver Wakeup Method Select
                WAKE: enum(u1) {
                    /// Configures RWU for idle-line wakeup.
                    WAKE_0 = 0x0,
                    /// Configures RWU with address-mark wakeup.
                    WAKE_1 = 0x1,
                },
                /// 9-Bit or 8-Bit Mode Select
                M: enum(u1) {
                    /// Receiver and transmitter use 8-bit data characters.
                    M_0 = 0x0,
                    /// Receiver and transmitter use 9-bit data characters.
                    M_1 = 0x1,
                },
                /// Receiver Source Select
                RSRC: enum(u1) {
                    /// Provided LOOPS is set, RSRC is cleared, selects internal loop back mode and the LPUART does not use the RXD pin.
                    RSRC_0 = 0x0,
                    /// Single-wire LPUART mode where the TXD pin is connected to the transmitter output and receiver input.
                    RSRC_1 = 0x1,
                },
                /// Doze Enable
                DOZEEN: enum(u1) {
                    /// LPUART is enabled in Doze mode.
                    DOZEEN_0 = 0x0,
                    /// LPUART is disabled in Doze mode.
                    DOZEEN_1 = 0x1,
                },
                /// Loop Mode Select
                LOOPS: enum(u1) {
                    /// Normal operation - RXD and TXD use separate pins.
                    LOOPS_0 = 0x0,
                    /// Loop mode or single-wire mode where transmitter outputs are internally connected to receiver input (see RSRC bit).
                    LOOPS_1 = 0x1,
                },
                /// Idle Configuration
                IDLECFG: enum(u3) {
                    /// 1 idle character
                    IDLECFG_0 = 0x0,
                    /// 2 idle characters
                    IDLECFG_1 = 0x1,
                    /// 4 idle characters
                    IDLECFG_2 = 0x2,
                    /// 8 idle characters
                    IDLECFG_3 = 0x3,
                    /// 16 idle characters
                    IDLECFG_4 = 0x4,
                    /// 32 idle characters
                    IDLECFG_5 = 0x5,
                    /// 64 idle characters
                    IDLECFG_6 = 0x6,
                    /// 128 idle characters
                    IDLECFG_7 = 0x7,
                },
                /// 7-Bit Mode Select
                M7: enum(u1) {
                    /// Receiver and transmitter use 8-bit to 10-bit data characters.
                    M7_0 = 0x0,
                    /// Receiver and transmitter use 7-bit data characters.
                    M7_1 = 0x1,
                },
                reserved14: u2 = 0,
                /// Match 2 Interrupt Enable
                MA2IE: enum(u1) {
                    /// MA2F interrupt disabled
                    MA2IE_0 = 0x0,
                    /// MA2F interrupt enabled
                    MA2IE_1 = 0x1,
                },
                /// Match 1 Interrupt Enable
                MA1IE: enum(u1) {
                    /// MA1F interrupt disabled
                    MA1IE_0 = 0x0,
                    /// MA1F interrupt enabled
                    MA1IE_1 = 0x1,
                },
                /// Send Break
                SBK: enum(u1) {
                    /// Normal transmitter operation.
                    SBK_0 = 0x0,
                    /// Queue break character(s) to be sent.
                    SBK_1 = 0x1,
                },
                /// Receiver Wakeup Control
                RWU: enum(u1) {
                    /// Normal receiver operation.
                    RWU_0 = 0x0,
                    /// LPUART receiver in standby waiting for wakeup condition.
                    RWU_1 = 0x1,
                },
                /// Receiver Enable
                RE: enum(u1) {
                    /// Receiver disabled.
                    RE_0 = 0x0,
                    /// Receiver enabled.
                    RE_1 = 0x1,
                },
                /// Transmitter Enable
                TE: enum(u1) {
                    /// Transmitter disabled.
                    TE_0 = 0x0,
                    /// Transmitter enabled.
                    TE_1 = 0x1,
                },
                /// Idle Line Interrupt Enable
                ILIE: enum(u1) {
                    /// Hardware interrupts from IDLE disabled; use polling.
                    ILIE_0 = 0x0,
                    /// Hardware interrupt requested when IDLE flag is 1.
                    ILIE_1 = 0x1,
                },
                /// Receiver Interrupt Enable
                RIE: enum(u1) {
                    /// Hardware interrupts from RDRF disabled; use polling.
                    RIE_0 = 0x0,
                    /// Hardware interrupt requested when RDRF flag is 1.
                    RIE_1 = 0x1,
                },
                /// Transmission Complete Interrupt Enable for
                TCIE: enum(u1) {
                    /// Hardware interrupts from TC disabled; use polling.
                    TCIE_0 = 0x0,
                    /// Hardware interrupt requested when TC flag is 1.
                    TCIE_1 = 0x1,
                },
                /// Transmit Interrupt Enable
                TIE: enum(u1) {
                    /// Hardware interrupts from TDRE disabled; use polling.
                    TIE_0 = 0x0,
                    /// Hardware interrupt requested when TDRE flag is 1.
                    TIE_1 = 0x1,
                },
                /// Parity Error Interrupt Enable
                PEIE: enum(u1) {
                    /// PF interrupts disabled; use polling).
                    PEIE_0 = 0x0,
                    /// Hardware interrupt requested when PF is set.
                    PEIE_1 = 0x1,
                },
                /// Framing Error Interrupt Enable
                FEIE: enum(u1) {
                    /// FE interrupts disabled; use polling.
                    FEIE_0 = 0x0,
                    /// Hardware interrupt requested when FE is set.
                    FEIE_1 = 0x1,
                },
                /// Noise Error Interrupt Enable
                NEIE: enum(u1) {
                    /// NF interrupts disabled; use polling.
                    NEIE_0 = 0x0,
                    /// Hardware interrupt requested when NF is set.
                    NEIE_1 = 0x1,
                },
                /// Overrun Interrupt Enable
                ORIE: enum(u1) {
                    /// OR interrupts disabled; use polling.
                    ORIE_0 = 0x0,
                    /// Hardware interrupt requested when OR is set.
                    ORIE_1 = 0x1,
                },
                /// Transmit Data Inversion
                TXINV: enum(u1) {
                    /// Transmit data not inverted.
                    TXINV_0 = 0x0,
                    /// Transmit data inverted.
                    TXINV_1 = 0x1,
                },
                /// TXD Pin Direction in Single-Wire Mode
                TXDIR: enum(u1) {
                    /// TXD pin is an input in single-wire mode.
                    TXDIR_0 = 0x0,
                    /// TXD pin is an output in single-wire mode.
                    TXDIR_1 = 0x1,
                },
                /// Receive Bit 9 / Transmit Bit 8
                R9T8: u1,
                /// Receive Bit 8 / Transmit Bit 9
                R8T9: u1,
            }),
            /// LPUART Data Register
            DATA: mmio.Mmio(packed struct(u32) {
                /// R0T0
                R0T0: u1,
                /// R1T1
                R1T1: u1,
                /// R2T2
                R2T2: u1,
                /// R3T3
                R3T3: u1,
                /// R4T4
                R4T4: u1,
                /// R5T5
                R5T5: u1,
                /// R6T6
                R6T6: u1,
                /// R7T7
                R7T7: u1,
                /// R8T8
                R8T8: u1,
                /// R9T9
                R9T9: u1,
                reserved11: u1 = 0,
                /// Idle Line
                IDLINE: enum(u1) {
                    /// Receiver was not idle before receiving this character.
                    IDLINE_0 = 0x0,
                    /// Receiver was idle before receiving this character.
                    IDLINE_1 = 0x1,
                },
                /// Receive Buffer Empty
                RXEMPT: enum(u1) {
                    /// Receive buffer contains valid data.
                    RXEMPT_0 = 0x0,
                    /// Receive buffer is empty, data returned on read is not valid.
                    RXEMPT_1 = 0x1,
                },
                /// Frame Error / Transmit Special Character
                FRETSC: enum(u1) {
                    /// The dataword was received without a frame error on read, or transmit a normal character on write.
                    FRETSC_0 = 0x0,
                    /// The dataword was received with a frame error, or transmit an idle or break character on transmit.
                    FRETSC_1 = 0x1,
                },
                /// PARITYE
                PARITYE: enum(u1) {
                    /// The dataword was received without a parity error.
                    PARITYE_0 = 0x0,
                    /// The dataword was received with a parity error.
                    PARITYE_1 = 0x1,
                },
                /// NOISY
                NOISY: enum(u1) {
                    /// The dataword was received without noise.
                    NOISY_0 = 0x0,
                    /// The data was received with noise.
                    NOISY_1 = 0x1,
                },
                padding: u16 = 0,
            }),
            /// LPUART Match Address Register
            MATCH: mmio.Mmio(packed struct(u32) {
                /// Match Address 1
                MA1: u10,
                reserved16: u6 = 0,
                /// Match Address 2
                MA2: u10,
                padding: u6 = 0,
            }),
            /// LPUART Modem IrDA Register
            MODIR: mmio.Mmio(packed struct(u32) {
                /// Transmitter clear-to-send enable
                TXCTSE: enum(u1) {
                    /// CTS has no effect on the transmitter.
                    TXCTSE_0 = 0x0,
                    /// Enables clear-to-send operation. The transmitter checks the state of CTS each time it is ready to send a character. If CTS is asserted, the character is sent. If CTS is deasserted, the signal TXD remains in the mark state and transmission is delayed until CTS is asserted. Changes in CTS as a character is being sent do not affect its transmission.
                    TXCTSE_1 = 0x1,
                },
                /// Transmitter request-to-send enable
                TXRTSE: enum(u1) {
                    /// The transmitter has no effect on RTS.
                    TXRTSE_0 = 0x0,
                    /// When a character is placed into an empty transmitter data buffer , RTS asserts one bit time before the start bit is transmitted. RTS deasserts one bit time after all characters in the transmitter data buffer and shift register are completely sent, including the last stop bit.
                    TXRTSE_1 = 0x1,
                },
                /// Transmitter request-to-send polarity
                TXRTSPOL: enum(u1) {
                    /// Transmitter RTS is active low.
                    TXRTSPOL_0 = 0x0,
                    /// Transmitter RTS is active high.
                    TXRTSPOL_1 = 0x1,
                },
                /// Receiver request-to-send enable
                RXRTSE: enum(u1) {
                    /// The receiver has no effect on RTS.
                    RXRTSE_0 = 0x0,
                    /// RTS is deasserted if the receiver data register is full or a start bit has been detected that would cause the receiver data register to become full. RTS is asserted if the receiver data register is not full and has not detected a start bit that would cause the receiver data register to become full.
                    RXRTSE_1 = 0x1,
                },
                /// Transmit CTS Configuration
                TXCTSC: enum(u1) {
                    /// CTS input is sampled at the start of each character.
                    TXCTSC_0 = 0x0,
                    /// CTS input is sampled when the transmitter is idle.
                    TXCTSC_1 = 0x1,
                },
                /// Transmit CTS Source
                TXCTSSRC: enum(u1) {
                    /// CTS input is the CTS_B pin.
                    TXCTSSRC_0 = 0x0,
                    /// CTS input is the inverted Receiver Match result.
                    TXCTSSRC_1 = 0x1,
                },
                reserved8: u2 = 0,
                /// Receive RTS Configuration
                RTSWATER: u2,
                reserved16: u6 = 0,
                /// Transmitter narrow pulse
                TNP: enum(u2) {
                    /// 1/OSR.
                    TNP_0 = 0x0,
                    /// 2/OSR.
                    TNP_1 = 0x1,
                    /// 3/OSR.
                    TNP_2 = 0x2,
                    /// 4/OSR.
                    TNP_3 = 0x3,
                },
                /// Infrared enable
                IREN: enum(u1) {
                    /// IR disabled.
                    IREN_0 = 0x0,
                    /// IR enabled.
                    IREN_1 = 0x1,
                },
                padding: u13 = 0,
            }),
            /// LPUART FIFO Register
            FIFO: mmio.Mmio(packed struct(u32) {
                /// Receive FIFO Buffer Depth
                RXFIFOSIZE: enum(u3) {
                    /// Receive FIFO/Buffer depth = 1 dataword.
                    RXFIFOSIZE_0 = 0x0,
                    /// Receive FIFO/Buffer depth = 4 datawords.
                    RXFIFOSIZE_1 = 0x1,
                    /// Receive FIFO/Buffer depth = 8 datawords.
                    RXFIFOSIZE_2 = 0x2,
                    /// Receive FIFO/Buffer depth = 16 datawords.
                    RXFIFOSIZE_3 = 0x3,
                    /// Receive FIFO/Buffer depth = 32 datawords.
                    RXFIFOSIZE_4 = 0x4,
                    /// Receive FIFO/Buffer depth = 64 datawords.
                    RXFIFOSIZE_5 = 0x5,
                    /// Receive FIFO/Buffer depth = 128 datawords.
                    RXFIFOSIZE_6 = 0x6,
                    /// Receive FIFO/Buffer depth = 256 datawords.
                    RXFIFOSIZE_7 = 0x7,
                },
                /// Receive FIFO Enable
                RXFE: enum(u1) {
                    /// Receive FIFO is not enabled. Buffer is depth 1.
                    RXFE_0 = 0x0,
                    /// Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.
                    RXFE_1 = 0x1,
                },
                /// Transmit FIFO Buffer Depth
                TXFIFOSIZE: enum(u3) {
                    /// Transmit FIFO/Buffer depth = 1 dataword.
                    TXFIFOSIZE_0 = 0x0,
                    /// Transmit FIFO/Buffer depth = 4 datawords.
                    TXFIFOSIZE_1 = 0x1,
                    /// Transmit FIFO/Buffer depth = 8 datawords.
                    TXFIFOSIZE_2 = 0x2,
                    /// Transmit FIFO/Buffer depth = 16 datawords.
                    TXFIFOSIZE_3 = 0x3,
                    /// Transmit FIFO/Buffer depth = 32 datawords.
                    TXFIFOSIZE_4 = 0x4,
                    /// Transmit FIFO/Buffer depth = 64 datawords.
                    TXFIFOSIZE_5 = 0x5,
                    /// Transmit FIFO/Buffer depth = 128 datawords.
                    TXFIFOSIZE_6 = 0x6,
                    /// Transmit FIFO/Buffer depth = 256 datawords
                    TXFIFOSIZE_7 = 0x7,
                },
                /// Transmit FIFO Enable
                TXFE: enum(u1) {
                    /// Transmit FIFO is not enabled. Buffer is depth 1.
                    TXFE_0 = 0x0,
                    /// Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.
                    TXFE_1 = 0x1,
                },
                /// Receive FIFO Underflow Interrupt Enable
                RXUFE: enum(u1) {
                    /// RXUF flag does not generate an interrupt to the host.
                    RXUFE_0 = 0x0,
                    /// RXUF flag generates an interrupt to the host.
                    RXUFE_1 = 0x1,
                },
                /// Transmit FIFO Overflow Interrupt Enable
                TXOFE: enum(u1) {
                    /// TXOF flag does not generate an interrupt to the host.
                    TXOFE_0 = 0x0,
                    /// TXOF flag generates an interrupt to the host.
                    TXOFE_1 = 0x1,
                },
                /// Receiver Idle Empty Enable
                RXIDEN: enum(u3) {
                    /// Disable RDRF assertion due to partially filled FIFO when receiver is idle.
                    RXIDEN_0 = 0x0,
                    /// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 1 character.
                    RXIDEN_1 = 0x1,
                    /// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 2 characters.
                    RXIDEN_2 = 0x2,
                    /// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 4 characters.
                    RXIDEN_3 = 0x3,
                    /// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 8 characters.
                    RXIDEN_4 = 0x4,
                    /// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 16 characters.
                    RXIDEN_5 = 0x5,
                    /// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 32 characters.
                    RXIDEN_6 = 0x6,
                    /// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 64 characters.
                    RXIDEN_7 = 0x7,
                },
                reserved14: u1 = 0,
                /// Receive FIFO/Buffer Flush
                RXFLUSH: enum(u1) {
                    /// No flush operation occurs.
                    RXFLUSH_0 = 0x0,
                    /// All data in the receive FIFO/buffer is cleared out.
                    RXFLUSH_1 = 0x1,
                },
                /// Transmit FIFO/Buffer Flush
                TXFLUSH: enum(u1) {
                    /// No flush operation occurs.
                    TXFLUSH_0 = 0x0,
                    /// All data in the transmit FIFO/Buffer is cleared out.
                    TXFLUSH_1 = 0x1,
                },
                /// Receiver Buffer Underflow Flag
                RXUF: enum(u1) {
                    /// No receive buffer underflow has occurred since the last time the flag was cleared.
                    RXUF_0 = 0x0,
                    /// At least one receive buffer underflow has occurred since the last time the flag was cleared.
                    RXUF_1 = 0x1,
                },
                /// Transmitter Buffer Overflow Flag
                TXOF: enum(u1) {
                    /// No transmit buffer overflow has occurred since the last time the flag was cleared.
                    TXOF_0 = 0x0,
                    /// At least one transmit buffer overflow has occurred since the last time the flag was cleared.
                    TXOF_1 = 0x1,
                },
                reserved22: u4 = 0,
                /// Receive Buffer/FIFO Empty
                RXEMPT: enum(u1) {
                    /// Receive buffer is not empty.
                    RXEMPT_0 = 0x0,
                    /// Receive buffer is empty.
                    RXEMPT_1 = 0x1,
                },
                /// Transmit Buffer/FIFO Empty
                TXEMPT: enum(u1) {
                    /// Transmit buffer is not empty.
                    TXEMPT_0 = 0x0,
                    /// Transmit buffer is empty.
                    TXEMPT_1 = 0x1,
                },
                padding: u8 = 0,
            }),
            /// LPUART Watermark Register
            WATER: mmio.Mmio(packed struct(u32) {
                /// Transmit Watermark
                TXWATER: u2,
                reserved8: u6 = 0,
                /// Transmit Counter
                TXCOUNT: u3,
                reserved16: u5 = 0,
                /// Receive Watermark
                RXWATER: u2,
                reserved24: u6 = 0,
                /// Receive Counter
                RXCOUNT: u3,
                padding: u5 = 0,
            }),
        };

        /// Nested Vectored Interrupt Controller
        pub const NVIC = extern struct {
            /// Interrupt Set Enable Register n
            NVICISER0: mmio.Mmio(packed struct(u32) {
                /// Interrupt set enable bits
                SETENA: u32,
            }),
            /// Interrupt Set Enable Register n
            NVICISER1: mmio.Mmio(packed struct(u32) {
                /// Interrupt set enable bits
                SETENA: u32,
            }),
            /// Interrupt Set Enable Register n
            NVICISER2: mmio.Mmio(packed struct(u32) {
                /// Interrupt set enable bits
                SETENA: u32,
            }),
            /// Interrupt Set Enable Register n
            NVICISER3: mmio.Mmio(packed struct(u32) {
                /// Interrupt set enable bits
                SETENA: u32,
            }),
            /// Interrupt Set Enable Register n
            NVICISER4: mmio.Mmio(packed struct(u32) {
                /// Interrupt set enable bits
                SETENA: u32,
            }),
            reserved128: [108]u8,
            /// Interrupt Clear Enable Register n
            NVICICER0: mmio.Mmio(packed struct(u32) {
                /// Interrupt clear-enable bits
                CLRENA: u32,
            }),
            /// Interrupt Clear Enable Register n
            NVICICER1: mmio.Mmio(packed struct(u32) {
                /// Interrupt clear-enable bits
                CLRENA: u32,
            }),
            /// Interrupt Clear Enable Register n
            NVICICER2: mmio.Mmio(packed struct(u32) {
                /// Interrupt clear-enable bits
                CLRENA: u32,
            }),
            /// Interrupt Clear Enable Register n
            NVICICER3: mmio.Mmio(packed struct(u32) {
                /// Interrupt clear-enable bits
                CLRENA: u32,
            }),
            /// Interrupt Clear Enable Register n
            NVICICER4: mmio.Mmio(packed struct(u32) {
                /// Interrupt clear-enable bits
                CLRENA: u32,
            }),
            reserved256: [108]u8,
            /// Interrupt Set Pending Register n
            NVICISPR0: mmio.Mmio(packed struct(u32) {
                /// Interrupt set-pending bits
                SETPEND: u32,
            }),
            /// Interrupt Set Pending Register n
            NVICISPR1: mmio.Mmio(packed struct(u32) {
                /// Interrupt set-pending bits
                SETPEND: u32,
            }),
            /// Interrupt Set Pending Register n
            NVICISPR2: mmio.Mmio(packed struct(u32) {
                /// Interrupt set-pending bits
                SETPEND: u32,
            }),
            /// Interrupt Set Pending Register n
            NVICISPR3: mmio.Mmio(packed struct(u32) {
                /// Interrupt set-pending bits
                SETPEND: u32,
            }),
            /// Interrupt Set Pending Register n
            NVICISPR4: mmio.Mmio(packed struct(u32) {
                /// Interrupt set-pending bits
                SETPEND: u32,
            }),
            reserved384: [108]u8,
            /// Interrupt Clear Pending Register n
            NVICICPR0: mmio.Mmio(packed struct(u32) {
                /// Interrupt clear-pending bits
                CLRPEND: u32,
            }),
            /// Interrupt Clear Pending Register n
            NVICICPR1: mmio.Mmio(packed struct(u32) {
                /// Interrupt clear-pending bits
                CLRPEND: u32,
            }),
            /// Interrupt Clear Pending Register n
            NVICICPR2: mmio.Mmio(packed struct(u32) {
                /// Interrupt clear-pending bits
                CLRPEND: u32,
            }),
            /// Interrupt Clear Pending Register n
            NVICICPR3: mmio.Mmio(packed struct(u32) {
                /// Interrupt clear-pending bits
                CLRPEND: u32,
            }),
            /// Interrupt Clear Pending Register n
            NVICICPR4: mmio.Mmio(packed struct(u32) {
                /// Interrupt clear-pending bits
                CLRPEND: u32,
            }),
            reserved512: [108]u8,
            /// Interrupt Active bit Register n
            NVICIABR0: mmio.Mmio(packed struct(u32) {
                /// Interrupt active flags
                ACTIVE: u32,
            }),
            /// Interrupt Active bit Register n
            NVICIABR1: mmio.Mmio(packed struct(u32) {
                /// Interrupt active flags
                ACTIVE: u32,
            }),
            /// Interrupt Active bit Register n
            NVICIABR2: mmio.Mmio(packed struct(u32) {
                /// Interrupt active flags
                ACTIVE: u32,
            }),
            /// Interrupt Active bit Register n
            NVICIABR3: mmio.Mmio(packed struct(u32) {
                /// Interrupt active flags
                ACTIVE: u32,
            }),
            /// Interrupt Active bit Register n
            NVICIABR4: mmio.Mmio(packed struct(u32) {
                /// Interrupt active flags
                ACTIVE: u32,
            }),
            reserved768: [236]u8,
            /// Interrupt Priority Register 0
            NVICIP0: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DMA0_DMA16 interrupt 0
                PRI0: u4,
            }),
            /// Interrupt Priority Register 1
            NVICIP1: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DMA1_DMA17 interrupt 1
                PRI1: u4,
            }),
            /// Interrupt Priority Register 2
            NVICIP2: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DMA2_DMA18 interrupt 2
                PRI2: u4,
            }),
            /// Interrupt Priority Register 3
            NVICIP3: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DMA3_DMA19 interrupt 3
                PRI3: u4,
            }),
            /// Interrupt Priority Register 4
            NVICIP4: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DMA4_DMA20 interrupt 4
                PRI4: u4,
            }),
            /// Interrupt Priority Register 5
            NVICIP5: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DMA5_DMA21 interrupt 5
                PRI5: u4,
            }),
            /// Interrupt Priority Register 6
            NVICIP6: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DMA6_DMA22 interrupt 6
                PRI6: u4,
            }),
            /// Interrupt Priority Register 7
            NVICIP7: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DMA7_DMA23 interrupt 7
                PRI7: u4,
            }),
            /// Interrupt Priority Register 8
            NVICIP8: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DMA8_DMA24 interrupt 8
                PRI8: u4,
            }),
            /// Interrupt Priority Register 9
            NVICIP9: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DMA9_DMA25 interrupt 9
                PRI9: u4,
            }),
            /// Interrupt Priority Register 10
            NVICIP10: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DMA10_DMA26 interrupt 10
                PRI10: u4,
            }),
            /// Interrupt Priority Register 11
            NVICIP11: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DMA11_DMA27 interrupt 11
                PRI11: u4,
            }),
            /// Interrupt Priority Register 12
            NVICIP12: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DMA12_DMA28 interrupt 12
                PRI12: u4,
            }),
            /// Interrupt Priority Register 13
            NVICIP13: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DMA13_DMA29 interrupt 13
                PRI13: u4,
            }),
            /// Interrupt Priority Register 14
            NVICIP14: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DMA14_DMA30 interrupt 14
                PRI14: u4,
            }),
            /// Interrupt Priority Register 15
            NVICIP15: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DMA15_DMA31 interrupt 15
                PRI15: u4,
            }),
            /// Interrupt Priority Register 16
            NVICIP16: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DMA_ERROR interrupt 16
                PRI16: u4,
            }),
            /// Interrupt Priority Register 17
            NVICIP17: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_CTI0_ERROR interrupt 17
                PRI17: u4,
            }),
            /// Interrupt Priority Register 18
            NVICIP18: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_CTI1_ERROR interrupt 18
                PRI18: u4,
            }),
            /// Interrupt Priority Register 19
            NVICIP19: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_CORE interrupt 19
                PRI19: u4,
            }),
            /// Interrupt Priority Register 20
            NVICIP20: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_LPUART1 interrupt 20
                PRI20: u4,
            }),
            /// Interrupt Priority Register 21
            NVICIP21: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_LPUART2 interrupt 21
                PRI21: u4,
            }),
            /// Interrupt Priority Register 22
            NVICIP22: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_LPUART3 interrupt 22
                PRI22: u4,
            }),
            /// Interrupt Priority Register 23
            NVICIP23: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_LPUART4 interrupt 23
                PRI23: u4,
            }),
            /// Interrupt Priority Register 24
            NVICIP24: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_LPUART5 interrupt 24
                PRI24: u4,
            }),
            /// Interrupt Priority Register 25
            NVICIP25: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_LPUART6 interrupt 25
                PRI25: u4,
            }),
            /// Interrupt Priority Register 26
            NVICIP26: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_LPUART7 interrupt 26
                PRI26: u4,
            }),
            /// Interrupt Priority Register 27
            NVICIP27: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_LPUART8 interrupt 27
                PRI27: u4,
            }),
            /// Interrupt Priority Register 28
            NVICIP28: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_LPI2C1 interrupt 28
                PRI28: u4,
            }),
            /// Interrupt Priority Register 29
            NVICIP29: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_LPI2C2 interrupt 29
                PRI29: u4,
            }),
            /// Interrupt Priority Register 30
            NVICIP30: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_LPI2C3 interrupt 30
                PRI30: u4,
            }),
            /// Interrupt Priority Register 31
            NVICIP31: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_LPI2C4 interrupt 31
                PRI31: u4,
            }),
            /// Interrupt Priority Register 32
            NVICIP32: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_LPSPI1 interrupt 32
                PRI32: u4,
            }),
            /// Interrupt Priority Register 33
            NVICIP33: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_LPSPI2 interrupt 33
                PRI33: u4,
            }),
            /// Interrupt Priority Register 34
            NVICIP34: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_LPSPI3 interrupt 34
                PRI34: u4,
            }),
            /// Interrupt Priority Register 35
            NVICIP35: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_LPSPI4 interrupt 35
                PRI35: u4,
            }),
            /// Interrupt Priority Register 36
            NVICIP36: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_CAN1 interrupt 36
                PRI36: u4,
            }),
            /// Interrupt Priority Register 37
            NVICIP37: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_CAN2 interrupt 37
                PRI37: u4,
            }),
            /// Interrupt Priority Register 38
            NVICIP38: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_FLEXRAM interrupt 38
                PRI38: u4,
            }),
            /// Interrupt Priority Register 39
            NVICIP39: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_KPP interrupt 39
                PRI39: u4,
            }),
            /// Interrupt Priority Register 40
            NVICIP40: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_TSC_DIG interrupt 40
                PRI40: u4,
            }),
            /// Interrupt Priority Register 41
            NVICIP41: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPR_IRQ interrupt 41
                PRI41: u4,
            }),
            /// Interrupt Priority Register 42
            NVICIP42: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_LCDIF interrupt 42
                PRI42: u4,
            }),
            /// Interrupt Priority Register 43
            NVICIP43: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_CSI interrupt 43
                PRI43: u4,
            }),
            /// Interrupt Priority Register 44
            NVICIP44: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PXP interrupt 44
                PRI44: u4,
            }),
            /// Interrupt Priority Register 45
            NVICIP45: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_WDOG2 interrupt 45
                PRI45: u4,
            }),
            /// Interrupt Priority Register 46
            NVICIP46: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_SNVS_HP_WRAPPER interrupt 46
                PRI46: u4,
            }),
            /// Interrupt Priority Register 47
            NVICIP47: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_SNVS_HP_WRAPPER_TZ interrupt 47
                PRI47: u4,
            }),
            /// Interrupt Priority Register 48
            NVICIP48: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_SNVS_LP_WRAPPER interrupt 48
                PRI48: u4,
            }),
            /// Interrupt Priority Register 49
            NVICIP49: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_CSU interrupt 49
                PRI49: u4,
            }),
            /// Interrupt Priority Register 50
            NVICIP50: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DCP interrupt 50
                PRI50: u4,
            }),
            /// Interrupt Priority Register 51
            NVICIP51: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DCP_VMI interrupt 51
                PRI51: u4,
            }),
            /// Interrupt Priority Register 52
            NVICIP52: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_Reserved68 interrupt 52
                PRI52: u4,
            }),
            /// Interrupt Priority Register 53
            NVICIP53: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_TRNG interrupt 53
                PRI53: u4,
            }),
            /// Interrupt Priority Register 54
            NVICIP54: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_SJC interrupt 54
                PRI54: u4,
            }),
            /// Interrupt Priority Register 55
            NVICIP55: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_BEE interrupt 55
                PRI55: u4,
            }),
            /// Interrupt Priority Register 56
            NVICIP56: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_SAI1 interrupt 56
                PRI56: u4,
            }),
            /// Interrupt Priority Register 57
            NVICIP57: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_SAI2 interrupt 57
                PRI57: u4,
            }),
            /// Interrupt Priority Register 58
            NVICIP58: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_SAI3_RX interrupt 58
                PRI58: u4,
            }),
            /// Interrupt Priority Register 59
            NVICIP59: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_SAI3_TX interrupt 59
                PRI59: u4,
            }),
            /// Interrupt Priority Register 60
            NVICIP60: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_SPDIF interrupt 60
                PRI60: u4,
            }),
            /// Interrupt Priority Register 61
            NVICIP61: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PMU_EVENT interrupt 61
                PRI61: u4,
            }),
            /// Interrupt Priority Register 62
            NVICIP62: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_Reserved78 interrupt 62
                PRI62: u4,
            }),
            /// Interrupt Priority Register 63
            NVICIP63: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_TEMP_LOW_HIGH interrupt 63
                PRI63: u4,
            }),
            /// Interrupt Priority Register 64
            NVICIP64: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_TEMP_PANIC interrupt 64
                PRI64: u4,
            }),
            /// Interrupt Priority Register 65
            NVICIP65: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_USB_PHY1 interrupt 65
                PRI65: u4,
            }),
            /// Interrupt Priority Register 66
            NVICIP66: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_USB_PHY2 interrupt 66
                PRI66: u4,
            }),
            /// Interrupt Priority Register 67
            NVICIP67: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_ADC1 interrupt 67
                PRI67: u4,
            }),
            /// Interrupt Priority Register 68
            NVICIP68: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_ADC2 interrupt 68
                PRI68: u4,
            }),
            /// Interrupt Priority Register 69
            NVICIP69: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_DCDC interrupt 69
                PRI69: u4,
            }),
            /// Interrupt Priority Register 70
            NVICIP70: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_Reserved86 interrupt 70
                PRI70: u4,
            }),
            /// Interrupt Priority Register 71
            NVICIP71: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_Reserved87 interrupt 71
                PRI71: u4,
            }),
            /// Interrupt Priority Register 72
            NVICIP72: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO1_INT0 interrupt 72
                PRI72: u4,
            }),
            /// Interrupt Priority Register 73
            NVICIP73: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO1_INT1 interrupt 73
                PRI73: u4,
            }),
            /// Interrupt Priority Register 74
            NVICIP74: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO1_INT2 interrupt 74
                PRI74: u4,
            }),
            /// Interrupt Priority Register 75
            NVICIP75: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO1_INT3 interrupt 75
                PRI75: u4,
            }),
            /// Interrupt Priority Register 76
            NVICIP76: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO1_INT4 interrupt 76
                PRI76: u4,
            }),
            /// Interrupt Priority Register 77
            NVICIP77: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO1_INT5 interrupt 77
                PRI77: u4,
            }),
            /// Interrupt Priority Register 78
            NVICIP78: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO1_INT6 interrupt 78
                PRI78: u4,
            }),
            /// Interrupt Priority Register 79
            NVICIP79: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO1_INT7 interrupt 79
                PRI79: u4,
            }),
            /// Interrupt Priority Register 80
            NVICIP80: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO1_Combined_0_15 interrupt 80
                PRI80: u4,
            }),
            /// Interrupt Priority Register 81
            NVICIP81: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO1_Combined_16_31 interrupt 81
                PRI81: u4,
            }),
            /// Interrupt Priority Register 82
            NVICIP82: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO2_Combined_0_15 interrupt 82
                PRI82: u4,
            }),
            /// Interrupt Priority Register 83
            NVICIP83: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO2_Combined_16_31 interrupt 83
                PRI83: u4,
            }),
            /// Interrupt Priority Register 84
            NVICIP84: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO3_Combined_0_15 interrupt 84
                PRI84: u4,
            }),
            /// Interrupt Priority Register 85
            NVICIP85: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO3_Combined_16_31 interrupt 85
                PRI85: u4,
            }),
            /// Interrupt Priority Register 86
            NVICIP86: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO4_Combined_0_15 interrupt 86
                PRI86: u4,
            }),
            /// Interrupt Priority Register 87
            NVICIP87: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO4_Combined_16_31 interrupt 87
                PRI87: u4,
            }),
            /// Interrupt Priority Register 88
            NVICIP88: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO5_Combined_0_15 interrupt 88
                PRI88: u4,
            }),
            /// Interrupt Priority Register 89
            NVICIP89: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO5_Combined_16_31 interrupt 89
                PRI89: u4,
            }),
            /// Interrupt Priority Register 90
            NVICIP90: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_FLEXIO1 interrupt 90
                PRI90: u4,
            }),
            /// Interrupt Priority Register 91
            NVICIP91: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_FLEXIO2 interrupt 91
                PRI91: u4,
            }),
            /// Interrupt Priority Register 92
            NVICIP92: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_WDOG1 interrupt 92
                PRI92: u4,
            }),
            /// Interrupt Priority Register 93
            NVICIP93: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_RTWDOG interrupt 93
                PRI93: u4,
            }),
            /// Interrupt Priority Register 94
            NVICIP94: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_EWM interrupt 94
                PRI94: u4,
            }),
            /// Interrupt Priority Register 95
            NVICIP95: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_CCM_1 interrupt 95
                PRI95: u4,
            }),
            /// Interrupt Priority Register 96
            NVICIP96: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_CCM_2 interrupt 96
                PRI96: u4,
            }),
            /// Interrupt Priority Register 97
            NVICIP97: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPC interrupt 97
                PRI97: u4,
            }),
            /// Interrupt Priority Register 98
            NVICIP98: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_SRC interrupt 98
                PRI98: u4,
            }),
            /// Interrupt Priority Register 99
            NVICIP99: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_Reserved115 interrupt 99
                PRI99: u4,
            }),
            /// Interrupt Priority Register 100
            NVICIP100: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPT1 interrupt 100
                PRI100: u4,
            }),
            /// Interrupt Priority Register 101
            NVICIP101: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPT2 interrupt 101
                PRI101: u4,
            }),
            /// Interrupt Priority Register 102
            NVICIP102: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM1_0 interrupt 102
                PRI102: u4,
            }),
            /// Interrupt Priority Register 103
            NVICIP103: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM1_1 interrupt 103
                PRI103: u4,
            }),
            /// Interrupt Priority Register 104
            NVICIP104: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM1_2 interrupt 104
                PRI104: u4,
            }),
            /// Interrupt Priority Register 105
            NVICIP105: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM1_3 interrupt 105
                PRI105: u4,
            }),
            /// Interrupt Priority Register 106
            NVICIP106: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM1_FAULT interrupt 106
                PRI106: u4,
            }),
            /// Interrupt Priority Register 107
            NVICIP107: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_FLEXSPI2 interrupt 107
                PRI107: u4,
            }),
            /// Interrupt Priority Register 108
            NVICIP108: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of interrupt 108
                PRI108: u4,
            }),
            /// Interrupt Priority Register 109
            NVICIP109: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_SEMC interrupt 109
                PRI109: u4,
            }),
            /// Interrupt Priority Register 110
            NVICIP110: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_USDHC1 interrupt 110
                PRI110: u4,
            }),
            /// Interrupt Priority Register 111
            NVICIP111: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_USDHC2 interrupt 111
                PRI111: u4,
            }),
            /// Interrupt Priority Register 112
            NVICIP112: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_USB_OTG2 interrupt 112
                PRI112: u4,
            }),
            /// Interrupt Priority Register 113
            NVICIP113: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_USB_OTG1 interrupt 113
                PRI113: u4,
            }),
            /// Interrupt Priority Register 114
            NVICIP114: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_ENET interrupt 114
                PRI114: u4,
            }),
            /// Interrupt Priority Register 115
            NVICIP115: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_ENET_1588_Timer interrupt 115
                PRI115: u4,
            }),
            /// Interrupt Priority Register 116
            NVICIP116: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_XBAR1_IRQ_0_1 interrupt 116
                PRI116: u4,
            }),
            /// Interrupt Priority Register 117
            NVICIP117: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_XBAR1_IRQ_2_3 interrupt 117
                PRI117: u4,
            }),
            /// Interrupt Priority Register 118
            NVICIP118: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_ADC_ETC_IRQ0 interrupt 118
                PRI118: u4,
            }),
            /// Interrupt Priority Register 119
            NVICIP119: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_ADC_ETC_IRQ1 interrupt 119
                PRI119: u4,
            }),
            /// Interrupt Priority Register 120
            NVICIP120: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_ADC_ETC_IRQ2 interrupt 120
                PRI120: u4,
            }),
            /// Interrupt Priority Register 121
            NVICIP121: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_ADC_ETC_ERROR_IRQ interrupt 121
                PRI121: u4,
            }),
            /// Interrupt Priority Register 122
            NVICIP122: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PIT interrupt 122
                PRI122: u4,
            }),
            /// Interrupt Priority Register 123
            NVICIP123: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_ACMP1 interrupt 123
                PRI123: u4,
            }),
            /// Interrupt Priority Register 124
            NVICIP124: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_ACMP2 interrupt 124
                PRI124: u4,
            }),
            /// Interrupt Priority Register 125
            NVICIP125: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_ACMP3 interrupt 125
                PRI125: u4,
            }),
            /// Interrupt Priority Register 126
            NVICIP126: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_ACMP4 interrupt 126
                PRI126: u4,
            }),
            /// Interrupt Priority Register 127
            NVICIP127: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_Reserved143 interrupt 127
                PRI127: u4,
            }),
            /// Interrupt Priority Register 128
            NVICIP128: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_Reserved144 interrupt 128
                PRI128: u4,
            }),
            /// Interrupt Priority Register 129
            NVICIP129: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_ENC1 interrupt 129
                PRI129: u4,
            }),
            /// Interrupt Priority Register 130
            NVICIP130: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_ENC2 interrupt 130
                PRI130: u4,
            }),
            /// Interrupt Priority Register 131
            NVICIP131: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_ENC3 interrupt 131
                PRI131: u4,
            }),
            /// Interrupt Priority Register 132
            NVICIP132: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_ENC4 interrupt 132
                PRI132: u4,
            }),
            /// Interrupt Priority Register 133
            NVICIP133: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_TMR1 interrupt 133
                PRI133: u4,
            }),
            /// Interrupt Priority Register 134
            NVICIP134: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_TMR2 interrupt 134
                PRI134: u4,
            }),
            /// Interrupt Priority Register 135
            NVICIP135: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_TMR3 interrupt 135
                PRI135: u4,
            }),
            /// Interrupt Priority Register 136
            NVICIP136: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_TMR4 interrupt 136
                PRI136: u4,
            }),
            /// Interrupt Priority Register 137
            NVICIP137: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM2_0 interrupt 137
                PRI137: u4,
            }),
            /// Interrupt Priority Register 138
            NVICIP138: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM2_1 interrupt 138
                PRI138: u4,
            }),
            /// Interrupt Priority Register 139
            NVICIP139: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM2_2 interrupt 139
                PRI139: u4,
            }),
            /// Interrupt Priority Register 140
            NVICIP140: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM2_3 interrupt 140
                PRI140: u4,
            }),
            /// Interrupt Priority Register 141
            NVICIP141: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM2_FAULT interrupt 141
                PRI141: u4,
            }),
            /// Interrupt Priority Register 142
            NVICIP142: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM3_0 interrupt 142
                PRI142: u4,
            }),
            /// Interrupt Priority Register 143
            NVICIP143: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM3_1 interrupt 143
                PRI143: u4,
            }),
            /// Interrupt Priority Register 144
            NVICIP144: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM3_2 interrupt 144
                PRI144: u4,
            }),
            /// Interrupt Priority Register 145
            NVICIP145: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM3_3 interrupt 145
                PRI145: u4,
            }),
            /// Interrupt Priority Register 146
            NVICIP146: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM3_FAULT interrupt 146
                PRI146: u4,
            }),
            /// Interrupt Priority Register 147
            NVICIP147: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM4_0 interrupt 147
                PRI147: u4,
            }),
            /// Interrupt Priority Register 148
            NVICIP148: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM4_1 interrupt 148
                PRI148: u4,
            }),
            /// Interrupt Priority Register 149
            NVICIP149: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM4_2 interrupt 149
                PRI149: u4,
            }),
            /// Interrupt Priority Register 150
            NVICIP150: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM4_3 interrupt 150
                PRI150: u4,
            }),
            /// Interrupt Priority Register 151
            NVICIP151: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_PWM4_FAULT interrupt 151
                PRI151: u4,
            }),
            /// Interrupt Priority Register 152
            NVICIP152: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_ENET2 interrupt 152
                PRI152: u4,
            }),
            /// Interrupt Priority Register 153
            NVICIP153: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_ENET2_1588_Timer interrupt 153
                PRI153: u4,
            }),
            /// Interrupt Priority Register 154
            NVICIP154: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_CAN3 interrupt 154
                PRI154: u4,
            }),
            /// Interrupt Priority Register 155
            NVICIP155: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_Reserved171 interrupt 155
                PRI155: u4,
            }),
            /// Interrupt Priority Register 156
            NVICIP156: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_FLEXIO3 interrupt 156
                PRI156: u4,
            }),
            /// Interrupt Priority Register 157
            NVICIP157: mmio.Mmio(packed struct(u8) {
                reserved4: u4 = 0,
                /// Priority of the INT_GPIO6_7_8_9 interrupt 157
                PRI157: u4,
            }),
            reserved3584: [2658]u8,
            /// Software Trigger Interrupt Register
            NVICSTIR: mmio.Mmio(packed struct(u32) {
                /// Interrupt ID of the interrupt to trigger, in the range 0-239. For example, a value of 0x03 specifies interrupt IRQ3.
                INTID: u9,
                padding: u23 = 0,
            }),
        };

        /// OCOTP
        pub const OCOTP = extern struct {
            /// OTP Controller Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                /// ADDR
                ADDR: u6,
                /// RSVD0
                RSVD0: u2,
                /// BUSY
                BUSY: u1,
                /// ERROR
                ERROR: u1,
                /// RELOAD_SHADOWS
                RELOAD_SHADOWS: u1,
                /// CRC_TEST
                CRC_TEST: u1,
                /// CRC_FAIL
                CRC_FAIL: u1,
                /// RSVD1
                RSVD1: u3,
                /// WR_UNLOCK
                WR_UNLOCK: enum(u16) {
                    /// Key needed to unlock HW_OCOTP_DATA register.
                    KEY = 0x3e77,
                    _,
                },
            }),
            /// OTP Controller Control Register
            CTRL_SET: mmio.Mmio(packed struct(u32) {
                /// ADDR
                ADDR: u6,
                /// RSVD0
                RSVD0: u2,
                /// BUSY
                BUSY: u1,
                /// ERROR
                ERROR: u1,
                /// RELOAD_SHADOWS
                RELOAD_SHADOWS: u1,
                /// CRC_TEST
                CRC_TEST: u1,
                /// CRC_FAIL
                CRC_FAIL: u1,
                /// RSVD1
                RSVD1: u3,
                /// WR_UNLOCK
                WR_UNLOCK: u16,
            }),
            /// OTP Controller Control Register
            CTRL_CLR: mmio.Mmio(packed struct(u32) {
                /// ADDR
                ADDR: u6,
                /// RSVD0
                RSVD0: u2,
                /// BUSY
                BUSY: u1,
                /// ERROR
                ERROR: u1,
                /// RELOAD_SHADOWS
                RELOAD_SHADOWS: u1,
                /// CRC_TEST
                CRC_TEST: u1,
                /// CRC_FAIL
                CRC_FAIL: u1,
                /// RSVD1
                RSVD1: u3,
                /// WR_UNLOCK
                WR_UNLOCK: u16,
            }),
            /// OTP Controller Control Register
            CTRL_TOG: mmio.Mmio(packed struct(u32) {
                /// ADDR
                ADDR: u6,
                /// RSVD0
                RSVD0: u2,
                /// BUSY
                BUSY: u1,
                /// ERROR
                ERROR: u1,
                /// RELOAD_SHADOWS
                RELOAD_SHADOWS: u1,
                /// CRC_TEST
                CRC_TEST: u1,
                /// CRC_FAIL
                CRC_FAIL: u1,
                /// RSVD1
                RSVD1: u3,
                /// WR_UNLOCK
                WR_UNLOCK: u16,
            }),
            /// OTP Controller Timing Register
            TIMING: mmio.Mmio(packed struct(u32) {
                /// STROBE_PROG
                STROBE_PROG: u12,
                /// RELAX
                RELAX: u4,
                /// STROBE_READ
                STROBE_READ: u6,
                /// WAIT
                WAIT: u6,
                /// RSRVD0
                RSRVD0: u4,
            }),
            reserved32: [12]u8,
            /// OTP Controller Write Data Register
            DATA: mmio.Mmio(packed struct(u32) {
                /// DATA
                DATA: u32,
            }),
            reserved48: [12]u8,
            /// OTP Controller Write Data Register
            READ_CTRL: mmio.Mmio(packed struct(u32) {
                /// READ_FUSE
                READ_FUSE: u1,
                /// RSVD0
                RSVD0: u31,
            }),
            reserved64: [12]u8,
            /// OTP Controller Read Data Register
            READ_FUSE_DATA: mmio.Mmio(packed struct(u32) {
                /// DATA
                DATA: u32,
            }),
            reserved80: [12]u8,
            /// Sticky bit Register
            SW_STICKY: mmio.Mmio(packed struct(u32) {
                /// BLOCK_DTCP_KEY
                BLOCK_DTCP_KEY: u1,
                /// SRK_REVOKE_LOCK
                SRK_REVOKE_LOCK: u1,
                /// FIELD_RETURN_LOCK
                FIELD_RETURN_LOCK: u1,
                /// BLOCK_ROM_PART
                BLOCK_ROM_PART: u1,
                /// JTAG_BLOCK_RELEASE
                JTAG_BLOCK_RELEASE: u1,
                /// RSVD0
                RSVD0: u27,
            }),
            reserved96: [12]u8,
            /// Software Controllable Signals Register
            SCS: mmio.Mmio(packed struct(u32) {
                /// HAB_JDE
                HAB_JDE: u1,
                /// SPARE
                SPARE: u30,
                /// LOCK
                LOCK: u1,
            }),
            /// Software Controllable Signals Register
            SCS_SET: mmio.Mmio(packed struct(u32) {
                /// HAB_JDE
                HAB_JDE: u1,
                /// SPARE
                SPARE: u30,
                /// LOCK
                LOCK: u1,
            }),
            /// Software Controllable Signals Register
            SCS_CLR: mmio.Mmio(packed struct(u32) {
                /// HAB_JDE
                HAB_JDE: u1,
                /// SPARE
                SPARE: u30,
                /// LOCK
                LOCK: u1,
            }),
            /// Software Controllable Signals Register
            SCS_TOG: mmio.Mmio(packed struct(u32) {
                /// HAB_JDE
                HAB_JDE: u1,
                /// SPARE
                SPARE: u30,
                /// LOCK
                LOCK: u1,
            }),
            /// OTP Controller CRC test address
            CRC_ADDR: mmio.Mmio(packed struct(u32) {
                /// DATA_START_ADDR
                DATA_START_ADDR: u8,
                /// DATA_END_ADDR
                DATA_END_ADDR: u8,
                /// CRC_ADDR
                CRC_ADDR: u8,
                /// OTPMK_CRC
                OTPMK_CRC: u1,
                /// RSVD0
                RSVD0: u7,
            }),
            reserved128: [12]u8,
            /// OTP Controller CRC Value Register
            CRC_VALUE: mmio.Mmio(packed struct(u32) {
                /// DATA
                DATA: u32,
            }),
            reserved144: [12]u8,
            /// OTP Controller Version Register
            VERSION: mmio.Mmio(packed struct(u32) {
                /// STEP
                STEP: u16,
                /// MINOR
                MINOR: u8,
                /// MAJOR
                MAJOR: u8,
            }),
            reserved256: [108]u8,
            /// OTP Controller Timing Register
            TIMING2: mmio.Mmio(packed struct(u32) {
                /// RELAX_PROG
                RELAX_PROG: u12,
                /// RSRVD0
                RSRVD0: u4,
                /// RELAX_READ
                RELAX_READ: u6,
                /// RSRVD0
                RSRVD1: u10,
            }),
            reserved1024: [764]u8,
            /// Value of OTP Bank0 Word0 (Lock controls)
            LOCK: mmio.Mmio(packed struct(u32) {
                /// TESTER
                TESTER: u2,
                /// BOOT_CFG
                BOOT_CFG: u2,
                /// MEM_TRIM
                MEM_TRIM: u2,
                /// SJC_RESP
                SJC_RESP: u1,
                /// GP4_RLOCK
                GP4_RLOCK: u1,
                /// MAC_ADDR
                MAC_ADDR: u2,
                /// GP1
                GP1: u2,
                /// GP2
                GP2: u2,
                reserved15: u1 = 0,
                /// ROM_PATCH
                ROM_PATCH: u1,
                /// SW_GP1
                SW_GP1: u1,
                /// OTPMK
                OTPMK: u1,
                /// ANALOG
                ANALOG: u2,
                /// OTPMK_CRC
                OTPMK_CRC: u1,
                /// SW_GP2_LOCK
                SW_GP2_LOCK: u1,
                /// MISC_CONF
                MISC_CONF: u1,
                /// SW_GP2_RLOCK
                SW_GP2_RLOCK: u1,
                /// GP4
                GP4: u2,
                /// GP3
                GP3: u2,
                /// FIELD_RETURN
                FIELD_RETURN: u4,
            }),
            reserved1040: [12]u8,
            /// Value of OTP Bank0 Word1 (Configuration and Manufacturing Info.)
            CFG0: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1056: [12]u8,
            /// Value of OTP Bank0 Word2 (Configuration and Manufacturing Info.)
            CFG1: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1072: [12]u8,
            /// Value of OTP Bank0 Word3 (Configuration and Manufacturing Info.)
            CFG2: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1088: [12]u8,
            /// Value of OTP Bank0 Word4 (Configuration and Manufacturing Info.)
            CFG3: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1104: [12]u8,
            /// Value of OTP Bank0 Word5 (Configuration and Manufacturing Info.)
            CFG4: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1120: [12]u8,
            /// Value of OTP Bank0 Word6 (Configuration and Manufacturing Info.)
            CFG5: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1136: [12]u8,
            /// Value of OTP Bank0 Word7 (Configuration and Manufacturing Info.)
            CFG6: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1152: [12]u8,
            /// Value of OTP Bank1 Word0 (Memory Related Info.)
            MEM0: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1168: [12]u8,
            /// Value of OTP Bank1 Word1 (Memory Related Info.)
            MEM1: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1184: [12]u8,
            /// Value of OTP Bank1 Word2 (Memory Related Info.)
            MEM2: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1200: [12]u8,
            /// Value of OTP Bank1 Word3 (Memory Related Info.)
            MEM3: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1216: [12]u8,
            /// Value of OTP Bank1 Word4 (Memory Related Info.)
            MEM4: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1232: [12]u8,
            /// Value of OTP Bank1 Word5 (Memory Related Info.)
            ANA0: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1248: [12]u8,
            /// Value of OTP Bank1 Word6 (General Purpose Customer Defined Info.)
            ANA1: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1264: [12]u8,
            /// Value of OTP Bank1 Word7 (General Purpose Customer Defined Info.)
            ANA2: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1280: [12]u8,
            /// Value of OTP Bank2 Word0 (OTPMK Key)
            OTPMK0: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1296: [12]u8,
            /// Value of OTP Bank2 Word1 (OTPMK Key)
            OTPMK1: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1312: [12]u8,
            /// Value of OTP Bank2 Word2 (OTPMK Key)
            OTPMK2: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1328: [12]u8,
            /// Value of OTP Bank2 Word3 (OTPMK Key)
            OTPMK3: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1344: [12]u8,
            /// Value of OTP Bank2 Word4 (OTPMK Key)
            OTPMK4: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1360: [12]u8,
            /// Value of OTP Bank2 Word5 (OTPMK Key)
            OTPMK5: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1376: [12]u8,
            /// Value of OTP Bank2 Word6 (OTPMK Key)
            OTPMK6: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1392: [12]u8,
            /// Value of OTP Bank2 Word7 (OTPMK Key)
            OTPMK7: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1408: [12]u8,
            /// Shadow Register for OTP Bank3 Word0 (SRK Hash)
            SRK0: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1424: [12]u8,
            /// Shadow Register for OTP Bank3 Word1 (SRK Hash)
            SRK1: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1440: [12]u8,
            /// Shadow Register for OTP Bank3 Word2 (SRK Hash)
            SRK2: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1456: [12]u8,
            /// Shadow Register for OTP Bank3 Word3 (SRK Hash)
            SRK3: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1472: [12]u8,
            /// Shadow Register for OTP Bank3 Word4 (SRK Hash)
            SRK4: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1488: [12]u8,
            /// Shadow Register for OTP Bank3 Word5 (SRK Hash)
            SRK5: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1504: [12]u8,
            /// Shadow Register for OTP Bank3 Word6 (SRK Hash)
            SRK6: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1520: [12]u8,
            /// Shadow Register for OTP Bank3 Word7 (SRK Hash)
            SRK7: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1536: [12]u8,
            /// Value of OTP Bank4 Word0 (Secure JTAG Response Field)
            SJC_RESP0: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1552: [12]u8,
            /// Value of OTP Bank4 Word1 (Secure JTAG Response Field)
            SJC_RESP1: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1568: [12]u8,
            /// Value of OTP Bank4 Word2 (MAC Address)
            MAC0: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1584: [12]u8,
            /// Value of OTP Bank4 Word3 (MAC Address)
            MAC1: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1600: [12]u8,
            /// Value of OTP Bank4 Word4 (MAC2 Address)
            MAC2: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1616: [12]u8,
            /// Value of OTP Bank4 Word5 (CRC Key)
            OTPMK_CRC32: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1632: [12]u8,
            /// Value of OTP Bank4 Word6 (General Purpose Customer Defined Info)
            GP1: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1648: [12]u8,
            /// Value of OTP Bank4 Word7 (General Purpose Customer Defined Info)
            GP2: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1664: [12]u8,
            /// Value of OTP Bank5 Word0 (SW GP1)
            SW_GP1: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1680: [12]u8,
            /// Value of OTP Bank5 Word1 (SW GP2)
            SW_GP20: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1696: [12]u8,
            /// Value of OTP Bank5 Word2 (SW GP2)
            SW_GP21: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1712: [12]u8,
            /// Value of OTP Bank5 Word3 (SW GP2)
            SW_GP22: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1728: [12]u8,
            /// Value of OTP Bank5 Word4 (SW GP2)
            SW_GP23: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1744: [12]u8,
            /// Value of OTP Bank5 Word5 (Misc Conf)
            MISC_CONF0: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1760: [12]u8,
            /// Value of OTP Bank5 Word6 (Misc Conf)
            MISC_CONF1: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved1776: [12]u8,
            /// Value of OTP Bank5 Word7 (SRK Revoke)
            SRK_REVOKE: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved2048: [268]u8,
            /// Value of OTP Bank6 Word0 (ROM Patch)
            ROM_PATCH0: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved2064: [12]u8,
            /// Value of OTP Bank6 Word1 (ROM Patch)
            ROM_PATCH1: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved2080: [12]u8,
            /// Value of OTP Bank6 Word2 (ROM Patch)
            ROM_PATCH2: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved2096: [12]u8,
            /// Value of OTP Bank6 Word3 (ROM Patch)
            ROM_PATCH3: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved2112: [12]u8,
            /// Value of OTP Bank6 Word4 (ROM Patch)
            ROM_PATCH4: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved2128: [12]u8,
            /// Value of OTP Bank6 Word5 (ROM Patch)
            ROM_PATCH5: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved2144: [12]u8,
            /// Value of OTP Bank6 Word6 (ROM Patch)
            ROM_PATCH6: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved2160: [12]u8,
            /// Value of OTP Bank6 Word7 (ROM Patch)
            ROM_PATCH7: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved2176: [12]u8,
            /// Value of OTP Bank7 Word0 (GP3)
            GP30: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved2192: [12]u8,
            /// Value of OTP Bank7 Word1 (GP3)
            GP31: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved2208: [12]u8,
            /// Value of OTP Bank7 Word2 (GP3)
            GP32: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved2224: [12]u8,
            /// Value of OTP Bank7 Word3 (GP3)
            GP33: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved2240: [12]u8,
            /// Value of OTP Bank7 Word4 (GP4)
            GP40: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved2256: [12]u8,
            /// Value of OTP Bank7 Word5 (GP4)
            GP41: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved2272: [12]u8,
            /// Value of OTP Bank7 Word6 (GP4)
            GP42: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
            reserved2288: [12]u8,
            /// Value of OTP Bank7 Word7 (GP4)
            GP43: mmio.Mmio(packed struct(u32) {
                /// BITS
                BITS: u32,
            }),
        };

        /// PGC
        pub const PGC = extern struct {
            reserved544: [544]u8,
            /// PGC Mega Control Register
            MEGA_CTRL: mmio.Mmio(packed struct(u32) {
                /// Power Control PCR must not change from power-down request (pdn_req) assertion until the target subsystem is completely powered up
                PCR: enum(u1) {
                    /// Do not switch off power even if pdn_req is asserted.
                    PCR_0 = 0x0,
                    /// Switch off power when pdn_req is asserted.
                    PCR_1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// PGC Mega Power Up Sequence Control Register
            MEGA_PUPSCR: mmio.Mmio(packed struct(u32) {
                /// After a power-up request (pup_req assertion), the PGC waits a number of IPG clocks equal to the value of SW before asserting power toggle on/off signal (switch_b)
                SW: u6,
                reserved8: u2 = 0,
                /// After asserting power toggle on/off signal (switch_b), the PGC waits a number of IPG clocks equal to the value of SW2ISO before negating isolation
                SW2ISO: u6,
                padding: u18 = 0,
            }),
            /// PGC Mega Pull Down Sequence Control Register
            MEGA_PDNSCR: mmio.Mmio(packed struct(u32) {
                /// After a power-down request (pdn_req assertion), the PGC waits a number of IPG clocks equal to the value of ISO before asserting isolation
                ISO: u6,
                reserved8: u2 = 0,
                /// After asserting isolation, the PGC waits a number of IPG clocks equal to the value of ISO2SW before negating power toggle on/off signal (switch_b)
                ISO2SW: u6,
                padding: u18 = 0,
            }),
            /// PGC Mega Power Gating Controller Status Register
            MEGA_SR: mmio.Mmio(packed struct(u32) {
                /// Power status
                PSR: enum(u1) {
                    /// The target subsystem was not powered down for the previous power-down request.
                    PSR_0 = 0x0,
                    /// The target subsystem was powered down for the previous power-down request.
                    PSR_1 = 0x1,
                },
                padding: u31 = 0,
            }),
            reserved672: [112]u8,
            /// PGC CPU Control Register
            CPU_CTRL: mmio.Mmio(packed struct(u32) {
                /// Power Control PCR must not change from power-down request (pdn_req) assertion until the target subsystem is completely powered up
                PCR: enum(u1) {
                    /// Do not switch off power even if pdn_req is asserted.
                    PCR_0 = 0x0,
                    /// Switch off power when pdn_req is asserted.
                    PCR_1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// PGC CPU Power Up Sequence Control Register
            CPU_PUPSCR: mmio.Mmio(packed struct(u32) {
                /// There are two different silicon revisions: 1
                SW: u6,
                reserved8: u2 = 0,
                /// There are two different silicon revisions: 1
                SW2ISO: u6,
                padding: u18 = 0,
            }),
            /// PGC CPU Pull Down Sequence Control Register
            CPU_PDNSCR: mmio.Mmio(packed struct(u32) {
                /// After a power-down request (pdn_req assertion), the PGC waits a number of 32k clocks equal to the value of ISO before asserting isolation
                ISO: u6,
                reserved8: u2 = 0,
                /// After asserting isolation, the PGC waits a number of 32k clocks equal to the value of ISO2SW before negating
                ISO2SW: u6,
                padding: u18 = 0,
            }),
            /// PGC CPU Power Gating Controller Status Register
            CPU_SR: mmio.Mmio(packed struct(u32) {
                /// Power status
                PSR: enum(u1) {
                    /// The target subsystem was not powered down for the previous power-down request.
                    PSR_0 = 0x0,
                    /// The target subsystem was powered down for the previous power-down request.
                    PSR_1 = 0x1,
                },
                padding: u31 = 0,
            }),
        };

        /// PIT
        pub const PIT = extern struct {
            /// PIT Module Control Register
            MCR: mmio.Mmio(packed struct(u32) {
                /// Freeze
                FRZ: enum(u1) {
                    /// Timers continue to run in Debug mode.
                    FRZ_0 = 0x0,
                    /// Timers are stopped in Debug mode.
                    FRZ_1 = 0x1,
                },
                /// Module Disable - (PIT section)
                MDIS: enum(u1) {
                    /// Clock for standard PIT timers is enabled.
                    MDIS_0 = 0x0,
                    /// Clock for standard PIT timers is disabled.
                    MDIS_1 = 0x1,
                },
                padding: u30 = 0,
            }),
            reserved224: [220]u8,
            /// PIT Upper Lifetime Timer Register
            LTMR64H: mmio.Mmio(packed struct(u32) {
                /// Life Timer value
                LTH: u32,
            }),
            /// PIT Lower Lifetime Timer Register
            LTMR64L: mmio.Mmio(packed struct(u32) {
                /// Life Timer value
                LTL: u32,
            }),
        };

        /// PMU
        pub const PMU = extern struct {
            reserved272: [272]u8,
            /// Regulator 1P1 Register
            REG_1P1: mmio.Mmio(packed struct(u32) {
                /// Control bit to enable the regulator output.
                ENABLE_LINREG: u1,
                /// Control bit to enable the brownout circuitry in the regulator.
                ENABLE_BO: u1,
                /// Control bit to enable the current-limit circuitry in the regulator.
                ENABLE_ILIMIT: u1,
                /// Control bit to enable the pull-down circuitry in the regulator
                ENABLE_PULLDOWN: u1,
                /// Control bits to adjust the regulator brownout offset voltage in 25mV steps
                BO_OFFSET: u3,
                reserved8: u1 = 0,
                /// Control bits to adjust the regulator output voltage
                OUTPUT_TRG: enum(u5) {
                    /// 0.8V
                    OUTPUT_TRG_4 = 0x4,
                    /// 1.1V
                    OUTPUT_TRG_16 = 0x10,
                    _,
                },
                reserved16: u3 = 0,
                /// Status bit that signals when a brownout is detected on the regulator output.
                BO_VDD1P1: u1,
                /// Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
                OK_VDD1P1: u1,
                /// Enables the weak 1p1 regulator
                ENABLE_WEAK_LINREG: u1,
                /// Selects the source for the reference voltage of the weak 1p1 regulator.
                SELREF_WEAK_LINREG: enum(u1) {
                    /// Weak-linreg output tracks low-power-bandgap voltage
                    SELREF_WEAK_LINREG_0 = 0x0,
                    /// Weak-linreg output tracks VDD_SOC_IN voltage
                    SELREF_WEAK_LINREG_1 = 0x1,
                },
                padding: u12 = 0,
            }),
            /// Regulator 1P1 Register
            REG_1P1_SET: mmio.Mmio(packed struct(u32) {
                /// Control bit to enable the regulator output.
                ENABLE_LINREG: u1,
                /// Control bit to enable the brownout circuitry in the regulator.
                ENABLE_BO: u1,
                /// Control bit to enable the current-limit circuitry in the regulator.
                ENABLE_ILIMIT: u1,
                /// Control bit to enable the pull-down circuitry in the regulator
                ENABLE_PULLDOWN: u1,
                /// Control bits to adjust the regulator brownout offset voltage in 25mV steps
                BO_OFFSET: u3,
                reserved8: u1 = 0,
                /// Control bits to adjust the regulator output voltage
                OUTPUT_TRG: enum(u5) {
                    /// 0.8V
                    OUTPUT_TRG_4 = 0x4,
                    /// 1.1V
                    OUTPUT_TRG_16 = 0x10,
                    _,
                },
                reserved16: u3 = 0,
                /// Status bit that signals when a brownout is detected on the regulator output.
                BO_VDD1P1: u1,
                /// Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
                OK_VDD1P1: u1,
                /// Enables the weak 1p1 regulator
                ENABLE_WEAK_LINREG: u1,
                /// Selects the source for the reference voltage of the weak 1p1 regulator.
                SELREF_WEAK_LINREG: enum(u1) {
                    /// Weak-linreg output tracks low-power-bandgap voltage
                    SELREF_WEAK_LINREG_0 = 0x0,
                    /// Weak-linreg output tracks VDD_SOC_IN voltage
                    SELREF_WEAK_LINREG_1 = 0x1,
                },
                padding: u12 = 0,
            }),
            /// Regulator 1P1 Register
            REG_1P1_CLR: mmio.Mmio(packed struct(u32) {
                /// Control bit to enable the regulator output.
                ENABLE_LINREG: u1,
                /// Control bit to enable the brownout circuitry in the regulator.
                ENABLE_BO: u1,
                /// Control bit to enable the current-limit circuitry in the regulator.
                ENABLE_ILIMIT: u1,
                /// Control bit to enable the pull-down circuitry in the regulator
                ENABLE_PULLDOWN: u1,
                /// Control bits to adjust the regulator brownout offset voltage in 25mV steps
                BO_OFFSET: u3,
                reserved8: u1 = 0,
                /// Control bits to adjust the regulator output voltage
                OUTPUT_TRG: enum(u5) {
                    /// 0.8V
                    OUTPUT_TRG_4 = 0x4,
                    /// 1.1V
                    OUTPUT_TRG_16 = 0x10,
                    _,
                },
                reserved16: u3 = 0,
                /// Status bit that signals when a brownout is detected on the regulator output.
                BO_VDD1P1: u1,
                /// Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
                OK_VDD1P1: u1,
                /// Enables the weak 1p1 regulator
                ENABLE_WEAK_LINREG: u1,
                /// Selects the source for the reference voltage of the weak 1p1 regulator.
                SELREF_WEAK_LINREG: enum(u1) {
                    /// Weak-linreg output tracks low-power-bandgap voltage
                    SELREF_WEAK_LINREG_0 = 0x0,
                    /// Weak-linreg output tracks VDD_SOC_IN voltage
                    SELREF_WEAK_LINREG_1 = 0x1,
                },
                padding: u12 = 0,
            }),
            /// Regulator 1P1 Register
            REG_1P1_TOG: mmio.Mmio(packed struct(u32) {
                /// Control bit to enable the regulator output.
                ENABLE_LINREG: u1,
                /// Control bit to enable the brownout circuitry in the regulator.
                ENABLE_BO: u1,
                /// Control bit to enable the current-limit circuitry in the regulator.
                ENABLE_ILIMIT: u1,
                /// Control bit to enable the pull-down circuitry in the regulator
                ENABLE_PULLDOWN: u1,
                /// Control bits to adjust the regulator brownout offset voltage in 25mV steps
                BO_OFFSET: u3,
                reserved8: u1 = 0,
                /// Control bits to adjust the regulator output voltage
                OUTPUT_TRG: enum(u5) {
                    /// 0.8V
                    OUTPUT_TRG_4 = 0x4,
                    /// 1.1V
                    OUTPUT_TRG_16 = 0x10,
                    _,
                },
                reserved16: u3 = 0,
                /// Status bit that signals when a brownout is detected on the regulator output.
                BO_VDD1P1: u1,
                /// Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
                OK_VDD1P1: u1,
                /// Enables the weak 1p1 regulator
                ENABLE_WEAK_LINREG: u1,
                /// Selects the source for the reference voltage of the weak 1p1 regulator.
                SELREF_WEAK_LINREG: enum(u1) {
                    /// Weak-linreg output tracks low-power-bandgap voltage
                    SELREF_WEAK_LINREG_0 = 0x0,
                    /// Weak-linreg output tracks VDD_SOC_IN voltage
                    SELREF_WEAK_LINREG_1 = 0x1,
                },
                padding: u12 = 0,
            }),
            /// Regulator 3P0 Register
            REG_3P0: mmio.Mmio(packed struct(u32) {
                /// Control bit to enable the regulator output to be set by the programmed target voltage setting and internal bandgap reference
                ENABLE_LINREG: u1,
                /// Control bit to enable the brownout circuitry in the regulator.
                ENABLE_BO: u1,
                /// Control bit to enable the current-limit circuitry in the regulator.
                ENABLE_ILIMIT: u1,
                reserved4: u1 = 0,
                /// Control bits to adjust the regulator brownout offset voltage in 25mV steps
                BO_OFFSET: u3,
                /// Select input voltage source for LDO_3P0 from either USB_OTG1_VBUS or USB_OTG2_VBUS
                VBUS_SEL: enum(u1) {
                    /// Utilize VBUS OTG2 power
                    USB_OTG2_VBUS = 0x0,
                    /// Utilize VBUS OTG1 power
                    USB_OTG1_VBUS = 0x1,
                },
                /// Control bits to adjust the regulator output voltage
                OUTPUT_TRG: enum(u5) {
                    /// 2.625V
                    OUTPUT_TRG_0 = 0x0,
                    /// 3.000V
                    OUTPUT_TRG_15 = 0xf,
                    /// 3.400V
                    OUTPUT_TRG_31 = 0x1f,
                    _,
                },
                reserved16: u3 = 0,
                /// Status bit that signals when a brownout is detected on the regulator output.
                BO_VDD3P0: u1,
                /// Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
                OK_VDD3P0: u1,
                padding: u14 = 0,
            }),
            /// Regulator 3P0 Register
            REG_3P0_SET: mmio.Mmio(packed struct(u32) {
                /// Control bit to enable the regulator output to be set by the programmed target voltage setting and internal bandgap reference
                ENABLE_LINREG: u1,
                /// Control bit to enable the brownout circuitry in the regulator.
                ENABLE_BO: u1,
                /// Control bit to enable the current-limit circuitry in the regulator.
                ENABLE_ILIMIT: u1,
                reserved4: u1 = 0,
                /// Control bits to adjust the regulator brownout offset voltage in 25mV steps
                BO_OFFSET: u3,
                /// Select input voltage source for LDO_3P0 from either USB_OTG1_VBUS or USB_OTG2_VBUS
                VBUS_SEL: enum(u1) {
                    /// Utilize VBUS OTG2 power
                    USB_OTG2_VBUS = 0x0,
                    /// Utilize VBUS OTG1 power
                    USB_OTG1_VBUS = 0x1,
                },
                /// Control bits to adjust the regulator output voltage
                OUTPUT_TRG: enum(u5) {
                    /// 2.625V
                    OUTPUT_TRG_0 = 0x0,
                    /// 3.000V
                    OUTPUT_TRG_15 = 0xf,
                    /// 3.400V
                    OUTPUT_TRG_31 = 0x1f,
                    _,
                },
                reserved16: u3 = 0,
                /// Status bit that signals when a brownout is detected on the regulator output.
                BO_VDD3P0: u1,
                /// Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
                OK_VDD3P0: u1,
                padding: u14 = 0,
            }),
            /// Regulator 3P0 Register
            REG_3P0_CLR: mmio.Mmio(packed struct(u32) {
                /// Control bit to enable the regulator output to be set by the programmed target voltage setting and internal bandgap reference
                ENABLE_LINREG: u1,
                /// Control bit to enable the brownout circuitry in the regulator.
                ENABLE_BO: u1,
                /// Control bit to enable the current-limit circuitry in the regulator.
                ENABLE_ILIMIT: u1,
                reserved4: u1 = 0,
                /// Control bits to adjust the regulator brownout offset voltage in 25mV steps
                BO_OFFSET: u3,
                /// Select input voltage source for LDO_3P0 from either USB_OTG1_VBUS or USB_OTG2_VBUS
                VBUS_SEL: enum(u1) {
                    /// Utilize VBUS OTG2 power
                    USB_OTG2_VBUS = 0x0,
                    /// Utilize VBUS OTG1 power
                    USB_OTG1_VBUS = 0x1,
                },
                /// Control bits to adjust the regulator output voltage
                OUTPUT_TRG: enum(u5) {
                    /// 2.625V
                    OUTPUT_TRG_0 = 0x0,
                    /// 3.000V
                    OUTPUT_TRG_15 = 0xf,
                    /// 3.400V
                    OUTPUT_TRG_31 = 0x1f,
                    _,
                },
                reserved16: u3 = 0,
                /// Status bit that signals when a brownout is detected on the regulator output.
                BO_VDD3P0: u1,
                /// Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
                OK_VDD3P0: u1,
                padding: u14 = 0,
            }),
            /// Regulator 3P0 Register
            REG_3P0_TOG: mmio.Mmio(packed struct(u32) {
                /// Control bit to enable the regulator output to be set by the programmed target voltage setting and internal bandgap reference
                ENABLE_LINREG: u1,
                /// Control bit to enable the brownout circuitry in the regulator.
                ENABLE_BO: u1,
                /// Control bit to enable the current-limit circuitry in the regulator.
                ENABLE_ILIMIT: u1,
                reserved4: u1 = 0,
                /// Control bits to adjust the regulator brownout offset voltage in 25mV steps
                BO_OFFSET: u3,
                /// Select input voltage source for LDO_3P0 from either USB_OTG1_VBUS or USB_OTG2_VBUS
                VBUS_SEL: enum(u1) {
                    /// Utilize VBUS OTG2 power
                    USB_OTG2_VBUS = 0x0,
                    /// Utilize VBUS OTG1 power
                    USB_OTG1_VBUS = 0x1,
                },
                /// Control bits to adjust the regulator output voltage
                OUTPUT_TRG: enum(u5) {
                    /// 2.625V
                    OUTPUT_TRG_0 = 0x0,
                    /// 3.000V
                    OUTPUT_TRG_15 = 0xf,
                    /// 3.400V
                    OUTPUT_TRG_31 = 0x1f,
                    _,
                },
                reserved16: u3 = 0,
                /// Status bit that signals when a brownout is detected on the regulator output.
                BO_VDD3P0: u1,
                /// Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
                OK_VDD3P0: u1,
                padding: u14 = 0,
            }),
            /// Regulator 2P5 Register
            REG_2P5: mmio.Mmio(packed struct(u32) {
                /// Control bit to enable the regulator output.
                ENABLE_LINREG: u1,
                /// Control bit to enable the brownout circuitry in the regulator.
                ENABLE_BO: u1,
                /// Control bit to enable the current-limit circuitry in the regulator.
                ENABLE_ILIMIT: u1,
                /// Control bit to enable the pull-down circuitry in the regulator
                ENABLE_PULLDOWN: u1,
                /// Control bits to adjust the regulator brownout offset voltage in 25mV steps
                BO_OFFSET: u3,
                reserved8: u1 = 0,
                /// Control bits to adjust the regulator output voltage
                OUTPUT_TRG: enum(u5) {
                    /// 2.10V
                    OUTPUT_TRG_0 = 0x0,
                    /// 2.50V
                    OUTPUT_TRG_16 = 0x10,
                    /// 2.875V
                    OUTPUT_TRG_31 = 0x1f,
                    _,
                },
                reserved16: u3 = 0,
                /// Status bit that signals when a brownout is detected on the regulator output.
                BO_VDD2P5: u1,
                /// Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
                OK_VDD2P5: u1,
                /// Enables the weak 2p5 regulator
                ENABLE_WEAK_LINREG: u1,
                padding: u13 = 0,
            }),
            /// Regulator 2P5 Register
            REG_2P5_SET: mmio.Mmio(packed struct(u32) {
                /// Control bit to enable the regulator output.
                ENABLE_LINREG: u1,
                /// Control bit to enable the brownout circuitry in the regulator.
                ENABLE_BO: u1,
                /// Control bit to enable the current-limit circuitry in the regulator.
                ENABLE_ILIMIT: u1,
                /// Control bit to enable the pull-down circuitry in the regulator
                ENABLE_PULLDOWN: u1,
                /// Control bits to adjust the regulator brownout offset voltage in 25mV steps
                BO_OFFSET: u3,
                reserved8: u1 = 0,
                /// Control bits to adjust the regulator output voltage
                OUTPUT_TRG: enum(u5) {
                    /// 2.10V
                    OUTPUT_TRG_0 = 0x0,
                    /// 2.50V
                    OUTPUT_TRG_16 = 0x10,
                    /// 2.875V
                    OUTPUT_TRG_31 = 0x1f,
                    _,
                },
                reserved16: u3 = 0,
                /// Status bit that signals when a brownout is detected on the regulator output.
                BO_VDD2P5: u1,
                /// Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
                OK_VDD2P5: u1,
                /// Enables the weak 2p5 regulator
                ENABLE_WEAK_LINREG: u1,
                padding: u13 = 0,
            }),
            /// Regulator 2P5 Register
            REG_2P5_CLR: mmio.Mmio(packed struct(u32) {
                /// Control bit to enable the regulator output.
                ENABLE_LINREG: u1,
                /// Control bit to enable the brownout circuitry in the regulator.
                ENABLE_BO: u1,
                /// Control bit to enable the current-limit circuitry in the regulator.
                ENABLE_ILIMIT: u1,
                /// Control bit to enable the pull-down circuitry in the regulator
                ENABLE_PULLDOWN: u1,
                /// Control bits to adjust the regulator brownout offset voltage in 25mV steps
                BO_OFFSET: u3,
                reserved8: u1 = 0,
                /// Control bits to adjust the regulator output voltage
                OUTPUT_TRG: enum(u5) {
                    /// 2.10V
                    OUTPUT_TRG_0 = 0x0,
                    /// 2.50V
                    OUTPUT_TRG_16 = 0x10,
                    /// 2.875V
                    OUTPUT_TRG_31 = 0x1f,
                    _,
                },
                reserved16: u3 = 0,
                /// Status bit that signals when a brownout is detected on the regulator output.
                BO_VDD2P5: u1,
                /// Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
                OK_VDD2P5: u1,
                /// Enables the weak 2p5 regulator
                ENABLE_WEAK_LINREG: u1,
                padding: u13 = 0,
            }),
            /// Regulator 2P5 Register
            REG_2P5_TOG: mmio.Mmio(packed struct(u32) {
                /// Control bit to enable the regulator output.
                ENABLE_LINREG: u1,
                /// Control bit to enable the brownout circuitry in the regulator.
                ENABLE_BO: u1,
                /// Control bit to enable the current-limit circuitry in the regulator.
                ENABLE_ILIMIT: u1,
                /// Control bit to enable the pull-down circuitry in the regulator
                ENABLE_PULLDOWN: u1,
                /// Control bits to adjust the regulator brownout offset voltage in 25mV steps
                BO_OFFSET: u3,
                reserved8: u1 = 0,
                /// Control bits to adjust the regulator output voltage
                OUTPUT_TRG: enum(u5) {
                    /// 2.10V
                    OUTPUT_TRG_0 = 0x0,
                    /// 2.50V
                    OUTPUT_TRG_16 = 0x10,
                    /// 2.875V
                    OUTPUT_TRG_31 = 0x1f,
                    _,
                },
                reserved16: u3 = 0,
                /// Status bit that signals when a brownout is detected on the regulator output.
                BO_VDD2P5: u1,
                /// Status bit that signals when the regulator output is ok. 1 = regulator output > brownout target
                OK_VDD2P5: u1,
                /// Enables the weak 2p5 regulator
                ENABLE_WEAK_LINREG: u1,
                padding: u13 = 0,
            }),
            /// Digital Regulator Core Register
            REG_CORE: mmio.Mmio(packed struct(u32) {
                /// This field defines the target voltage for the ARM core power domain
                REG0_TARG: enum(u5) {
                    /// Power gated off
                    REG0_TARG_0 = 0x0,
                    /// Target core voltage = 0.725V
                    REG0_TARG_1 = 0x1,
                    /// Target core voltage = 0.750V
                    REG0_TARG_2 = 0x2,
                    /// Target core voltage = 0.775V
                    REG0_TARG_3 = 0x3,
                    /// Target core voltage = 1.100V
                    REG0_TARG_16 = 0x10,
                    /// Target core voltage = 1.450V
                    REG0_TARG_30 = 0x1e,
                    /// Power FET switched full on. No regulation.
                    REG0_TARG_31 = 0x1f,
                    _,
                },
                /// This bit field defines the adjustment bits to calibrate the target value of Reg0. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
                REG0_ADJ: enum(u4) {
                    /// No adjustment
                    REG0_ADJ_0 = 0x0,
                    /// + 0.25%
                    REG0_ADJ_1 = 0x1,
                    /// + 0.50%
                    REG0_ADJ_2 = 0x2,
                    /// + 0.75%
                    REG0_ADJ_3 = 0x3,
                    /// + 1.00%
                    REG0_ADJ_4 = 0x4,
                    /// + 1.25%
                    REG0_ADJ_5 = 0x5,
                    /// + 1.50%
                    REG0_ADJ_6 = 0x6,
                    /// + 1.75%
                    REG0_ADJ_7 = 0x7,
                    /// - 0.25%
                    REG0_ADJ_8 = 0x8,
                    /// - 0.50%
                    REG0_ADJ_9 = 0x9,
                    /// - 0.75%
                    REG0_ADJ_10 = 0xa,
                    /// - 1.00%
                    REG0_ADJ_11 = 0xb,
                    /// - 1.25%
                    REG0_ADJ_12 = 0xc,
                    /// - 1.50%
                    REG0_ADJ_13 = 0xd,
                    /// - 1.75%
                    REG0_ADJ_14 = 0xe,
                    /// - 2.00%
                    REG0_ADJ_15 = 0xf,
                },
                /// This bit field defines the target voltage for the vpu/gpu power domain. Single bit increments reflect 25mV core voltage steps. Not all steps will make sense to use either because of input supply limitations or load operation.
                REG1_TARG: enum(u5) {
                    /// Power gated off
                    REG1_TARG_0 = 0x0,
                    /// Target core voltage = 0.725V
                    REG1_TARG_1 = 0x1,
                    /// Target core voltage = 0.750V
                    REG1_TARG_2 = 0x2,
                    /// Target core voltage = 0.775V
                    REG1_TARG_3 = 0x3,
                    /// Target core voltage = 1.100V
                    REG1_TARG_16 = 0x10,
                    /// Target core voltage = 1.450V
                    REG1_TARG_30 = 0x1e,
                    /// Power FET switched full on. No regulation.
                    REG1_TARG_31 = 0x1f,
                    _,
                },
                /// This bit field defines the adjustment bits to calibrate the target value of Reg1. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
                REG1_ADJ: enum(u4) {
                    /// No adjustment
                    REG1_ADJ_0 = 0x0,
                    /// + 0.25%
                    REG1_ADJ_1 = 0x1,
                    /// + 0.50%
                    REG1_ADJ_2 = 0x2,
                    /// + 0.75%
                    REG1_ADJ_3 = 0x3,
                    /// + 1.00%
                    REG1_ADJ_4 = 0x4,
                    /// + 1.25%
                    REG1_ADJ_5 = 0x5,
                    /// + 1.50%
                    REG1_ADJ_6 = 0x6,
                    /// + 1.75%
                    REG1_ADJ_7 = 0x7,
                    /// - 0.25%
                    REG1_ADJ_8 = 0x8,
                    /// - 0.50%
                    REG1_ADJ_9 = 0x9,
                    /// - 0.75%
                    REG1_ADJ_10 = 0xa,
                    /// - 1.00%
                    REG1_ADJ_11 = 0xb,
                    /// - 1.25%
                    REG1_ADJ_12 = 0xc,
                    /// - 1.50%
                    REG1_ADJ_13 = 0xd,
                    /// - 1.75%
                    REG1_ADJ_14 = 0xe,
                    /// - 2.00%
                    REG1_ADJ_15 = 0xf,
                },
                /// This field defines the target voltage for the SOC power domain
                REG2_TARG: enum(u5) {
                    /// Power gated off
                    REG2_TARG_0 = 0x0,
                    /// Target core voltage = 0.725V
                    REG2_TARG_1 = 0x1,
                    /// Target core voltage = 0.750V
                    REG2_TARG_2 = 0x2,
                    /// Target core voltage = 0.775V
                    REG2_TARG_3 = 0x3,
                    /// Target core voltage = 1.100V
                    REG2_TARG_16 = 0x10,
                    /// Target core voltage = 1.450V
                    REG2_TARG_30 = 0x1e,
                    /// Power FET switched full on. No regulation.
                    REG2_TARG_31 = 0x1f,
                    _,
                },
                /// This bit field defines the adjustment bits to calibrate the target value of Reg2. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
                REG2_ADJ: enum(u4) {
                    /// No adjustment
                    REG2_ADJ_0 = 0x0,
                    /// + 0.25%
                    REG2_ADJ_1 = 0x1,
                    /// + 0.50%
                    REG2_ADJ_2 = 0x2,
                    /// + 0.75%
                    REG2_ADJ_3 = 0x3,
                    /// + 1.00%
                    REG2_ADJ_4 = 0x4,
                    /// + 1.25%
                    REG2_ADJ_5 = 0x5,
                    /// + 1.50%
                    REG2_ADJ_6 = 0x6,
                    /// + 1.75%
                    REG2_ADJ_7 = 0x7,
                    /// - 0.25%
                    REG2_ADJ_8 = 0x8,
                    /// - 0.50%
                    REG2_ADJ_9 = 0x9,
                    /// - 0.75%
                    REG2_ADJ_10 = 0xa,
                    /// - 1.00%
                    REG2_ADJ_11 = 0xb,
                    /// - 1.25%
                    REG2_ADJ_12 = 0xc,
                    /// - 1.50%
                    REG2_ADJ_13 = 0xd,
                    /// - 1.75%
                    REG2_ADJ_14 = 0xe,
                    /// - 2.00%
                    REG2_ADJ_15 = 0xf,
                },
                /// Regulator voltage ramp rate.
                RAMP_RATE: enum(u2) {
                    /// Fast
                    RAMP_RATE_0 = 0x0,
                    /// Medium Fast
                    RAMP_RATE_1 = 0x1,
                    /// Medium Slow
                    RAMP_RATE_2 = 0x2,
                    /// Slow
                    RAMP_RATE_3 = 0x3,
                },
                /// If set, increases the gate drive on power gating FETs to reduce leakage in the off state
                FET_ODRIVE: u1,
                padding: u2 = 0,
            }),
            /// Digital Regulator Core Register
            REG_CORE_SET: mmio.Mmio(packed struct(u32) {
                /// This field defines the target voltage for the ARM core power domain
                REG0_TARG: enum(u5) {
                    /// Power gated off
                    REG0_TARG_0 = 0x0,
                    /// Target core voltage = 0.725V
                    REG0_TARG_1 = 0x1,
                    /// Target core voltage = 0.750V
                    REG0_TARG_2 = 0x2,
                    /// Target core voltage = 0.775V
                    REG0_TARG_3 = 0x3,
                    /// Target core voltage = 1.100V
                    REG0_TARG_16 = 0x10,
                    /// Target core voltage = 1.450V
                    REG0_TARG_30 = 0x1e,
                    /// Power FET switched full on. No regulation.
                    REG0_TARG_31 = 0x1f,
                    _,
                },
                /// This bit field defines the adjustment bits to calibrate the target value of Reg0. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
                REG0_ADJ: enum(u4) {
                    /// No adjustment
                    REG0_ADJ_0 = 0x0,
                    /// + 0.25%
                    REG0_ADJ_1 = 0x1,
                    /// + 0.50%
                    REG0_ADJ_2 = 0x2,
                    /// + 0.75%
                    REG0_ADJ_3 = 0x3,
                    /// + 1.00%
                    REG0_ADJ_4 = 0x4,
                    /// + 1.25%
                    REG0_ADJ_5 = 0x5,
                    /// + 1.50%
                    REG0_ADJ_6 = 0x6,
                    /// + 1.75%
                    REG0_ADJ_7 = 0x7,
                    /// - 0.25%
                    REG0_ADJ_8 = 0x8,
                    /// - 0.50%
                    REG0_ADJ_9 = 0x9,
                    /// - 0.75%
                    REG0_ADJ_10 = 0xa,
                    /// - 1.00%
                    REG0_ADJ_11 = 0xb,
                    /// - 1.25%
                    REG0_ADJ_12 = 0xc,
                    /// - 1.50%
                    REG0_ADJ_13 = 0xd,
                    /// - 1.75%
                    REG0_ADJ_14 = 0xe,
                    /// - 2.00%
                    REG0_ADJ_15 = 0xf,
                },
                /// This bit field defines the target voltage for the vpu/gpu power domain. Single bit increments reflect 25mV core voltage steps. Not all steps will make sense to use either because of input supply limitations or load operation.
                REG1_TARG: enum(u5) {
                    /// Power gated off
                    REG1_TARG_0 = 0x0,
                    /// Target core voltage = 0.725V
                    REG1_TARG_1 = 0x1,
                    /// Target core voltage = 0.750V
                    REG1_TARG_2 = 0x2,
                    /// Target core voltage = 0.775V
                    REG1_TARG_3 = 0x3,
                    /// Target core voltage = 1.100V
                    REG1_TARG_16 = 0x10,
                    /// Target core voltage = 1.450V
                    REG1_TARG_30 = 0x1e,
                    /// Power FET switched full on. No regulation.
                    REG1_TARG_31 = 0x1f,
                    _,
                },
                /// This bit field defines the adjustment bits to calibrate the target value of Reg1. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
                REG1_ADJ: enum(u4) {
                    /// No adjustment
                    REG1_ADJ_0 = 0x0,
                    /// + 0.25%
                    REG1_ADJ_1 = 0x1,
                    /// + 0.50%
                    REG1_ADJ_2 = 0x2,
                    /// + 0.75%
                    REG1_ADJ_3 = 0x3,
                    /// + 1.00%
                    REG1_ADJ_4 = 0x4,
                    /// + 1.25%
                    REG1_ADJ_5 = 0x5,
                    /// + 1.50%
                    REG1_ADJ_6 = 0x6,
                    /// + 1.75%
                    REG1_ADJ_7 = 0x7,
                    /// - 0.25%
                    REG1_ADJ_8 = 0x8,
                    /// - 0.50%
                    REG1_ADJ_9 = 0x9,
                    /// - 0.75%
                    REG1_ADJ_10 = 0xa,
                    /// - 1.00%
                    REG1_ADJ_11 = 0xb,
                    /// - 1.25%
                    REG1_ADJ_12 = 0xc,
                    /// - 1.50%
                    REG1_ADJ_13 = 0xd,
                    /// - 1.75%
                    REG1_ADJ_14 = 0xe,
                    /// - 2.00%
                    REG1_ADJ_15 = 0xf,
                },
                /// This field defines the target voltage for the SOC power domain
                REG2_TARG: enum(u5) {
                    /// Power gated off
                    REG2_TARG_0 = 0x0,
                    /// Target core voltage = 0.725V
                    REG2_TARG_1 = 0x1,
                    /// Target core voltage = 0.750V
                    REG2_TARG_2 = 0x2,
                    /// Target core voltage = 0.775V
                    REG2_TARG_3 = 0x3,
                    /// Target core voltage = 1.100V
                    REG2_TARG_16 = 0x10,
                    /// Target core voltage = 1.450V
                    REG2_TARG_30 = 0x1e,
                    /// Power FET switched full on. No regulation.
                    REG2_TARG_31 = 0x1f,
                    _,
                },
                /// This bit field defines the adjustment bits to calibrate the target value of Reg2. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
                REG2_ADJ: enum(u4) {
                    /// No adjustment
                    REG2_ADJ_0 = 0x0,
                    /// + 0.25%
                    REG2_ADJ_1 = 0x1,
                    /// + 0.50%
                    REG2_ADJ_2 = 0x2,
                    /// + 0.75%
                    REG2_ADJ_3 = 0x3,
                    /// + 1.00%
                    REG2_ADJ_4 = 0x4,
                    /// + 1.25%
                    REG2_ADJ_5 = 0x5,
                    /// + 1.50%
                    REG2_ADJ_6 = 0x6,
                    /// + 1.75%
                    REG2_ADJ_7 = 0x7,
                    /// - 0.25%
                    REG2_ADJ_8 = 0x8,
                    /// - 0.50%
                    REG2_ADJ_9 = 0x9,
                    /// - 0.75%
                    REG2_ADJ_10 = 0xa,
                    /// - 1.00%
                    REG2_ADJ_11 = 0xb,
                    /// - 1.25%
                    REG2_ADJ_12 = 0xc,
                    /// - 1.50%
                    REG2_ADJ_13 = 0xd,
                    /// - 1.75%
                    REG2_ADJ_14 = 0xe,
                    /// - 2.00%
                    REG2_ADJ_15 = 0xf,
                },
                /// Regulator voltage ramp rate.
                RAMP_RATE: enum(u2) {
                    /// Fast
                    RAMP_RATE_0 = 0x0,
                    /// Medium Fast
                    RAMP_RATE_1 = 0x1,
                    /// Medium Slow
                    RAMP_RATE_2 = 0x2,
                    /// Slow
                    RAMP_RATE_3 = 0x3,
                },
                /// If set, increases the gate drive on power gating FETs to reduce leakage in the off state
                FET_ODRIVE: u1,
                padding: u2 = 0,
            }),
            /// Digital Regulator Core Register
            REG_CORE_CLR: mmio.Mmio(packed struct(u32) {
                /// This field defines the target voltage for the ARM core power domain
                REG0_TARG: enum(u5) {
                    /// Power gated off
                    REG0_TARG_0 = 0x0,
                    /// Target core voltage = 0.725V
                    REG0_TARG_1 = 0x1,
                    /// Target core voltage = 0.750V
                    REG0_TARG_2 = 0x2,
                    /// Target core voltage = 0.775V
                    REG0_TARG_3 = 0x3,
                    /// Target core voltage = 1.100V
                    REG0_TARG_16 = 0x10,
                    /// Target core voltage = 1.450V
                    REG0_TARG_30 = 0x1e,
                    /// Power FET switched full on. No regulation.
                    REG0_TARG_31 = 0x1f,
                    _,
                },
                /// This bit field defines the adjustment bits to calibrate the target value of Reg0. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
                REG0_ADJ: enum(u4) {
                    /// No adjustment
                    REG0_ADJ_0 = 0x0,
                    /// + 0.25%
                    REG0_ADJ_1 = 0x1,
                    /// + 0.50%
                    REG0_ADJ_2 = 0x2,
                    /// + 0.75%
                    REG0_ADJ_3 = 0x3,
                    /// + 1.00%
                    REG0_ADJ_4 = 0x4,
                    /// + 1.25%
                    REG0_ADJ_5 = 0x5,
                    /// + 1.50%
                    REG0_ADJ_6 = 0x6,
                    /// + 1.75%
                    REG0_ADJ_7 = 0x7,
                    /// - 0.25%
                    REG0_ADJ_8 = 0x8,
                    /// - 0.50%
                    REG0_ADJ_9 = 0x9,
                    /// - 0.75%
                    REG0_ADJ_10 = 0xa,
                    /// - 1.00%
                    REG0_ADJ_11 = 0xb,
                    /// - 1.25%
                    REG0_ADJ_12 = 0xc,
                    /// - 1.50%
                    REG0_ADJ_13 = 0xd,
                    /// - 1.75%
                    REG0_ADJ_14 = 0xe,
                    /// - 2.00%
                    REG0_ADJ_15 = 0xf,
                },
                /// This bit field defines the target voltage for the vpu/gpu power domain. Single bit increments reflect 25mV core voltage steps. Not all steps will make sense to use either because of input supply limitations or load operation.
                REG1_TARG: enum(u5) {
                    /// Power gated off
                    REG1_TARG_0 = 0x0,
                    /// Target core voltage = 0.725V
                    REG1_TARG_1 = 0x1,
                    /// Target core voltage = 0.750V
                    REG1_TARG_2 = 0x2,
                    /// Target core voltage = 0.775V
                    REG1_TARG_3 = 0x3,
                    /// Target core voltage = 1.100V
                    REG1_TARG_16 = 0x10,
                    /// Target core voltage = 1.450V
                    REG1_TARG_30 = 0x1e,
                    /// Power FET switched full on. No regulation.
                    REG1_TARG_31 = 0x1f,
                    _,
                },
                /// This bit field defines the adjustment bits to calibrate the target value of Reg1. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
                REG1_ADJ: enum(u4) {
                    /// No adjustment
                    REG1_ADJ_0 = 0x0,
                    /// + 0.25%
                    REG1_ADJ_1 = 0x1,
                    /// + 0.50%
                    REG1_ADJ_2 = 0x2,
                    /// + 0.75%
                    REG1_ADJ_3 = 0x3,
                    /// + 1.00%
                    REG1_ADJ_4 = 0x4,
                    /// + 1.25%
                    REG1_ADJ_5 = 0x5,
                    /// + 1.50%
                    REG1_ADJ_6 = 0x6,
                    /// + 1.75%
                    REG1_ADJ_7 = 0x7,
                    /// - 0.25%
                    REG1_ADJ_8 = 0x8,
                    /// - 0.50%
                    REG1_ADJ_9 = 0x9,
                    /// - 0.75%
                    REG1_ADJ_10 = 0xa,
                    /// - 1.00%
                    REG1_ADJ_11 = 0xb,
                    /// - 1.25%
                    REG1_ADJ_12 = 0xc,
                    /// - 1.50%
                    REG1_ADJ_13 = 0xd,
                    /// - 1.75%
                    REG1_ADJ_14 = 0xe,
                    /// - 2.00%
                    REG1_ADJ_15 = 0xf,
                },
                /// This field defines the target voltage for the SOC power domain
                REG2_TARG: enum(u5) {
                    /// Power gated off
                    REG2_TARG_0 = 0x0,
                    /// Target core voltage = 0.725V
                    REG2_TARG_1 = 0x1,
                    /// Target core voltage = 0.750V
                    REG2_TARG_2 = 0x2,
                    /// Target core voltage = 0.775V
                    REG2_TARG_3 = 0x3,
                    /// Target core voltage = 1.100V
                    REG2_TARG_16 = 0x10,
                    /// Target core voltage = 1.450V
                    REG2_TARG_30 = 0x1e,
                    /// Power FET switched full on. No regulation.
                    REG2_TARG_31 = 0x1f,
                    _,
                },
                /// This bit field defines the adjustment bits to calibrate the target value of Reg2. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
                REG2_ADJ: enum(u4) {
                    /// No adjustment
                    REG2_ADJ_0 = 0x0,
                    /// + 0.25%
                    REG2_ADJ_1 = 0x1,
                    /// + 0.50%
                    REG2_ADJ_2 = 0x2,
                    /// + 0.75%
                    REG2_ADJ_3 = 0x3,
                    /// + 1.00%
                    REG2_ADJ_4 = 0x4,
                    /// + 1.25%
                    REG2_ADJ_5 = 0x5,
                    /// + 1.50%
                    REG2_ADJ_6 = 0x6,
                    /// + 1.75%
                    REG2_ADJ_7 = 0x7,
                    /// - 0.25%
                    REG2_ADJ_8 = 0x8,
                    /// - 0.50%
                    REG2_ADJ_9 = 0x9,
                    /// - 0.75%
                    REG2_ADJ_10 = 0xa,
                    /// - 1.00%
                    REG2_ADJ_11 = 0xb,
                    /// - 1.25%
                    REG2_ADJ_12 = 0xc,
                    /// - 1.50%
                    REG2_ADJ_13 = 0xd,
                    /// - 1.75%
                    REG2_ADJ_14 = 0xe,
                    /// - 2.00%
                    REG2_ADJ_15 = 0xf,
                },
                /// Regulator voltage ramp rate.
                RAMP_RATE: enum(u2) {
                    /// Fast
                    RAMP_RATE_0 = 0x0,
                    /// Medium Fast
                    RAMP_RATE_1 = 0x1,
                    /// Medium Slow
                    RAMP_RATE_2 = 0x2,
                    /// Slow
                    RAMP_RATE_3 = 0x3,
                },
                /// If set, increases the gate drive on power gating FETs to reduce leakage in the off state
                FET_ODRIVE: u1,
                padding: u2 = 0,
            }),
            /// Digital Regulator Core Register
            REG_CORE_TOG: mmio.Mmio(packed struct(u32) {
                /// This field defines the target voltage for the ARM core power domain
                REG0_TARG: enum(u5) {
                    /// Power gated off
                    REG0_TARG_0 = 0x0,
                    /// Target core voltage = 0.725V
                    REG0_TARG_1 = 0x1,
                    /// Target core voltage = 0.750V
                    REG0_TARG_2 = 0x2,
                    /// Target core voltage = 0.775V
                    REG0_TARG_3 = 0x3,
                    /// Target core voltage = 1.100V
                    REG0_TARG_16 = 0x10,
                    /// Target core voltage = 1.450V
                    REG0_TARG_30 = 0x1e,
                    /// Power FET switched full on. No regulation.
                    REG0_TARG_31 = 0x1f,
                    _,
                },
                /// This bit field defines the adjustment bits to calibrate the target value of Reg0. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
                REG0_ADJ: enum(u4) {
                    /// No adjustment
                    REG0_ADJ_0 = 0x0,
                    /// + 0.25%
                    REG0_ADJ_1 = 0x1,
                    /// + 0.50%
                    REG0_ADJ_2 = 0x2,
                    /// + 0.75%
                    REG0_ADJ_3 = 0x3,
                    /// + 1.00%
                    REG0_ADJ_4 = 0x4,
                    /// + 1.25%
                    REG0_ADJ_5 = 0x5,
                    /// + 1.50%
                    REG0_ADJ_6 = 0x6,
                    /// + 1.75%
                    REG0_ADJ_7 = 0x7,
                    /// - 0.25%
                    REG0_ADJ_8 = 0x8,
                    /// - 0.50%
                    REG0_ADJ_9 = 0x9,
                    /// - 0.75%
                    REG0_ADJ_10 = 0xa,
                    /// - 1.00%
                    REG0_ADJ_11 = 0xb,
                    /// - 1.25%
                    REG0_ADJ_12 = 0xc,
                    /// - 1.50%
                    REG0_ADJ_13 = 0xd,
                    /// - 1.75%
                    REG0_ADJ_14 = 0xe,
                    /// - 2.00%
                    REG0_ADJ_15 = 0xf,
                },
                /// This bit field defines the target voltage for the vpu/gpu power domain. Single bit increments reflect 25mV core voltage steps. Not all steps will make sense to use either because of input supply limitations or load operation.
                REG1_TARG: enum(u5) {
                    /// Power gated off
                    REG1_TARG_0 = 0x0,
                    /// Target core voltage = 0.725V
                    REG1_TARG_1 = 0x1,
                    /// Target core voltage = 0.750V
                    REG1_TARG_2 = 0x2,
                    /// Target core voltage = 0.775V
                    REG1_TARG_3 = 0x3,
                    /// Target core voltage = 1.100V
                    REG1_TARG_16 = 0x10,
                    /// Target core voltage = 1.450V
                    REG1_TARG_30 = 0x1e,
                    /// Power FET switched full on. No regulation.
                    REG1_TARG_31 = 0x1f,
                    _,
                },
                /// This bit field defines the adjustment bits to calibrate the target value of Reg1. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
                REG1_ADJ: enum(u4) {
                    /// No adjustment
                    REG1_ADJ_0 = 0x0,
                    /// + 0.25%
                    REG1_ADJ_1 = 0x1,
                    /// + 0.50%
                    REG1_ADJ_2 = 0x2,
                    /// + 0.75%
                    REG1_ADJ_3 = 0x3,
                    /// + 1.00%
                    REG1_ADJ_4 = 0x4,
                    /// + 1.25%
                    REG1_ADJ_5 = 0x5,
                    /// + 1.50%
                    REG1_ADJ_6 = 0x6,
                    /// + 1.75%
                    REG1_ADJ_7 = 0x7,
                    /// - 0.25%
                    REG1_ADJ_8 = 0x8,
                    /// - 0.50%
                    REG1_ADJ_9 = 0x9,
                    /// - 0.75%
                    REG1_ADJ_10 = 0xa,
                    /// - 1.00%
                    REG1_ADJ_11 = 0xb,
                    /// - 1.25%
                    REG1_ADJ_12 = 0xc,
                    /// - 1.50%
                    REG1_ADJ_13 = 0xd,
                    /// - 1.75%
                    REG1_ADJ_14 = 0xe,
                    /// - 2.00%
                    REG1_ADJ_15 = 0xf,
                },
                /// This field defines the target voltage for the SOC power domain
                REG2_TARG: enum(u5) {
                    /// Power gated off
                    REG2_TARG_0 = 0x0,
                    /// Target core voltage = 0.725V
                    REG2_TARG_1 = 0x1,
                    /// Target core voltage = 0.750V
                    REG2_TARG_2 = 0x2,
                    /// Target core voltage = 0.775V
                    REG2_TARG_3 = 0x3,
                    /// Target core voltage = 1.100V
                    REG2_TARG_16 = 0x10,
                    /// Target core voltage = 1.450V
                    REG2_TARG_30 = 0x1e,
                    /// Power FET switched full on. No regulation.
                    REG2_TARG_31 = 0x1f,
                    _,
                },
                /// This bit field defines the adjustment bits to calibrate the target value of Reg2. The adjustment is applied on top on any adjustment applied to the global reference in the misc0 register.
                REG2_ADJ: enum(u4) {
                    /// No adjustment
                    REG2_ADJ_0 = 0x0,
                    /// + 0.25%
                    REG2_ADJ_1 = 0x1,
                    /// + 0.50%
                    REG2_ADJ_2 = 0x2,
                    /// + 0.75%
                    REG2_ADJ_3 = 0x3,
                    /// + 1.00%
                    REG2_ADJ_4 = 0x4,
                    /// + 1.25%
                    REG2_ADJ_5 = 0x5,
                    /// + 1.50%
                    REG2_ADJ_6 = 0x6,
                    /// + 1.75%
                    REG2_ADJ_7 = 0x7,
                    /// - 0.25%
                    REG2_ADJ_8 = 0x8,
                    /// - 0.50%
                    REG2_ADJ_9 = 0x9,
                    /// - 0.75%
                    REG2_ADJ_10 = 0xa,
                    /// - 1.00%
                    REG2_ADJ_11 = 0xb,
                    /// - 1.25%
                    REG2_ADJ_12 = 0xc,
                    /// - 1.50%
                    REG2_ADJ_13 = 0xd,
                    /// - 1.75%
                    REG2_ADJ_14 = 0xe,
                    /// - 2.00%
                    REG2_ADJ_15 = 0xf,
                },
                /// Regulator voltage ramp rate.
                RAMP_RATE: enum(u2) {
                    /// Fast
                    RAMP_RATE_0 = 0x0,
                    /// Medium Fast
                    RAMP_RATE_1 = 0x1,
                    /// Medium Slow
                    RAMP_RATE_2 = 0x2,
                    /// Slow
                    RAMP_RATE_3 = 0x3,
                },
                /// If set, increases the gate drive on power gating FETs to reduce leakage in the off state
                FET_ODRIVE: u1,
                padding: u2 = 0,
            }),
            /// Miscellaneous Register 0
            MISC0: mmio.Mmio(packed struct(u32) {
                /// Control bit to power-down the analog bandgap reference circuitry
                REFTOP_PWD: u1,
                reserved3: u2 = 0,
                /// Control bit to disable the self-bias circuit in the analog bandgap
                REFTOP_SELFBIASOFF: enum(u1) {
                    /// Uses coarse bias currents for startup
                    REFTOP_SELFBIASOFF_0 = 0x0,
                    /// Uses bandgap-based bias currents for best performance.
                    REFTOP_SELFBIASOFF_1 = 0x1,
                },
                /// no description available
                REFTOP_VBGADJ: enum(u3) {
                    /// Nominal VBG
                    REFTOP_VBGADJ_0 = 0x0,
                    /// VBG+0.78%
                    REFTOP_VBGADJ_1 = 0x1,
                    /// VBG+1.56%
                    REFTOP_VBGADJ_2 = 0x2,
                    /// VBG+2.34%
                    REFTOP_VBGADJ_3 = 0x3,
                    /// VBG-0.78%
                    REFTOP_VBGADJ_4 = 0x4,
                    /// VBG-1.56%
                    REFTOP_VBGADJ_5 = 0x5,
                    /// VBG-2.34%
                    REFTOP_VBGADJ_6 = 0x6,
                    /// VBG-3.12%
                    REFTOP_VBGADJ_7 = 0x7,
                },
                /// Status bit that signals the analog bandgap voltage is up and stable. 1 - Stable.
                REFTOP_VBGUP: u1,
                reserved10: u2 = 0,
                /// Configure the analog behavior in stop mode.
                STOP_MODE_CONFIG: enum(u2) {
                    /// SUSPEND (DSM)
                    STOP_MODE_CONFIG_0 = 0x0,
                    /// Analog regulators are ON.
                    STANDBY = 0x1,
                    /// STOP (lower power)
                    STOP_MODE_CONFIG_2 = 0x2,
                    /// STOP (very lower power)
                    STOP_MODE_CONFIG_3 = 0x3,
                },
                /// This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
                DISCON_HIGH_SNVS: enum(u1) {
                    /// Turn on the switch
                    DISCON_HIGH_SNVS_0 = 0x0,
                    /// Turn off the switch
                    DISCON_HIGH_SNVS_1 = 0x1,
                },
                /// This field determines the bias current in the 24MHz oscillator
                OSC_I: enum(u2) {
                    /// Nominal
                    NOMINAL = 0x0,
                    /// Decrease current by 12.5%
                    MINUS_12_5_PERCENT = 0x1,
                    /// Decrease current by 25.0%
                    MINUS_25_PERCENT = 0x2,
                    /// Decrease current by 37.5%
                    MINUS_37_5_PERCENT = 0x3,
                },
                /// Status bit that signals that the output of the 24-MHz crystal oscillator is stable
                OSC_XTALOK: u1,
                /// This bit enables the detector that signals when the 24MHz crystal oscillator is stable
                OSC_XTALOK_EN: u1,
                reserved25: u8 = 0,
                /// This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
                CLKGATE_CTRL: enum(u1) {
                    /// Allow the logic to automatically gate the clock when the XTAL is powered down.
                    ALLOW_AUTO_GATE = 0x0,
                    /// Prevent the logic from ever gating off the clock.
                    NO_AUTO_GATE = 0x1,
                },
                /// This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
                CLKGATE_DELAY: enum(u3) {
                    /// 0.5ms
                    CLKGATE_DELAY_0 = 0x0,
                    /// 1.0ms
                    CLKGATE_DELAY_1 = 0x1,
                    /// 2.0ms
                    CLKGATE_DELAY_2 = 0x2,
                    /// 3.0ms
                    CLKGATE_DELAY_3 = 0x3,
                    /// 4.0ms
                    CLKGATE_DELAY_4 = 0x4,
                    /// 5.0ms
                    CLKGATE_DELAY_5 = 0x5,
                    /// 6.0ms
                    CLKGATE_DELAY_6 = 0x6,
                    /// 7.0ms
                    CLKGATE_DELAY_7 = 0x7,
                },
                /// This field indicates which chip source is being used for the rtc clock.
                RTC_XTAL_SOURCE: enum(u1) {
                    /// Internal ring oscillator
                    RTC_XTAL_SOURCE_0 = 0x0,
                    /// RTC_XTAL
                    RTC_XTAL_SOURCE_1 = 0x1,
                },
                /// This field powers down the 24M crystal oscillator if set true.
                XTAL_24M_PWD: u1,
                /// Predivider for the source clock of the PLL's.
                VID_PLL_PREDIV: enum(u1) {
                    /// Divide by 1
                    VID_PLL_PREDIV_0 = 0x0,
                    /// Divide by 2
                    VID_PLL_PREDIV_1 = 0x1,
                },
            }),
            /// Miscellaneous Register 0
            MISC0_SET: mmio.Mmio(packed struct(u32) {
                /// Control bit to power-down the analog bandgap reference circuitry
                REFTOP_PWD: u1,
                reserved3: u2 = 0,
                /// Control bit to disable the self-bias circuit in the analog bandgap
                REFTOP_SELFBIASOFF: enum(u1) {
                    /// Uses coarse bias currents for startup
                    REFTOP_SELFBIASOFF_0 = 0x0,
                    /// Uses bandgap-based bias currents for best performance.
                    REFTOP_SELFBIASOFF_1 = 0x1,
                },
                /// no description available
                REFTOP_VBGADJ: enum(u3) {
                    /// Nominal VBG
                    REFTOP_VBGADJ_0 = 0x0,
                    /// VBG+0.78%
                    REFTOP_VBGADJ_1 = 0x1,
                    /// VBG+1.56%
                    REFTOP_VBGADJ_2 = 0x2,
                    /// VBG+2.34%
                    REFTOP_VBGADJ_3 = 0x3,
                    /// VBG-0.78%
                    REFTOP_VBGADJ_4 = 0x4,
                    /// VBG-1.56%
                    REFTOP_VBGADJ_5 = 0x5,
                    /// VBG-2.34%
                    REFTOP_VBGADJ_6 = 0x6,
                    /// VBG-3.12%
                    REFTOP_VBGADJ_7 = 0x7,
                },
                /// Status bit that signals the analog bandgap voltage is up and stable. 1 - Stable.
                REFTOP_VBGUP: u1,
                reserved10: u2 = 0,
                /// Configure the analog behavior in stop mode.
                STOP_MODE_CONFIG: enum(u2) {
                    /// SUSPEND (DSM)
                    STOP_MODE_CONFIG_0 = 0x0,
                    /// Analog regulators are ON.
                    STANDBY = 0x1,
                    /// STOP (lower power)
                    STOP_MODE_CONFIG_2 = 0x2,
                    /// STOP (very lower power)
                    STOP_MODE_CONFIG_3 = 0x3,
                },
                /// This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
                DISCON_HIGH_SNVS: enum(u1) {
                    /// Turn on the switch
                    DISCON_HIGH_SNVS_0 = 0x0,
                    /// Turn off the switch
                    DISCON_HIGH_SNVS_1 = 0x1,
                },
                /// This field determines the bias current in the 24MHz oscillator
                OSC_I: enum(u2) {
                    /// Nominal
                    NOMINAL = 0x0,
                    /// Decrease current by 12.5%
                    MINUS_12_5_PERCENT = 0x1,
                    /// Decrease current by 25.0%
                    MINUS_25_PERCENT = 0x2,
                    /// Decrease current by 37.5%
                    MINUS_37_5_PERCENT = 0x3,
                },
                /// Status bit that signals that the output of the 24-MHz crystal oscillator is stable
                OSC_XTALOK: u1,
                /// This bit enables the detector that signals when the 24MHz crystal oscillator is stable
                OSC_XTALOK_EN: u1,
                reserved25: u8 = 0,
                /// This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
                CLKGATE_CTRL: enum(u1) {
                    /// Allow the logic to automatically gate the clock when the XTAL is powered down.
                    ALLOW_AUTO_GATE = 0x0,
                    /// Prevent the logic from ever gating off the clock.
                    NO_AUTO_GATE = 0x1,
                },
                /// This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
                CLKGATE_DELAY: enum(u3) {
                    /// 0.5ms
                    CLKGATE_DELAY_0 = 0x0,
                    /// 1.0ms
                    CLKGATE_DELAY_1 = 0x1,
                    /// 2.0ms
                    CLKGATE_DELAY_2 = 0x2,
                    /// 3.0ms
                    CLKGATE_DELAY_3 = 0x3,
                    /// 4.0ms
                    CLKGATE_DELAY_4 = 0x4,
                    /// 5.0ms
                    CLKGATE_DELAY_5 = 0x5,
                    /// 6.0ms
                    CLKGATE_DELAY_6 = 0x6,
                    /// 7.0ms
                    CLKGATE_DELAY_7 = 0x7,
                },
                /// This field indicates which chip source is being used for the rtc clock.
                RTC_XTAL_SOURCE: enum(u1) {
                    /// Internal ring oscillator
                    RTC_XTAL_SOURCE_0 = 0x0,
                    /// RTC_XTAL
                    RTC_XTAL_SOURCE_1 = 0x1,
                },
                /// This field powers down the 24M crystal oscillator if set true.
                XTAL_24M_PWD: u1,
                /// Predivider for the source clock of the PLL's.
                VID_PLL_PREDIV: enum(u1) {
                    /// Divide by 1
                    VID_PLL_PREDIV_0 = 0x0,
                    /// Divide by 2
                    VID_PLL_PREDIV_1 = 0x1,
                },
            }),
            /// Miscellaneous Register 0
            MISC0_CLR: mmio.Mmio(packed struct(u32) {
                /// Control bit to power-down the analog bandgap reference circuitry
                REFTOP_PWD: u1,
                reserved3: u2 = 0,
                /// Control bit to disable the self-bias circuit in the analog bandgap
                REFTOP_SELFBIASOFF: enum(u1) {
                    /// Uses coarse bias currents for startup
                    REFTOP_SELFBIASOFF_0 = 0x0,
                    /// Uses bandgap-based bias currents for best performance.
                    REFTOP_SELFBIASOFF_1 = 0x1,
                },
                /// no description available
                REFTOP_VBGADJ: enum(u3) {
                    /// Nominal VBG
                    REFTOP_VBGADJ_0 = 0x0,
                    /// VBG+0.78%
                    REFTOP_VBGADJ_1 = 0x1,
                    /// VBG+1.56%
                    REFTOP_VBGADJ_2 = 0x2,
                    /// VBG+2.34%
                    REFTOP_VBGADJ_3 = 0x3,
                    /// VBG-0.78%
                    REFTOP_VBGADJ_4 = 0x4,
                    /// VBG-1.56%
                    REFTOP_VBGADJ_5 = 0x5,
                    /// VBG-2.34%
                    REFTOP_VBGADJ_6 = 0x6,
                    /// VBG-3.12%
                    REFTOP_VBGADJ_7 = 0x7,
                },
                /// Status bit that signals the analog bandgap voltage is up and stable. 1 - Stable.
                REFTOP_VBGUP: u1,
                reserved10: u2 = 0,
                /// Configure the analog behavior in stop mode.
                STOP_MODE_CONFIG: enum(u2) {
                    /// SUSPEND (DSM)
                    STOP_MODE_CONFIG_0 = 0x0,
                    /// Analog regulators are ON.
                    STANDBY = 0x1,
                    /// STOP (lower power)
                    STOP_MODE_CONFIG_2 = 0x2,
                    /// STOP (very lower power)
                    STOP_MODE_CONFIG_3 = 0x3,
                },
                /// This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
                DISCON_HIGH_SNVS: enum(u1) {
                    /// Turn on the switch
                    DISCON_HIGH_SNVS_0 = 0x0,
                    /// Turn off the switch
                    DISCON_HIGH_SNVS_1 = 0x1,
                },
                /// This field determines the bias current in the 24MHz oscillator
                OSC_I: enum(u2) {
                    /// Nominal
                    NOMINAL = 0x0,
                    /// Decrease current by 12.5%
                    MINUS_12_5_PERCENT = 0x1,
                    /// Decrease current by 25.0%
                    MINUS_25_PERCENT = 0x2,
                    /// Decrease current by 37.5%
                    MINUS_37_5_PERCENT = 0x3,
                },
                /// Status bit that signals that the output of the 24-MHz crystal oscillator is stable
                OSC_XTALOK: u1,
                /// This bit enables the detector that signals when the 24MHz crystal oscillator is stable
                OSC_XTALOK_EN: u1,
                reserved25: u8 = 0,
                /// This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
                CLKGATE_CTRL: enum(u1) {
                    /// Allow the logic to automatically gate the clock when the XTAL is powered down.
                    ALLOW_AUTO_GATE = 0x0,
                    /// Prevent the logic from ever gating off the clock.
                    NO_AUTO_GATE = 0x1,
                },
                /// This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
                CLKGATE_DELAY: enum(u3) {
                    /// 0.5ms
                    CLKGATE_DELAY_0 = 0x0,
                    /// 1.0ms
                    CLKGATE_DELAY_1 = 0x1,
                    /// 2.0ms
                    CLKGATE_DELAY_2 = 0x2,
                    /// 3.0ms
                    CLKGATE_DELAY_3 = 0x3,
                    /// 4.0ms
                    CLKGATE_DELAY_4 = 0x4,
                    /// 5.0ms
                    CLKGATE_DELAY_5 = 0x5,
                    /// 6.0ms
                    CLKGATE_DELAY_6 = 0x6,
                    /// 7.0ms
                    CLKGATE_DELAY_7 = 0x7,
                },
                /// This field indicates which chip source is being used for the rtc clock.
                RTC_XTAL_SOURCE: enum(u1) {
                    /// Internal ring oscillator
                    RTC_XTAL_SOURCE_0 = 0x0,
                    /// RTC_XTAL
                    RTC_XTAL_SOURCE_1 = 0x1,
                },
                /// This field powers down the 24M crystal oscillator if set true.
                XTAL_24M_PWD: u1,
                /// Predivider for the source clock of the PLL's.
                VID_PLL_PREDIV: enum(u1) {
                    /// Divide by 1
                    VID_PLL_PREDIV_0 = 0x0,
                    /// Divide by 2
                    VID_PLL_PREDIV_1 = 0x1,
                },
            }),
            /// Miscellaneous Register 0
            MISC0_TOG: mmio.Mmio(packed struct(u32) {
                /// Control bit to power-down the analog bandgap reference circuitry
                REFTOP_PWD: u1,
                reserved3: u2 = 0,
                /// Control bit to disable the self-bias circuit in the analog bandgap
                REFTOP_SELFBIASOFF: enum(u1) {
                    /// Uses coarse bias currents for startup
                    REFTOP_SELFBIASOFF_0 = 0x0,
                    /// Uses bandgap-based bias currents for best performance.
                    REFTOP_SELFBIASOFF_1 = 0x1,
                },
                /// no description available
                REFTOP_VBGADJ: enum(u3) {
                    /// Nominal VBG
                    REFTOP_VBGADJ_0 = 0x0,
                    /// VBG+0.78%
                    REFTOP_VBGADJ_1 = 0x1,
                    /// VBG+1.56%
                    REFTOP_VBGADJ_2 = 0x2,
                    /// VBG+2.34%
                    REFTOP_VBGADJ_3 = 0x3,
                    /// VBG-0.78%
                    REFTOP_VBGADJ_4 = 0x4,
                    /// VBG-1.56%
                    REFTOP_VBGADJ_5 = 0x5,
                    /// VBG-2.34%
                    REFTOP_VBGADJ_6 = 0x6,
                    /// VBG-3.12%
                    REFTOP_VBGADJ_7 = 0x7,
                },
                /// Status bit that signals the analog bandgap voltage is up and stable. 1 - Stable.
                REFTOP_VBGUP: u1,
                reserved10: u2 = 0,
                /// Configure the analog behavior in stop mode.
                STOP_MODE_CONFIG: enum(u2) {
                    /// SUSPEND (DSM)
                    STOP_MODE_CONFIG_0 = 0x0,
                    /// Analog regulators are ON.
                    STANDBY = 0x1,
                    /// STOP (lower power)
                    STOP_MODE_CONFIG_2 = 0x2,
                    /// STOP (very lower power)
                    STOP_MODE_CONFIG_3 = 0x3,
                },
                /// This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
                DISCON_HIGH_SNVS: enum(u1) {
                    /// Turn on the switch
                    DISCON_HIGH_SNVS_0 = 0x0,
                    /// Turn off the switch
                    DISCON_HIGH_SNVS_1 = 0x1,
                },
                /// This field determines the bias current in the 24MHz oscillator
                OSC_I: enum(u2) {
                    /// Nominal
                    NOMINAL = 0x0,
                    /// Decrease current by 12.5%
                    MINUS_12_5_PERCENT = 0x1,
                    /// Decrease current by 25.0%
                    MINUS_25_PERCENT = 0x2,
                    /// Decrease current by 37.5%
                    MINUS_37_5_PERCENT = 0x3,
                },
                /// Status bit that signals that the output of the 24-MHz crystal oscillator is stable
                OSC_XTALOK: u1,
                /// This bit enables the detector that signals when the 24MHz crystal oscillator is stable
                OSC_XTALOK_EN: u1,
                reserved25: u8 = 0,
                /// This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
                CLKGATE_CTRL: enum(u1) {
                    /// Allow the logic to automatically gate the clock when the XTAL is powered down.
                    ALLOW_AUTO_GATE = 0x0,
                    /// Prevent the logic from ever gating off the clock.
                    NO_AUTO_GATE = 0x1,
                },
                /// This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
                CLKGATE_DELAY: enum(u3) {
                    /// 0.5ms
                    CLKGATE_DELAY_0 = 0x0,
                    /// 1.0ms
                    CLKGATE_DELAY_1 = 0x1,
                    /// 2.0ms
                    CLKGATE_DELAY_2 = 0x2,
                    /// 3.0ms
                    CLKGATE_DELAY_3 = 0x3,
                    /// 4.0ms
                    CLKGATE_DELAY_4 = 0x4,
                    /// 5.0ms
                    CLKGATE_DELAY_5 = 0x5,
                    /// 6.0ms
                    CLKGATE_DELAY_6 = 0x6,
                    /// 7.0ms
                    CLKGATE_DELAY_7 = 0x7,
                },
                /// This field indicates which chip source is being used for the rtc clock.
                RTC_XTAL_SOURCE: enum(u1) {
                    /// Internal ring oscillator
                    RTC_XTAL_SOURCE_0 = 0x0,
                    /// RTC_XTAL
                    RTC_XTAL_SOURCE_1 = 0x1,
                },
                /// This field powers down the 24M crystal oscillator if set true.
                XTAL_24M_PWD: u1,
                /// Predivider for the source clock of the PLL's.
                VID_PLL_PREDIV: enum(u1) {
                    /// Divide by 1
                    VID_PLL_PREDIV_0 = 0x0,
                    /// Divide by 2
                    VID_PLL_PREDIV_1 = 0x1,
                },
            }),
            /// Miscellaneous Register 1
            MISC1: mmio.Mmio(packed struct(u32) {
                /// This field selects the clk to be routed to anaclk1/1b.Not related to PMU.
                LVDS1_CLK_SEL: enum(u5) {
                    /// Arm PLL
                    ARM_PLL = 0x0,
                    /// System PLL
                    SYS_PLL = 0x1,
                    /// ref_pfd4_clk == pll2_pfd0_clk
                    PFD4 = 0x2,
                    /// ref_pfd5_clk == pll2_pfd1_clk
                    PFD5 = 0x3,
                    /// ref_pfd6_clk == pll2_pfd2_clk
                    PFD6 = 0x4,
                    /// ref_pfd7_clk == pll2_pfd3_clk
                    PFD7 = 0x5,
                    /// Audio PLL
                    AUDIO_PLL = 0x6,
                    /// Video PLL
                    VIDEO_PLL = 0x7,
                    /// ethernet ref clock (ENET_PLL)
                    ETHERNET_REF = 0x9,
                    /// USB1 PLL clock
                    USB1_PLL = 0xc,
                    /// USB2 PLL clock
                    USB2_PLL = 0xd,
                    /// ref_pfd0_clk == pll3_pfd0_clk
                    PFD0 = 0xe,
                    /// ref_pfd1_clk == pll3_pfd1_clk
                    PFD1 = 0xf,
                    /// ref_pfd2_clk == pll3_pfd2_clk
                    PFD2 = 0x10,
                    /// ref_pfd3_clk == pll3_pfd3_clk
                    PFD3 = 0x11,
                    /// xtal (24M)
                    XTAL = 0x12,
                    _,
                },
                /// This field selects the clk to be routed to anaclk2/2b.Not related to PMU.
                LVDS2_CLK_SEL: enum(u5) {
                    /// Arm PLL
                    ARM_PLL = 0x0,
                    /// System PLL
                    SYS_PLL = 0x1,
                    /// ref_pfd4_clk == pll2_pfd0_clk
                    PFD4 = 0x2,
                    /// ref_pfd5_clk == pll2_pfd1_clk
                    PFD5 = 0x3,
                    /// ref_pfd6_clk == pll2_pfd2_clk
                    PFD6 = 0x4,
                    /// ref_pfd7_clk == pll2_pfd3_clk
                    PFD7 = 0x5,
                    /// Audio PLL
                    AUDIO_PLL = 0x6,
                    /// Video PLL
                    VIDEO_PLL = 0x7,
                    /// MLB PLL
                    MLB_PLL = 0x8,
                    /// ethernet ref clock (ENET_PLL)
                    ETHERNET_REF = 0x9,
                    /// PCIe ref clock (125M)
                    PCIE_REF = 0xa,
                    /// SATA ref clock (100M)
                    SATA_REF = 0xb,
                    /// USB1 PLL clock
                    USB1_PLL = 0xc,
                    /// USB2 PLL clock
                    USB2_PLL = 0xd,
                    /// ref_pfd0_clk == pll3_pfd0_clk
                    PFD0 = 0xe,
                    /// ref_pfd1_clk == pll3_pfd1_clk
                    PFD1 = 0xf,
                    /// ref_pfd2_clk == pll3_pfd2_clk
                    PFD2 = 0x10,
                    /// ref_pfd3_clk == pll3_pfd3_clk
                    PFD3 = 0x11,
                    /// xtal (24M)
                    XTAL = 0x12,
                    /// LVDS1 (loopback)
                    LVDS1 = 0x13,
                    /// LVDS2 (not useful)
                    LVDS2 = 0x14,
                    _,
                },
                /// This enables the LVDS output buffer for anaclk1/1b
                LVDSCLK1_OBEN: u1,
                /// This enables the LVDS output buffer for anaclk2/2b
                LVDSCLK2_OBEN: u1,
                /// This enables the LVDS input buffer for anaclk1/1b
                LVDSCLK1_IBEN: u1,
                /// This enables the LVDS input buffer for anaclk2/2b
                LVDSCLK2_IBEN: u1,
                reserved16: u2 = 0,
                /// This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
                PFD_480_AUTOGATE_EN: u1,
                /// This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
                PFD_528_AUTOGATE_EN: u1,
                reserved27: u9 = 0,
                /// This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
                IRQ_TEMPPANIC: u1,
                /// This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
                IRQ_TEMPLOW: u1,
                /// This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
                IRQ_TEMPHIGH: u1,
                /// This status bit is set to one when when any of the analog regulator brownout interrupts assert
                IRQ_ANA_BO: u1,
                /// This status bit is set to one when when any of the digital regulator brownout interrupts assert
                IRQ_DIG_BO: u1,
            }),
            /// Miscellaneous Register 1
            MISC1_SET: mmio.Mmio(packed struct(u32) {
                /// This field selects the clk to be routed to anaclk1/1b.Not related to PMU.
                LVDS1_CLK_SEL: enum(u5) {
                    /// Arm PLL
                    ARM_PLL = 0x0,
                    /// System PLL
                    SYS_PLL = 0x1,
                    /// ref_pfd4_clk == pll2_pfd0_clk
                    PFD4 = 0x2,
                    /// ref_pfd5_clk == pll2_pfd1_clk
                    PFD5 = 0x3,
                    /// ref_pfd6_clk == pll2_pfd2_clk
                    PFD6 = 0x4,
                    /// ref_pfd7_clk == pll2_pfd3_clk
                    PFD7 = 0x5,
                    /// Audio PLL
                    AUDIO_PLL = 0x6,
                    /// Video PLL
                    VIDEO_PLL = 0x7,
                    /// ethernet ref clock (ENET_PLL)
                    ETHERNET_REF = 0x9,
                    /// USB1 PLL clock
                    USB1_PLL = 0xc,
                    /// USB2 PLL clock
                    USB2_PLL = 0xd,
                    /// ref_pfd0_clk == pll3_pfd0_clk
                    PFD0 = 0xe,
                    /// ref_pfd1_clk == pll3_pfd1_clk
                    PFD1 = 0xf,
                    /// ref_pfd2_clk == pll3_pfd2_clk
                    PFD2 = 0x10,
                    /// ref_pfd3_clk == pll3_pfd3_clk
                    PFD3 = 0x11,
                    /// xtal (24M)
                    XTAL = 0x12,
                    _,
                },
                /// This field selects the clk to be routed to anaclk2/2b.Not related to PMU.
                LVDS2_CLK_SEL: enum(u5) {
                    /// Arm PLL
                    ARM_PLL = 0x0,
                    /// System PLL
                    SYS_PLL = 0x1,
                    /// ref_pfd4_clk == pll2_pfd0_clk
                    PFD4 = 0x2,
                    /// ref_pfd5_clk == pll2_pfd1_clk
                    PFD5 = 0x3,
                    /// ref_pfd6_clk == pll2_pfd2_clk
                    PFD6 = 0x4,
                    /// ref_pfd7_clk == pll2_pfd3_clk
                    PFD7 = 0x5,
                    /// Audio PLL
                    AUDIO_PLL = 0x6,
                    /// Video PLL
                    VIDEO_PLL = 0x7,
                    /// MLB PLL
                    MLB_PLL = 0x8,
                    /// ethernet ref clock (ENET_PLL)
                    ETHERNET_REF = 0x9,
                    /// PCIe ref clock (125M)
                    PCIE_REF = 0xa,
                    /// SATA ref clock (100M)
                    SATA_REF = 0xb,
                    /// USB1 PLL clock
                    USB1_PLL = 0xc,
                    /// USB2 PLL clock
                    USB2_PLL = 0xd,
                    /// ref_pfd0_clk == pll3_pfd0_clk
                    PFD0 = 0xe,
                    /// ref_pfd1_clk == pll3_pfd1_clk
                    PFD1 = 0xf,
                    /// ref_pfd2_clk == pll3_pfd2_clk
                    PFD2 = 0x10,
                    /// ref_pfd3_clk == pll3_pfd3_clk
                    PFD3 = 0x11,
                    /// xtal (24M)
                    XTAL = 0x12,
                    /// LVDS1 (loopback)
                    LVDS1 = 0x13,
                    /// LVDS2 (not useful)
                    LVDS2 = 0x14,
                    _,
                },
                /// This enables the LVDS output buffer for anaclk1/1b
                LVDSCLK1_OBEN: u1,
                /// This enables the LVDS output buffer for anaclk2/2b
                LVDSCLK2_OBEN: u1,
                /// This enables the LVDS input buffer for anaclk1/1b
                LVDSCLK1_IBEN: u1,
                /// This enables the LVDS input buffer for anaclk2/2b
                LVDSCLK2_IBEN: u1,
                reserved16: u2 = 0,
                /// This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
                PFD_480_AUTOGATE_EN: u1,
                /// This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
                PFD_528_AUTOGATE_EN: u1,
                reserved27: u9 = 0,
                /// This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
                IRQ_TEMPPANIC: u1,
                /// This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
                IRQ_TEMPLOW: u1,
                /// This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
                IRQ_TEMPHIGH: u1,
                /// This status bit is set to one when when any of the analog regulator brownout interrupts assert
                IRQ_ANA_BO: u1,
                /// This status bit is set to one when when any of the digital regulator brownout interrupts assert
                IRQ_DIG_BO: u1,
            }),
            /// Miscellaneous Register 1
            MISC1_CLR: mmio.Mmio(packed struct(u32) {
                /// This field selects the clk to be routed to anaclk1/1b.Not related to PMU.
                LVDS1_CLK_SEL: enum(u5) {
                    /// Arm PLL
                    ARM_PLL = 0x0,
                    /// System PLL
                    SYS_PLL = 0x1,
                    /// ref_pfd4_clk == pll2_pfd0_clk
                    PFD4 = 0x2,
                    /// ref_pfd5_clk == pll2_pfd1_clk
                    PFD5 = 0x3,
                    /// ref_pfd6_clk == pll2_pfd2_clk
                    PFD6 = 0x4,
                    /// ref_pfd7_clk == pll2_pfd3_clk
                    PFD7 = 0x5,
                    /// Audio PLL
                    AUDIO_PLL = 0x6,
                    /// Video PLL
                    VIDEO_PLL = 0x7,
                    /// ethernet ref clock (ENET_PLL)
                    ETHERNET_REF = 0x9,
                    /// USB1 PLL clock
                    USB1_PLL = 0xc,
                    /// USB2 PLL clock
                    USB2_PLL = 0xd,
                    /// ref_pfd0_clk == pll3_pfd0_clk
                    PFD0 = 0xe,
                    /// ref_pfd1_clk == pll3_pfd1_clk
                    PFD1 = 0xf,
                    /// ref_pfd2_clk == pll3_pfd2_clk
                    PFD2 = 0x10,
                    /// ref_pfd3_clk == pll3_pfd3_clk
                    PFD3 = 0x11,
                    /// xtal (24M)
                    XTAL = 0x12,
                    _,
                },
                /// This field selects the clk to be routed to anaclk2/2b.Not related to PMU.
                LVDS2_CLK_SEL: enum(u5) {
                    /// Arm PLL
                    ARM_PLL = 0x0,
                    /// System PLL
                    SYS_PLL = 0x1,
                    /// ref_pfd4_clk == pll2_pfd0_clk
                    PFD4 = 0x2,
                    /// ref_pfd5_clk == pll2_pfd1_clk
                    PFD5 = 0x3,
                    /// ref_pfd6_clk == pll2_pfd2_clk
                    PFD6 = 0x4,
                    /// ref_pfd7_clk == pll2_pfd3_clk
                    PFD7 = 0x5,
                    /// Audio PLL
                    AUDIO_PLL = 0x6,
                    /// Video PLL
                    VIDEO_PLL = 0x7,
                    /// MLB PLL
                    MLB_PLL = 0x8,
                    /// ethernet ref clock (ENET_PLL)
                    ETHERNET_REF = 0x9,
                    /// PCIe ref clock (125M)
                    PCIE_REF = 0xa,
                    /// SATA ref clock (100M)
                    SATA_REF = 0xb,
                    /// USB1 PLL clock
                    USB1_PLL = 0xc,
                    /// USB2 PLL clock
                    USB2_PLL = 0xd,
                    /// ref_pfd0_clk == pll3_pfd0_clk
                    PFD0 = 0xe,
                    /// ref_pfd1_clk == pll3_pfd1_clk
                    PFD1 = 0xf,
                    /// ref_pfd2_clk == pll3_pfd2_clk
                    PFD2 = 0x10,
                    /// ref_pfd3_clk == pll3_pfd3_clk
                    PFD3 = 0x11,
                    /// xtal (24M)
                    XTAL = 0x12,
                    /// LVDS1 (loopback)
                    LVDS1 = 0x13,
                    /// LVDS2 (not useful)
                    LVDS2 = 0x14,
                    _,
                },
                /// This enables the LVDS output buffer for anaclk1/1b
                LVDSCLK1_OBEN: u1,
                /// This enables the LVDS output buffer for anaclk2/2b
                LVDSCLK2_OBEN: u1,
                /// This enables the LVDS input buffer for anaclk1/1b
                LVDSCLK1_IBEN: u1,
                /// This enables the LVDS input buffer for anaclk2/2b
                LVDSCLK2_IBEN: u1,
                reserved16: u2 = 0,
                /// This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
                PFD_480_AUTOGATE_EN: u1,
                /// This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
                PFD_528_AUTOGATE_EN: u1,
                reserved27: u9 = 0,
                /// This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
                IRQ_TEMPPANIC: u1,
                /// This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
                IRQ_TEMPLOW: u1,
                /// This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
                IRQ_TEMPHIGH: u1,
                /// This status bit is set to one when when any of the analog regulator brownout interrupts assert
                IRQ_ANA_BO: u1,
                /// This status bit is set to one when when any of the digital regulator brownout interrupts assert
                IRQ_DIG_BO: u1,
            }),
            /// Miscellaneous Register 1
            MISC1_TOG: mmio.Mmio(packed struct(u32) {
                /// This field selects the clk to be routed to anaclk1/1b.Not related to PMU.
                LVDS1_CLK_SEL: enum(u5) {
                    /// Arm PLL
                    ARM_PLL = 0x0,
                    /// System PLL
                    SYS_PLL = 0x1,
                    /// ref_pfd4_clk == pll2_pfd0_clk
                    PFD4 = 0x2,
                    /// ref_pfd5_clk == pll2_pfd1_clk
                    PFD5 = 0x3,
                    /// ref_pfd6_clk == pll2_pfd2_clk
                    PFD6 = 0x4,
                    /// ref_pfd7_clk == pll2_pfd3_clk
                    PFD7 = 0x5,
                    /// Audio PLL
                    AUDIO_PLL = 0x6,
                    /// Video PLL
                    VIDEO_PLL = 0x7,
                    /// ethernet ref clock (ENET_PLL)
                    ETHERNET_REF = 0x9,
                    /// USB1 PLL clock
                    USB1_PLL = 0xc,
                    /// USB2 PLL clock
                    USB2_PLL = 0xd,
                    /// ref_pfd0_clk == pll3_pfd0_clk
                    PFD0 = 0xe,
                    /// ref_pfd1_clk == pll3_pfd1_clk
                    PFD1 = 0xf,
                    /// ref_pfd2_clk == pll3_pfd2_clk
                    PFD2 = 0x10,
                    /// ref_pfd3_clk == pll3_pfd3_clk
                    PFD3 = 0x11,
                    /// xtal (24M)
                    XTAL = 0x12,
                    _,
                },
                /// This field selects the clk to be routed to anaclk2/2b.Not related to PMU.
                LVDS2_CLK_SEL: enum(u5) {
                    /// Arm PLL
                    ARM_PLL = 0x0,
                    /// System PLL
                    SYS_PLL = 0x1,
                    /// ref_pfd4_clk == pll2_pfd0_clk
                    PFD4 = 0x2,
                    /// ref_pfd5_clk == pll2_pfd1_clk
                    PFD5 = 0x3,
                    /// ref_pfd6_clk == pll2_pfd2_clk
                    PFD6 = 0x4,
                    /// ref_pfd7_clk == pll2_pfd3_clk
                    PFD7 = 0x5,
                    /// Audio PLL
                    AUDIO_PLL = 0x6,
                    /// Video PLL
                    VIDEO_PLL = 0x7,
                    /// MLB PLL
                    MLB_PLL = 0x8,
                    /// ethernet ref clock (ENET_PLL)
                    ETHERNET_REF = 0x9,
                    /// PCIe ref clock (125M)
                    PCIE_REF = 0xa,
                    /// SATA ref clock (100M)
                    SATA_REF = 0xb,
                    /// USB1 PLL clock
                    USB1_PLL = 0xc,
                    /// USB2 PLL clock
                    USB2_PLL = 0xd,
                    /// ref_pfd0_clk == pll3_pfd0_clk
                    PFD0 = 0xe,
                    /// ref_pfd1_clk == pll3_pfd1_clk
                    PFD1 = 0xf,
                    /// ref_pfd2_clk == pll3_pfd2_clk
                    PFD2 = 0x10,
                    /// ref_pfd3_clk == pll3_pfd3_clk
                    PFD3 = 0x11,
                    /// xtal (24M)
                    XTAL = 0x12,
                    /// LVDS1 (loopback)
                    LVDS1 = 0x13,
                    /// LVDS2 (not useful)
                    LVDS2 = 0x14,
                    _,
                },
                /// This enables the LVDS output buffer for anaclk1/1b
                LVDSCLK1_OBEN: u1,
                /// This enables the LVDS output buffer for anaclk2/2b
                LVDSCLK2_OBEN: u1,
                /// This enables the LVDS input buffer for anaclk1/1b
                LVDSCLK1_IBEN: u1,
                /// This enables the LVDS input buffer for anaclk2/2b
                LVDSCLK2_IBEN: u1,
                reserved16: u2 = 0,
                /// This enables a feature that will clkgate (reset) all PFD_480 clocks anytime the USB1_PLL_480 is unlocked or powered off
                PFD_480_AUTOGATE_EN: u1,
                /// This enables a feature that will clkgate (reset) all PFD_528 clocks anytime the PLL_528 is unlocked or powered off
                PFD_528_AUTOGATE_EN: u1,
                reserved27: u9 = 0,
                /// This status bit is set to one when the temperature sensor panic interrupt asserts for a panic high temperature
                IRQ_TEMPPANIC: u1,
                /// This status bit is set to one when the temperature sensor low interrupt asserts for low temperature
                IRQ_TEMPLOW: u1,
                /// This status bit is set to one when the temperature sensor high interrupt asserts for high temperature
                IRQ_TEMPHIGH: u1,
                /// This status bit is set to one when when any of the analog regulator brownout interrupts assert
                IRQ_ANA_BO: u1,
                /// This status bit is set to one when when any of the digital regulator brownout interrupts assert
                IRQ_DIG_BO: u1,
            }),
            /// Miscellaneous Control Register
            MISC2: mmio.Mmio(packed struct(u32) {
                /// This field defines the brown out voltage offset for the CORE power domain
                REG0_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG0_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG0_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg0 brownout status bit.
                REG0_BO_STATUS: enum(u1) {
                    /// Brownout, supply is below target minus brownout offset.
                    REG0_BO_STATUS_1 = 0x1,
                    _,
                },
                reserved5: u1 = 0,
                /// Enables the brownout detection.
                REG0_ENABLE_BO: u1,
                reserved7: u1 = 0,
                /// Default value of "0"
                PLL3_disable: u1,
                /// This field defines the brown out voltage offset for the xPU power domain
                REG1_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG1_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG1_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg1 brownout status bit.
                REG1_BO_STATUS: enum(u1) {
                    /// Brownout, supply is below target minus brownout offset.
                    REG1_BO_STATUS_1 = 0x1,
                    _,
                },
                reserved13: u1 = 0,
                /// Enables the brownout detection.
                REG1_ENABLE_BO: u1,
                reserved15: u1 = 0,
                /// LSB of Post-divider for Audio PLL
                AUDIO_DIV_LSB: enum(u1) {
                    /// divide by 1 (Default)
                    AUDIO_DIV_LSB_0 = 0x0,
                    /// divide by 2
                    AUDIO_DIV_LSB_1 = 0x1,
                },
                /// This field defines the brown out voltage offset for the xPU power domain
                REG2_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG2_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG2_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg2 brownout status bit.
                REG2_BO_STATUS: u1,
                reserved21: u1 = 0,
                /// Enables the brownout detection.
                REG2_ENABLE_BO: u1,
                /// Signals that the voltage is above the brownout level for the SOC supply
                REG2_OK: u1,
                /// MSB of Post-divider for Audio PLL
                AUDIO_DIV_MSB: enum(u1) {
                    /// divide by 1 (Default)
                    AUDIO_DIV_MSB_0 = 0x0,
                    /// divide by 2
                    AUDIO_DIV_MSB_1 = 0x1,
                },
                /// Number of clock periods (24MHz clock).
                REG0_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Number of clock periods (24MHz clock).
                REG1_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Number of clock periods (24MHz clock).
                REG2_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Post-divider for video
                VIDEO_DIV: enum(u2) {
                    /// divide by 1 (Default)
                    VIDEO_DIV_0 = 0x0,
                    /// divide by 2
                    VIDEO_DIV_1 = 0x1,
                    /// divide by 1
                    VIDEO_DIV_2 = 0x2,
                    /// divide by 4
                    VIDEO_DIV_3 = 0x3,
                },
            }),
            /// Miscellaneous Control Register
            MISC2_SET: mmio.Mmio(packed struct(u32) {
                /// This field defines the brown out voltage offset for the CORE power domain
                REG0_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG0_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG0_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg0 brownout status bit.
                REG0_BO_STATUS: enum(u1) {
                    /// Brownout, supply is below target minus brownout offset.
                    REG0_BO_STATUS_1 = 0x1,
                    _,
                },
                reserved5: u1 = 0,
                /// Enables the brownout detection.
                REG0_ENABLE_BO: u1,
                reserved7: u1 = 0,
                /// Default value of "0"
                PLL3_disable: u1,
                /// This field defines the brown out voltage offset for the xPU power domain
                REG1_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG1_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG1_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg1 brownout status bit.
                REG1_BO_STATUS: enum(u1) {
                    /// Brownout, supply is below target minus brownout offset.
                    REG1_BO_STATUS_1 = 0x1,
                    _,
                },
                reserved13: u1 = 0,
                /// Enables the brownout detection.
                REG1_ENABLE_BO: u1,
                reserved15: u1 = 0,
                /// LSB of Post-divider for Audio PLL
                AUDIO_DIV_LSB: enum(u1) {
                    /// divide by 1 (Default)
                    AUDIO_DIV_LSB_0 = 0x0,
                    /// divide by 2
                    AUDIO_DIV_LSB_1 = 0x1,
                },
                /// This field defines the brown out voltage offset for the xPU power domain
                REG2_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG2_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG2_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg2 brownout status bit.
                REG2_BO_STATUS: u1,
                reserved21: u1 = 0,
                /// Enables the brownout detection.
                REG2_ENABLE_BO: u1,
                /// Signals that the voltage is above the brownout level for the SOC supply
                REG2_OK: u1,
                /// MSB of Post-divider for Audio PLL
                AUDIO_DIV_MSB: enum(u1) {
                    /// divide by 1 (Default)
                    AUDIO_DIV_MSB_0 = 0x0,
                    /// divide by 2
                    AUDIO_DIV_MSB_1 = 0x1,
                },
                /// Number of clock periods (24MHz clock).
                REG0_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Number of clock periods (24MHz clock).
                REG1_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Number of clock periods (24MHz clock).
                REG2_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Post-divider for video
                VIDEO_DIV: enum(u2) {
                    /// divide by 1 (Default)
                    VIDEO_DIV_0 = 0x0,
                    /// divide by 2
                    VIDEO_DIV_1 = 0x1,
                    /// divide by 1
                    VIDEO_DIV_2 = 0x2,
                    /// divide by 4
                    VIDEO_DIV_3 = 0x3,
                },
            }),
            /// Miscellaneous Control Register
            MISC2_CLR: mmio.Mmio(packed struct(u32) {
                /// This field defines the brown out voltage offset for the CORE power domain
                REG0_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG0_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG0_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg0 brownout status bit.
                REG0_BO_STATUS: enum(u1) {
                    /// Brownout, supply is below target minus brownout offset.
                    REG0_BO_STATUS_1 = 0x1,
                    _,
                },
                reserved5: u1 = 0,
                /// Enables the brownout detection.
                REG0_ENABLE_BO: u1,
                reserved7: u1 = 0,
                /// Default value of "0"
                PLL3_disable: u1,
                /// This field defines the brown out voltage offset for the xPU power domain
                REG1_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG1_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG1_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg1 brownout status bit.
                REG1_BO_STATUS: enum(u1) {
                    /// Brownout, supply is below target minus brownout offset.
                    REG1_BO_STATUS_1 = 0x1,
                    _,
                },
                reserved13: u1 = 0,
                /// Enables the brownout detection.
                REG1_ENABLE_BO: u1,
                reserved15: u1 = 0,
                /// LSB of Post-divider for Audio PLL
                AUDIO_DIV_LSB: enum(u1) {
                    /// divide by 1 (Default)
                    AUDIO_DIV_LSB_0 = 0x0,
                    /// divide by 2
                    AUDIO_DIV_LSB_1 = 0x1,
                },
                /// This field defines the brown out voltage offset for the xPU power domain
                REG2_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG2_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG2_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg2 brownout status bit.
                REG2_BO_STATUS: u1,
                reserved21: u1 = 0,
                /// Enables the brownout detection.
                REG2_ENABLE_BO: u1,
                /// Signals that the voltage is above the brownout level for the SOC supply
                REG2_OK: u1,
                /// MSB of Post-divider for Audio PLL
                AUDIO_DIV_MSB: enum(u1) {
                    /// divide by 1 (Default)
                    AUDIO_DIV_MSB_0 = 0x0,
                    /// divide by 2
                    AUDIO_DIV_MSB_1 = 0x1,
                },
                /// Number of clock periods (24MHz clock).
                REG0_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Number of clock periods (24MHz clock).
                REG1_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Number of clock periods (24MHz clock).
                REG2_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Post-divider for video
                VIDEO_DIV: enum(u2) {
                    /// divide by 1 (Default)
                    VIDEO_DIV_0 = 0x0,
                    /// divide by 2
                    VIDEO_DIV_1 = 0x1,
                    /// divide by 1
                    VIDEO_DIV_2 = 0x2,
                    /// divide by 4
                    VIDEO_DIV_3 = 0x3,
                },
            }),
            /// Miscellaneous Control Register
            MISC2_TOG: mmio.Mmio(packed struct(u32) {
                /// This field defines the brown out voltage offset for the CORE power domain
                REG0_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG0_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG0_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg0 brownout status bit.
                REG0_BO_STATUS: enum(u1) {
                    /// Brownout, supply is below target minus brownout offset.
                    REG0_BO_STATUS_1 = 0x1,
                    _,
                },
                reserved5: u1 = 0,
                /// Enables the brownout detection.
                REG0_ENABLE_BO: u1,
                reserved7: u1 = 0,
                /// Default value of "0"
                PLL3_disable: u1,
                /// This field defines the brown out voltage offset for the xPU power domain
                REG1_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG1_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG1_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg1 brownout status bit.
                REG1_BO_STATUS: enum(u1) {
                    /// Brownout, supply is below target minus brownout offset.
                    REG1_BO_STATUS_1 = 0x1,
                    _,
                },
                reserved13: u1 = 0,
                /// Enables the brownout detection.
                REG1_ENABLE_BO: u1,
                reserved15: u1 = 0,
                /// LSB of Post-divider for Audio PLL
                AUDIO_DIV_LSB: enum(u1) {
                    /// divide by 1 (Default)
                    AUDIO_DIV_LSB_0 = 0x0,
                    /// divide by 2
                    AUDIO_DIV_LSB_1 = 0x1,
                },
                /// This field defines the brown out voltage offset for the xPU power domain
                REG2_BO_OFFSET: enum(u3) {
                    /// Brownout offset = 0.100V
                    REG2_BO_OFFSET_4 = 0x4,
                    /// Brownout offset = 0.175V
                    REG2_BO_OFFSET_7 = 0x7,
                    _,
                },
                /// Reg2 brownout status bit.
                REG2_BO_STATUS: u1,
                reserved21: u1 = 0,
                /// Enables the brownout detection.
                REG2_ENABLE_BO: u1,
                /// Signals that the voltage is above the brownout level for the SOC supply
                REG2_OK: u1,
                /// MSB of Post-divider for Audio PLL
                AUDIO_DIV_MSB: enum(u1) {
                    /// divide by 1 (Default)
                    AUDIO_DIV_MSB_0 = 0x0,
                    /// divide by 2
                    AUDIO_DIV_MSB_1 = 0x1,
                },
                /// Number of clock periods (24MHz clock).
                REG0_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Number of clock periods (24MHz clock).
                REG1_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Number of clock periods (24MHz clock).
                REG2_STEP_TIME: enum(u2) {
                    /// 64
                    @"64_CLOCKS" = 0x0,
                    /// 128
                    @"128_CLOCKS" = 0x1,
                    /// 256
                    @"256_CLOCKS" = 0x2,
                    /// 512
                    @"512_CLOCKS" = 0x3,
                },
                /// Post-divider for video
                VIDEO_DIV: enum(u2) {
                    /// divide by 1 (Default)
                    VIDEO_DIV_0 = 0x0,
                    /// divide by 2
                    VIDEO_DIV_1 = 0x1,
                    /// divide by 1
                    VIDEO_DIV_2 = 0x2,
                    /// divide by 4
                    VIDEO_DIV_3 = 0x3,
                },
            }),
        };

        /// PWM
        pub const PWM1 = extern struct {
            /// Counter Register
            SM0CNT: mmio.Mmio(packed struct(u16) {
                /// Counter Register Bits
                CNT: u16,
            }),
            /// Initial Count Register
            SM0INIT: mmio.Mmio(packed struct(u16) {
                /// Initial Count Register Bits
                INIT: u16,
            }),
            /// Control 2 Register
            SM0CTRL2: mmio.Mmio(packed struct(u16) {
                /// Clock Source Select
                CLK_SEL: enum(u2) {
                    /// The IPBus clock is used as the clock for the local prescaler and counter.
                    CLK_SEL_0 = 0x0,
                    /// EXT_CLK is used as the clock for the local prescaler and counter.
                    CLK_SEL_1 = 0x1,
                    /// Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
                    CLK_SEL_2 = 0x2,
                    _,
                },
                /// Reload Source Select
                RELOAD_SEL: enum(u1) {
                    /// The local RELOAD signal is used to reload registers.
                    RELOAD_SEL_0 = 0x0,
                    /// The master RELOAD signal (from submodule 0) is used to reload registers. This setting should not be used in submodule 0 as it will force the RELOAD signal to logic 0.
                    RELOAD_SEL_1 = 0x1,
                },
                /// This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
                FORCE_SEL: enum(u3) {
                    /// The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
                    FORCE_SEL_0 = 0x0,
                    /// The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
                    FORCE_SEL_1 = 0x1,
                    /// The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
                    FORCE_SEL_2 = 0x2,
                    /// The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
                    FORCE_SEL_3 = 0x3,
                    /// The local sync signal from this submodule is used to force updates.
                    FORCE_SEL_4 = 0x4,
                    /// The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
                    FORCE_SEL_5 = 0x5,
                    /// The external force signal, EXT_FORCE, from outside the PWM module causes updates.
                    FORCE_SEL_6 = 0x6,
                    /// The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
                    FORCE_SEL_7 = 0x7,
                },
                /// Force Initialization
                FORCE: u1,
                /// FRCEN
                FRCEN: enum(u1) {
                    /// Initialization from a FORCE_OUT is disabled.
                    FRCEN_0 = 0x0,
                    /// Initialization from a FORCE_OUT is enabled.
                    FRCEN_1 = 0x1,
                },
                /// Initialization Control Select
                INIT_SEL: enum(u2) {
                    /// Local sync (PWM_X) causes initialization.
                    INIT_SEL_0 = 0x0,
                    /// Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
                    INIT_SEL_1 = 0x1,
                    /// Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
                    INIT_SEL_2 = 0x2,
                    /// EXT_SYNC causes initialization.
                    INIT_SEL_3 = 0x3,
                },
                /// PWM_X Initial Value
                PWMX_INIT: u1,
                /// PWM45 Initial Value
                PWM45_INIT: u1,
                /// PWM23 Initial Value
                PWM23_INIT: u1,
                /// Independent or Complementary Pair Operation
                INDEP: enum(u1) {
                    /// PWM_A and PWM_B form a complementary PWM pair.
                    INDEP_0 = 0x0,
                    /// PWM_A and PWM_B outputs are independent PWMs.
                    INDEP_1 = 0x1,
                },
                /// WAIT Enable
                WAITEN: u1,
                /// Debug Enable
                DBGEN: u1,
            }),
            /// Control Register
            SM0CTRL: mmio.Mmio(packed struct(u16) {
                /// Double Switching Enable
                DBLEN: enum(u1) {
                    /// Double switching disabled.
                    DBLEN_0 = 0x0,
                    /// Double switching enabled.
                    DBLEN_1 = 0x1,
                },
                /// PWMX Double Switching Enable
                DBLX: enum(u1) {
                    /// PWMX double pulse disabled.
                    DBLX_0 = 0x0,
                    /// PWMX double pulse enabled.
                    DBLX_1 = 0x1,
                },
                /// Load Mode Select
                LDMOD: enum(u1) {
                    /// Buffered registers of this submodule are loaded and take effect at the next PWM reload if MCTRL[LDOK] is set.
                    LDMOD_0 = 0x0,
                    /// Buffered registers of this submodule are loaded and take effect immediately upon MCTRL[LDOK] being set. In this case it is not necessary to set CTRL[FULL] or CTRL[HALF].
                    LDMOD_1 = 0x1,
                },
                /// Split the DBLPWM signal to PWMA and PWMB
                SPLIT: enum(u1) {
                    /// DBLPWM is not split. PWMA and PWMB each have double pulses.
                    SPLIT_0 = 0x0,
                    /// DBLPWM is split to PWMA and PWMB.
                    SPLIT_1 = 0x1,
                },
                /// Prescaler
                PRSC: enum(u3) {
                    /// PWM clock frequency = fclk
                    PRSC_0 = 0x0,
                    /// PWM clock frequency = fclk/2
                    PRSC_1 = 0x1,
                    /// PWM clock frequency = fclk/4
                    PRSC_2 = 0x2,
                    /// PWM clock frequency = fclk/8
                    PRSC_3 = 0x3,
                    /// PWM clock frequency = fclk/16
                    PRSC_4 = 0x4,
                    /// PWM clock frequency = fclk/32
                    PRSC_5 = 0x5,
                    /// PWM clock frequency = fclk/64
                    PRSC_6 = 0x6,
                    /// PWM clock frequency = fclk/128
                    PRSC_7 = 0x7,
                },
                /// Compare Mode
                COMPMODE: enum(u1) {
                    /// The VAL* registers and the PWM counter are compared using an "equal to" method. This means that PWM edges are only produced when the counter is equal to one of the VAL* register values. This implies that a PWMA output that is high at the end of a period will maintain this state until a match with VAL3 clears the output in the following period.
                    COMPMODE_0 = 0x0,
                    /// The VAL* registers and the PWM counter are compared using an "equal to or greater than" method. This means that PWM edges are produced when the counter is equal to or greater than one of the VAL* register values. This implies that a PWMA output that is high at the end of a period could go low at the start of the next period if the starting counter value is greater than (but not necessarily equal to) the new VAL3 value.
                    COMPMODE_1 = 0x1,
                },
                /// Deadtime
                DT: u2,
                /// Full Cycle Reload
                FULL: enum(u1) {
                    /// Full-cycle reloads disabled.
                    FULL_0 = 0x0,
                    /// Full-cycle reloads enabled.
                    FULL_1 = 0x1,
                },
                /// Half Cycle Reload
                HALF: enum(u1) {
                    /// Half-cycle reloads disabled.
                    HALF_0 = 0x0,
                    /// Half-cycle reloads enabled.
                    HALF_1 = 0x1,
                },
                /// Load Frequency
                LDFQ: enum(u4) {
                    /// Every PWM opportunity
                    LDFQ_0 = 0x0,
                    /// Every 2 PWM opportunities
                    LDFQ_1 = 0x1,
                    /// Every 3 PWM opportunities
                    LDFQ_2 = 0x2,
                    /// Every 4 PWM opportunities
                    LDFQ_3 = 0x3,
                    /// Every 5 PWM opportunities
                    LDFQ_4 = 0x4,
                    /// Every 6 PWM opportunities
                    LDFQ_5 = 0x5,
                    /// Every 7 PWM opportunities
                    LDFQ_6 = 0x6,
                    /// Every 8 PWM opportunities
                    LDFQ_7 = 0x7,
                    /// Every 9 PWM opportunities
                    LDFQ_8 = 0x8,
                    /// Every 10 PWM opportunities
                    LDFQ_9 = 0x9,
                    /// Every 11 PWM opportunities
                    LDFQ_10 = 0xa,
                    /// Every 12 PWM opportunities
                    LDFQ_11 = 0xb,
                    /// Every 13 PWM opportunities
                    LDFQ_12 = 0xc,
                    /// Every 14 PWM opportunities
                    LDFQ_13 = 0xd,
                    /// Every 15 PWM opportunities
                    LDFQ_14 = 0xe,
                    /// Every 16 PWM opportunities
                    LDFQ_15 = 0xf,
                },
            }),
            reserved10: [2]u8,
            /// Value Register 0
            SM0VAL0: mmio.Mmio(packed struct(u16) {
                /// Value Register 0
                VAL0: u16,
            }),
            /// Fractional Value Register 1
            SM0FRACVAL1: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 1 Register
                FRACVAL1: u5,
            }),
            /// Value Register 1
            SM0VAL1: mmio.Mmio(packed struct(u16) {
                /// Value Register 1
                VAL1: u16,
            }),
            /// Fractional Value Register 2
            SM0FRACVAL2: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 2
                FRACVAL2: u5,
            }),
            /// Value Register 2
            SM0VAL2: mmio.Mmio(packed struct(u16) {
                /// Value Register 2
                VAL2: u16,
            }),
            /// Fractional Value Register 3
            SM0FRACVAL3: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 3
                FRACVAL3: u5,
            }),
            /// Value Register 3
            SM0VAL3: mmio.Mmio(packed struct(u16) {
                /// Value Register 3
                VAL3: u16,
            }),
            /// Fractional Value Register 4
            SM0FRACVAL4: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 4
                FRACVAL4: u5,
            }),
            /// Value Register 4
            SM0VAL4: mmio.Mmio(packed struct(u16) {
                /// Value Register 4
                VAL4: u16,
            }),
            /// Fractional Value Register 5
            SM0FRACVAL5: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 5
                FRACVAL5: u5,
            }),
            /// Value Register 5
            SM0VAL5: mmio.Mmio(packed struct(u16) {
                /// Value Register 5
                VAL5: u16,
            }),
            /// Fractional Control Register
            SM0FRCTRL: mmio.Mmio(packed struct(u16) {
                reserved1: u1 = 0,
                /// Fractional Cycle PWM Period Enable
                FRAC1_EN: enum(u1) {
                    /// Disable fractional cycle length for the PWM period.
                    FRAC1_EN_0 = 0x0,
                    /// Enable fractional cycle length for the PWM period.
                    FRAC1_EN_1 = 0x1,
                },
                /// Fractional Cycle Placement Enable for PWM_A
                FRAC23_EN: enum(u1) {
                    /// Disable fractional cycle placement for PWM_A.
                    FRAC23_EN_0 = 0x0,
                    /// Enable fractional cycle placement for PWM_A.
                    FRAC23_EN_1 = 0x1,
                },
                reserved4: u1 = 0,
                /// Fractional Cycle Placement Enable for PWM_B
                FRAC45_EN: enum(u1) {
                    /// Disable fractional cycle placement for PWM_B.
                    FRAC45_EN_0 = 0x0,
                    /// Enable fractional cycle placement for PWM_B.
                    FRAC45_EN_1 = 0x1,
                },
                reserved8: u3 = 0,
                /// Fractional Delay Circuit Power Up
                FRAC_PU: enum(u1) {
                    /// Turn off fractional delay logic.
                    FRAC_PU_0 = 0x0,
                    /// Power up fractional delay logic.
                    FRAC_PU_1 = 0x1,
                },
                reserved15: u6 = 0,
                /// Test Status Bit
                TEST: u1,
            }),
            /// Output Control Register
            SM0OCTRL: mmio.Mmio(packed struct(u16) {
                /// PWM_X Fault State
                PWMXFS: enum(u2) {
                    /// Output is forced to logic 0 state prior to consideration of output polarity control.
                    PWMXFS_0 = 0x0,
                    /// Output is forced to logic 1 state prior to consideration of output polarity control.
                    PWMXFS_1 = 0x1,
                    /// Output is tristated.
                    PWMXFS_2 = 0x2,
                    /// Output is tristated.
                    PWMXFS_3 = 0x3,
                },
                /// PWM_B Fault State
                PWMBFS: enum(u2) {
                    /// Output is forced to logic 0 state prior to consideration of output polarity control.
                    PWMBFS_0 = 0x0,
                    /// Output is forced to logic 1 state prior to consideration of output polarity control.
                    PWMBFS_1 = 0x1,
                    /// Output is tristated.
                    PWMBFS_2 = 0x2,
                    /// Output is tristated.
                    PWMBFS_3 = 0x3,
                },
                /// PWM_A Fault State
                PWMAFS: enum(u2) {
                    /// Output is forced to logic 0 state prior to consideration of output polarity control.
                    PWMAFS_0 = 0x0,
                    /// Output is forced to logic 1 state prior to consideration of output polarity control.
                    PWMAFS_1 = 0x1,
                    /// Output is tristated.
                    PWMAFS_2 = 0x2,
                    /// Output is tristated.
                    PWMAFS_3 = 0x3,
                },
                reserved8: u2 = 0,
                /// PWM_X Output Polarity
                POLX: enum(u1) {
                    /// PWM_X output not inverted. A high level on the PWM_X pin represents the "on" or "active" state.
                    POLX_0 = 0x0,
                    /// PWM_X output inverted. A low level on the PWM_X pin represents the "on" or "active" state.
                    POLX_1 = 0x1,
                },
                /// PWM_B Output Polarity
                POLB: enum(u1) {
                    /// PWM_B output not inverted. A high level on the PWM_B pin represents the "on" or "active" state.
                    POLB_0 = 0x0,
                    /// PWM_B output inverted. A low level on the PWM_B pin represents the "on" or "active" state.
                    POLB_1 = 0x1,
                },
                /// PWM_A Output Polarity
                POLA: enum(u1) {
                    /// PWM_A output not inverted. A high level on the PWM_A pin represents the "on" or "active" state.
                    POLA_0 = 0x0,
                    /// PWM_A output inverted. A low level on the PWM_A pin represents the "on" or "active" state.
                    POLA_1 = 0x1,
                },
                reserved13: u2 = 0,
                /// PWM_X Input
                PWMX_IN: u1,
                /// PWM_B Input
                PWMB_IN: u1,
                /// PWM_A Input
                PWMA_IN: u1,
            }),
            /// Status Register
            SM0STS: mmio.Mmio(packed struct(u16) {
                /// Compare Flags
                CMPF: enum(u6) {
                    /// No compare event has occurred for a particular VALx value.
                    CMPF_0 = 0x0,
                    /// A compare event has occurred for a particular VALx value.
                    CMPF_1 = 0x1,
                    _,
                },
                /// Capture Flag X0
                CFX0: u1,
                /// Capture Flag X1
                CFX1: u1,
                /// Capture Flag B0
                CFB0: u1,
                /// Capture Flag B1
                CFB1: u1,
                /// Capture Flag A0
                CFA0: u1,
                /// Capture Flag A1
                CFA1: u1,
                /// Reload Flag
                RF: enum(u1) {
                    /// No new reload cycle since last STS[RF] clearing
                    RF_0 = 0x0,
                    /// New reload cycle since last STS[RF] clearing
                    RF_1 = 0x1,
                },
                /// Reload Error Flag
                REF: enum(u1) {
                    /// No reload error occurred.
                    REF_0 = 0x0,
                    /// Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
                    REF_1 = 0x1,
                },
                /// Registers Updated Flag
                RUF: enum(u1) {
                    /// No register update has occurred since last reload.
                    RUF_0 = 0x0,
                    /// At least one of the double buffered registers has been updated since the last reload.
                    RUF_1 = 0x1,
                },
                padding: u1 = 0,
            }),
            /// Interrupt Enable Register
            SM0INTEN: mmio.Mmio(packed struct(u16) {
                /// Compare Interrupt Enables
                CMPIE: enum(u6) {
                    /// The corresponding STS[CMPF] bit will not cause an interrupt request.
                    CMPIE_0 = 0x0,
                    /// The corresponding STS[CMPF] bit will cause an interrupt request.
                    CMPIE_1 = 0x1,
                    _,
                },
                /// Capture X 0 Interrupt Enable
                CX0IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFX0].
                    CX0IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFX0].
                    CX0IE_1 = 0x1,
                },
                /// Capture X 1 Interrupt Enable
                CX1IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFX1].
                    CX1IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFX1].
                    CX1IE_1 = 0x1,
                },
                /// Capture B 0 Interrupt Enable
                CB0IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFB0].
                    CB0IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFB0].
                    CB0IE_1 = 0x1,
                },
                /// Capture B 1 Interrupt Enable
                CB1IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFB1].
                    CB1IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFB1].
                    CB1IE_1 = 0x1,
                },
                /// Capture A 0 Interrupt Enable
                CA0IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFA0].
                    CA0IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFA0].
                    CA0IE_1 = 0x1,
                },
                /// Capture A 1 Interrupt Enable
                CA1IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFA1].
                    CA1IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFA1].
                    CA1IE_1 = 0x1,
                },
                /// Reload Interrupt Enable
                RIE: enum(u1) {
                    /// STS[RF] CPU interrupt requests disabled
                    RIE_0 = 0x0,
                    /// STS[RF] CPU interrupt requests enabled
                    RIE_1 = 0x1,
                },
                /// Reload Error Interrupt Enable
                REIE: enum(u1) {
                    /// STS[REF] CPU interrupt requests disabled
                    REIE_0 = 0x0,
                    /// STS[REF] CPU interrupt requests enabled
                    REIE_1 = 0x1,
                },
                padding: u2 = 0,
            }),
            /// DMA Enable Register
            SM0DMAEN: mmio.Mmio(packed struct(u16) {
                /// Capture X0 FIFO DMA Enable
                CX0DE: u1,
                /// Capture X1 FIFO DMA Enable
                CX1DE: u1,
                /// Capture B0 FIFO DMA Enable
                CB0DE: u1,
                /// Capture B1 FIFO DMA Enable
                CB1DE: u1,
                /// Capture A0 FIFO DMA Enable
                CA0DE: u1,
                /// Capture A1 FIFO DMA Enable
                CA1DE: u1,
                /// Capture DMA Enable Source Select
                CAPTDE: enum(u2) {
                    /// Read DMA requests disabled.
                    CAPTDE_0 = 0x0,
                    /// Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
                    CAPTDE_1 = 0x1,
                    /// A local sync (VAL1 matches counter) sets the read DMA request.
                    CAPTDE_2 = 0x2,
                    /// A local reload (STS[RF] being set) sets the read DMA request.
                    CAPTDE_3 = 0x3,
                },
                /// FIFO Watermark AND Control
                FAND: enum(u1) {
                    /// Selected FIFO watermarks are OR'ed together.
                    FAND_0 = 0x0,
                    /// Selected FIFO watermarks are AND'ed together.
                    FAND_1 = 0x1,
                },
                /// Value Registers DMA Enable
                VALDE: enum(u1) {
                    /// DMA write requests disabled
                    VALDE_0 = 0x0,
                    /// DMA write requests for the VALx and FRACVALx registers enabled
                    VALDE_1 = 0x1,
                },
                padding: u6 = 0,
            }),
            /// Output Trigger Control Register
            SM0TCTRL: mmio.Mmio(packed struct(u16) {
                /// Output Trigger Enables
                OUT_TRIG_EN: enum(u6) {
                    /// PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
                    OUT_TRIG_EN_0 = 0x0,
                    /// PWM_OUT_TRIGx will set when the counter value matches the VALx value.
                    OUT_TRIG_EN_1 = 0x1,
                    _,
                },
                reserved12: u6 = 0,
                /// Trigger frequency
                TRGFRQ: enum(u1) {
                    /// Trigger outputs are generated during every PWM period even if the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
                    TRGFRQ_0 = 0x0,
                    /// Trigger outputs are generated only during the final PWM period prior to a reload opportunity when the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
                    TRGFRQ_1 = 0x1,
                },
                reserved14: u1 = 0,
                /// Output Trigger 1 Source Select
                PWBOT1: enum(u1) {
                    /// Route the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.
                    PWBOT1_0 = 0x0,
                    /// Route the PWMB output to the PWM_OUT_TRIG1 port.
                    PWBOT1_1 = 0x1,
                },
                /// Output Trigger 0 Source Select
                PWAOT0: enum(u1) {
                    /// Route the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.
                    PWAOT0_0 = 0x0,
                    /// Route the PWMA output to the PWM_OUT_TRIG0 port.
                    PWAOT0_1 = 0x1,
                },
            }),
            /// Fault Disable Mapping Register 0
            SM0DISMAP0: mmio.Mmio(packed struct(u16) {
                /// PWM_A Fault Disable Mask 0
                DIS0A: u4,
                /// PWM_B Fault Disable Mask 0
                DIS0B: u4,
                /// PWM_X Fault Disable Mask 0
                DIS0X: u4,
                padding: u4 = 0,
            }),
            /// Fault Disable Mapping Register 1
            SM0DISMAP1: mmio.Mmio(packed struct(u16) {
                /// PWM_A Fault Disable Mask 1
                DIS1A: u4,
                /// PWM_B Fault Disable Mask 1
                DIS1B: u4,
                /// PWM_X Fault Disable Mask 1
                DIS1X: u4,
                padding: u4 = 0,
            }),
            /// Deadtime Count Register 0
            SM0DTCNT0: mmio.Mmio(packed struct(u16) {
                /// DTCNT0
                DTCNT0: u16,
            }),
            /// Deadtime Count Register 1
            SM0DTCNT1: mmio.Mmio(packed struct(u16) {
                /// DTCNT1
                DTCNT1: u16,
            }),
            /// Capture Control A Register
            SM0CAPTCTRLA: mmio.Mmio(packed struct(u16) {
                /// Arm A
                ARMA: enum(u1) {
                    /// Input capture operation is disabled.
                    ARMA_0 = 0x0,
                    /// Input capture operation as specified by CAPTCTRLA[EDGAx] is enabled.
                    ARMA_1 = 0x1,
                },
                /// One Shot Mode A
                ONESHOTA: enum(u1) {
                    /// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
                    ONESHOTA_0 = 0x0,
                    /// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLA[ARMA] is cleared. No further captures will be performed until CAPTCTRLA[ARMA] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLA[ARMA] is then cleared.
                    ONESHOTA_1 = 0x1,
                },
                /// Edge A 0
                EDGA0: enum(u2) {
                    /// Disabled
                    EDGA0_0 = 0x0,
                    /// Capture falling edges
                    EDGA0_1 = 0x1,
                    /// Capture rising edges
                    EDGA0_2 = 0x2,
                    /// Capture any edge
                    EDGA0_3 = 0x3,
                },
                /// Edge A 1
                EDGA1: enum(u2) {
                    /// Disabled
                    EDGA1_0 = 0x0,
                    /// Capture falling edges
                    EDGA1_1 = 0x1,
                    /// Capture rising edges
                    EDGA1_2 = 0x2,
                    /// Capture any edge
                    EDGA1_3 = 0x3,
                },
                /// Input Select A
                INP_SELA: enum(u1) {
                    /// Raw PWM_A input signal selected as source.
                    INP_SELA_0 = 0x0,
                    /// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLA[EDGA0] and CAPTCTRLA[EDGA1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRA[EDGA0] and/or CAPTCTRLA[EDGA1] fields in order to enable one or both of the capture registers.
                    INP_SELA_1 = 0x1,
                },
                /// Edge Counter A Enable
                EDGCNTA_EN: enum(u1) {
                    /// Edge counter disabled and held in reset
                    EDGCNTA_EN_0 = 0x0,
                    /// Edge counter enabled
                    EDGCNTA_EN_1 = 0x1,
                },
                /// Capture A FIFOs Water Mark
                CFAWM: u2,
                /// Capture A0 FIFO Word Count
                CA0CNT: u3,
                /// Capture A1 FIFO Word Count
                CA1CNT: u3,
            }),
            /// Capture Compare A Register
            SM0CAPTCOMPA: mmio.Mmio(packed struct(u16) {
                /// Edge Compare A
                EDGCMPA: u8,
                /// Edge Counter A
                EDGCNTA: u8,
            }),
            /// Capture Control B Register
            SM0CAPTCTRLB: mmio.Mmio(packed struct(u16) {
                /// Arm B
                ARMB: enum(u1) {
                    /// Input capture operation is disabled.
                    ARMB_0 = 0x0,
                    /// Input capture operation as specified by CAPTCTRLB[EDGBx] is enabled.
                    ARMB_1 = 0x1,
                },
                /// One Shot Mode B
                ONESHOTB: enum(u1) {
                    /// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
                    ONESHOTB_0 = 0x0,
                    /// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLB[ARMB] is cleared. No further captures will be performed until CAPTCTRLB[ARMB] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLB[ARMB] is then cleared.
                    ONESHOTB_1 = 0x1,
                },
                /// Edge B 0
                EDGB0: enum(u2) {
                    /// Disabled
                    EDGB0_0 = 0x0,
                    /// Capture falling edges
                    EDGB0_1 = 0x1,
                    /// Capture rising edges
                    EDGB0_2 = 0x2,
                    /// Capture any edge
                    EDGB0_3 = 0x3,
                },
                /// Edge B 1
                EDGB1: enum(u2) {
                    /// Disabled
                    EDGB1_0 = 0x0,
                    /// Capture falling edges
                    EDGB1_1 = 0x1,
                    /// Capture rising edges
                    EDGB1_2 = 0x2,
                    /// Capture any edge
                    EDGB1_3 = 0x3,
                },
                /// Input Select B
                INP_SELB: enum(u1) {
                    /// Raw PWM_B input signal selected as source.
                    INP_SELB_0 = 0x0,
                    /// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLB[EDGB0] and CAPTCTRLB[EDGB1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRB[EDGB0] and/or CAPTCTRLB[EDGB1] fields in order to enable one or both of the capture registers.
                    INP_SELB_1 = 0x1,
                },
                /// Edge Counter B Enable
                EDGCNTB_EN: enum(u1) {
                    /// Edge counter disabled and held in reset
                    EDGCNTB_EN_0 = 0x0,
                    /// Edge counter enabled
                    EDGCNTB_EN_1 = 0x1,
                },
                /// Capture B FIFOs Water Mark
                CFBWM: u2,
                /// Capture B0 FIFO Word Count
                CB0CNT: u3,
                /// Capture B1 FIFO Word Count
                CB1CNT: u3,
            }),
            /// Capture Compare B Register
            SM0CAPTCOMPB: mmio.Mmio(packed struct(u16) {
                /// Edge Compare B
                EDGCMPB: u8,
                /// Edge Counter B
                EDGCNTB: u8,
            }),
            /// Capture Control X Register
            SM0CAPTCTRLX: mmio.Mmio(packed struct(u16) {
                /// Arm X
                ARMX: enum(u1) {
                    /// Input capture operation is disabled.
                    ARMX_0 = 0x0,
                    /// Input capture operation as specified by CAPTCTRLX[EDGXx] is enabled.
                    ARMX_1 = 0x1,
                },
                /// One Shot Mode Aux
                ONESHOTX: enum(u1) {
                    /// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
                    ONESHOTX_0 = 0x0,
                    /// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and the ARMX bit is cleared. No further captures will be performed until the ARMX bit is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and the ARMX bit is then cleared.
                    ONESHOTX_1 = 0x1,
                },
                /// Edge X 0
                EDGX0: enum(u2) {
                    /// Disabled
                    EDGX0_0 = 0x0,
                    /// Capture falling edges
                    EDGX0_1 = 0x1,
                    /// Capture rising edges
                    EDGX0_2 = 0x2,
                    /// Capture any edge
                    EDGX0_3 = 0x3,
                },
                /// Edge X 1
                EDGX1: enum(u2) {
                    /// Disabled
                    EDGX1_0 = 0x0,
                    /// Capture falling edges
                    EDGX1_1 = 0x1,
                    /// Capture rising edges
                    EDGX1_2 = 0x2,
                    /// Capture any edge
                    EDGX1_3 = 0x3,
                },
                /// Input Select X
                INP_SELX: enum(u1) {
                    /// Raw PWM_X input signal selected as source.
                    INP_SELX_0 = 0x0,
                    /// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLX[EDGX0] and CAPTCTRLX[EDGX1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRX[EDGX0] and/or CAPTCTRLX[EDGX1] fields in order to enable one or both of the capture registers.
                    INP_SELX_1 = 0x1,
                },
                /// Edge Counter X Enable
                EDGCNTX_EN: enum(u1) {
                    /// Edge counter disabled and held in reset
                    EDGCNTX_EN_0 = 0x0,
                    /// Edge counter enabled
                    EDGCNTX_EN_1 = 0x1,
                },
                /// Capture X FIFOs Water Mark
                CFXWM: u2,
                /// Capture X0 FIFO Word Count
                CX0CNT: u3,
                /// Capture X1 FIFO Word Count
                CX1CNT: u3,
            }),
            /// Capture Compare X Register
            SM0CAPTCOMPX: mmio.Mmio(packed struct(u16) {
                /// Edge Compare X
                EDGCMPX: u8,
                /// Edge Counter X
                EDGCNTX: u8,
            }),
            /// Capture Value 0 Register
            SM0CVAL0: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL0
                CAPTVAL0: u16,
            }),
            /// Capture Value 0 Cycle Register
            SM0CVAL0CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL0CYC
                CVAL0CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 1 Register
            SM0CVAL1: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL1
                CAPTVAL1: u16,
            }),
            /// Capture Value 1 Cycle Register
            SM0CVAL1CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL1CYC
                CVAL1CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 2 Register
            SM0CVAL2: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL2
                CAPTVAL2: u16,
            }),
            /// Capture Value 2 Cycle Register
            SM0CVAL2CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL2CYC
                CVAL2CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 3 Register
            SM0CVAL3: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL3
                CAPTVAL3: u16,
            }),
            /// Capture Value 3 Cycle Register
            SM0CVAL3CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL3CYC
                CVAL3CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 4 Register
            SM0CVAL4: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL4
                CAPTVAL4: u16,
            }),
            /// Capture Value 4 Cycle Register
            SM0CVAL4CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL4CYC
                CVAL4CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 5 Register
            SM0CVAL5: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL5
                CAPTVAL5: u16,
            }),
            /// Capture Value 5 Cycle Register
            SM0CVAL5CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL5CYC
                CVAL5CYC: u4,
                padding: u12 = 0,
            }),
            reserved96: [8]u8,
            /// Counter Register
            SM1CNT: mmio.Mmio(packed struct(u16) {
                /// Counter Register Bits
                CNT: u16,
            }),
            /// Initial Count Register
            SM1INIT: mmio.Mmio(packed struct(u16) {
                /// Initial Count Register Bits
                INIT: u16,
            }),
            /// Control 2 Register
            SM1CTRL2: mmio.Mmio(packed struct(u16) {
                /// Clock Source Select
                CLK_SEL: enum(u2) {
                    /// The IPBus clock is used as the clock for the local prescaler and counter.
                    CLK_SEL_0 = 0x0,
                    /// EXT_CLK is used as the clock for the local prescaler and counter.
                    CLK_SEL_1 = 0x1,
                    /// Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
                    CLK_SEL_2 = 0x2,
                    _,
                },
                /// Reload Source Select
                RELOAD_SEL: enum(u1) {
                    /// The local RELOAD signal is used to reload registers.
                    RELOAD_SEL_0 = 0x0,
                    /// The master RELOAD signal (from submodule 0) is used to reload registers. This setting should not be used in submodule 0 as it will force the RELOAD signal to logic 0.
                    RELOAD_SEL_1 = 0x1,
                },
                /// This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
                FORCE_SEL: enum(u3) {
                    /// The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
                    FORCE_SEL_0 = 0x0,
                    /// The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
                    FORCE_SEL_1 = 0x1,
                    /// The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
                    FORCE_SEL_2 = 0x2,
                    /// The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
                    FORCE_SEL_3 = 0x3,
                    /// The local sync signal from this submodule is used to force updates.
                    FORCE_SEL_4 = 0x4,
                    /// The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
                    FORCE_SEL_5 = 0x5,
                    /// The external force signal, EXT_FORCE, from outside the PWM module causes updates.
                    FORCE_SEL_6 = 0x6,
                    /// The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
                    FORCE_SEL_7 = 0x7,
                },
                /// Force Initialization
                FORCE: u1,
                /// FRCEN
                FRCEN: enum(u1) {
                    /// Initialization from a FORCE_OUT is disabled.
                    FRCEN_0 = 0x0,
                    /// Initialization from a FORCE_OUT is enabled.
                    FRCEN_1 = 0x1,
                },
                /// Initialization Control Select
                INIT_SEL: enum(u2) {
                    /// Local sync (PWM_X) causes initialization.
                    INIT_SEL_0 = 0x0,
                    /// Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
                    INIT_SEL_1 = 0x1,
                    /// Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
                    INIT_SEL_2 = 0x2,
                    /// EXT_SYNC causes initialization.
                    INIT_SEL_3 = 0x3,
                },
                /// PWM_X Initial Value
                PWMX_INIT: u1,
                /// PWM45 Initial Value
                PWM45_INIT: u1,
                /// PWM23 Initial Value
                PWM23_INIT: u1,
                /// Independent or Complementary Pair Operation
                INDEP: enum(u1) {
                    /// PWM_A and PWM_B form a complementary PWM pair.
                    INDEP_0 = 0x0,
                    /// PWM_A and PWM_B outputs are independent PWMs.
                    INDEP_1 = 0x1,
                },
                /// WAIT Enable
                WAITEN: u1,
                /// Debug Enable
                DBGEN: u1,
            }),
            /// Control Register
            SM1CTRL: mmio.Mmio(packed struct(u16) {
                /// Double Switching Enable
                DBLEN: enum(u1) {
                    /// Double switching disabled.
                    DBLEN_0 = 0x0,
                    /// Double switching enabled.
                    DBLEN_1 = 0x1,
                },
                /// PWMX Double Switching Enable
                DBLX: enum(u1) {
                    /// PWMX double pulse disabled.
                    DBLX_0 = 0x0,
                    /// PWMX double pulse enabled.
                    DBLX_1 = 0x1,
                },
                /// Load Mode Select
                LDMOD: enum(u1) {
                    /// Buffered registers of this submodule are loaded and take effect at the next PWM reload if MCTRL[LDOK] is set.
                    LDMOD_0 = 0x0,
                    /// Buffered registers of this submodule are loaded and take effect immediately upon MCTRL[LDOK] being set. In this case it is not necessary to set CTRL[FULL] or CTRL[HALF].
                    LDMOD_1 = 0x1,
                },
                /// Split the DBLPWM signal to PWMA and PWMB
                SPLIT: enum(u1) {
                    /// DBLPWM is not split. PWMA and PWMB each have double pulses.
                    SPLIT_0 = 0x0,
                    /// DBLPWM is split to PWMA and PWMB.
                    SPLIT_1 = 0x1,
                },
                /// Prescaler
                PRSC: enum(u3) {
                    /// PWM clock frequency = fclk
                    PRSC_0 = 0x0,
                    /// PWM clock frequency = fclk/2
                    PRSC_1 = 0x1,
                    /// PWM clock frequency = fclk/4
                    PRSC_2 = 0x2,
                    /// PWM clock frequency = fclk/8
                    PRSC_3 = 0x3,
                    /// PWM clock frequency = fclk/16
                    PRSC_4 = 0x4,
                    /// PWM clock frequency = fclk/32
                    PRSC_5 = 0x5,
                    /// PWM clock frequency = fclk/64
                    PRSC_6 = 0x6,
                    /// PWM clock frequency = fclk/128
                    PRSC_7 = 0x7,
                },
                /// Compare Mode
                COMPMODE: enum(u1) {
                    /// The VAL* registers and the PWM counter are compared using an "equal to" method. This means that PWM edges are only produced when the counter is equal to one of the VAL* register values. This implies that a PWMA output that is high at the end of a period will maintain this state until a match with VAL3 clears the output in the following period.
                    COMPMODE_0 = 0x0,
                    /// The VAL* registers and the PWM counter are compared using an "equal to or greater than" method. This means that PWM edges are produced when the counter is equal to or greater than one of the VAL* register values. This implies that a PWMA output that is high at the end of a period could go low at the start of the next period if the starting counter value is greater than (but not necessarily equal to) the new VAL3 value.
                    COMPMODE_1 = 0x1,
                },
                /// Deadtime
                DT: u2,
                /// Full Cycle Reload
                FULL: enum(u1) {
                    /// Full-cycle reloads disabled.
                    FULL_0 = 0x0,
                    /// Full-cycle reloads enabled.
                    FULL_1 = 0x1,
                },
                /// Half Cycle Reload
                HALF: enum(u1) {
                    /// Half-cycle reloads disabled.
                    HALF_0 = 0x0,
                    /// Half-cycle reloads enabled.
                    HALF_1 = 0x1,
                },
                /// Load Frequency
                LDFQ: enum(u4) {
                    /// Every PWM opportunity
                    LDFQ_0 = 0x0,
                    /// Every 2 PWM opportunities
                    LDFQ_1 = 0x1,
                    /// Every 3 PWM opportunities
                    LDFQ_2 = 0x2,
                    /// Every 4 PWM opportunities
                    LDFQ_3 = 0x3,
                    /// Every 5 PWM opportunities
                    LDFQ_4 = 0x4,
                    /// Every 6 PWM opportunities
                    LDFQ_5 = 0x5,
                    /// Every 7 PWM opportunities
                    LDFQ_6 = 0x6,
                    /// Every 8 PWM opportunities
                    LDFQ_7 = 0x7,
                    /// Every 9 PWM opportunities
                    LDFQ_8 = 0x8,
                    /// Every 10 PWM opportunities
                    LDFQ_9 = 0x9,
                    /// Every 11 PWM opportunities
                    LDFQ_10 = 0xa,
                    /// Every 12 PWM opportunities
                    LDFQ_11 = 0xb,
                    /// Every 13 PWM opportunities
                    LDFQ_12 = 0xc,
                    /// Every 14 PWM opportunities
                    LDFQ_13 = 0xd,
                    /// Every 15 PWM opportunities
                    LDFQ_14 = 0xe,
                    /// Every 16 PWM opportunities
                    LDFQ_15 = 0xf,
                },
            }),
            reserved106: [2]u8,
            /// Value Register 0
            SM1VAL0: mmio.Mmio(packed struct(u16) {
                /// Value Register 0
                VAL0: u16,
            }),
            /// Fractional Value Register 1
            SM1FRACVAL1: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 1 Register
                FRACVAL1: u5,
            }),
            /// Value Register 1
            SM1VAL1: mmio.Mmio(packed struct(u16) {
                /// Value Register 1
                VAL1: u16,
            }),
            /// Fractional Value Register 2
            SM1FRACVAL2: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 2
                FRACVAL2: u5,
            }),
            /// Value Register 2
            SM1VAL2: mmio.Mmio(packed struct(u16) {
                /// Value Register 2
                VAL2: u16,
            }),
            /// Fractional Value Register 3
            SM1FRACVAL3: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 3
                FRACVAL3: u5,
            }),
            /// Value Register 3
            SM1VAL3: mmio.Mmio(packed struct(u16) {
                /// Value Register 3
                VAL3: u16,
            }),
            /// Fractional Value Register 4
            SM1FRACVAL4: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 4
                FRACVAL4: u5,
            }),
            /// Value Register 4
            SM1VAL4: mmio.Mmio(packed struct(u16) {
                /// Value Register 4
                VAL4: u16,
            }),
            /// Fractional Value Register 5
            SM1FRACVAL5: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 5
                FRACVAL5: u5,
            }),
            /// Value Register 5
            SM1VAL5: mmio.Mmio(packed struct(u16) {
                /// Value Register 5
                VAL5: u16,
            }),
            /// Fractional Control Register
            SM1FRCTRL: mmio.Mmio(packed struct(u16) {
                reserved1: u1 = 0,
                /// Fractional Cycle PWM Period Enable
                FRAC1_EN: enum(u1) {
                    /// Disable fractional cycle length for the PWM period.
                    FRAC1_EN_0 = 0x0,
                    /// Enable fractional cycle length for the PWM period.
                    FRAC1_EN_1 = 0x1,
                },
                /// Fractional Cycle Placement Enable for PWM_A
                FRAC23_EN: enum(u1) {
                    /// Disable fractional cycle placement for PWM_A.
                    FRAC23_EN_0 = 0x0,
                    /// Enable fractional cycle placement for PWM_A.
                    FRAC23_EN_1 = 0x1,
                },
                reserved4: u1 = 0,
                /// Fractional Cycle Placement Enable for PWM_B
                FRAC45_EN: enum(u1) {
                    /// Disable fractional cycle placement for PWM_B.
                    FRAC45_EN_0 = 0x0,
                    /// Enable fractional cycle placement for PWM_B.
                    FRAC45_EN_1 = 0x1,
                },
                reserved8: u3 = 0,
                /// Fractional Delay Circuit Power Up
                FRAC_PU: enum(u1) {
                    /// Turn off fractional delay logic.
                    FRAC_PU_0 = 0x0,
                    /// Power up fractional delay logic.
                    FRAC_PU_1 = 0x1,
                },
                reserved15: u6 = 0,
                /// Test Status Bit
                TEST: u1,
            }),
            /// Output Control Register
            SM1OCTRL: mmio.Mmio(packed struct(u16) {
                /// PWM_X Fault State
                PWMXFS: enum(u2) {
                    /// Output is forced to logic 0 state prior to consideration of output polarity control.
                    PWMXFS_0 = 0x0,
                    /// Output is forced to logic 1 state prior to consideration of output polarity control.
                    PWMXFS_1 = 0x1,
                    /// Output is tristated.
                    PWMXFS_2 = 0x2,
                    /// Output is tristated.
                    PWMXFS_3 = 0x3,
                },
                /// PWM_B Fault State
                PWMBFS: enum(u2) {
                    /// Output is forced to logic 0 state prior to consideration of output polarity control.
                    PWMBFS_0 = 0x0,
                    /// Output is forced to logic 1 state prior to consideration of output polarity control.
                    PWMBFS_1 = 0x1,
                    /// Output is tristated.
                    PWMBFS_2 = 0x2,
                    /// Output is tristated.
                    PWMBFS_3 = 0x3,
                },
                /// PWM_A Fault State
                PWMAFS: enum(u2) {
                    /// Output is forced to logic 0 state prior to consideration of output polarity control.
                    PWMAFS_0 = 0x0,
                    /// Output is forced to logic 1 state prior to consideration of output polarity control.
                    PWMAFS_1 = 0x1,
                    /// Output is tristated.
                    PWMAFS_2 = 0x2,
                    /// Output is tristated.
                    PWMAFS_3 = 0x3,
                },
                reserved8: u2 = 0,
                /// PWM_X Output Polarity
                POLX: enum(u1) {
                    /// PWM_X output not inverted. A high level on the PWM_X pin represents the "on" or "active" state.
                    POLX_0 = 0x0,
                    /// PWM_X output inverted. A low level on the PWM_X pin represents the "on" or "active" state.
                    POLX_1 = 0x1,
                },
                /// PWM_B Output Polarity
                POLB: enum(u1) {
                    /// PWM_B output not inverted. A high level on the PWM_B pin represents the "on" or "active" state.
                    POLB_0 = 0x0,
                    /// PWM_B output inverted. A low level on the PWM_B pin represents the "on" or "active" state.
                    POLB_1 = 0x1,
                },
                /// PWM_A Output Polarity
                POLA: enum(u1) {
                    /// PWM_A output not inverted. A high level on the PWM_A pin represents the "on" or "active" state.
                    POLA_0 = 0x0,
                    /// PWM_A output inverted. A low level on the PWM_A pin represents the "on" or "active" state.
                    POLA_1 = 0x1,
                },
                reserved13: u2 = 0,
                /// PWM_X Input
                PWMX_IN: u1,
                /// PWM_B Input
                PWMB_IN: u1,
                /// PWM_A Input
                PWMA_IN: u1,
            }),
            /// Status Register
            SM1STS: mmio.Mmio(packed struct(u16) {
                /// Compare Flags
                CMPF: enum(u6) {
                    /// No compare event has occurred for a particular VALx value.
                    CMPF_0 = 0x0,
                    /// A compare event has occurred for a particular VALx value.
                    CMPF_1 = 0x1,
                    _,
                },
                /// Capture Flag X0
                CFX0: u1,
                /// Capture Flag X1
                CFX1: u1,
                /// Capture Flag B0
                CFB0: u1,
                /// Capture Flag B1
                CFB1: u1,
                /// Capture Flag A0
                CFA0: u1,
                /// Capture Flag A1
                CFA1: u1,
                /// Reload Flag
                RF: enum(u1) {
                    /// No new reload cycle since last STS[RF] clearing
                    RF_0 = 0x0,
                    /// New reload cycle since last STS[RF] clearing
                    RF_1 = 0x1,
                },
                /// Reload Error Flag
                REF: enum(u1) {
                    /// No reload error occurred.
                    REF_0 = 0x0,
                    /// Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
                    REF_1 = 0x1,
                },
                /// Registers Updated Flag
                RUF: enum(u1) {
                    /// No register update has occurred since last reload.
                    RUF_0 = 0x0,
                    /// At least one of the double buffered registers has been updated since the last reload.
                    RUF_1 = 0x1,
                },
                padding: u1 = 0,
            }),
            /// Interrupt Enable Register
            SM1INTEN: mmio.Mmio(packed struct(u16) {
                /// Compare Interrupt Enables
                CMPIE: enum(u6) {
                    /// The corresponding STS[CMPF] bit will not cause an interrupt request.
                    CMPIE_0 = 0x0,
                    /// The corresponding STS[CMPF] bit will cause an interrupt request.
                    CMPIE_1 = 0x1,
                    _,
                },
                /// Capture X 0 Interrupt Enable
                CX0IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFX0].
                    CX0IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFX0].
                    CX0IE_1 = 0x1,
                },
                /// Capture X 1 Interrupt Enable
                CX1IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFX1].
                    CX1IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFX1].
                    CX1IE_1 = 0x1,
                },
                /// Capture B 0 Interrupt Enable
                CB0IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFB0].
                    CB0IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFB0].
                    CB0IE_1 = 0x1,
                },
                /// Capture B 1 Interrupt Enable
                CB1IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFB1].
                    CB1IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFB1].
                    CB1IE_1 = 0x1,
                },
                /// Capture A 0 Interrupt Enable
                CA0IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFA0].
                    CA0IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFA0].
                    CA0IE_1 = 0x1,
                },
                /// Capture A 1 Interrupt Enable
                CA1IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFA1].
                    CA1IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFA1].
                    CA1IE_1 = 0x1,
                },
                /// Reload Interrupt Enable
                RIE: enum(u1) {
                    /// STS[RF] CPU interrupt requests disabled
                    RIE_0 = 0x0,
                    /// STS[RF] CPU interrupt requests enabled
                    RIE_1 = 0x1,
                },
                /// Reload Error Interrupt Enable
                REIE: enum(u1) {
                    /// STS[REF] CPU interrupt requests disabled
                    REIE_0 = 0x0,
                    /// STS[REF] CPU interrupt requests enabled
                    REIE_1 = 0x1,
                },
                padding: u2 = 0,
            }),
            /// DMA Enable Register
            SM1DMAEN: mmio.Mmio(packed struct(u16) {
                /// Capture X0 FIFO DMA Enable
                CX0DE: u1,
                /// Capture X1 FIFO DMA Enable
                CX1DE: u1,
                /// Capture B0 FIFO DMA Enable
                CB0DE: u1,
                /// Capture B1 FIFO DMA Enable
                CB1DE: u1,
                /// Capture A0 FIFO DMA Enable
                CA0DE: u1,
                /// Capture A1 FIFO DMA Enable
                CA1DE: u1,
                /// Capture DMA Enable Source Select
                CAPTDE: enum(u2) {
                    /// Read DMA requests disabled.
                    CAPTDE_0 = 0x0,
                    /// Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
                    CAPTDE_1 = 0x1,
                    /// A local sync (VAL1 matches counter) sets the read DMA request.
                    CAPTDE_2 = 0x2,
                    /// A local reload (STS[RF] being set) sets the read DMA request.
                    CAPTDE_3 = 0x3,
                },
                /// FIFO Watermark AND Control
                FAND: enum(u1) {
                    /// Selected FIFO watermarks are OR'ed together.
                    FAND_0 = 0x0,
                    /// Selected FIFO watermarks are AND'ed together.
                    FAND_1 = 0x1,
                },
                /// Value Registers DMA Enable
                VALDE: enum(u1) {
                    /// DMA write requests disabled
                    VALDE_0 = 0x0,
                    /// DMA write requests for the VALx and FRACVALx registers enabled
                    VALDE_1 = 0x1,
                },
                padding: u6 = 0,
            }),
            /// Output Trigger Control Register
            SM1TCTRL: mmio.Mmio(packed struct(u16) {
                /// Output Trigger Enables
                OUT_TRIG_EN: enum(u6) {
                    /// PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
                    OUT_TRIG_EN_0 = 0x0,
                    /// PWM_OUT_TRIGx will set when the counter value matches the VALx value.
                    OUT_TRIG_EN_1 = 0x1,
                    _,
                },
                reserved12: u6 = 0,
                /// Trigger frequency
                TRGFRQ: enum(u1) {
                    /// Trigger outputs are generated during every PWM period even if the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
                    TRGFRQ_0 = 0x0,
                    /// Trigger outputs are generated only during the final PWM period prior to a reload opportunity when the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
                    TRGFRQ_1 = 0x1,
                },
                reserved14: u1 = 0,
                /// Output Trigger 1 Source Select
                PWBOT1: enum(u1) {
                    /// Route the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.
                    PWBOT1_0 = 0x0,
                    /// Route the PWMB output to the PWM_OUT_TRIG1 port.
                    PWBOT1_1 = 0x1,
                },
                /// Output Trigger 0 Source Select
                PWAOT0: enum(u1) {
                    /// Route the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.
                    PWAOT0_0 = 0x0,
                    /// Route the PWMA output to the PWM_OUT_TRIG0 port.
                    PWAOT0_1 = 0x1,
                },
            }),
            /// Fault Disable Mapping Register 0
            SM1DISMAP0: mmio.Mmio(packed struct(u16) {
                /// PWM_A Fault Disable Mask 0
                DIS0A: u4,
                /// PWM_B Fault Disable Mask 0
                DIS0B: u4,
                /// PWM_X Fault Disable Mask 0
                DIS0X: u4,
                padding: u4 = 0,
            }),
            /// Fault Disable Mapping Register 1
            SM1DISMAP1: mmio.Mmio(packed struct(u16) {
                /// PWM_A Fault Disable Mask 1
                DIS1A: u4,
                /// PWM_B Fault Disable Mask 1
                DIS1B: u4,
                /// PWM_X Fault Disable Mask 1
                DIS1X: u4,
                padding: u4 = 0,
            }),
            /// Deadtime Count Register 0
            SM1DTCNT0: mmio.Mmio(packed struct(u16) {
                /// DTCNT0
                DTCNT0: u16,
            }),
            /// Deadtime Count Register 1
            SM1DTCNT1: mmio.Mmio(packed struct(u16) {
                /// DTCNT1
                DTCNT1: u16,
            }),
            /// Capture Control A Register
            SM1CAPTCTRLA: mmio.Mmio(packed struct(u16) {
                /// Arm A
                ARMA: enum(u1) {
                    /// Input capture operation is disabled.
                    ARMA_0 = 0x0,
                    /// Input capture operation as specified by CAPTCTRLA[EDGAx] is enabled.
                    ARMA_1 = 0x1,
                },
                /// One Shot Mode A
                ONESHOTA: enum(u1) {
                    /// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
                    ONESHOTA_0 = 0x0,
                    /// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLA[ARMA] is cleared. No further captures will be performed until CAPTCTRLA[ARMA] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLA[ARMA] is then cleared.
                    ONESHOTA_1 = 0x1,
                },
                /// Edge A 0
                EDGA0: enum(u2) {
                    /// Disabled
                    EDGA0_0 = 0x0,
                    /// Capture falling edges
                    EDGA0_1 = 0x1,
                    /// Capture rising edges
                    EDGA0_2 = 0x2,
                    /// Capture any edge
                    EDGA0_3 = 0x3,
                },
                /// Edge A 1
                EDGA1: enum(u2) {
                    /// Disabled
                    EDGA1_0 = 0x0,
                    /// Capture falling edges
                    EDGA1_1 = 0x1,
                    /// Capture rising edges
                    EDGA1_2 = 0x2,
                    /// Capture any edge
                    EDGA1_3 = 0x3,
                },
                /// Input Select A
                INP_SELA: enum(u1) {
                    /// Raw PWM_A input signal selected as source.
                    INP_SELA_0 = 0x0,
                    /// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLA[EDGA0] and CAPTCTRLA[EDGA1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRA[EDGA0] and/or CAPTCTRLA[EDGA1] fields in order to enable one or both of the capture registers.
                    INP_SELA_1 = 0x1,
                },
                /// Edge Counter A Enable
                EDGCNTA_EN: enum(u1) {
                    /// Edge counter disabled and held in reset
                    EDGCNTA_EN_0 = 0x0,
                    /// Edge counter enabled
                    EDGCNTA_EN_1 = 0x1,
                },
                /// Capture A FIFOs Water Mark
                CFAWM: u2,
                /// Capture A0 FIFO Word Count
                CA0CNT: u3,
                /// Capture A1 FIFO Word Count
                CA1CNT: u3,
            }),
            /// Capture Compare A Register
            SM1CAPTCOMPA: mmio.Mmio(packed struct(u16) {
                /// Edge Compare A
                EDGCMPA: u8,
                /// Edge Counter A
                EDGCNTA: u8,
            }),
            /// Capture Control B Register
            SM1CAPTCTRLB: mmio.Mmio(packed struct(u16) {
                /// Arm B
                ARMB: enum(u1) {
                    /// Input capture operation is disabled.
                    ARMB_0 = 0x0,
                    /// Input capture operation as specified by CAPTCTRLB[EDGBx] is enabled.
                    ARMB_1 = 0x1,
                },
                /// One Shot Mode B
                ONESHOTB: enum(u1) {
                    /// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
                    ONESHOTB_0 = 0x0,
                    /// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLB[ARMB] is cleared. No further captures will be performed until CAPTCTRLB[ARMB] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLB[ARMB] is then cleared.
                    ONESHOTB_1 = 0x1,
                },
                /// Edge B 0
                EDGB0: enum(u2) {
                    /// Disabled
                    EDGB0_0 = 0x0,
                    /// Capture falling edges
                    EDGB0_1 = 0x1,
                    /// Capture rising edges
                    EDGB0_2 = 0x2,
                    /// Capture any edge
                    EDGB0_3 = 0x3,
                },
                /// Edge B 1
                EDGB1: enum(u2) {
                    /// Disabled
                    EDGB1_0 = 0x0,
                    /// Capture falling edges
                    EDGB1_1 = 0x1,
                    /// Capture rising edges
                    EDGB1_2 = 0x2,
                    /// Capture any edge
                    EDGB1_3 = 0x3,
                },
                /// Input Select B
                INP_SELB: enum(u1) {
                    /// Raw PWM_B input signal selected as source.
                    INP_SELB_0 = 0x0,
                    /// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLB[EDGB0] and CAPTCTRLB[EDGB1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRB[EDGB0] and/or CAPTCTRLB[EDGB1] fields in order to enable one or both of the capture registers.
                    INP_SELB_1 = 0x1,
                },
                /// Edge Counter B Enable
                EDGCNTB_EN: enum(u1) {
                    /// Edge counter disabled and held in reset
                    EDGCNTB_EN_0 = 0x0,
                    /// Edge counter enabled
                    EDGCNTB_EN_1 = 0x1,
                },
                /// Capture B FIFOs Water Mark
                CFBWM: u2,
                /// Capture B0 FIFO Word Count
                CB0CNT: u3,
                /// Capture B1 FIFO Word Count
                CB1CNT: u3,
            }),
            /// Capture Compare B Register
            SM1CAPTCOMPB: mmio.Mmio(packed struct(u16) {
                /// Edge Compare B
                EDGCMPB: u8,
                /// Edge Counter B
                EDGCNTB: u8,
            }),
            /// Capture Control X Register
            SM1CAPTCTRLX: mmio.Mmio(packed struct(u16) {
                /// Arm X
                ARMX: enum(u1) {
                    /// Input capture operation is disabled.
                    ARMX_0 = 0x0,
                    /// Input capture operation as specified by CAPTCTRLX[EDGXx] is enabled.
                    ARMX_1 = 0x1,
                },
                /// One Shot Mode Aux
                ONESHOTX: enum(u1) {
                    /// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
                    ONESHOTX_0 = 0x0,
                    /// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and the ARMX bit is cleared. No further captures will be performed until the ARMX bit is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and the ARMX bit is then cleared.
                    ONESHOTX_1 = 0x1,
                },
                /// Edge X 0
                EDGX0: enum(u2) {
                    /// Disabled
                    EDGX0_0 = 0x0,
                    /// Capture falling edges
                    EDGX0_1 = 0x1,
                    /// Capture rising edges
                    EDGX0_2 = 0x2,
                    /// Capture any edge
                    EDGX0_3 = 0x3,
                },
                /// Edge X 1
                EDGX1: enum(u2) {
                    /// Disabled
                    EDGX1_0 = 0x0,
                    /// Capture falling edges
                    EDGX1_1 = 0x1,
                    /// Capture rising edges
                    EDGX1_2 = 0x2,
                    /// Capture any edge
                    EDGX1_3 = 0x3,
                },
                /// Input Select X
                INP_SELX: enum(u1) {
                    /// Raw PWM_X input signal selected as source.
                    INP_SELX_0 = 0x0,
                    /// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLX[EDGX0] and CAPTCTRLX[EDGX1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRX[EDGX0] and/or CAPTCTRLX[EDGX1] fields in order to enable one or both of the capture registers.
                    INP_SELX_1 = 0x1,
                },
                /// Edge Counter X Enable
                EDGCNTX_EN: enum(u1) {
                    /// Edge counter disabled and held in reset
                    EDGCNTX_EN_0 = 0x0,
                    /// Edge counter enabled
                    EDGCNTX_EN_1 = 0x1,
                },
                /// Capture X FIFOs Water Mark
                CFXWM: u2,
                /// Capture X0 FIFO Word Count
                CX0CNT: u3,
                /// Capture X1 FIFO Word Count
                CX1CNT: u3,
            }),
            /// Capture Compare X Register
            SM1CAPTCOMPX: mmio.Mmio(packed struct(u16) {
                /// Edge Compare X
                EDGCMPX: u8,
                /// Edge Counter X
                EDGCNTX: u8,
            }),
            /// Capture Value 0 Register
            SM1CVAL0: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL0
                CAPTVAL0: u16,
            }),
            /// Capture Value 0 Cycle Register
            SM1CVAL0CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL0CYC
                CVAL0CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 1 Register
            SM1CVAL1: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL1
                CAPTVAL1: u16,
            }),
            /// Capture Value 1 Cycle Register
            SM1CVAL1CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL1CYC
                CVAL1CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 2 Register
            SM1CVAL2: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL2
                CAPTVAL2: u16,
            }),
            /// Capture Value 2 Cycle Register
            SM1CVAL2CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL2CYC
                CVAL2CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 3 Register
            SM1CVAL3: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL3
                CAPTVAL3: u16,
            }),
            /// Capture Value 3 Cycle Register
            SM1CVAL3CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL3CYC
                CVAL3CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 4 Register
            SM1CVAL4: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL4
                CAPTVAL4: u16,
            }),
            /// Capture Value 4 Cycle Register
            SM1CVAL4CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL4CYC
                CVAL4CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 5 Register
            SM1CVAL5: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL5
                CAPTVAL5: u16,
            }),
            /// Capture Value 5 Cycle Register
            SM1CVAL5CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL5CYC
                CVAL5CYC: u4,
                padding: u12 = 0,
            }),
            reserved192: [8]u8,
            /// Counter Register
            SM2CNT: mmio.Mmio(packed struct(u16) {
                /// Counter Register Bits
                CNT: u16,
            }),
            /// Initial Count Register
            SM2INIT: mmio.Mmio(packed struct(u16) {
                /// Initial Count Register Bits
                INIT: u16,
            }),
            /// Control 2 Register
            SM2CTRL2: mmio.Mmio(packed struct(u16) {
                /// Clock Source Select
                CLK_SEL: enum(u2) {
                    /// The IPBus clock is used as the clock for the local prescaler and counter.
                    CLK_SEL_0 = 0x0,
                    /// EXT_CLK is used as the clock for the local prescaler and counter.
                    CLK_SEL_1 = 0x1,
                    /// Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
                    CLK_SEL_2 = 0x2,
                    _,
                },
                /// Reload Source Select
                RELOAD_SEL: enum(u1) {
                    /// The local RELOAD signal is used to reload registers.
                    RELOAD_SEL_0 = 0x0,
                    /// The master RELOAD signal (from submodule 0) is used to reload registers. This setting should not be used in submodule 0 as it will force the RELOAD signal to logic 0.
                    RELOAD_SEL_1 = 0x1,
                },
                /// This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
                FORCE_SEL: enum(u3) {
                    /// The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
                    FORCE_SEL_0 = 0x0,
                    /// The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
                    FORCE_SEL_1 = 0x1,
                    /// The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
                    FORCE_SEL_2 = 0x2,
                    /// The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
                    FORCE_SEL_3 = 0x3,
                    /// The local sync signal from this submodule is used to force updates.
                    FORCE_SEL_4 = 0x4,
                    /// The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
                    FORCE_SEL_5 = 0x5,
                    /// The external force signal, EXT_FORCE, from outside the PWM module causes updates.
                    FORCE_SEL_6 = 0x6,
                    /// The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
                    FORCE_SEL_7 = 0x7,
                },
                /// Force Initialization
                FORCE: u1,
                /// FRCEN
                FRCEN: enum(u1) {
                    /// Initialization from a FORCE_OUT is disabled.
                    FRCEN_0 = 0x0,
                    /// Initialization from a FORCE_OUT is enabled.
                    FRCEN_1 = 0x1,
                },
                /// Initialization Control Select
                INIT_SEL: enum(u2) {
                    /// Local sync (PWM_X) causes initialization.
                    INIT_SEL_0 = 0x0,
                    /// Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
                    INIT_SEL_1 = 0x1,
                    /// Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
                    INIT_SEL_2 = 0x2,
                    /// EXT_SYNC causes initialization.
                    INIT_SEL_3 = 0x3,
                },
                /// PWM_X Initial Value
                PWMX_INIT: u1,
                /// PWM45 Initial Value
                PWM45_INIT: u1,
                /// PWM23 Initial Value
                PWM23_INIT: u1,
                /// Independent or Complementary Pair Operation
                INDEP: enum(u1) {
                    /// PWM_A and PWM_B form a complementary PWM pair.
                    INDEP_0 = 0x0,
                    /// PWM_A and PWM_B outputs are independent PWMs.
                    INDEP_1 = 0x1,
                },
                /// WAIT Enable
                WAITEN: u1,
                /// Debug Enable
                DBGEN: u1,
            }),
            /// Control Register
            SM2CTRL: mmio.Mmio(packed struct(u16) {
                /// Double Switching Enable
                DBLEN: enum(u1) {
                    /// Double switching disabled.
                    DBLEN_0 = 0x0,
                    /// Double switching enabled.
                    DBLEN_1 = 0x1,
                },
                /// PWMX Double Switching Enable
                DBLX: enum(u1) {
                    /// PWMX double pulse disabled.
                    DBLX_0 = 0x0,
                    /// PWMX double pulse enabled.
                    DBLX_1 = 0x1,
                },
                /// Load Mode Select
                LDMOD: enum(u1) {
                    /// Buffered registers of this submodule are loaded and take effect at the next PWM reload if MCTRL[LDOK] is set.
                    LDMOD_0 = 0x0,
                    /// Buffered registers of this submodule are loaded and take effect immediately upon MCTRL[LDOK] being set. In this case it is not necessary to set CTRL[FULL] or CTRL[HALF].
                    LDMOD_1 = 0x1,
                },
                /// Split the DBLPWM signal to PWMA and PWMB
                SPLIT: enum(u1) {
                    /// DBLPWM is not split. PWMA and PWMB each have double pulses.
                    SPLIT_0 = 0x0,
                    /// DBLPWM is split to PWMA and PWMB.
                    SPLIT_1 = 0x1,
                },
                /// Prescaler
                PRSC: enum(u3) {
                    /// PWM clock frequency = fclk
                    PRSC_0 = 0x0,
                    /// PWM clock frequency = fclk/2
                    PRSC_1 = 0x1,
                    /// PWM clock frequency = fclk/4
                    PRSC_2 = 0x2,
                    /// PWM clock frequency = fclk/8
                    PRSC_3 = 0x3,
                    /// PWM clock frequency = fclk/16
                    PRSC_4 = 0x4,
                    /// PWM clock frequency = fclk/32
                    PRSC_5 = 0x5,
                    /// PWM clock frequency = fclk/64
                    PRSC_6 = 0x6,
                    /// PWM clock frequency = fclk/128
                    PRSC_7 = 0x7,
                },
                /// Compare Mode
                COMPMODE: enum(u1) {
                    /// The VAL* registers and the PWM counter are compared using an "equal to" method. This means that PWM edges are only produced when the counter is equal to one of the VAL* register values. This implies that a PWMA output that is high at the end of a period will maintain this state until a match with VAL3 clears the output in the following period.
                    COMPMODE_0 = 0x0,
                    /// The VAL* registers and the PWM counter are compared using an "equal to or greater than" method. This means that PWM edges are produced when the counter is equal to or greater than one of the VAL* register values. This implies that a PWMA output that is high at the end of a period could go low at the start of the next period if the starting counter value is greater than (but not necessarily equal to) the new VAL3 value.
                    COMPMODE_1 = 0x1,
                },
                /// Deadtime
                DT: u2,
                /// Full Cycle Reload
                FULL: enum(u1) {
                    /// Full-cycle reloads disabled.
                    FULL_0 = 0x0,
                    /// Full-cycle reloads enabled.
                    FULL_1 = 0x1,
                },
                /// Half Cycle Reload
                HALF: enum(u1) {
                    /// Half-cycle reloads disabled.
                    HALF_0 = 0x0,
                    /// Half-cycle reloads enabled.
                    HALF_1 = 0x1,
                },
                /// Load Frequency
                LDFQ: enum(u4) {
                    /// Every PWM opportunity
                    LDFQ_0 = 0x0,
                    /// Every 2 PWM opportunities
                    LDFQ_1 = 0x1,
                    /// Every 3 PWM opportunities
                    LDFQ_2 = 0x2,
                    /// Every 4 PWM opportunities
                    LDFQ_3 = 0x3,
                    /// Every 5 PWM opportunities
                    LDFQ_4 = 0x4,
                    /// Every 6 PWM opportunities
                    LDFQ_5 = 0x5,
                    /// Every 7 PWM opportunities
                    LDFQ_6 = 0x6,
                    /// Every 8 PWM opportunities
                    LDFQ_7 = 0x7,
                    /// Every 9 PWM opportunities
                    LDFQ_8 = 0x8,
                    /// Every 10 PWM opportunities
                    LDFQ_9 = 0x9,
                    /// Every 11 PWM opportunities
                    LDFQ_10 = 0xa,
                    /// Every 12 PWM opportunities
                    LDFQ_11 = 0xb,
                    /// Every 13 PWM opportunities
                    LDFQ_12 = 0xc,
                    /// Every 14 PWM opportunities
                    LDFQ_13 = 0xd,
                    /// Every 15 PWM opportunities
                    LDFQ_14 = 0xe,
                    /// Every 16 PWM opportunities
                    LDFQ_15 = 0xf,
                },
            }),
            reserved202: [2]u8,
            /// Value Register 0
            SM2VAL0: mmio.Mmio(packed struct(u16) {
                /// Value Register 0
                VAL0: u16,
            }),
            /// Fractional Value Register 1
            SM2FRACVAL1: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 1 Register
                FRACVAL1: u5,
            }),
            /// Value Register 1
            SM2VAL1: mmio.Mmio(packed struct(u16) {
                /// Value Register 1
                VAL1: u16,
            }),
            /// Fractional Value Register 2
            SM2FRACVAL2: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 2
                FRACVAL2: u5,
            }),
            /// Value Register 2
            SM2VAL2: mmio.Mmio(packed struct(u16) {
                /// Value Register 2
                VAL2: u16,
            }),
            /// Fractional Value Register 3
            SM2FRACVAL3: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 3
                FRACVAL3: u5,
            }),
            /// Value Register 3
            SM2VAL3: mmio.Mmio(packed struct(u16) {
                /// Value Register 3
                VAL3: u16,
            }),
            /// Fractional Value Register 4
            SM2FRACVAL4: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 4
                FRACVAL4: u5,
            }),
            /// Value Register 4
            SM2VAL4: mmio.Mmio(packed struct(u16) {
                /// Value Register 4
                VAL4: u16,
            }),
            /// Fractional Value Register 5
            SM2FRACVAL5: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 5
                FRACVAL5: u5,
            }),
            /// Value Register 5
            SM2VAL5: mmio.Mmio(packed struct(u16) {
                /// Value Register 5
                VAL5: u16,
            }),
            /// Fractional Control Register
            SM2FRCTRL: mmio.Mmio(packed struct(u16) {
                reserved1: u1 = 0,
                /// Fractional Cycle PWM Period Enable
                FRAC1_EN: enum(u1) {
                    /// Disable fractional cycle length for the PWM period.
                    FRAC1_EN_0 = 0x0,
                    /// Enable fractional cycle length for the PWM period.
                    FRAC1_EN_1 = 0x1,
                },
                /// Fractional Cycle Placement Enable for PWM_A
                FRAC23_EN: enum(u1) {
                    /// Disable fractional cycle placement for PWM_A.
                    FRAC23_EN_0 = 0x0,
                    /// Enable fractional cycle placement for PWM_A.
                    FRAC23_EN_1 = 0x1,
                },
                reserved4: u1 = 0,
                /// Fractional Cycle Placement Enable for PWM_B
                FRAC45_EN: enum(u1) {
                    /// Disable fractional cycle placement for PWM_B.
                    FRAC45_EN_0 = 0x0,
                    /// Enable fractional cycle placement for PWM_B.
                    FRAC45_EN_1 = 0x1,
                },
                reserved8: u3 = 0,
                /// Fractional Delay Circuit Power Up
                FRAC_PU: enum(u1) {
                    /// Turn off fractional delay logic.
                    FRAC_PU_0 = 0x0,
                    /// Power up fractional delay logic.
                    FRAC_PU_1 = 0x1,
                },
                reserved15: u6 = 0,
                /// Test Status Bit
                TEST: u1,
            }),
            /// Output Control Register
            SM2OCTRL: mmio.Mmio(packed struct(u16) {
                /// PWM_X Fault State
                PWMXFS: enum(u2) {
                    /// Output is forced to logic 0 state prior to consideration of output polarity control.
                    PWMXFS_0 = 0x0,
                    /// Output is forced to logic 1 state prior to consideration of output polarity control.
                    PWMXFS_1 = 0x1,
                    /// Output is tristated.
                    PWMXFS_2 = 0x2,
                    /// Output is tristated.
                    PWMXFS_3 = 0x3,
                },
                /// PWM_B Fault State
                PWMBFS: enum(u2) {
                    /// Output is forced to logic 0 state prior to consideration of output polarity control.
                    PWMBFS_0 = 0x0,
                    /// Output is forced to logic 1 state prior to consideration of output polarity control.
                    PWMBFS_1 = 0x1,
                    /// Output is tristated.
                    PWMBFS_2 = 0x2,
                    /// Output is tristated.
                    PWMBFS_3 = 0x3,
                },
                /// PWM_A Fault State
                PWMAFS: enum(u2) {
                    /// Output is forced to logic 0 state prior to consideration of output polarity control.
                    PWMAFS_0 = 0x0,
                    /// Output is forced to logic 1 state prior to consideration of output polarity control.
                    PWMAFS_1 = 0x1,
                    /// Output is tristated.
                    PWMAFS_2 = 0x2,
                    /// Output is tristated.
                    PWMAFS_3 = 0x3,
                },
                reserved8: u2 = 0,
                /// PWM_X Output Polarity
                POLX: enum(u1) {
                    /// PWM_X output not inverted. A high level on the PWM_X pin represents the "on" or "active" state.
                    POLX_0 = 0x0,
                    /// PWM_X output inverted. A low level on the PWM_X pin represents the "on" or "active" state.
                    POLX_1 = 0x1,
                },
                /// PWM_B Output Polarity
                POLB: enum(u1) {
                    /// PWM_B output not inverted. A high level on the PWM_B pin represents the "on" or "active" state.
                    POLB_0 = 0x0,
                    /// PWM_B output inverted. A low level on the PWM_B pin represents the "on" or "active" state.
                    POLB_1 = 0x1,
                },
                /// PWM_A Output Polarity
                POLA: enum(u1) {
                    /// PWM_A output not inverted. A high level on the PWM_A pin represents the "on" or "active" state.
                    POLA_0 = 0x0,
                    /// PWM_A output inverted. A low level on the PWM_A pin represents the "on" or "active" state.
                    POLA_1 = 0x1,
                },
                reserved13: u2 = 0,
                /// PWM_X Input
                PWMX_IN: u1,
                /// PWM_B Input
                PWMB_IN: u1,
                /// PWM_A Input
                PWMA_IN: u1,
            }),
            /// Status Register
            SM2STS: mmio.Mmio(packed struct(u16) {
                /// Compare Flags
                CMPF: enum(u6) {
                    /// No compare event has occurred for a particular VALx value.
                    CMPF_0 = 0x0,
                    /// A compare event has occurred for a particular VALx value.
                    CMPF_1 = 0x1,
                    _,
                },
                /// Capture Flag X0
                CFX0: u1,
                /// Capture Flag X1
                CFX1: u1,
                /// Capture Flag B0
                CFB0: u1,
                /// Capture Flag B1
                CFB1: u1,
                /// Capture Flag A0
                CFA0: u1,
                /// Capture Flag A1
                CFA1: u1,
                /// Reload Flag
                RF: enum(u1) {
                    /// No new reload cycle since last STS[RF] clearing
                    RF_0 = 0x0,
                    /// New reload cycle since last STS[RF] clearing
                    RF_1 = 0x1,
                },
                /// Reload Error Flag
                REF: enum(u1) {
                    /// No reload error occurred.
                    REF_0 = 0x0,
                    /// Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
                    REF_1 = 0x1,
                },
                /// Registers Updated Flag
                RUF: enum(u1) {
                    /// No register update has occurred since last reload.
                    RUF_0 = 0x0,
                    /// At least one of the double buffered registers has been updated since the last reload.
                    RUF_1 = 0x1,
                },
                padding: u1 = 0,
            }),
            /// Interrupt Enable Register
            SM2INTEN: mmio.Mmio(packed struct(u16) {
                /// Compare Interrupt Enables
                CMPIE: enum(u6) {
                    /// The corresponding STS[CMPF] bit will not cause an interrupt request.
                    CMPIE_0 = 0x0,
                    /// The corresponding STS[CMPF] bit will cause an interrupt request.
                    CMPIE_1 = 0x1,
                    _,
                },
                /// Capture X 0 Interrupt Enable
                CX0IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFX0].
                    CX0IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFX0].
                    CX0IE_1 = 0x1,
                },
                /// Capture X 1 Interrupt Enable
                CX1IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFX1].
                    CX1IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFX1].
                    CX1IE_1 = 0x1,
                },
                /// Capture B 0 Interrupt Enable
                CB0IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFB0].
                    CB0IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFB0].
                    CB0IE_1 = 0x1,
                },
                /// Capture B 1 Interrupt Enable
                CB1IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFB1].
                    CB1IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFB1].
                    CB1IE_1 = 0x1,
                },
                /// Capture A 0 Interrupt Enable
                CA0IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFA0].
                    CA0IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFA0].
                    CA0IE_1 = 0x1,
                },
                /// Capture A 1 Interrupt Enable
                CA1IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFA1].
                    CA1IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFA1].
                    CA1IE_1 = 0x1,
                },
                /// Reload Interrupt Enable
                RIE: enum(u1) {
                    /// STS[RF] CPU interrupt requests disabled
                    RIE_0 = 0x0,
                    /// STS[RF] CPU interrupt requests enabled
                    RIE_1 = 0x1,
                },
                /// Reload Error Interrupt Enable
                REIE: enum(u1) {
                    /// STS[REF] CPU interrupt requests disabled
                    REIE_0 = 0x0,
                    /// STS[REF] CPU interrupt requests enabled
                    REIE_1 = 0x1,
                },
                padding: u2 = 0,
            }),
            /// DMA Enable Register
            SM2DMAEN: mmio.Mmio(packed struct(u16) {
                /// Capture X0 FIFO DMA Enable
                CX0DE: u1,
                /// Capture X1 FIFO DMA Enable
                CX1DE: u1,
                /// Capture B0 FIFO DMA Enable
                CB0DE: u1,
                /// Capture B1 FIFO DMA Enable
                CB1DE: u1,
                /// Capture A0 FIFO DMA Enable
                CA0DE: u1,
                /// Capture A1 FIFO DMA Enable
                CA1DE: u1,
                /// Capture DMA Enable Source Select
                CAPTDE: enum(u2) {
                    /// Read DMA requests disabled.
                    CAPTDE_0 = 0x0,
                    /// Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
                    CAPTDE_1 = 0x1,
                    /// A local sync (VAL1 matches counter) sets the read DMA request.
                    CAPTDE_2 = 0x2,
                    /// A local reload (STS[RF] being set) sets the read DMA request.
                    CAPTDE_3 = 0x3,
                },
                /// FIFO Watermark AND Control
                FAND: enum(u1) {
                    /// Selected FIFO watermarks are OR'ed together.
                    FAND_0 = 0x0,
                    /// Selected FIFO watermarks are AND'ed together.
                    FAND_1 = 0x1,
                },
                /// Value Registers DMA Enable
                VALDE: enum(u1) {
                    /// DMA write requests disabled
                    VALDE_0 = 0x0,
                    /// DMA write requests for the VALx and FRACVALx registers enabled
                    VALDE_1 = 0x1,
                },
                padding: u6 = 0,
            }),
            /// Output Trigger Control Register
            SM2TCTRL: mmio.Mmio(packed struct(u16) {
                /// Output Trigger Enables
                OUT_TRIG_EN: enum(u6) {
                    /// PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
                    OUT_TRIG_EN_0 = 0x0,
                    /// PWM_OUT_TRIGx will set when the counter value matches the VALx value.
                    OUT_TRIG_EN_1 = 0x1,
                    _,
                },
                reserved12: u6 = 0,
                /// Trigger frequency
                TRGFRQ: enum(u1) {
                    /// Trigger outputs are generated during every PWM period even if the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
                    TRGFRQ_0 = 0x0,
                    /// Trigger outputs are generated only during the final PWM period prior to a reload opportunity when the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
                    TRGFRQ_1 = 0x1,
                },
                reserved14: u1 = 0,
                /// Output Trigger 1 Source Select
                PWBOT1: enum(u1) {
                    /// Route the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.
                    PWBOT1_0 = 0x0,
                    /// Route the PWMB output to the PWM_OUT_TRIG1 port.
                    PWBOT1_1 = 0x1,
                },
                /// Output Trigger 0 Source Select
                PWAOT0: enum(u1) {
                    /// Route the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.
                    PWAOT0_0 = 0x0,
                    /// Route the PWMA output to the PWM_OUT_TRIG0 port.
                    PWAOT0_1 = 0x1,
                },
            }),
            /// Fault Disable Mapping Register 0
            SM2DISMAP0: mmio.Mmio(packed struct(u16) {
                /// PWM_A Fault Disable Mask 0
                DIS0A: u4,
                /// PWM_B Fault Disable Mask 0
                DIS0B: u4,
                /// PWM_X Fault Disable Mask 0
                DIS0X: u4,
                padding: u4 = 0,
            }),
            /// Fault Disable Mapping Register 1
            SM2DISMAP1: mmio.Mmio(packed struct(u16) {
                /// PWM_A Fault Disable Mask 1
                DIS1A: u4,
                /// PWM_B Fault Disable Mask 1
                DIS1B: u4,
                /// PWM_X Fault Disable Mask 1
                DIS1X: u4,
                padding: u4 = 0,
            }),
            /// Deadtime Count Register 0
            SM2DTCNT0: mmio.Mmio(packed struct(u16) {
                /// DTCNT0
                DTCNT0: u16,
            }),
            /// Deadtime Count Register 1
            SM2DTCNT1: mmio.Mmio(packed struct(u16) {
                /// DTCNT1
                DTCNT1: u16,
            }),
            /// Capture Control A Register
            SM2CAPTCTRLA: mmio.Mmio(packed struct(u16) {
                /// Arm A
                ARMA: enum(u1) {
                    /// Input capture operation is disabled.
                    ARMA_0 = 0x0,
                    /// Input capture operation as specified by CAPTCTRLA[EDGAx] is enabled.
                    ARMA_1 = 0x1,
                },
                /// One Shot Mode A
                ONESHOTA: enum(u1) {
                    /// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
                    ONESHOTA_0 = 0x0,
                    /// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLA[ARMA] is cleared. No further captures will be performed until CAPTCTRLA[ARMA] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLA[ARMA] is then cleared.
                    ONESHOTA_1 = 0x1,
                },
                /// Edge A 0
                EDGA0: enum(u2) {
                    /// Disabled
                    EDGA0_0 = 0x0,
                    /// Capture falling edges
                    EDGA0_1 = 0x1,
                    /// Capture rising edges
                    EDGA0_2 = 0x2,
                    /// Capture any edge
                    EDGA0_3 = 0x3,
                },
                /// Edge A 1
                EDGA1: enum(u2) {
                    /// Disabled
                    EDGA1_0 = 0x0,
                    /// Capture falling edges
                    EDGA1_1 = 0x1,
                    /// Capture rising edges
                    EDGA1_2 = 0x2,
                    /// Capture any edge
                    EDGA1_3 = 0x3,
                },
                /// Input Select A
                INP_SELA: enum(u1) {
                    /// Raw PWM_A input signal selected as source.
                    INP_SELA_0 = 0x0,
                    /// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLA[EDGA0] and CAPTCTRLA[EDGA1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRA[EDGA0] and/or CAPTCTRLA[EDGA1] fields in order to enable one or both of the capture registers.
                    INP_SELA_1 = 0x1,
                },
                /// Edge Counter A Enable
                EDGCNTA_EN: enum(u1) {
                    /// Edge counter disabled and held in reset
                    EDGCNTA_EN_0 = 0x0,
                    /// Edge counter enabled
                    EDGCNTA_EN_1 = 0x1,
                },
                /// Capture A FIFOs Water Mark
                CFAWM: u2,
                /// Capture A0 FIFO Word Count
                CA0CNT: u3,
                /// Capture A1 FIFO Word Count
                CA1CNT: u3,
            }),
            /// Capture Compare A Register
            SM2CAPTCOMPA: mmio.Mmio(packed struct(u16) {
                /// Edge Compare A
                EDGCMPA: u8,
                /// Edge Counter A
                EDGCNTA: u8,
            }),
            /// Capture Control B Register
            SM2CAPTCTRLB: mmio.Mmio(packed struct(u16) {
                /// Arm B
                ARMB: enum(u1) {
                    /// Input capture operation is disabled.
                    ARMB_0 = 0x0,
                    /// Input capture operation as specified by CAPTCTRLB[EDGBx] is enabled.
                    ARMB_1 = 0x1,
                },
                /// One Shot Mode B
                ONESHOTB: enum(u1) {
                    /// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
                    ONESHOTB_0 = 0x0,
                    /// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLB[ARMB] is cleared. No further captures will be performed until CAPTCTRLB[ARMB] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLB[ARMB] is then cleared.
                    ONESHOTB_1 = 0x1,
                },
                /// Edge B 0
                EDGB0: enum(u2) {
                    /// Disabled
                    EDGB0_0 = 0x0,
                    /// Capture falling edges
                    EDGB0_1 = 0x1,
                    /// Capture rising edges
                    EDGB0_2 = 0x2,
                    /// Capture any edge
                    EDGB0_3 = 0x3,
                },
                /// Edge B 1
                EDGB1: enum(u2) {
                    /// Disabled
                    EDGB1_0 = 0x0,
                    /// Capture falling edges
                    EDGB1_1 = 0x1,
                    /// Capture rising edges
                    EDGB1_2 = 0x2,
                    /// Capture any edge
                    EDGB1_3 = 0x3,
                },
                /// Input Select B
                INP_SELB: enum(u1) {
                    /// Raw PWM_B input signal selected as source.
                    INP_SELB_0 = 0x0,
                    /// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLB[EDGB0] and CAPTCTRLB[EDGB1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRB[EDGB0] and/or CAPTCTRLB[EDGB1] fields in order to enable one or both of the capture registers.
                    INP_SELB_1 = 0x1,
                },
                /// Edge Counter B Enable
                EDGCNTB_EN: enum(u1) {
                    /// Edge counter disabled and held in reset
                    EDGCNTB_EN_0 = 0x0,
                    /// Edge counter enabled
                    EDGCNTB_EN_1 = 0x1,
                },
                /// Capture B FIFOs Water Mark
                CFBWM: u2,
                /// Capture B0 FIFO Word Count
                CB0CNT: u3,
                /// Capture B1 FIFO Word Count
                CB1CNT: u3,
            }),
            /// Capture Compare B Register
            SM2CAPTCOMPB: mmio.Mmio(packed struct(u16) {
                /// Edge Compare B
                EDGCMPB: u8,
                /// Edge Counter B
                EDGCNTB: u8,
            }),
            /// Capture Control X Register
            SM2CAPTCTRLX: mmio.Mmio(packed struct(u16) {
                /// Arm X
                ARMX: enum(u1) {
                    /// Input capture operation is disabled.
                    ARMX_0 = 0x0,
                    /// Input capture operation as specified by CAPTCTRLX[EDGXx] is enabled.
                    ARMX_1 = 0x1,
                },
                /// One Shot Mode Aux
                ONESHOTX: enum(u1) {
                    /// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
                    ONESHOTX_0 = 0x0,
                    /// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and the ARMX bit is cleared. No further captures will be performed until the ARMX bit is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and the ARMX bit is then cleared.
                    ONESHOTX_1 = 0x1,
                },
                /// Edge X 0
                EDGX0: enum(u2) {
                    /// Disabled
                    EDGX0_0 = 0x0,
                    /// Capture falling edges
                    EDGX0_1 = 0x1,
                    /// Capture rising edges
                    EDGX0_2 = 0x2,
                    /// Capture any edge
                    EDGX0_3 = 0x3,
                },
                /// Edge X 1
                EDGX1: enum(u2) {
                    /// Disabled
                    EDGX1_0 = 0x0,
                    /// Capture falling edges
                    EDGX1_1 = 0x1,
                    /// Capture rising edges
                    EDGX1_2 = 0x2,
                    /// Capture any edge
                    EDGX1_3 = 0x3,
                },
                /// Input Select X
                INP_SELX: enum(u1) {
                    /// Raw PWM_X input signal selected as source.
                    INP_SELX_0 = 0x0,
                    /// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLX[EDGX0] and CAPTCTRLX[EDGX1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRX[EDGX0] and/or CAPTCTRLX[EDGX1] fields in order to enable one or both of the capture registers.
                    INP_SELX_1 = 0x1,
                },
                /// Edge Counter X Enable
                EDGCNTX_EN: enum(u1) {
                    /// Edge counter disabled and held in reset
                    EDGCNTX_EN_0 = 0x0,
                    /// Edge counter enabled
                    EDGCNTX_EN_1 = 0x1,
                },
                /// Capture X FIFOs Water Mark
                CFXWM: u2,
                /// Capture X0 FIFO Word Count
                CX0CNT: u3,
                /// Capture X1 FIFO Word Count
                CX1CNT: u3,
            }),
            /// Capture Compare X Register
            SM2CAPTCOMPX: mmio.Mmio(packed struct(u16) {
                /// Edge Compare X
                EDGCMPX: u8,
                /// Edge Counter X
                EDGCNTX: u8,
            }),
            /// Capture Value 0 Register
            SM2CVAL0: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL0
                CAPTVAL0: u16,
            }),
            /// Capture Value 0 Cycle Register
            SM2CVAL0CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL0CYC
                CVAL0CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 1 Register
            SM2CVAL1: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL1
                CAPTVAL1: u16,
            }),
            /// Capture Value 1 Cycle Register
            SM2CVAL1CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL1CYC
                CVAL1CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 2 Register
            SM2CVAL2: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL2
                CAPTVAL2: u16,
            }),
            /// Capture Value 2 Cycle Register
            SM2CVAL2CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL2CYC
                CVAL2CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 3 Register
            SM2CVAL3: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL3
                CAPTVAL3: u16,
            }),
            /// Capture Value 3 Cycle Register
            SM2CVAL3CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL3CYC
                CVAL3CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 4 Register
            SM2CVAL4: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL4
                CAPTVAL4: u16,
            }),
            /// Capture Value 4 Cycle Register
            SM2CVAL4CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL4CYC
                CVAL4CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 5 Register
            SM2CVAL5: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL5
                CAPTVAL5: u16,
            }),
            /// Capture Value 5 Cycle Register
            SM2CVAL5CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL5CYC
                CVAL5CYC: u4,
                padding: u12 = 0,
            }),
            reserved288: [8]u8,
            /// Counter Register
            SM3CNT: mmio.Mmio(packed struct(u16) {
                /// Counter Register Bits
                CNT: u16,
            }),
            /// Initial Count Register
            SM3INIT: mmio.Mmio(packed struct(u16) {
                /// Initial Count Register Bits
                INIT: u16,
            }),
            /// Control 2 Register
            SM3CTRL2: mmio.Mmio(packed struct(u16) {
                /// Clock Source Select
                CLK_SEL: enum(u2) {
                    /// The IPBus clock is used as the clock for the local prescaler and counter.
                    CLK_SEL_0 = 0x0,
                    /// EXT_CLK is used as the clock for the local prescaler and counter.
                    CLK_SEL_1 = 0x1,
                    /// Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
                    CLK_SEL_2 = 0x2,
                    _,
                },
                /// Reload Source Select
                RELOAD_SEL: enum(u1) {
                    /// The local RELOAD signal is used to reload registers.
                    RELOAD_SEL_0 = 0x0,
                    /// The master RELOAD signal (from submodule 0) is used to reload registers. This setting should not be used in submodule 0 as it will force the RELOAD signal to logic 0.
                    RELOAD_SEL_1 = 0x1,
                },
                /// This read/write bit determines the source of the FORCE OUTPUT signal for this submodule.
                FORCE_SEL: enum(u3) {
                    /// The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
                    FORCE_SEL_0 = 0x0,
                    /// The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
                    FORCE_SEL_1 = 0x1,
                    /// The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
                    FORCE_SEL_2 = 0x2,
                    /// The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
                    FORCE_SEL_3 = 0x3,
                    /// The local sync signal from this submodule is used to force updates.
                    FORCE_SEL_4 = 0x4,
                    /// The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
                    FORCE_SEL_5 = 0x5,
                    /// The external force signal, EXT_FORCE, from outside the PWM module causes updates.
                    FORCE_SEL_6 = 0x6,
                    /// The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
                    FORCE_SEL_7 = 0x7,
                },
                /// Force Initialization
                FORCE: u1,
                /// FRCEN
                FRCEN: enum(u1) {
                    /// Initialization from a FORCE_OUT is disabled.
                    FRCEN_0 = 0x0,
                    /// Initialization from a FORCE_OUT is enabled.
                    FRCEN_1 = 0x1,
                },
                /// Initialization Control Select
                INIT_SEL: enum(u2) {
                    /// Local sync (PWM_X) causes initialization.
                    INIT_SEL_0 = 0x0,
                    /// Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
                    INIT_SEL_1 = 0x1,
                    /// Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
                    INIT_SEL_2 = 0x2,
                    /// EXT_SYNC causes initialization.
                    INIT_SEL_3 = 0x3,
                },
                /// PWM_X Initial Value
                PWMX_INIT: u1,
                /// PWM45 Initial Value
                PWM45_INIT: u1,
                /// PWM23 Initial Value
                PWM23_INIT: u1,
                /// Independent or Complementary Pair Operation
                INDEP: enum(u1) {
                    /// PWM_A and PWM_B form a complementary PWM pair.
                    INDEP_0 = 0x0,
                    /// PWM_A and PWM_B outputs are independent PWMs.
                    INDEP_1 = 0x1,
                },
                /// WAIT Enable
                WAITEN: u1,
                /// Debug Enable
                DBGEN: u1,
            }),
            /// Control Register
            SM3CTRL: mmio.Mmio(packed struct(u16) {
                /// Double Switching Enable
                DBLEN: enum(u1) {
                    /// Double switching disabled.
                    DBLEN_0 = 0x0,
                    /// Double switching enabled.
                    DBLEN_1 = 0x1,
                },
                /// PWMX Double Switching Enable
                DBLX: enum(u1) {
                    /// PWMX double pulse disabled.
                    DBLX_0 = 0x0,
                    /// PWMX double pulse enabled.
                    DBLX_1 = 0x1,
                },
                /// Load Mode Select
                LDMOD: enum(u1) {
                    /// Buffered registers of this submodule are loaded and take effect at the next PWM reload if MCTRL[LDOK] is set.
                    LDMOD_0 = 0x0,
                    /// Buffered registers of this submodule are loaded and take effect immediately upon MCTRL[LDOK] being set. In this case it is not necessary to set CTRL[FULL] or CTRL[HALF].
                    LDMOD_1 = 0x1,
                },
                /// Split the DBLPWM signal to PWMA and PWMB
                SPLIT: enum(u1) {
                    /// DBLPWM is not split. PWMA and PWMB each have double pulses.
                    SPLIT_0 = 0x0,
                    /// DBLPWM is split to PWMA and PWMB.
                    SPLIT_1 = 0x1,
                },
                /// Prescaler
                PRSC: enum(u3) {
                    /// PWM clock frequency = fclk
                    PRSC_0 = 0x0,
                    /// PWM clock frequency = fclk/2
                    PRSC_1 = 0x1,
                    /// PWM clock frequency = fclk/4
                    PRSC_2 = 0x2,
                    /// PWM clock frequency = fclk/8
                    PRSC_3 = 0x3,
                    /// PWM clock frequency = fclk/16
                    PRSC_4 = 0x4,
                    /// PWM clock frequency = fclk/32
                    PRSC_5 = 0x5,
                    /// PWM clock frequency = fclk/64
                    PRSC_6 = 0x6,
                    /// PWM clock frequency = fclk/128
                    PRSC_7 = 0x7,
                },
                /// Compare Mode
                COMPMODE: enum(u1) {
                    /// The VAL* registers and the PWM counter are compared using an "equal to" method. This means that PWM edges are only produced when the counter is equal to one of the VAL* register values. This implies that a PWMA output that is high at the end of a period will maintain this state until a match with VAL3 clears the output in the following period.
                    COMPMODE_0 = 0x0,
                    /// The VAL* registers and the PWM counter are compared using an "equal to or greater than" method. This means that PWM edges are produced when the counter is equal to or greater than one of the VAL* register values. This implies that a PWMA output that is high at the end of a period could go low at the start of the next period if the starting counter value is greater than (but not necessarily equal to) the new VAL3 value.
                    COMPMODE_1 = 0x1,
                },
                /// Deadtime
                DT: u2,
                /// Full Cycle Reload
                FULL: enum(u1) {
                    /// Full-cycle reloads disabled.
                    FULL_0 = 0x0,
                    /// Full-cycle reloads enabled.
                    FULL_1 = 0x1,
                },
                /// Half Cycle Reload
                HALF: enum(u1) {
                    /// Half-cycle reloads disabled.
                    HALF_0 = 0x0,
                    /// Half-cycle reloads enabled.
                    HALF_1 = 0x1,
                },
                /// Load Frequency
                LDFQ: enum(u4) {
                    /// Every PWM opportunity
                    LDFQ_0 = 0x0,
                    /// Every 2 PWM opportunities
                    LDFQ_1 = 0x1,
                    /// Every 3 PWM opportunities
                    LDFQ_2 = 0x2,
                    /// Every 4 PWM opportunities
                    LDFQ_3 = 0x3,
                    /// Every 5 PWM opportunities
                    LDFQ_4 = 0x4,
                    /// Every 6 PWM opportunities
                    LDFQ_5 = 0x5,
                    /// Every 7 PWM opportunities
                    LDFQ_6 = 0x6,
                    /// Every 8 PWM opportunities
                    LDFQ_7 = 0x7,
                    /// Every 9 PWM opportunities
                    LDFQ_8 = 0x8,
                    /// Every 10 PWM opportunities
                    LDFQ_9 = 0x9,
                    /// Every 11 PWM opportunities
                    LDFQ_10 = 0xa,
                    /// Every 12 PWM opportunities
                    LDFQ_11 = 0xb,
                    /// Every 13 PWM opportunities
                    LDFQ_12 = 0xc,
                    /// Every 14 PWM opportunities
                    LDFQ_13 = 0xd,
                    /// Every 15 PWM opportunities
                    LDFQ_14 = 0xe,
                    /// Every 16 PWM opportunities
                    LDFQ_15 = 0xf,
                },
            }),
            reserved298: [2]u8,
            /// Value Register 0
            SM3VAL0: mmio.Mmio(packed struct(u16) {
                /// Value Register 0
                VAL0: u16,
            }),
            /// Fractional Value Register 1
            SM3FRACVAL1: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 1 Register
                FRACVAL1: u5,
            }),
            /// Value Register 1
            SM3VAL1: mmio.Mmio(packed struct(u16) {
                /// Value Register 1
                VAL1: u16,
            }),
            /// Fractional Value Register 2
            SM3FRACVAL2: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 2
                FRACVAL2: u5,
            }),
            /// Value Register 2
            SM3VAL2: mmio.Mmio(packed struct(u16) {
                /// Value Register 2
                VAL2: u16,
            }),
            /// Fractional Value Register 3
            SM3FRACVAL3: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 3
                FRACVAL3: u5,
            }),
            /// Value Register 3
            SM3VAL3: mmio.Mmio(packed struct(u16) {
                /// Value Register 3
                VAL3: u16,
            }),
            /// Fractional Value Register 4
            SM3FRACVAL4: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 4
                FRACVAL4: u5,
            }),
            /// Value Register 4
            SM3VAL4: mmio.Mmio(packed struct(u16) {
                /// Value Register 4
                VAL4: u16,
            }),
            /// Fractional Value Register 5
            SM3FRACVAL5: mmio.Mmio(packed struct(u16) {
                reserved11: u11 = 0,
                /// Fractional Value 5
                FRACVAL5: u5,
            }),
            /// Value Register 5
            SM3VAL5: mmio.Mmio(packed struct(u16) {
                /// Value Register 5
                VAL5: u16,
            }),
            /// Fractional Control Register
            SM3FRCTRL: mmio.Mmio(packed struct(u16) {
                reserved1: u1 = 0,
                /// Fractional Cycle PWM Period Enable
                FRAC1_EN: enum(u1) {
                    /// Disable fractional cycle length for the PWM period.
                    FRAC1_EN_0 = 0x0,
                    /// Enable fractional cycle length for the PWM period.
                    FRAC1_EN_1 = 0x1,
                },
                /// Fractional Cycle Placement Enable for PWM_A
                FRAC23_EN: enum(u1) {
                    /// Disable fractional cycle placement for PWM_A.
                    FRAC23_EN_0 = 0x0,
                    /// Enable fractional cycle placement for PWM_A.
                    FRAC23_EN_1 = 0x1,
                },
                reserved4: u1 = 0,
                /// Fractional Cycle Placement Enable for PWM_B
                FRAC45_EN: enum(u1) {
                    /// Disable fractional cycle placement for PWM_B.
                    FRAC45_EN_0 = 0x0,
                    /// Enable fractional cycle placement for PWM_B.
                    FRAC45_EN_1 = 0x1,
                },
                reserved8: u3 = 0,
                /// Fractional Delay Circuit Power Up
                FRAC_PU: enum(u1) {
                    /// Turn off fractional delay logic.
                    FRAC_PU_0 = 0x0,
                    /// Power up fractional delay logic.
                    FRAC_PU_1 = 0x1,
                },
                reserved15: u6 = 0,
                /// Test Status Bit
                TEST: u1,
            }),
            /// Output Control Register
            SM3OCTRL: mmio.Mmio(packed struct(u16) {
                /// PWM_X Fault State
                PWMXFS: enum(u2) {
                    /// Output is forced to logic 0 state prior to consideration of output polarity control.
                    PWMXFS_0 = 0x0,
                    /// Output is forced to logic 1 state prior to consideration of output polarity control.
                    PWMXFS_1 = 0x1,
                    /// Output is tristated.
                    PWMXFS_2 = 0x2,
                    /// Output is tristated.
                    PWMXFS_3 = 0x3,
                },
                /// PWM_B Fault State
                PWMBFS: enum(u2) {
                    /// Output is forced to logic 0 state prior to consideration of output polarity control.
                    PWMBFS_0 = 0x0,
                    /// Output is forced to logic 1 state prior to consideration of output polarity control.
                    PWMBFS_1 = 0x1,
                    /// Output is tristated.
                    PWMBFS_2 = 0x2,
                    /// Output is tristated.
                    PWMBFS_3 = 0x3,
                },
                /// PWM_A Fault State
                PWMAFS: enum(u2) {
                    /// Output is forced to logic 0 state prior to consideration of output polarity control.
                    PWMAFS_0 = 0x0,
                    /// Output is forced to logic 1 state prior to consideration of output polarity control.
                    PWMAFS_1 = 0x1,
                    /// Output is tristated.
                    PWMAFS_2 = 0x2,
                    /// Output is tristated.
                    PWMAFS_3 = 0x3,
                },
                reserved8: u2 = 0,
                /// PWM_X Output Polarity
                POLX: enum(u1) {
                    /// PWM_X output not inverted. A high level on the PWM_X pin represents the "on" or "active" state.
                    POLX_0 = 0x0,
                    /// PWM_X output inverted. A low level on the PWM_X pin represents the "on" or "active" state.
                    POLX_1 = 0x1,
                },
                /// PWM_B Output Polarity
                POLB: enum(u1) {
                    /// PWM_B output not inverted. A high level on the PWM_B pin represents the "on" or "active" state.
                    POLB_0 = 0x0,
                    /// PWM_B output inverted. A low level on the PWM_B pin represents the "on" or "active" state.
                    POLB_1 = 0x1,
                },
                /// PWM_A Output Polarity
                POLA: enum(u1) {
                    /// PWM_A output not inverted. A high level on the PWM_A pin represents the "on" or "active" state.
                    POLA_0 = 0x0,
                    /// PWM_A output inverted. A low level on the PWM_A pin represents the "on" or "active" state.
                    POLA_1 = 0x1,
                },
                reserved13: u2 = 0,
                /// PWM_X Input
                PWMX_IN: u1,
                /// PWM_B Input
                PWMB_IN: u1,
                /// PWM_A Input
                PWMA_IN: u1,
            }),
            /// Status Register
            SM3STS: mmio.Mmio(packed struct(u16) {
                /// Compare Flags
                CMPF: enum(u6) {
                    /// No compare event has occurred for a particular VALx value.
                    CMPF_0 = 0x0,
                    /// A compare event has occurred for a particular VALx value.
                    CMPF_1 = 0x1,
                    _,
                },
                /// Capture Flag X0
                CFX0: u1,
                /// Capture Flag X1
                CFX1: u1,
                /// Capture Flag B0
                CFB0: u1,
                /// Capture Flag B1
                CFB1: u1,
                /// Capture Flag A0
                CFA0: u1,
                /// Capture Flag A1
                CFA1: u1,
                /// Reload Flag
                RF: enum(u1) {
                    /// No new reload cycle since last STS[RF] clearing
                    RF_0 = 0x0,
                    /// New reload cycle since last STS[RF] clearing
                    RF_1 = 0x1,
                },
                /// Reload Error Flag
                REF: enum(u1) {
                    /// No reload error occurred.
                    REF_0 = 0x0,
                    /// Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
                    REF_1 = 0x1,
                },
                /// Registers Updated Flag
                RUF: enum(u1) {
                    /// No register update has occurred since last reload.
                    RUF_0 = 0x0,
                    /// At least one of the double buffered registers has been updated since the last reload.
                    RUF_1 = 0x1,
                },
                padding: u1 = 0,
            }),
            /// Interrupt Enable Register
            SM3INTEN: mmio.Mmio(packed struct(u16) {
                /// Compare Interrupt Enables
                CMPIE: enum(u6) {
                    /// The corresponding STS[CMPF] bit will not cause an interrupt request.
                    CMPIE_0 = 0x0,
                    /// The corresponding STS[CMPF] bit will cause an interrupt request.
                    CMPIE_1 = 0x1,
                    _,
                },
                /// Capture X 0 Interrupt Enable
                CX0IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFX0].
                    CX0IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFX0].
                    CX0IE_1 = 0x1,
                },
                /// Capture X 1 Interrupt Enable
                CX1IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFX1].
                    CX1IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFX1].
                    CX1IE_1 = 0x1,
                },
                /// Capture B 0 Interrupt Enable
                CB0IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFB0].
                    CB0IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFB0].
                    CB0IE_1 = 0x1,
                },
                /// Capture B 1 Interrupt Enable
                CB1IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFB1].
                    CB1IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFB1].
                    CB1IE_1 = 0x1,
                },
                /// Capture A 0 Interrupt Enable
                CA0IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFA0].
                    CA0IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFA0].
                    CA0IE_1 = 0x1,
                },
                /// Capture A 1 Interrupt Enable
                CA1IE: enum(u1) {
                    /// Interrupt request disabled for STS[CFA1].
                    CA1IE_0 = 0x0,
                    /// Interrupt request enabled for STS[CFA1].
                    CA1IE_1 = 0x1,
                },
                /// Reload Interrupt Enable
                RIE: enum(u1) {
                    /// STS[RF] CPU interrupt requests disabled
                    RIE_0 = 0x0,
                    /// STS[RF] CPU interrupt requests enabled
                    RIE_1 = 0x1,
                },
                /// Reload Error Interrupt Enable
                REIE: enum(u1) {
                    /// STS[REF] CPU interrupt requests disabled
                    REIE_0 = 0x0,
                    /// STS[REF] CPU interrupt requests enabled
                    REIE_1 = 0x1,
                },
                padding: u2 = 0,
            }),
            /// DMA Enable Register
            SM3DMAEN: mmio.Mmio(packed struct(u16) {
                /// Capture X0 FIFO DMA Enable
                CX0DE: u1,
                /// Capture X1 FIFO DMA Enable
                CX1DE: u1,
                /// Capture B0 FIFO DMA Enable
                CB0DE: u1,
                /// Capture B1 FIFO DMA Enable
                CB1DE: u1,
                /// Capture A0 FIFO DMA Enable
                CA0DE: u1,
                /// Capture A1 FIFO DMA Enable
                CA1DE: u1,
                /// Capture DMA Enable Source Select
                CAPTDE: enum(u2) {
                    /// Read DMA requests disabled.
                    CAPTDE_0 = 0x0,
                    /// Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
                    CAPTDE_1 = 0x1,
                    /// A local sync (VAL1 matches counter) sets the read DMA request.
                    CAPTDE_2 = 0x2,
                    /// A local reload (STS[RF] being set) sets the read DMA request.
                    CAPTDE_3 = 0x3,
                },
                /// FIFO Watermark AND Control
                FAND: enum(u1) {
                    /// Selected FIFO watermarks are OR'ed together.
                    FAND_0 = 0x0,
                    /// Selected FIFO watermarks are AND'ed together.
                    FAND_1 = 0x1,
                },
                /// Value Registers DMA Enable
                VALDE: enum(u1) {
                    /// DMA write requests disabled
                    VALDE_0 = 0x0,
                    /// DMA write requests for the VALx and FRACVALx registers enabled
                    VALDE_1 = 0x1,
                },
                padding: u6 = 0,
            }),
            /// Output Trigger Control Register
            SM3TCTRL: mmio.Mmio(packed struct(u16) {
                /// Output Trigger Enables
                OUT_TRIG_EN: enum(u6) {
                    /// PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
                    OUT_TRIG_EN_0 = 0x0,
                    /// PWM_OUT_TRIGx will set when the counter value matches the VALx value.
                    OUT_TRIG_EN_1 = 0x1,
                    _,
                },
                reserved12: u6 = 0,
                /// Trigger frequency
                TRGFRQ: enum(u1) {
                    /// Trigger outputs are generated during every PWM period even if the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
                    TRGFRQ_0 = 0x0,
                    /// Trigger outputs are generated only during the final PWM period prior to a reload opportunity when the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
                    TRGFRQ_1 = 0x1,
                },
                reserved14: u1 = 0,
                /// Output Trigger 1 Source Select
                PWBOT1: enum(u1) {
                    /// Route the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.
                    PWBOT1_0 = 0x0,
                    /// Route the PWMB output to the PWM_OUT_TRIG1 port.
                    PWBOT1_1 = 0x1,
                },
                /// Output Trigger 0 Source Select
                PWAOT0: enum(u1) {
                    /// Route the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.
                    PWAOT0_0 = 0x0,
                    /// Route the PWMA output to the PWM_OUT_TRIG0 port.
                    PWAOT0_1 = 0x1,
                },
            }),
            /// Fault Disable Mapping Register 0
            SM3DISMAP0: mmio.Mmio(packed struct(u16) {
                /// PWM_A Fault Disable Mask 0
                DIS0A: u4,
                /// PWM_B Fault Disable Mask 0
                DIS0B: u4,
                /// PWM_X Fault Disable Mask 0
                DIS0X: u4,
                padding: u4 = 0,
            }),
            /// Fault Disable Mapping Register 1
            SM3DISMAP1: mmio.Mmio(packed struct(u16) {
                /// PWM_A Fault Disable Mask 1
                DIS1A: u4,
                /// PWM_B Fault Disable Mask 1
                DIS1B: u4,
                /// PWM_X Fault Disable Mask 1
                DIS1X: u4,
                padding: u4 = 0,
            }),
            /// Deadtime Count Register 0
            SM3DTCNT0: mmio.Mmio(packed struct(u16) {
                /// DTCNT0
                DTCNT0: u16,
            }),
            /// Deadtime Count Register 1
            SM3DTCNT1: mmio.Mmio(packed struct(u16) {
                /// DTCNT1
                DTCNT1: u16,
            }),
            /// Capture Control A Register
            SM3CAPTCTRLA: mmio.Mmio(packed struct(u16) {
                /// Arm A
                ARMA: enum(u1) {
                    /// Input capture operation is disabled.
                    ARMA_0 = 0x0,
                    /// Input capture operation as specified by CAPTCTRLA[EDGAx] is enabled.
                    ARMA_1 = 0x1,
                },
                /// One Shot Mode A
                ONESHOTA: enum(u1) {
                    /// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
                    ONESHOTA_0 = 0x0,
                    /// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLA[ARMA] is cleared. No further captures will be performed until CAPTCTRLA[ARMA] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLA[ARMA] is then cleared.
                    ONESHOTA_1 = 0x1,
                },
                /// Edge A 0
                EDGA0: enum(u2) {
                    /// Disabled
                    EDGA0_0 = 0x0,
                    /// Capture falling edges
                    EDGA0_1 = 0x1,
                    /// Capture rising edges
                    EDGA0_2 = 0x2,
                    /// Capture any edge
                    EDGA0_3 = 0x3,
                },
                /// Edge A 1
                EDGA1: enum(u2) {
                    /// Disabled
                    EDGA1_0 = 0x0,
                    /// Capture falling edges
                    EDGA1_1 = 0x1,
                    /// Capture rising edges
                    EDGA1_2 = 0x2,
                    /// Capture any edge
                    EDGA1_3 = 0x3,
                },
                /// Input Select A
                INP_SELA: enum(u1) {
                    /// Raw PWM_A input signal selected as source.
                    INP_SELA_0 = 0x0,
                    /// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLA[EDGA0] and CAPTCTRLA[EDGA1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRA[EDGA0] and/or CAPTCTRLA[EDGA1] fields in order to enable one or both of the capture registers.
                    INP_SELA_1 = 0x1,
                },
                /// Edge Counter A Enable
                EDGCNTA_EN: enum(u1) {
                    /// Edge counter disabled and held in reset
                    EDGCNTA_EN_0 = 0x0,
                    /// Edge counter enabled
                    EDGCNTA_EN_1 = 0x1,
                },
                /// Capture A FIFOs Water Mark
                CFAWM: u2,
                /// Capture A0 FIFO Word Count
                CA0CNT: u3,
                /// Capture A1 FIFO Word Count
                CA1CNT: u3,
            }),
            /// Capture Compare A Register
            SM3CAPTCOMPA: mmio.Mmio(packed struct(u16) {
                /// Edge Compare A
                EDGCMPA: u8,
                /// Edge Counter A
                EDGCNTA: u8,
            }),
            /// Capture Control B Register
            SM3CAPTCTRLB: mmio.Mmio(packed struct(u16) {
                /// Arm B
                ARMB: enum(u1) {
                    /// Input capture operation is disabled.
                    ARMB_0 = 0x0,
                    /// Input capture operation as specified by CAPTCTRLB[EDGBx] is enabled.
                    ARMB_1 = 0x1,
                },
                /// One Shot Mode B
                ONESHOTB: enum(u1) {
                    /// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
                    ONESHOTB_0 = 0x0,
                    /// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLB[ARMB] is cleared. No further captures will be performed until CAPTCTRLB[ARMB] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLB[ARMB] is then cleared.
                    ONESHOTB_1 = 0x1,
                },
                /// Edge B 0
                EDGB0: enum(u2) {
                    /// Disabled
                    EDGB0_0 = 0x0,
                    /// Capture falling edges
                    EDGB0_1 = 0x1,
                    /// Capture rising edges
                    EDGB0_2 = 0x2,
                    /// Capture any edge
                    EDGB0_3 = 0x3,
                },
                /// Edge B 1
                EDGB1: enum(u2) {
                    /// Disabled
                    EDGB1_0 = 0x0,
                    /// Capture falling edges
                    EDGB1_1 = 0x1,
                    /// Capture rising edges
                    EDGB1_2 = 0x2,
                    /// Capture any edge
                    EDGB1_3 = 0x3,
                },
                /// Input Select B
                INP_SELB: enum(u1) {
                    /// Raw PWM_B input signal selected as source.
                    INP_SELB_0 = 0x0,
                    /// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLB[EDGB0] and CAPTCTRLB[EDGB1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRB[EDGB0] and/or CAPTCTRLB[EDGB1] fields in order to enable one or both of the capture registers.
                    INP_SELB_1 = 0x1,
                },
                /// Edge Counter B Enable
                EDGCNTB_EN: enum(u1) {
                    /// Edge counter disabled and held in reset
                    EDGCNTB_EN_0 = 0x0,
                    /// Edge counter enabled
                    EDGCNTB_EN_1 = 0x1,
                },
                /// Capture B FIFOs Water Mark
                CFBWM: u2,
                /// Capture B0 FIFO Word Count
                CB0CNT: u3,
                /// Capture B1 FIFO Word Count
                CB1CNT: u3,
            }),
            /// Capture Compare B Register
            SM3CAPTCOMPB: mmio.Mmio(packed struct(u16) {
                /// Edge Compare B
                EDGCMPB: u8,
                /// Edge Counter B
                EDGCNTB: u8,
            }),
            /// Capture Control X Register
            SM3CAPTCTRLX: mmio.Mmio(packed struct(u16) {
                /// Arm X
                ARMX: enum(u1) {
                    /// Input capture operation is disabled.
                    ARMX_0 = 0x0,
                    /// Input capture operation as specified by CAPTCTRLX[EDGXx] is enabled.
                    ARMX_1 = 0x1,
                },
                /// One Shot Mode Aux
                ONESHOTX: enum(u1) {
                    /// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
                    ONESHOTX_0 = 0x0,
                    /// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and the ARMX bit is cleared. No further captures will be performed until the ARMX bit is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and the ARMX bit is then cleared.
                    ONESHOTX_1 = 0x1,
                },
                /// Edge X 0
                EDGX0: enum(u2) {
                    /// Disabled
                    EDGX0_0 = 0x0,
                    /// Capture falling edges
                    EDGX0_1 = 0x1,
                    /// Capture rising edges
                    EDGX0_2 = 0x2,
                    /// Capture any edge
                    EDGX0_3 = 0x3,
                },
                /// Edge X 1
                EDGX1: enum(u2) {
                    /// Disabled
                    EDGX1_0 = 0x0,
                    /// Capture falling edges
                    EDGX1_1 = 0x1,
                    /// Capture rising edges
                    EDGX1_2 = 0x2,
                    /// Capture any edge
                    EDGX1_3 = 0x3,
                },
                /// Input Select X
                INP_SELX: enum(u1) {
                    /// Raw PWM_X input signal selected as source.
                    INP_SELX_0 = 0x0,
                    /// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLX[EDGX0] and CAPTCTRLX[EDGX1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRX[EDGX0] and/or CAPTCTRLX[EDGX1] fields in order to enable one or both of the capture registers.
                    INP_SELX_1 = 0x1,
                },
                /// Edge Counter X Enable
                EDGCNTX_EN: enum(u1) {
                    /// Edge counter disabled and held in reset
                    EDGCNTX_EN_0 = 0x0,
                    /// Edge counter enabled
                    EDGCNTX_EN_1 = 0x1,
                },
                /// Capture X FIFOs Water Mark
                CFXWM: u2,
                /// Capture X0 FIFO Word Count
                CX0CNT: u3,
                /// Capture X1 FIFO Word Count
                CX1CNT: u3,
            }),
            /// Capture Compare X Register
            SM3CAPTCOMPX: mmio.Mmio(packed struct(u16) {
                /// Edge Compare X
                EDGCMPX: u8,
                /// Edge Counter X
                EDGCNTX: u8,
            }),
            /// Capture Value 0 Register
            SM3CVAL0: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL0
                CAPTVAL0: u16,
            }),
            /// Capture Value 0 Cycle Register
            SM3CVAL0CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL0CYC
                CVAL0CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 1 Register
            SM3CVAL1: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL1
                CAPTVAL1: u16,
            }),
            /// Capture Value 1 Cycle Register
            SM3CVAL1CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL1CYC
                CVAL1CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 2 Register
            SM3CVAL2: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL2
                CAPTVAL2: u16,
            }),
            /// Capture Value 2 Cycle Register
            SM3CVAL2CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL2CYC
                CVAL2CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 3 Register
            SM3CVAL3: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL3
                CAPTVAL3: u16,
            }),
            /// Capture Value 3 Cycle Register
            SM3CVAL3CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL3CYC
                CVAL3CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 4 Register
            SM3CVAL4: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL4
                CAPTVAL4: u16,
            }),
            /// Capture Value 4 Cycle Register
            SM3CVAL4CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL4CYC
                CVAL4CYC: u4,
                padding: u12 = 0,
            }),
            /// Capture Value 5 Register
            SM3CVAL5: mmio.Mmio(packed struct(u16) {
                /// CAPTVAL5
                CAPTVAL5: u16,
            }),
            /// Capture Value 5 Cycle Register
            SM3CVAL5CYC: mmio.Mmio(packed struct(u16) {
                /// CVAL5CYC
                CVAL5CYC: u4,
                padding: u12 = 0,
            }),
            reserved384: [8]u8,
            /// Output Enable Register
            OUTEN: mmio.Mmio(packed struct(u16) {
                /// PWM_X Output Enables
                PWMX_EN: enum(u4) {
                    /// PWM_X output disabled.
                    PWMX_EN_0 = 0x0,
                    /// PWM_X output enabled.
                    PWMX_EN_1 = 0x1,
                    _,
                },
                /// PWM_B Output Enables
                PWMB_EN: enum(u4) {
                    /// PWM_B output disabled.
                    PWMB_EN_0 = 0x0,
                    /// PWM_B output enabled.
                    PWMB_EN_1 = 0x1,
                    _,
                },
                /// PWM_A Output Enables
                PWMA_EN: enum(u4) {
                    /// PWM_A output disabled.
                    PWMA_EN_0 = 0x0,
                    /// PWM_A output enabled.
                    PWMA_EN_1 = 0x1,
                    _,
                },
                padding: u4 = 0,
            }),
            /// Mask Register
            MASK: mmio.Mmio(packed struct(u16) {
                /// PWM_X Masks
                MASKX: enum(u4) {
                    /// PWM_X output normal.
                    MASKX_0 = 0x0,
                    /// PWM_X output masked.
                    MASKX_1 = 0x1,
                    _,
                },
                /// PWM_B Masks
                MASKB: enum(u4) {
                    /// PWM_B output normal.
                    MASKB_0 = 0x0,
                    /// PWM_B output masked.
                    MASKB_1 = 0x1,
                    _,
                },
                /// PWM_A Masks
                MASKA: enum(u4) {
                    /// PWM_A output normal.
                    MASKA_0 = 0x0,
                    /// PWM_A output masked.
                    MASKA_1 = 0x1,
                    _,
                },
                /// Update Mask Bits Immediately
                UPDATE_MASK: enum(u4) {
                    /// Normal operation. MASK* bits within the corresponding submodule are not updated until a FORCE_OUT event occurs within the submodule.
                    UPDATE_MASK_0 = 0x0,
                    /// Immediate operation. MASK* bits within the corresponding submodule are updated on the following clock edge after setting this bit.
                    UPDATE_MASK_1 = 0x1,
                    _,
                },
            }),
            /// Software Controlled Output Register
            SWCOUT: mmio.Mmio(packed struct(u16) {
                /// Submodule 0 Software Controlled Output 45
                SM0OUT45: enum(u1) {
                    /// A logic 0 is supplied to the deadtime generator of submodule 0 instead of PWM45.
                    SM0OUT45_0 = 0x0,
                    /// A logic 1 is supplied to the deadtime generator of submodule 0 instead of PWM45.
                    SM0OUT45_1 = 0x1,
                },
                /// Submodule 0 Software Controlled Output 23
                SM0OUT23: enum(u1) {
                    /// A logic 0 is supplied to the deadtime generator of submodule 0 instead of PWM23.
                    SM0OUT23_0 = 0x0,
                    /// A logic 1 is supplied to the deadtime generator of submodule 0 instead of PWM23.
                    SM0OUT23_1 = 0x1,
                },
                /// Submodule 1 Software Controlled Output 45
                SM1OUT45: enum(u1) {
                    /// A logic 0 is supplied to the deadtime generator of submodule 1 instead of PWM45.
                    SM1OUT45_0 = 0x0,
                    /// A logic 1 is supplied to the deadtime generator of submodule 1 instead of PWM45.
                    SM1OUT45_1 = 0x1,
                },
                /// Submodule 1 Software Controlled Output 23
                SM1OUT23: enum(u1) {
                    /// A logic 0 is supplied to the deadtime generator of submodule 1 instead of PWM23.
                    SM1OUT23_0 = 0x0,
                    /// A logic 1 is supplied to the deadtime generator of submodule 1 instead of PWM23.
                    SM1OUT23_1 = 0x1,
                },
                /// Submodule 2 Software Controlled Output 45
                SM2OUT45: enum(u1) {
                    /// A logic 0 is supplied to the deadtime generator of submodule 2 instead of PWM45.
                    SM2OUT45_0 = 0x0,
                    /// A logic 1 is supplied to the deadtime generator of submodule 2 instead of PWM45.
                    SM2OUT45_1 = 0x1,
                },
                /// Submodule 2 Software Controlled Output 23
                SM2OUT23: enum(u1) {
                    /// A logic 0 is supplied to the deadtime generator of submodule 2 instead of PWM23.
                    SM2OUT23_0 = 0x0,
                    /// A logic 1 is supplied to the deadtime generator of submodule 2 instead of PWM23.
                    SM2OUT23_1 = 0x1,
                },
                /// Submodule 3 Software Controlled Output 45
                SM3OUT45: enum(u1) {
                    /// A logic 0 is supplied to the deadtime generator of submodule 3 instead of PWM45.
                    SM3OUT45_0 = 0x0,
                    /// A logic 1 is supplied to the deadtime generator of submodule 3 instead of PWM45.
                    SM3OUT45_1 = 0x1,
                },
                /// Submodule 3 Software Controlled Output 23
                SM3OUT23: enum(u1) {
                    /// A logic 0 is supplied to the deadtime generator of submodule 3 instead of PWM23.
                    SM3OUT23_0 = 0x0,
                    /// A logic 1 is supplied to the deadtime generator of submodule 3 instead of PWM23.
                    SM3OUT23_1 = 0x1,
                },
                padding: u8 = 0,
            }),
            /// PWM Source Select Register
            DTSRCSEL: mmio.Mmio(packed struct(u16) {
                /// Submodule 0 PWM45 Control Select
                SM0SEL45: enum(u2) {
                    /// Generated SM0PWM45 signal is used by the deadtime logic.
                    SM0SEL45_0 = 0x0,
                    /// Inverted generated SM0PWM45 signal is used by the deadtime logic.
                    SM0SEL45_1 = 0x1,
                    /// SWCOUT[SM0OUT45] is used by the deadtime logic.
                    SM0SEL45_2 = 0x2,
                    /// PWM0_EXTB signal is used by the deadtime logic.
                    SM0SEL45_3 = 0x3,
                },
                /// Submodule 0 PWM23 Control Select
                SM0SEL23: enum(u2) {
                    /// Generated SM0PWM23 signal is used by the deadtime logic.
                    SM0SEL23_0 = 0x0,
                    /// Inverted generated SM0PWM23 signal is used by the deadtime logic.
                    SM0SEL23_1 = 0x1,
                    /// SWCOUT[SM0OUT23] is used by the deadtime logic.
                    SM0SEL23_2 = 0x2,
                    /// PWM0_EXTA signal is used by the deadtime logic.
                    SM0SEL23_3 = 0x3,
                },
                /// Submodule 1 PWM45 Control Select
                SM1SEL45: enum(u2) {
                    /// Generated SM1PWM45 signal is used by the deadtime logic.
                    SM1SEL45_0 = 0x0,
                    /// Inverted generated SM1PWM45 signal is used by the deadtime logic.
                    SM1SEL45_1 = 0x1,
                    /// SWCOUT[SM1OUT45] is used by the deadtime logic.
                    SM1SEL45_2 = 0x2,
                    /// PWM1_EXTB signal is used by the deadtime logic.
                    SM1SEL45_3 = 0x3,
                },
                /// Submodule 1 PWM23 Control Select
                SM1SEL23: enum(u2) {
                    /// Generated SM1PWM23 signal is used by the deadtime logic.
                    SM1SEL23_0 = 0x0,
                    /// Inverted generated SM1PWM23 signal is used by the deadtime logic.
                    SM1SEL23_1 = 0x1,
                    /// SWCOUT[SM1OUT23] is used by the deadtime logic.
                    SM1SEL23_2 = 0x2,
                    /// PWM1_EXTA signal is used by the deadtime logic.
                    SM1SEL23_3 = 0x3,
                },
                /// Submodule 2 PWM45 Control Select
                SM2SEL45: enum(u2) {
                    /// Generated SM2PWM45 signal is used by the deadtime logic.
                    SM2SEL45_0 = 0x0,
                    /// Inverted generated SM2PWM45 signal is used by the deadtime logic.
                    SM2SEL45_1 = 0x1,
                    /// SWCOUT[SM2OUT45] is used by the deadtime logic.
                    SM2SEL45_2 = 0x2,
                    /// PWM2_EXTB signal is used by the deadtime logic.
                    SM2SEL45_3 = 0x3,
                },
                /// Submodule 2 PWM23 Control Select
                SM2SEL23: enum(u2) {
                    /// Generated SM2PWM23 signal is used by the deadtime logic.
                    SM2SEL23_0 = 0x0,
                    /// Inverted generated SM2PWM23 signal is used by the deadtime logic.
                    SM2SEL23_1 = 0x1,
                    /// SWCOUT[SM2OUT23] is used by the deadtime logic.
                    SM2SEL23_2 = 0x2,
                    /// PWM2_EXTA signal is used by the deadtime logic.
                    SM2SEL23_3 = 0x3,
                },
                /// Submodule 3 PWM45 Control Select
                SM3SEL45: enum(u2) {
                    /// Generated SM3PWM45 signal is used by the deadtime logic.
                    SM3SEL45_0 = 0x0,
                    /// Inverted generated SM3PWM45 signal is used by the deadtime logic.
                    SM3SEL45_1 = 0x1,
                    /// SWCOUT[SM3OUT45] is used by the deadtime logic.
                    SM3SEL45_2 = 0x2,
                    /// PWM3_EXTB signal is used by the deadtime logic.
                    SM3SEL45_3 = 0x3,
                },
                /// Submodule 3 PWM23 Control Select
                SM3SEL23: enum(u2) {
                    /// Generated SM3PWM23 signal is used by the deadtime logic.
                    SM3SEL23_0 = 0x0,
                    /// Inverted generated SM3PWM23 signal is used by the deadtime logic.
                    SM3SEL23_1 = 0x1,
                    /// SWCOUT[SM3OUT23] is used by the deadtime logic.
                    SM3SEL23_2 = 0x2,
                    /// PWM3_EXTA signal is used by the deadtime logic.
                    SM3SEL23_3 = 0x3,
                },
            }),
            /// Master Control Register
            MCTRL: mmio.Mmio(packed struct(u16) {
                /// Load Okay
                LDOK: enum(u4) {
                    /// Do not load new values.
                    LDOK_0 = 0x0,
                    /// Load prescaler, modulus, and PWM values of the corresponding submodule.
                    LDOK_1 = 0x1,
                    _,
                },
                /// Clear Load Okay
                CLDOK: u4,
                /// Run
                RUN: enum(u4) {
                    /// PWM generator is disabled in the corresponding submodule.
                    RUN_0 = 0x0,
                    /// PWM generator is enabled in the corresponding submodule.
                    RUN_1 = 0x1,
                    _,
                },
                /// Current Polarity
                IPOL: enum(u4) {
                    /// PWM23 is used to generate complementary PWM pair in the corresponding submodule.
                    IPOL_0 = 0x0,
                    /// PWM45 is used to generate complementary PWM pair in the corresponding submodule.
                    IPOL_1 = 0x1,
                    _,
                },
            }),
            /// Master Control 2 Register
            MCTRL2: mmio.Mmio(packed struct(u16) {
                /// Monitor PLL State
                MONPLL: enum(u2) {
                    /// Not locked. Do not monitor PLL operation. Resetting of the fractional delay block in case of PLL losing lock will be controlled by software.
                    MONPLL_0 = 0x0,
                    /// Not locked. Monitor PLL operation to automatically disable the fractional delay block when the PLL encounters problems.
                    MONPLL_1 = 0x1,
                    /// Locked. Do not monitor PLL operation. Resetting of the fractional delay block in case of PLL losing lock will be controlled by software. These bits are write protected until the next reset.
                    MONPLL_2 = 0x2,
                    /// Locked. Monitor PLL operation to automatically disable the fractional delay block when the PLL encounters problems. These bits are write protected until the next reset.
                    MONPLL_3 = 0x3,
                },
                padding: u14 = 0,
            }),
            /// Fault Control Register
            FCTRL0: mmio.Mmio(packed struct(u16) {
                /// Fault Interrupt Enables
                FIE: enum(u4) {
                    /// FAULTx CPU interrupt requests disabled.
                    FIE_0 = 0x0,
                    /// FAULTx CPU interrupt requests enabled.
                    FIE_1 = 0x1,
                    _,
                },
                /// Fault Safety Mode
                FSAFE: enum(u4) {
                    /// Normal mode. PWM outputs disabled by this fault are not enabled until FSTS[FFLAGx] is clear at the start of a half cycle or full cycle depending on the state of FSTS[FFULL] without regard to the state of FSTS[FFPINx]. The PWM outputs disabled by this fault input will not be re-enabled until the actual FAULTx input signal de-asserts since the fault input will combinationally disable the PWM outputs (as programmed in DISMAPn).
                    FSAFE_0 = 0x0,
                    /// Safe mode. PWM outputs disabled by this fault are not enabled until FSTS[FFLAGx] is clear and FSTS[FFPINx] is clear at the start of a half cycle or full cycle depending on the state of FSTS[FFULL].
                    FSAFE_1 = 0x1,
                    _,
                },
                /// Automatic Fault Clearing
                FAUTO: enum(u4) {
                    /// Manual fault clearing. PWM outputs disabled by this fault are not enabled until FSTS[FFLAGx] is clear at the start of a half cycle or full cycle depending the state of FSTS[FFULL]. This is further controlled by FCTRL[FSAFE].
                    FAUTO_0 = 0x0,
                    /// Automatic fault clearing. PWM outputs disabled by this fault are enabled when FSTS[FFPINx] is clear at the start of a half cycle or full cycle depending on the state of FSTS[FFULL] without regard to the state of FSTS[FFLAGx].
                    FAUTO_1 = 0x1,
                    _,
                },
                /// Fault Level
                FLVL: enum(u4) {
                    /// A logic 0 on the fault input indicates a fault condition.
                    FLVL_0 = 0x0,
                    /// A logic 1 on the fault input indicates a fault condition.
                    FLVL_1 = 0x1,
                    _,
                },
            }),
            /// Fault Status Register
            FSTS0: mmio.Mmio(packed struct(u16) {
                /// Fault Flags
                FFLAG: enum(u4) {
                    /// No fault on the FAULTx pin.
                    FFLAG_0 = 0x0,
                    /// Fault on the FAULTx pin.
                    FFLAG_1 = 0x1,
                    _,
                },
                /// Full Cycle
                FFULL: enum(u4) {
                    /// PWM outputs are not re-enabled at the start of a full cycle
                    FFULL_0 = 0x0,
                    /// PWM outputs are re-enabled at the start of a full cycle
                    FFULL_1 = 0x1,
                    _,
                },
                /// Filtered Fault Pins
                FFPIN: u4,
                /// Half Cycle Fault Recovery
                FHALF: enum(u4) {
                    /// PWM outputs are not re-enabled at the start of a half cycle.
                    FHALF_0 = 0x0,
                    /// PWM outputs are re-enabled at the start of a half cycle (as defined by VAL0).
                    FHALF_1 = 0x1,
                    _,
                },
            }),
            /// Fault Filter Register
            FFILT0: mmio.Mmio(packed struct(u16) {
                /// Fault Filter Period
                FILT_PER: u8,
                /// Fault Filter Count
                FILT_CNT: u3,
                reserved15: u4 = 0,
                /// Fault Glitch Stretch Enable
                GSTR: enum(u1) {
                    /// Fault input glitch stretching is disabled.
                    GSTR_0 = 0x0,
                    /// Input fault signals will be stretched to at least 2 IPBus clock cycles.
                    GSTR_1 = 0x1,
                },
            }),
            /// Fault Test Register
            FTST0: mmio.Mmio(packed struct(u16) {
                /// Fault Test
                FTEST: enum(u1) {
                    /// No fault
                    FTEST_0 = 0x0,
                    /// Cause a simulated fault
                    FTEST_1 = 0x1,
                },
                padding: u15 = 0,
            }),
            /// Fault Control 2 Register
            FCTRL20: mmio.Mmio(packed struct(u16) {
                /// No Combinational Path From Fault Input To PWM Output
                NOCOMB: enum(u4) {
                    /// There is a combinational link from the fault inputs to the PWM outputs. The fault inputs are combined with the filtered and latched fault signals to disable the PWM outputs.
                    NOCOMB_0 = 0x0,
                    /// The direct combinational path from the fault inputs to the PWM outputs is disabled and the filtered and latched fault signals are used to disable the PWM outputs.
                    NOCOMB_1 = 0x1,
                    _,
                },
                padding: u12 = 0,
            }),
        };

        /// PXP v2.0 Register Reference Index
        pub const PXP = extern struct {
            /// Control Register 0
            CTRL: mmio.Mmio(packed struct(u32) {
                /// Enables PXP operation with specified parameters
                ENABLE: u1,
                /// Interrupt enable
                IRQ_ENABLE: u1,
                /// Next command interrupt enable
                NEXT_IRQ_ENABLE: u1,
                reserved4: u1 = 0,
                /// Enable handshake with LCD controller
                ENABLE_LCD_HANDSHAKE: u1,
                /// Reserved, always set to zero.
                RSVD0: u3,
                /// Indicates the clockwise rotation to be applied at the output buffer
                ROTATE: enum(u2) {
                    /// ROT_0
                    ROT_0 = 0x0,
                    /// ROT_90
                    ROT_90 = 0x1,
                    /// ROT_180
                    ROT_180 = 0x2,
                    /// ROT_270
                    ROT_270 = 0x3,
                },
                /// Indicates that the output buffer should be flipped horizontally (effect applied before rotation).
                HFLIP: u1,
                /// Indicates that the output buffer should be flipped vertically (effect applied before rotation).
                VFLIP: u1,
                /// Reserved, always set to zero.
                RSVD1: u10,
                /// This bit controls where rotation will occur in the PXP datapath
                ROT_POS: u1,
                /// Select the block size to process.
                BLOCK_SIZE: enum(u1) {
                    /// Process 8x8 pixel blocks.
                    @"8X8" = 0x0,
                    /// Process 16x16 pixel blocks.
                    @"16X16" = 0x1,
                },
                /// Reserved, always set to zero.
                RSVD3: u4,
                /// Enable the PXP to run continuously
                EN_REPEAT: u1,
                /// Reserved, always set to zero.
                RSVD4: u1,
                /// This bit must be set to zero for normal operation
                CLKGATE: u1,
                /// Set this bit to zero to enable normal PXP operation
                SFTRST: u1,
            }),
            /// Control Register 0
            CTRL_SET: mmio.Mmio(packed struct(u32) {
                /// Enables PXP operation with specified parameters
                ENABLE: u1,
                /// Interrupt enable
                IRQ_ENABLE: u1,
                /// Next command interrupt enable
                NEXT_IRQ_ENABLE: u1,
                reserved4: u1 = 0,
                /// Enable handshake with LCD controller
                ENABLE_LCD_HANDSHAKE: u1,
                /// Reserved, always set to zero.
                RSVD0: u3,
                /// Indicates the clockwise rotation to be applied at the output buffer
                ROTATE: enum(u2) {
                    /// ROT_0
                    ROT_0 = 0x0,
                    /// ROT_90
                    ROT_90 = 0x1,
                    /// ROT_180
                    ROT_180 = 0x2,
                    /// ROT_270
                    ROT_270 = 0x3,
                },
                /// Indicates that the output buffer should be flipped horizontally (effect applied before rotation).
                HFLIP: u1,
                /// Indicates that the output buffer should be flipped vertically (effect applied before rotation).
                VFLIP: u1,
                /// Reserved, always set to zero.
                RSVD1: u10,
                /// This bit controls where rotation will occur in the PXP datapath
                ROT_POS: u1,
                /// Select the block size to process.
                BLOCK_SIZE: enum(u1) {
                    /// Process 8x8 pixel blocks.
                    @"8X8" = 0x0,
                    /// Process 16x16 pixel blocks.
                    @"16X16" = 0x1,
                },
                /// Reserved, always set to zero.
                RSVD3: u4,
                /// Enable the PXP to run continuously
                EN_REPEAT: u1,
                /// Reserved, always set to zero.
                RSVD4: u1,
                /// This bit must be set to zero for normal operation
                CLKGATE: u1,
                /// Set this bit to zero to enable normal PXP operation
                SFTRST: u1,
            }),
            /// Control Register 0
            CTRL_CLR: mmio.Mmio(packed struct(u32) {
                /// Enables PXP operation with specified parameters
                ENABLE: u1,
                /// Interrupt enable
                IRQ_ENABLE: u1,
                /// Next command interrupt enable
                NEXT_IRQ_ENABLE: u1,
                reserved4: u1 = 0,
                /// Enable handshake with LCD controller
                ENABLE_LCD_HANDSHAKE: u1,
                /// Reserved, always set to zero.
                RSVD0: u3,
                /// Indicates the clockwise rotation to be applied at the output buffer
                ROTATE: enum(u2) {
                    /// ROT_0
                    ROT_0 = 0x0,
                    /// ROT_90
                    ROT_90 = 0x1,
                    /// ROT_180
                    ROT_180 = 0x2,
                    /// ROT_270
                    ROT_270 = 0x3,
                },
                /// Indicates that the output buffer should be flipped horizontally (effect applied before rotation).
                HFLIP: u1,
                /// Indicates that the output buffer should be flipped vertically (effect applied before rotation).
                VFLIP: u1,
                /// Reserved, always set to zero.
                RSVD1: u10,
                /// This bit controls where rotation will occur in the PXP datapath
                ROT_POS: u1,
                /// Select the block size to process.
                BLOCK_SIZE: enum(u1) {
                    /// Process 8x8 pixel blocks.
                    @"8X8" = 0x0,
                    /// Process 16x16 pixel blocks.
                    @"16X16" = 0x1,
                },
                /// Reserved, always set to zero.
                RSVD3: u4,
                /// Enable the PXP to run continuously
                EN_REPEAT: u1,
                /// Reserved, always set to zero.
                RSVD4: u1,
                /// This bit must be set to zero for normal operation
                CLKGATE: u1,
                /// Set this bit to zero to enable normal PXP operation
                SFTRST: u1,
            }),
            /// Control Register 0
            CTRL_TOG: mmio.Mmio(packed struct(u32) {
                /// Enables PXP operation with specified parameters
                ENABLE: u1,
                /// Interrupt enable
                IRQ_ENABLE: u1,
                /// Next command interrupt enable
                NEXT_IRQ_ENABLE: u1,
                reserved4: u1 = 0,
                /// Enable handshake with LCD controller
                ENABLE_LCD_HANDSHAKE: u1,
                /// Reserved, always set to zero.
                RSVD0: u3,
                /// Indicates the clockwise rotation to be applied at the output buffer
                ROTATE: enum(u2) {
                    /// ROT_0
                    ROT_0 = 0x0,
                    /// ROT_90
                    ROT_90 = 0x1,
                    /// ROT_180
                    ROT_180 = 0x2,
                    /// ROT_270
                    ROT_270 = 0x3,
                },
                /// Indicates that the output buffer should be flipped horizontally (effect applied before rotation).
                HFLIP: u1,
                /// Indicates that the output buffer should be flipped vertically (effect applied before rotation).
                VFLIP: u1,
                /// Reserved, always set to zero.
                RSVD1: u10,
                /// This bit controls where rotation will occur in the PXP datapath
                ROT_POS: u1,
                /// Select the block size to process.
                BLOCK_SIZE: enum(u1) {
                    /// Process 8x8 pixel blocks.
                    @"8X8" = 0x0,
                    /// Process 16x16 pixel blocks.
                    @"16X16" = 0x1,
                },
                /// Reserved, always set to zero.
                RSVD3: u4,
                /// Enable the PXP to run continuously
                EN_REPEAT: u1,
                /// Reserved, always set to zero.
                RSVD4: u1,
                /// This bit must be set to zero for normal operation
                CLKGATE: u1,
                /// Set this bit to zero to enable normal PXP operation
                SFTRST: u1,
            }),
            /// Status Register
            STAT: mmio.Mmio(packed struct(u32) {
                /// Indicates current PXP interrupt status
                IRQ: u1,
                /// Indicates PXP encountered an AXI write error and processing has been terminated.
                AXI_WRITE_ERROR: u1,
                /// Indicates PXP encountered an AXI read error and processing has been terminated.
                AXI_READ_ERROR: u1,
                /// Indicates that a command issued with the "Next Command" functionality has been issued and that a new command may be initiated with a write to the PXP_NEXT register
                NEXT_IRQ: u1,
                /// Indicates the AXI ID of the failing bus operation.
                AXI_ERROR_ID: u4,
                /// Indicates that the LUT DMA transfer has completed.
                LUT_DMA_LOAD_DONE_IRQ: u1,
                /// Reserved, always set to zero.
                RSVD2: u7,
                /// Indicates the X coordinate of the block currently being rendered.
                BLOCKY: u8,
                /// Indicates the X coordinate of the block currently being rendered.
                BLOCKX: u8,
            }),
            /// Status Register
            STAT_SET: mmio.Mmio(packed struct(u32) {
                /// Indicates current PXP interrupt status
                IRQ: u1,
                /// Indicates PXP encountered an AXI write error and processing has been terminated.
                AXI_WRITE_ERROR: u1,
                /// Indicates PXP encountered an AXI read error and processing has been terminated.
                AXI_READ_ERROR: u1,
                /// Indicates that a command issued with the "Next Command" functionality has been issued and that a new command may be initiated with a write to the PXP_NEXT register
                NEXT_IRQ: u1,
                /// Indicates the AXI ID of the failing bus operation.
                AXI_ERROR_ID: u4,
                /// Indicates that the LUT DMA transfer has completed.
                LUT_DMA_LOAD_DONE_IRQ: u1,
                /// Reserved, always set to zero.
                RSVD2: u7,
                /// Indicates the X coordinate of the block currently being rendered.
                BLOCKY: u8,
                /// Indicates the X coordinate of the block currently being rendered.
                BLOCKX: u8,
            }),
            /// Status Register
            STAT_CLR: mmio.Mmio(packed struct(u32) {
                /// Indicates current PXP interrupt status
                IRQ: u1,
                /// Indicates PXP encountered an AXI write error and processing has been terminated.
                AXI_WRITE_ERROR: u1,
                /// Indicates PXP encountered an AXI read error and processing has been terminated.
                AXI_READ_ERROR: u1,
                /// Indicates that a command issued with the "Next Command" functionality has been issued and that a new command may be initiated with a write to the PXP_NEXT register
                NEXT_IRQ: u1,
                /// Indicates the AXI ID of the failing bus operation.
                AXI_ERROR_ID: u4,
                /// Indicates that the LUT DMA transfer has completed.
                LUT_DMA_LOAD_DONE_IRQ: u1,
                /// Reserved, always set to zero.
                RSVD2: u7,
                /// Indicates the X coordinate of the block currently being rendered.
                BLOCKY: u8,
                /// Indicates the X coordinate of the block currently being rendered.
                BLOCKX: u8,
            }),
            /// Status Register
            STAT_TOG: mmio.Mmio(packed struct(u32) {
                /// Indicates current PXP interrupt status
                IRQ: u1,
                /// Indicates PXP encountered an AXI write error and processing has been terminated.
                AXI_WRITE_ERROR: u1,
                /// Indicates PXP encountered an AXI read error and processing has been terminated.
                AXI_READ_ERROR: u1,
                /// Indicates that a command issued with the "Next Command" functionality has been issued and that a new command may be initiated with a write to the PXP_NEXT register
                NEXT_IRQ: u1,
                /// Indicates the AXI ID of the failing bus operation.
                AXI_ERROR_ID: u4,
                /// Indicates that the LUT DMA transfer has completed.
                LUT_DMA_LOAD_DONE_IRQ: u1,
                /// Reserved, always set to zero.
                RSVD2: u7,
                /// Indicates the X coordinate of the block currently being rendered.
                BLOCKY: u8,
                /// Indicates the X coordinate of the block currently being rendered.
                BLOCKX: u8,
            }),
            /// Output Buffer Control Register
            OUT_CTRL: mmio.Mmio(packed struct(u32) {
                /// Output framebuffer format
                FORMAT: enum(u5) {
                    /// 32-bit pixels
                    ARGB8888 = 0x0,
                    /// 32-bit pixels (unpacked 24-bit pixel in 32 bit DWORD.)
                    RGB888 = 0x4,
                    /// 24-bit pixels (packed 24-bit format)
                    RGB888P = 0x5,
                    /// 16-bit pixels
                    ARGB1555 = 0x8,
                    /// 16-bit pixels
                    ARGB4444 = 0x9,
                    /// 16-bit pixels
                    RGB555 = 0xc,
                    /// 16-bit pixels
                    RGB444 = 0xd,
                    /// 16-bit pixels
                    RGB565 = 0xe,
                    /// 32-bit pixels (1-plane XYUV unpacked)
                    YUV1P444 = 0x10,
                    /// 16-bit pixels (1-plane U0,Y0,V0,Y1 interleaved bytes)
                    UYVY1P422 = 0x12,
                    /// 16-bit pixels (1-plane V0,Y0,U0,Y1 interleaved bytes)
                    VYUY1P422 = 0x13,
                    /// 8-bit monochrome pixels (1-plane Y luma output)
                    Y8 = 0x14,
                    /// 4-bit monochrome pixels (1-plane Y luma, 4 bit truncation)
                    Y4 = 0x15,
                    /// 16-bit pixels (2-plane UV interleaved bytes)
                    YUV2P422 = 0x18,
                    /// 16-bit pixels (2-plane UV)
                    YUV2P420 = 0x19,
                    /// 16-bit pixels (2-plane VU interleaved bytes)
                    YVU2P422 = 0x1a,
                    /// 16-bit pixels (2-plane VU)
                    YVU2P420 = 0x1b,
                    _,
                },
                /// Reserved, always set to zero.
                RSVD0: u3,
                /// Determines how the PXP writes it's output data
                INTERLACED_OUTPUT: enum(u2) {
                    /// All data written in progressive format to the OUTBUF Pointer.
                    PROGRESSIVE = 0x0,
                    /// Interlaced output: only data for field 0 is written to the OUTBUF Pointer.
                    FIELD0 = 0x1,
                    /// Interlaced output: only data for field 1 is written to the OUTBUF2 Pointer.
                    FIELD1 = 0x2,
                    /// Interlaced output: data for field 0 is written to OUTBUF and data for field 1 is written to OUTBUF2.
                    INTERLACED = 0x3,
                },
                /// Reserved, always set to zero.
                RSVD1: u13,
                /// Indicates that alpha component in output buffer pixels should be overwritten by PXP_OUT_CTRL[ALPHA]
                ALPHA_OUTPUT: u1,
                /// When generating an output buffer with an alpha component, the value in this field will be used when enabled to override the alpha passed through the pixel data pipeline
                ALPHA: u8,
            }),
            /// Output Buffer Control Register
            OUT_CTRL_SET: mmio.Mmio(packed struct(u32) {
                /// Output framebuffer format
                FORMAT: enum(u5) {
                    /// 32-bit pixels
                    ARGB8888 = 0x0,
                    /// 32-bit pixels (unpacked 24-bit pixel in 32 bit DWORD.)
                    RGB888 = 0x4,
                    /// 24-bit pixels (packed 24-bit format)
                    RGB888P = 0x5,
                    /// 16-bit pixels
                    ARGB1555 = 0x8,
                    /// 16-bit pixels
                    ARGB4444 = 0x9,
                    /// 16-bit pixels
                    RGB555 = 0xc,
                    /// 16-bit pixels
                    RGB444 = 0xd,
                    /// 16-bit pixels
                    RGB565 = 0xe,
                    /// 32-bit pixels (1-plane XYUV unpacked)
                    YUV1P444 = 0x10,
                    /// 16-bit pixels (1-plane U0,Y0,V0,Y1 interleaved bytes)
                    UYVY1P422 = 0x12,
                    /// 16-bit pixels (1-plane V0,Y0,U0,Y1 interleaved bytes)
                    VYUY1P422 = 0x13,
                    /// 8-bit monochrome pixels (1-plane Y luma output)
                    Y8 = 0x14,
                    /// 4-bit monochrome pixels (1-plane Y luma, 4 bit truncation)
                    Y4 = 0x15,
                    /// 16-bit pixels (2-plane UV interleaved bytes)
                    YUV2P422 = 0x18,
                    /// 16-bit pixels (2-plane UV)
                    YUV2P420 = 0x19,
                    /// 16-bit pixels (2-plane VU interleaved bytes)
                    YVU2P422 = 0x1a,
                    /// 16-bit pixels (2-plane VU)
                    YVU2P420 = 0x1b,
                    _,
                },
                /// Reserved, always set to zero.
                RSVD0: u3,
                /// Determines how the PXP writes it's output data
                INTERLACED_OUTPUT: enum(u2) {
                    /// All data written in progressive format to the OUTBUF Pointer.
                    PROGRESSIVE = 0x0,
                    /// Interlaced output: only data for field 0 is written to the OUTBUF Pointer.
                    FIELD0 = 0x1,
                    /// Interlaced output: only data for field 1 is written to the OUTBUF2 Pointer.
                    FIELD1 = 0x2,
                    /// Interlaced output: data for field 0 is written to OUTBUF and data for field 1 is written to OUTBUF2.
                    INTERLACED = 0x3,
                },
                /// Reserved, always set to zero.
                RSVD1: u13,
                /// Indicates that alpha component in output buffer pixels should be overwritten by PXP_OUT_CTRL[ALPHA]
                ALPHA_OUTPUT: u1,
                /// When generating an output buffer with an alpha component, the value in this field will be used when enabled to override the alpha passed through the pixel data pipeline
                ALPHA: u8,
            }),
            /// Output Buffer Control Register
            OUT_CTRL_CLR: mmio.Mmio(packed struct(u32) {
                /// Output framebuffer format
                FORMAT: enum(u5) {
                    /// 32-bit pixels
                    ARGB8888 = 0x0,
                    /// 32-bit pixels (unpacked 24-bit pixel in 32 bit DWORD.)
                    RGB888 = 0x4,
                    /// 24-bit pixels (packed 24-bit format)
                    RGB888P = 0x5,
                    /// 16-bit pixels
                    ARGB1555 = 0x8,
                    /// 16-bit pixels
                    ARGB4444 = 0x9,
                    /// 16-bit pixels
                    RGB555 = 0xc,
                    /// 16-bit pixels
                    RGB444 = 0xd,
                    /// 16-bit pixels
                    RGB565 = 0xe,
                    /// 32-bit pixels (1-plane XYUV unpacked)
                    YUV1P444 = 0x10,
                    /// 16-bit pixels (1-plane U0,Y0,V0,Y1 interleaved bytes)
                    UYVY1P422 = 0x12,
                    /// 16-bit pixels (1-plane V0,Y0,U0,Y1 interleaved bytes)
                    VYUY1P422 = 0x13,
                    /// 8-bit monochrome pixels (1-plane Y luma output)
                    Y8 = 0x14,
                    /// 4-bit monochrome pixels (1-plane Y luma, 4 bit truncation)
                    Y4 = 0x15,
                    /// 16-bit pixels (2-plane UV interleaved bytes)
                    YUV2P422 = 0x18,
                    /// 16-bit pixels (2-plane UV)
                    YUV2P420 = 0x19,
                    /// 16-bit pixels (2-plane VU interleaved bytes)
                    YVU2P422 = 0x1a,
                    /// 16-bit pixels (2-plane VU)
                    YVU2P420 = 0x1b,
                    _,
                },
                /// Reserved, always set to zero.
                RSVD0: u3,
                /// Determines how the PXP writes it's output data
                INTERLACED_OUTPUT: enum(u2) {
                    /// All data written in progressive format to the OUTBUF Pointer.
                    PROGRESSIVE = 0x0,
                    /// Interlaced output: only data for field 0 is written to the OUTBUF Pointer.
                    FIELD0 = 0x1,
                    /// Interlaced output: only data for field 1 is written to the OUTBUF2 Pointer.
                    FIELD1 = 0x2,
                    /// Interlaced output: data for field 0 is written to OUTBUF and data for field 1 is written to OUTBUF2.
                    INTERLACED = 0x3,
                },
                /// Reserved, always set to zero.
                RSVD1: u13,
                /// Indicates that alpha component in output buffer pixels should be overwritten by PXP_OUT_CTRL[ALPHA]
                ALPHA_OUTPUT: u1,
                /// When generating an output buffer with an alpha component, the value in this field will be used when enabled to override the alpha passed through the pixel data pipeline
                ALPHA: u8,
            }),
            /// Output Buffer Control Register
            OUT_CTRL_TOG: mmio.Mmio(packed struct(u32) {
                /// Output framebuffer format
                FORMAT: enum(u5) {
                    /// 32-bit pixels
                    ARGB8888 = 0x0,
                    /// 32-bit pixels (unpacked 24-bit pixel in 32 bit DWORD.)
                    RGB888 = 0x4,
                    /// 24-bit pixels (packed 24-bit format)
                    RGB888P = 0x5,
                    /// 16-bit pixels
                    ARGB1555 = 0x8,
                    /// 16-bit pixels
                    ARGB4444 = 0x9,
                    /// 16-bit pixels
                    RGB555 = 0xc,
                    /// 16-bit pixels
                    RGB444 = 0xd,
                    /// 16-bit pixels
                    RGB565 = 0xe,
                    /// 32-bit pixels (1-plane XYUV unpacked)
                    YUV1P444 = 0x10,
                    /// 16-bit pixels (1-plane U0,Y0,V0,Y1 interleaved bytes)
                    UYVY1P422 = 0x12,
                    /// 16-bit pixels (1-plane V0,Y0,U0,Y1 interleaved bytes)
                    VYUY1P422 = 0x13,
                    /// 8-bit monochrome pixels (1-plane Y luma output)
                    Y8 = 0x14,
                    /// 4-bit monochrome pixels (1-plane Y luma, 4 bit truncation)
                    Y4 = 0x15,
                    /// 16-bit pixels (2-plane UV interleaved bytes)
                    YUV2P422 = 0x18,
                    /// 16-bit pixels (2-plane UV)
                    YUV2P420 = 0x19,
                    /// 16-bit pixels (2-plane VU interleaved bytes)
                    YVU2P422 = 0x1a,
                    /// 16-bit pixels (2-plane VU)
                    YVU2P420 = 0x1b,
                    _,
                },
                /// Reserved, always set to zero.
                RSVD0: u3,
                /// Determines how the PXP writes it's output data
                INTERLACED_OUTPUT: enum(u2) {
                    /// All data written in progressive format to the OUTBUF Pointer.
                    PROGRESSIVE = 0x0,
                    /// Interlaced output: only data for field 0 is written to the OUTBUF Pointer.
                    FIELD0 = 0x1,
                    /// Interlaced output: only data for field 1 is written to the OUTBUF2 Pointer.
                    FIELD1 = 0x2,
                    /// Interlaced output: data for field 0 is written to OUTBUF and data for field 1 is written to OUTBUF2.
                    INTERLACED = 0x3,
                },
                /// Reserved, always set to zero.
                RSVD1: u13,
                /// Indicates that alpha component in output buffer pixels should be overwritten by PXP_OUT_CTRL[ALPHA]
                ALPHA_OUTPUT: u1,
                /// When generating an output buffer with an alpha component, the value in this field will be used when enabled to override the alpha passed through the pixel data pipeline
                ALPHA: u8,
            }),
            /// Output Frame Buffer Pointer
            OUT_BUF: mmio.Mmio(packed struct(u32) {
                /// Current address pointer for the output frame buffer
                ADDR: u32,
            }),
            reserved64: [12]u8,
            /// Output Frame Buffer Pointer #2
            OUT_BUF2: mmio.Mmio(packed struct(u32) {
                /// Current address pointer for the output frame buffer
                ADDR: u32,
            }),
            reserved80: [12]u8,
            /// Output Buffer Pitch
            OUT_PITCH: mmio.Mmio(packed struct(u32) {
                /// Indicates the number of bytes in memory between two vertically adjacent pixels.
                PITCH: u16,
                /// Reserved, always set to zero.
                RSVD: u16,
            }),
            reserved96: [12]u8,
            /// Output Surface Lower Right Coordinate
            OUT_LRC: mmio.Mmio(packed struct(u32) {
                /// Indicates the number of vertical PIXELS in the output surface (non-rotated)
                Y: u14,
                /// Reserved, always set to zero.
                RSVD0: u2,
                /// Indicates number of horizontal PIXELS in the output surface (non-rotated)
                X: u14,
                /// Reserved, always set to zero.
                RSVD1: u2,
            }),
            reserved112: [12]u8,
            /// Processed Surface Upper Left Coordinate
            OUT_PS_ULC: mmio.Mmio(packed struct(u32) {
                /// This field indicates the upper left Y-coordinate (in pixels) of the processed surface in the output buffer
                Y: u14,
                /// Reserved, always set to zero.
                RSVD0: u2,
                /// This field indicates the upper left X-coordinate (in pixels) of the processed surface (PS) in the output buffer
                X: u14,
                /// Reserved, always set to zero.
                RSVD1: u2,
            }),
            reserved128: [12]u8,
            /// Processed Surface Lower Right Coordinate
            OUT_PS_LRC: mmio.Mmio(packed struct(u32) {
                /// This field indicates the lower right Y-coordinate (in pixels) of the processed surface in the output frame buffer
                Y: u14,
                /// Reserved, always set to zero.
                RSVD0: u2,
                /// This field indicates the lower right X-coordinate (in pixels) of the processed surface (PS) in the output frame buffer
                X: u14,
                /// Reserved, always set to zero.
                RSVD1: u2,
            }),
            reserved144: [12]u8,
            /// Alpha Surface Upper Left Coordinate
            OUT_AS_ULC: mmio.Mmio(packed struct(u32) {
                /// This field indicates the upper left Y-coordinate (in pixels) of the alpha surface in the output frame buffer
                Y: u14,
                /// Reserved, always set to zero.
                RSVD0: u2,
                /// This field indicates the upper left X-coordinate (in pixels) of the alpha surface (AS) in the output frame buffer
                X: u14,
                /// Reserved, always set to zero.
                RSVD1: u2,
            }),
            reserved160: [12]u8,
            /// Alpha Surface Lower Right Coordinate
            OUT_AS_LRC: mmio.Mmio(packed struct(u32) {
                /// This field indicates the lower right Y-coordinate (in pixels) of the alpha surface in the output frame buffer
                Y: u14,
                /// Reserved, always set to zero.
                RSVD0: u2,
                /// This field indicates the lower right X-coordinate (in pixels) of the alpha surface (AS) in the output frame buffer
                X: u14,
                /// Reserved, always set to zero.
                RSVD1: u2,
            }),
            reserved176: [12]u8,
            /// Processed Surface (PS) Control Register
            PS_CTRL: mmio.Mmio(packed struct(u32) {
                /// PS buffer format. To select between YUV and YCbCr formats, see bit 31 of the CSC1_COEF0 register.
                FORMAT: enum(u5) {
                    /// 32-bit pixels (unpacked 24-bit format)
                    RGB888 = 0x4,
                    /// 16-bit pixels
                    RGB555 = 0xc,
                    /// 16-bit pixels
                    RGB444 = 0xd,
                    /// 16-bit pixels
                    RGB565 = 0xe,
                    /// 32-bit pixels (1-plane XYUV unpacked)
                    YUV1P444 = 0x10,
                    /// 16-bit pixels (1-plane U0,Y0,V0,Y1 interleaved bytes)
                    UYVY1P422 = 0x12,
                    /// 16-bit pixels (1-plane V0,Y0,U0,Y1 interleaved bytes)
                    VYUY1P422 = 0x13,
                    /// 8-bit monochrome pixels (1-plane Y luma output)
                    Y8 = 0x14,
                    /// 4-bit monochrome pixels (1-plane Y luma, 4 bit truncation)
                    Y4 = 0x15,
                    /// 16-bit pixels (2-plane UV interleaved bytes)
                    YUV2P422 = 0x18,
                    /// 16-bit pixels (2-plane UV)
                    YUV2P420 = 0x19,
                    /// 16-bit pixels (2-plane VU interleaved bytes)
                    YVU2P422 = 0x1a,
                    /// 16-bit pixels (2-plane VU)
                    YVU2P420 = 0x1b,
                    /// 16-bit pixels (3-plane format)
                    YUV422 = 0x1e,
                    /// 16-bit pixels (3-plane format)
                    YUV420 = 0x1f,
                    _,
                },
                /// Swap bytes in words. For each 16 bit word, the two bytes will be swapped.
                WB_SWAP: u1,
                /// Reserved, always set to zero.
                RSVD0: u2,
                /// Verticle pre decimation filter control.
                DECY: enum(u2) {
                    /// Disable pre-decimation filter.
                    DISABLE = 0x0,
                    /// Decimate PS by 2.
                    DECY2 = 0x1,
                    /// Decimate PS by 4.
                    DECY4 = 0x2,
                    /// Decimate PS by 8.
                    DECY8 = 0x3,
                },
                /// Horizontal pre decimation filter control.
                DECX: enum(u2) {
                    /// Disable pre-decimation filter.
                    DISABLE = 0x0,
                    /// Decimate PS by 2.
                    DECX2 = 0x1,
                    /// Decimate PS by 4.
                    DECX4 = 0x2,
                    /// Decimate PS by 8.
                    DECX8 = 0x3,
                },
                /// Reserved, always set to zero.
                RSVD1: u20,
            }),
            /// Processed Surface (PS) Control Register
            PS_CTRL_SET: mmio.Mmio(packed struct(u32) {
                /// PS buffer format. To select between YUV and YCbCr formats, see bit 31 of the CSC1_COEF0 register.
                FORMAT: enum(u5) {
                    /// 32-bit pixels (unpacked 24-bit format)
                    RGB888 = 0x4,
                    /// 16-bit pixels
                    RGB555 = 0xc,
                    /// 16-bit pixels
                    RGB444 = 0xd,
                    /// 16-bit pixels
                    RGB565 = 0xe,
                    /// 32-bit pixels (1-plane XYUV unpacked)
                    YUV1P444 = 0x10,
                    /// 16-bit pixels (1-plane U0,Y0,V0,Y1 interleaved bytes)
                    UYVY1P422 = 0x12,
                    /// 16-bit pixels (1-plane V0,Y0,U0,Y1 interleaved bytes)
                    VYUY1P422 = 0x13,
                    /// 8-bit monochrome pixels (1-plane Y luma output)
                    Y8 = 0x14,
                    /// 4-bit monochrome pixels (1-plane Y luma, 4 bit truncation)
                    Y4 = 0x15,
                    /// 16-bit pixels (2-plane UV interleaved bytes)
                    YUV2P422 = 0x18,
                    /// 16-bit pixels (2-plane UV)
                    YUV2P420 = 0x19,
                    /// 16-bit pixels (2-plane VU interleaved bytes)
                    YVU2P422 = 0x1a,
                    /// 16-bit pixels (2-plane VU)
                    YVU2P420 = 0x1b,
                    /// 16-bit pixels (3-plane format)
                    YUV422 = 0x1e,
                    /// 16-bit pixels (3-plane format)
                    YUV420 = 0x1f,
                    _,
                },
                /// Swap bytes in words. For each 16 bit word, the two bytes will be swapped.
                WB_SWAP: u1,
                /// Reserved, always set to zero.
                RSVD0: u2,
                /// Verticle pre decimation filter control.
                DECY: enum(u2) {
                    /// Disable pre-decimation filter.
                    DISABLE = 0x0,
                    /// Decimate PS by 2.
                    DECY2 = 0x1,
                    /// Decimate PS by 4.
                    DECY4 = 0x2,
                    /// Decimate PS by 8.
                    DECY8 = 0x3,
                },
                /// Horizontal pre decimation filter control.
                DECX: enum(u2) {
                    /// Disable pre-decimation filter.
                    DISABLE = 0x0,
                    /// Decimate PS by 2.
                    DECX2 = 0x1,
                    /// Decimate PS by 4.
                    DECX4 = 0x2,
                    /// Decimate PS by 8.
                    DECX8 = 0x3,
                },
                /// Reserved, always set to zero.
                RSVD1: u20,
            }),
            /// Processed Surface (PS) Control Register
            PS_CTRL_CLR: mmio.Mmio(packed struct(u32) {
                /// PS buffer format. To select between YUV and YCbCr formats, see bit 31 of the CSC1_COEF0 register.
                FORMAT: enum(u5) {
                    /// 32-bit pixels (unpacked 24-bit format)
                    RGB888 = 0x4,
                    /// 16-bit pixels
                    RGB555 = 0xc,
                    /// 16-bit pixels
                    RGB444 = 0xd,
                    /// 16-bit pixels
                    RGB565 = 0xe,
                    /// 32-bit pixels (1-plane XYUV unpacked)
                    YUV1P444 = 0x10,
                    /// 16-bit pixels (1-plane U0,Y0,V0,Y1 interleaved bytes)
                    UYVY1P422 = 0x12,
                    /// 16-bit pixels (1-plane V0,Y0,U0,Y1 interleaved bytes)
                    VYUY1P422 = 0x13,
                    /// 8-bit monochrome pixels (1-plane Y luma output)
                    Y8 = 0x14,
                    /// 4-bit monochrome pixels (1-plane Y luma, 4 bit truncation)
                    Y4 = 0x15,
                    /// 16-bit pixels (2-plane UV interleaved bytes)
                    YUV2P422 = 0x18,
                    /// 16-bit pixels (2-plane UV)
                    YUV2P420 = 0x19,
                    /// 16-bit pixels (2-plane VU interleaved bytes)
                    YVU2P422 = 0x1a,
                    /// 16-bit pixels (2-plane VU)
                    YVU2P420 = 0x1b,
                    /// 16-bit pixels (3-plane format)
                    YUV422 = 0x1e,
                    /// 16-bit pixels (3-plane format)
                    YUV420 = 0x1f,
                    _,
                },
                /// Swap bytes in words. For each 16 bit word, the two bytes will be swapped.
                WB_SWAP: u1,
                /// Reserved, always set to zero.
                RSVD0: u2,
                /// Verticle pre decimation filter control.
                DECY: enum(u2) {
                    /// Disable pre-decimation filter.
                    DISABLE = 0x0,
                    /// Decimate PS by 2.
                    DECY2 = 0x1,
                    /// Decimate PS by 4.
                    DECY4 = 0x2,
                    /// Decimate PS by 8.
                    DECY8 = 0x3,
                },
                /// Horizontal pre decimation filter control.
                DECX: enum(u2) {
                    /// Disable pre-decimation filter.
                    DISABLE = 0x0,
                    /// Decimate PS by 2.
                    DECX2 = 0x1,
                    /// Decimate PS by 4.
                    DECX4 = 0x2,
                    /// Decimate PS by 8.
                    DECX8 = 0x3,
                },
                /// Reserved, always set to zero.
                RSVD1: u20,
            }),
            /// Processed Surface (PS) Control Register
            PS_CTRL_TOG: mmio.Mmio(packed struct(u32) {
                /// PS buffer format. To select between YUV and YCbCr formats, see bit 31 of the CSC1_COEF0 register.
                FORMAT: enum(u5) {
                    /// 32-bit pixels (unpacked 24-bit format)
                    RGB888 = 0x4,
                    /// 16-bit pixels
                    RGB555 = 0xc,
                    /// 16-bit pixels
                    RGB444 = 0xd,
                    /// 16-bit pixels
                    RGB565 = 0xe,
                    /// 32-bit pixels (1-plane XYUV unpacked)
                    YUV1P444 = 0x10,
                    /// 16-bit pixels (1-plane U0,Y0,V0,Y1 interleaved bytes)
                    UYVY1P422 = 0x12,
                    /// 16-bit pixels (1-plane V0,Y0,U0,Y1 interleaved bytes)
                    VYUY1P422 = 0x13,
                    /// 8-bit monochrome pixels (1-plane Y luma output)
                    Y8 = 0x14,
                    /// 4-bit monochrome pixels (1-plane Y luma, 4 bit truncation)
                    Y4 = 0x15,
                    /// 16-bit pixels (2-plane UV interleaved bytes)
                    YUV2P422 = 0x18,
                    /// 16-bit pixels (2-plane UV)
                    YUV2P420 = 0x19,
                    /// 16-bit pixels (2-plane VU interleaved bytes)
                    YVU2P422 = 0x1a,
                    /// 16-bit pixels (2-plane VU)
                    YVU2P420 = 0x1b,
                    /// 16-bit pixels (3-plane format)
                    YUV422 = 0x1e,
                    /// 16-bit pixels (3-plane format)
                    YUV420 = 0x1f,
                    _,
                },
                /// Swap bytes in words. For each 16 bit word, the two bytes will be swapped.
                WB_SWAP: u1,
                /// Reserved, always set to zero.
                RSVD0: u2,
                /// Verticle pre decimation filter control.
                DECY: enum(u2) {
                    /// Disable pre-decimation filter.
                    DISABLE = 0x0,
                    /// Decimate PS by 2.
                    DECY2 = 0x1,
                    /// Decimate PS by 4.
                    DECY4 = 0x2,
                    /// Decimate PS by 8.
                    DECY8 = 0x3,
                },
                /// Horizontal pre decimation filter control.
                DECX: enum(u2) {
                    /// Disable pre-decimation filter.
                    DISABLE = 0x0,
                    /// Decimate PS by 2.
                    DECX2 = 0x1,
                    /// Decimate PS by 4.
                    DECX4 = 0x2,
                    /// Decimate PS by 8.
                    DECX8 = 0x3,
                },
                /// Reserved, always set to zero.
                RSVD1: u20,
            }),
            /// PS Input Buffer Address
            PS_BUF: mmio.Mmio(packed struct(u32) {
                /// Address pointer for the PS RGB or Y (luma) input buffer.
                ADDR: u32,
            }),
            reserved208: [12]u8,
            /// PS U/Cb or 2 Plane UV Input Buffer Address
            PS_UBUF: mmio.Mmio(packed struct(u32) {
                /// Address pointer for the PS U/Cb or 2 plane UV Chroma input buffer.
                ADDR: u32,
            }),
            reserved224: [12]u8,
            /// PS V/Cr Input Buffer Address
            PS_VBUF: mmio.Mmio(packed struct(u32) {
                /// Address pointer for the PS V/Cr Chroma input buffer.
                ADDR: u32,
            }),
            reserved240: [12]u8,
            /// Processed Surface Pitch
            PS_PITCH: mmio.Mmio(packed struct(u32) {
                /// Indicates the number of bytes in memory between two vertically adjacent pixels.
                PITCH: u16,
                /// Reserved, always set to zero.
                RSVD: u16,
            }),
            reserved256: [12]u8,
            /// PS Background Color
            PS_BACKGROUND: mmio.Mmio(packed struct(u32) {
                /// Background color (in 24bpp format) for any pixels not within the buffer range specified by the PS ULC/LRC
                COLOR: u24,
                /// Reserved, always set to zero.
                RSVD: u8,
            }),
            reserved272: [12]u8,
            /// PS Scale Factor Register
            PS_SCALE: mmio.Mmio(packed struct(u32) {
                /// This is a two bit integer and 12 bit fractional representation (##
                XSCALE: u15,
                /// Reserved, always set to zero.
                RSVD1: u1,
                /// This is a two bit integer and 12 bit fractional representation (##
                YSCALE: u15,
                /// Reserved, always set to zero.
                RSVD2: u1,
            }),
            reserved288: [12]u8,
            /// PS Scale Offset Register
            PS_OFFSET: mmio.Mmio(packed struct(u32) {
                /// This is a 12 bit fractional representation (0
                XOFFSET: u12,
                /// Reserved, always set to zero.
                RSVD1: u4,
                /// This is a 12 bit fractional representation (0
                YOFFSET: u12,
                /// Reserved, always set to zero.
                RSVD2: u4,
            }),
            reserved304: [12]u8,
            /// PS Color Key Low
            PS_CLRKEYLOW: mmio.Mmio(packed struct(u32) {
                /// Low range of color key applied to PS buffer
                PIXEL: u24,
                /// Reserved, always set to zero.
                RSVD1: u8,
            }),
            reserved320: [12]u8,
            /// PS Color Key High
            PS_CLRKEYHIGH: mmio.Mmio(packed struct(u32) {
                /// High range of color key applied to PS buffer
                PIXEL: u24,
                /// Reserved, always set to zero.
                RSVD1: u8,
            }),
            reserved336: [12]u8,
            /// Alpha Surface Control
            AS_CTRL: mmio.Mmio(packed struct(u32) {
                /// Reserved, always set to zero.
                RSVD0: u1,
                /// Determines how the alpha value is constructed for this alpha surface
                ALPHA_CTRL: enum(u2) {
                    /// Indicates that the AS pixel alpha value will be used to blend the AS with PS. The ALPHA field is ignored.
                    Embedded = 0x0,
                    /// Indicates that the value in the ALPHA field should be used instead of the alpha values present in the input pixels.
                    Override = 0x1,
                    /// Indicates that the value in the ALPHA field should be used to scale all pixel alpha values. Each pixel alpha is multiplied by the value in the ALPHA field.
                    Multiply = 0x2,
                    /// Enable ROPs. The ROP field indicates an operation to be performed on the alpha surface and PS pixels.
                    ROPs = 0x3,
                },
                /// Indicates that colorkey functionality is enabled for this alpha surface
                ENABLE_COLORKEY: u1,
                /// Indicates the input buffer format for AS.
                FORMAT: enum(u4) {
                    /// 32-bit pixels with alpha
                    ARGB8888 = 0x0,
                    /// 32-bit pixels without alpha (unpacked 24-bit format)
                    RGB888 = 0x4,
                    /// 16-bit pixels with alpha
                    ARGB1555 = 0x8,
                    /// 16-bit pixels with alpha
                    ARGB4444 = 0x9,
                    /// 16-bit pixels without alpha
                    RGB555 = 0xc,
                    /// 16-bit pixels without alpha
                    RGB444 = 0xd,
                    /// 16-bit pixels without alpha
                    RGB565 = 0xe,
                    _,
                },
                /// Alpha modifier used when the ALPHA_MULTIPLY or ALPHA_OVERRIDE values are programmed in PXP_AS_CTRL[ALPHA_CTRL]
                ALPHA: u8,
                /// Indicates a raster operation to perform when enabled
                ROP: enum(u4) {
                    /// AS AND PS
                    MASKAS = 0x0,
                    /// nAS AND PS
                    MASKNOTAS = 0x1,
                    /// AS AND nPS
                    MASKASNOT = 0x2,
                    /// AS OR PS
                    MERGEAS = 0x3,
                    /// nAS OR PS
                    MERGENOTAS = 0x4,
                    /// AS OR nPS
                    MERGEASNOT = 0x5,
                    /// nAS
                    NOTCOPYAS = 0x6,
                    /// nPS
                    NOT = 0x7,
                    /// AS NAND PS
                    NOTMASKAS = 0x8,
                    /// AS NOR PS
                    NOTMERGEAS = 0x9,
                    /// AS XOR PS
                    XORAS = 0xa,
                    /// AS XNOR PS
                    NOTXORAS = 0xb,
                    _,
                },
                /// Setting this bit to logic 0 will not alter the alpha value
                ALPHA_INVERT: u1,
                /// Reserved, always set to zero.
                RSVD1: u11,
            }),
            reserved352: [12]u8,
            /// Alpha Surface Buffer Pointer
            AS_BUF: mmio.Mmio(packed struct(u32) {
                /// Address pointer for the alpha surface 0 buffer.
                ADDR: u32,
            }),
            reserved368: [12]u8,
            /// Alpha Surface Pitch
            AS_PITCH: mmio.Mmio(packed struct(u32) {
                /// Indicates the number of bytes in memory between two vertically adjacent pixels.
                PITCH: u16,
                /// Reserved, always set to zero.
                RSVD: u16,
            }),
            reserved384: [12]u8,
            /// Overlay Color Key Low
            AS_CLRKEYLOW: mmio.Mmio(packed struct(u32) {
                /// Low range of RGB color key applied to AS buffer. Each overlay has an independent colorkey enable.
                PIXEL: u24,
                /// Reserved, always set to zero.
                RSVD1: u8,
            }),
            reserved400: [12]u8,
            /// Overlay Color Key High
            AS_CLRKEYHIGH: mmio.Mmio(packed struct(u32) {
                /// High range of RGB color key applied to AS buffer. Each overlay has an independent colorkey enable.
                PIXEL: u24,
                /// Reserved, always set to zero.
                RSVD1: u8,
            }),
            reserved416: [12]u8,
            /// Color Space Conversion Coefficient Register 0
            CSC1_COEF0: mmio.Mmio(packed struct(u32) {
                /// Two's compliment amplitude offset implicit in the Y data
                Y_OFFSET: u9,
                /// Two's compliment phase offset implicit for CbCr data
                UV_OFFSET: u9,
                /// Two's compliment Y multiplier coefficient. YUV=0x100 (1.000) YCbCr=0x12A (1.164)
                C0: u11,
                /// Reserved, always set to zero.
                RSVD1: u1,
                /// Bypass the CSC unit in the scaling engine
                BYPASS: u1,
                /// Set to 1 when performing YCbCr conversion to RGB
                YCBCR_MODE: u1,
            }),
            reserved432: [12]u8,
            /// Color Space Conversion Coefficient Register 1
            CSC1_COEF1: mmio.Mmio(packed struct(u32) {
                /// Two's compliment Blue U/Cb multiplier coefficient. YUV=0x208 (2.032) YCbCr=0x204 (2.017)
                C4: u11,
                /// Reserved, always set to zero.
                RSVD0: u5,
                /// Two's compliment Red V/Cr multiplier coefficient. YUV=0x123 (1.140) YCbCr=0x198 (1.596)
                C1: u11,
                /// Reserved, always set to zero.
                RSVD1: u5,
            }),
            reserved448: [12]u8,
            /// Color Space Conversion Coefficient Register 2
            CSC1_COEF2: mmio.Mmio(packed struct(u32) {
                /// Two's complement Green U/Cb multiplier coefficient. YUV=0x79C (-0.394) YCbCr=0x79C (-0.392)
                C3: u11,
                /// Reserved, always set to zero.
                RSVD0: u5,
                /// Two's complement Green V/Cr multiplier coefficient. YUV=0x76B (-0.581) YCbCr=0x730 (-0.813)
                C2: u11,
                /// Reserved, always set to zero.
                RSVD1: u5,
            }),
            reserved800: [348]u8,
            /// PXP Power Control Register
            POWER: mmio.Mmio(packed struct(u32) {
                reserved9: u9 = 0,
                /// Select the low power state of the ROT memory.
                ROT_MEM_LP_STATE: enum(u3) {
                    /// Memory is not in low power state.
                    NONE = 0x0,
                    /// Light Sleep Mode. Low leakage mode, maintain memory contents.
                    LS = 0x1,
                    /// Deep Sleep Mode. Low leakage mode, maintain memory contents.
                    DS = 0x2,
                    /// Shut Down Mode. Shut Down periphery and core, no memory retention.
                    SD = 0x4,
                    _,
                },
                /// Power control for the PXP.
                CTRL: u20,
            }),
            reserved1024: [220]u8,
            /// Next Frame Pointer
            NEXT: mmio.Mmio(packed struct(u32) {
                /// Indicates that the "next frame" functionality has been enabled
                ENABLED: u1,
                /// Reserved, always set to zero.
                RSVD: u1,
                /// A pointer to a data structure containing register values to be used when processing the next frame
                POINTER: u30,
            }),
            reserved1088: [60]u8,
            /// PXP Alpha Engine A Control Register.
            PORTER_DUFF_CTRL: mmio.Mmio(packed struct(u32) {
                /// poter_duff enable
                POTER_DUFF_ENABLE: u1,
                /// s0 to s1 factor mode
                S0_S1_FACTOR_MODE: u2,
                /// s0 global alpha mode
                S0_GLOBAL_ALPHA_MODE: u2,
                /// s0 alpha mode
                S0_ALPHA_MODE: u1,
                /// s0 color mode
                S0_COLOR_MODE: u1,
                reserved8: u1 = 0,
                /// s1 to s0 factor mode
                S1_S0_FACTOR_MODE: u2,
                /// s1 global alpha mode
                S1_GLOBAL_ALPHA_MODE: u2,
                /// s1 alpha mode
                S1_ALPHA_MODE: u1,
                /// s1 color mode
                S1_COLOR_MODE: u1,
                reserved16: u2 = 0,
                /// s0 global alpha
                S0_GLOBAL_ALPHA: u8,
                /// s1 global alpha
                S1_GLOBAL_ALPHA: u8,
            }),
        };

        /// ROMC
        pub const ROMC = extern struct {
            reserved244: [244]u8,
            /// ROMC Control Register
            ROMPATCHCNTL: mmio.Mmio(packed struct(u32) {
                /// Data Fix Enable - Controls the use of the first 8 address comparators for 1-word data fix or for code patch routine
                DATAFIX: enum(u8) {
                    /// Address comparator triggers a opcode patch
                    DATAFIX_0 = 0x0,
                    /// Address comparator triggers a data fix
                    DATAFIX_1 = 0x1,
                    _,
                },
                reserved29: u21 = 0,
                /// ROMC Disable -- This bit, when set, disables all ROMC operations
                DIS: enum(u1) {
                    /// Does not affect any ROMC functions (default)
                    DIS_0 = 0x0,
                    /// Disable all ROMC functions: data fixing, and opcode patching
                    DIS_1 = 0x1,
                },
                padding: u2 = 0,
            }),
            /// ROMC Enable Register High
            ROMPATCHENH: u32,
            /// ROMC Enable Register Low
            ROMPATCHENL: mmio.Mmio(packed struct(u32) {
                /// Enable Address Comparator - This bit enables the corresponding address comparator to trigger an event
                ENABLE: enum(u16) {
                    /// Address comparator disabled
                    ENABLE_0 = 0x0,
                    /// Address comparator enabled, ROMC will trigger a opcode patch or data fix event upon matching of the associated address
                    ENABLE_1 = 0x1,
                    _,
                },
                padding: u16 = 0,
            }),
            reserved520: [264]u8,
            /// ROMC Status Register
            ROMPATCHSR: mmio.Mmio(packed struct(u32) {
                /// ROMC Source Number - Binary encoding of the number of the address comparator which has an address match in the most recent patch event on ROMC AHB
                SOURCE: enum(u6) {
                    /// Address Comparator 0 matched
                    SOURCE_0 = 0x0,
                    /// Address Comparator 1 matched
                    SOURCE_1 = 0x1,
                    /// Address Comparator 15 matched
                    SOURCE_15 = 0xf,
                    _,
                },
                reserved17: u11 = 0,
                /// ROMC AHB Multiple Address Comparator matches Indicator - Indicates that multiple address comparator matches occurred
                SW: enum(u1) {
                    /// no event or comparator collisions
                    SW_0 = 0x0,
                    /// a collision has occurred
                    SW_1 = 0x1,
                },
                padding: u14 = 0,
            }),
        };

        /// WDOG
        pub const RTWDOG = extern struct {
            /// Watchdog Control and Status Register
            CS: mmio.Mmio(packed struct(u32) {
                /// Stop Enable
                STOP: enum(u1) {
                    /// Watchdog disabled in chip stop mode.
                    STOP_0 = 0x0,
                    /// Watchdog enabled in chip stop mode.
                    STOP_1 = 0x1,
                },
                /// Wait Enable
                WAIT: enum(u1) {
                    /// Watchdog disabled in chip wait mode.
                    WAIT_0 = 0x0,
                    /// Watchdog enabled in chip wait mode.
                    WAIT_1 = 0x1,
                },
                /// Debug Enable
                DBG: enum(u1) {
                    /// Watchdog disabled in chip debug mode.
                    DBG_0 = 0x0,
                    /// Watchdog enabled in chip debug mode.
                    DBG_1 = 0x1,
                },
                /// Watchdog Test
                TST: enum(u2) {
                    /// Watchdog test mode disabled.
                    TST_0 = 0x0,
                    /// Watchdog user mode enabled. (Watchdog test mode disabled.) After testing the watchdog, software should use this setting to indicate that the watchdog is functioning normally in user mode.
                    TST_1 = 0x1,
                    /// Watchdog test mode enabled, only the low byte is used. CNT[CNTLOW] is compared with TOVAL[TOVALLOW].
                    TST_2 = 0x2,
                    /// Watchdog test mode enabled, only the high byte is used. CNT[CNTHIGH] is compared with TOVAL[TOVALHIGH].
                    TST_3 = 0x3,
                },
                /// Allow updates
                UPDATE: enum(u1) {
                    /// Updates not allowed. After the initial configuration, the watchdog cannot be later modified without forcing a reset.
                    UPDATE_0 = 0x0,
                    /// Updates allowed. Software can modify the watchdog configuration registers within 128 bus clocks after performing the unlock write sequence.
                    UPDATE_1 = 0x1,
                },
                /// Watchdog Interrupt
                INT: enum(u1) {
                    /// Watchdog interrupts are disabled. Watchdog resets are not delayed.
                    INT_0 = 0x0,
                    /// Watchdog interrupts are enabled. Watchdog resets are delayed by 128 bus clocks from the interrupt vector fetch.
                    INT_1 = 0x1,
                },
                /// Watchdog Enable
                EN: enum(u1) {
                    /// Watchdog disabled.
                    EN_0 = 0x0,
                    /// Watchdog enabled.
                    EN_1 = 0x1,
                },
                /// Watchdog Clock
                CLK: enum(u2) {
                    /// Bus clock
                    CLK_0 = 0x0,
                    /// LPO clock
                    CLK_1 = 0x1,
                    /// INTCLK (internal clock)
                    CLK_2 = 0x2,
                    /// ERCLK (external reference clock)
                    CLK_3 = 0x3,
                },
                /// Reconfiguration Success
                RCS: enum(u1) {
                    /// Reconfiguring WDOG.
                    RCS_0 = 0x0,
                    /// Reconfiguration is successful.
                    RCS_1 = 0x1,
                },
                /// Unlock status
                ULK: enum(u1) {
                    /// WDOG is locked.
                    ULK_0 = 0x0,
                    /// WDOG is unlocked.
                    ULK_1 = 0x1,
                },
                /// Watchdog prescaler
                PRES: enum(u1) {
                    /// 256 prescaler disabled.
                    PRES_0 = 0x0,
                    /// 256 prescaler enabled.
                    PRES_1 = 0x1,
                },
                /// Enables or disables WDOG support for 32-bit (otherwise 16-bit or 8-bit) refresh/unlock command write words
                CMD32EN: enum(u1) {
                    /// Disables support for 32-bit refresh/unlock command write words. Only 16-bit or 8-bit is supported.
                    CMD32EN_0 = 0x0,
                    /// Enables support for 32-bit refresh/unlock command write words. 16-bit or 8-bit is NOT supported.
                    CMD32EN_1 = 0x1,
                },
                /// Watchdog Interrupt Flag
                FLG: enum(u1) {
                    /// No interrupt occurred.
                    FLG_0 = 0x0,
                    /// An interrupt occurred.
                    FLG_1 = 0x1,
                },
                /// Watchdog Window
                WIN: enum(u1) {
                    /// Window mode disabled.
                    WIN_0 = 0x0,
                    /// Window mode enabled.
                    WIN_1 = 0x1,
                },
                padding: u16 = 0,
            }),
            /// Watchdog Counter Register
            CNT: mmio.Mmio(packed struct(u32) {
                /// Low byte of the Watchdog Counter
                CNTLOW: u8,
                /// High byte of the Watchdog Counter
                CNTHIGH: u8,
                padding: u16 = 0,
            }),
            /// Watchdog Timeout Value Register
            TOVAL: mmio.Mmio(packed struct(u32) {
                /// Low byte of the timeout value
                TOVALLOW: u8,
                /// High byte of the timeout value
                TOVALHIGH: u8,
                padding: u16 = 0,
            }),
            /// Watchdog Window Register
            WIN: mmio.Mmio(packed struct(u32) {
                /// Low byte of Watchdog Window
                WINLOW: u8,
                /// High byte of Watchdog Window
                WINHIGH: u8,
                padding: u16 = 0,
            }),
        };

        /// I2S
        pub const SAI1 = extern struct {
            /// Version ID Register
            VERID: mmio.Mmio(packed struct(u32) {
                /// Feature Specification Number
                FEATURE: enum(u16) {
                    /// Standard feature set.
                    FEATURE_0 = 0x0,
                    _,
                },
                /// Minor Version Number
                MINOR: u8,
                /// Major Version Number
                MAJOR: u8,
            }),
            /// Parameter Register
            PARAM: mmio.Mmio(packed struct(u32) {
                /// Number of Datalines
                DATALINE: u4,
                reserved8: u4 = 0,
                /// FIFO Size
                FIFO: u4,
                reserved16: u4 = 0,
                /// Frame Size
                FRAME: u4,
                padding: u12 = 0,
            }),
            /// SAI Transmit Control Register
            TCSR: mmio.Mmio(packed struct(u32) {
                /// FIFO Request DMA Enable
                FRDE: enum(u1) {
                    /// Disables the DMA request.
                    FRDE_0 = 0x0,
                    /// Enables the DMA request.
                    FRDE_1 = 0x1,
                },
                /// FIFO Warning DMA Enable
                FWDE: enum(u1) {
                    /// Disables the DMA request.
                    FWDE_0 = 0x0,
                    /// Enables the DMA request.
                    FWDE_1 = 0x1,
                },
                reserved8: u6 = 0,
                /// FIFO Request Interrupt Enable
                FRIE: enum(u1) {
                    /// Disables the interrupt.
                    FRIE_0 = 0x0,
                    /// Enables the interrupt.
                    FRIE_1 = 0x1,
                },
                /// FIFO Warning Interrupt Enable
                FWIE: enum(u1) {
                    /// Disables the interrupt.
                    FWIE_0 = 0x0,
                    /// Enables the interrupt.
                    FWIE_1 = 0x1,
                },
                /// FIFO Error Interrupt Enable
                FEIE: enum(u1) {
                    /// Disables the interrupt.
                    FEIE_0 = 0x0,
                    /// Enables the interrupt.
                    FEIE_1 = 0x1,
                },
                /// Sync Error Interrupt Enable
                SEIE: enum(u1) {
                    /// Disables interrupt.
                    SEIE_0 = 0x0,
                    /// Enables interrupt.
                    SEIE_1 = 0x1,
                },
                /// Word Start Interrupt Enable
                WSIE: enum(u1) {
                    /// Disables interrupt.
                    WSIE_0 = 0x0,
                    /// Enables interrupt.
                    WSIE_1 = 0x1,
                },
                reserved16: u3 = 0,
                /// FIFO Request Flag
                FRF: enum(u1) {
                    /// Transmit FIFO watermark has not been reached.
                    FRF_0 = 0x0,
                    /// Transmit FIFO watermark has been reached.
                    FRF_1 = 0x1,
                },
                /// FIFO Warning Flag
                FWF: enum(u1) {
                    /// No enabled transmit FIFO is empty.
                    FWF_0 = 0x0,
                    /// Enabled transmit FIFO is empty.
                    FWF_1 = 0x1,
                },
                /// FIFO Error Flag
                FEF: enum(u1) {
                    /// Transmit underrun not detected.
                    FEF_0 = 0x0,
                    /// Transmit underrun detected.
                    FEF_1 = 0x1,
                },
                /// Sync Error Flag
                SEF: enum(u1) {
                    /// Sync error not detected.
                    SEF_0 = 0x0,
                    /// Frame sync error detected.
                    SEF_1 = 0x1,
                },
                /// Word Start Flag
                WSF: enum(u1) {
                    /// Start of word not detected.
                    WSF_0 = 0x0,
                    /// Start of word detected.
                    WSF_1 = 0x1,
                },
                reserved24: u3 = 0,
                /// Software Reset
                SR: enum(u1) {
                    /// No effect.
                    SR_0 = 0x0,
                    /// Software reset.
                    SR_1 = 0x1,
                },
                /// FIFO Reset
                FR: enum(u1) {
                    /// No effect.
                    FR_0 = 0x0,
                    /// FIFO reset.
                    FR_1 = 0x1,
                },
                reserved28: u2 = 0,
                /// Bit Clock Enable
                BCE: enum(u1) {
                    /// Transmit bit clock is disabled.
                    BCE_0 = 0x0,
                    /// Transmit bit clock is enabled.
                    BCE_1 = 0x1,
                },
                /// Debug Enable
                DBGE: enum(u1) {
                    /// Transmitter is disabled in Debug mode, after completing the current frame.
                    DBGE_0 = 0x0,
                    /// Transmitter is enabled in Debug mode.
                    DBGE_1 = 0x1,
                },
                /// Stop Enable
                STOPE: enum(u1) {
                    /// Transmitter disabled in Stop mode.
                    STOPE_0 = 0x0,
                    /// Transmitter enabled in Stop mode.
                    STOPE_1 = 0x1,
                },
                /// Transmitter Enable
                TE: enum(u1) {
                    /// Transmitter is disabled.
                    TE_0 = 0x0,
                    /// Transmitter is enabled, or transmitter has been disabled and has not yet reached end of frame.
                    TE_1 = 0x1,
                },
            }),
            /// SAI Transmit Configuration 1 Register
            TCR1: mmio.Mmio(packed struct(u32) {
                /// Transmit FIFO Watermark
                TFW: u5,
                padding: u27 = 0,
            }),
            /// SAI Transmit Configuration 2 Register
            TCR2: mmio.Mmio(packed struct(u32) {
                /// Bit Clock Divide
                DIV: u8,
                reserved24: u16 = 0,
                /// Bit Clock Direction
                BCD: enum(u1) {
                    /// Bit clock is generated externally in Slave mode.
                    BCD_0 = 0x0,
                    /// Bit clock is generated internally in Master mode.
                    BCD_1 = 0x1,
                },
                /// Bit Clock Polarity
                BCP: enum(u1) {
                    /// Bit clock is active high with drive outputs on rising edge and sample inputs on falling edge.
                    BCP_0 = 0x0,
                    /// Bit clock is active low with drive outputs on falling edge and sample inputs on rising edge.
                    BCP_1 = 0x1,
                },
                /// MCLK Select
                MSEL: enum(u2) {
                    /// Bus Clock selected.
                    MSEL_0 = 0x0,
                    /// Master Clock (MCLK) 1 option selected.
                    MSEL_1 = 0x1,
                    /// Master Clock (MCLK) 2 option selected.
                    MSEL_2 = 0x2,
                    /// Master Clock (MCLK) 3 option selected.
                    MSEL_3 = 0x3,
                },
                /// Bit Clock Input
                BCI: enum(u1) {
                    /// No effect.
                    BCI_0 = 0x0,
                    /// Internal logic is clocked as if bit clock was externally generated.
                    BCI_1 = 0x1,
                },
                /// Bit Clock Swap
                BCS: enum(u1) {
                    /// Use the normal bit clock source.
                    BCS_0 = 0x0,
                    /// Swap the bit clock source.
                    BCS_1 = 0x1,
                },
                /// Synchronous Mode
                SYNC: enum(u2) {
                    /// Asynchronous mode.
                    SYNC_0 = 0x0,
                    /// Synchronous with receiver.
                    SYNC_1 = 0x1,
                    _,
                },
            }),
            /// SAI Transmit Configuration 3 Register
            TCR3: mmio.Mmio(packed struct(u32) {
                /// Word Flag Configuration
                WDFL: u5,
                reserved16: u11 = 0,
                /// Transmit Channel Enable
                TCE: u4,
                reserved24: u4 = 0,
                /// Channel FIFO Reset
                CFR: u4,
                padding: u4 = 0,
            }),
            /// SAI Transmit Configuration 4 Register
            TCR4: mmio.Mmio(packed struct(u32) {
                /// Frame Sync Direction
                FSD: enum(u1) {
                    /// Frame sync is generated externally in Slave mode.
                    FSD_0 = 0x0,
                    /// Frame sync is generated internally in Master mode.
                    FSD_1 = 0x1,
                },
                /// Frame Sync Polarity
                FSP: enum(u1) {
                    /// Frame sync is active high.
                    FSP_0 = 0x0,
                    /// Frame sync is active low.
                    FSP_1 = 0x1,
                },
                /// On Demand Mode
                ONDEM: enum(u1) {
                    /// Internal frame sync is generated continuously.
                    ONDEM_0 = 0x0,
                    /// Internal frame sync is generated when the FIFO warning flag is clear.
                    ONDEM_1 = 0x1,
                },
                /// Frame Sync Early
                FSE: enum(u1) {
                    /// Frame sync asserts with the first bit of the frame.
                    FSE_0 = 0x0,
                    /// Frame sync asserts one bit before the first bit of the frame.
                    FSE_1 = 0x1,
                },
                /// MSB First
                MF: enum(u1) {
                    /// LSB is transmitted first.
                    MF_0 = 0x0,
                    /// MSB is transmitted first.
                    MF_1 = 0x1,
                },
                /// Channel Mode
                CHMOD: enum(u1) {
                    /// TDM mode, transmit data pins are tri-stated when slots are masked or channels are disabled.
                    CHMOD_0 = 0x0,
                    /// Output mode, transmit data pins are never tri-stated and will output zero when slots are masked or channels are disabled.
                    CHMOD_1 = 0x1,
                },
                reserved8: u2 = 0,
                /// Sync Width
                SYWD: u5,
                reserved16: u3 = 0,
                /// Frame size
                FRSZ: u5,
                reserved24: u3 = 0,
                /// FIFO Packing Mode
                FPACK: enum(u2) {
                    /// FIFO packing is disabled
                    FPACK_0 = 0x0,
                    /// 8-bit FIFO packing is enabled
                    FPACK_2 = 0x2,
                    /// 16-bit FIFO packing is enabled
                    FPACK_3 = 0x3,
                    _,
                },
                /// FIFO Combine Mode
                FCOMB: enum(u2) {
                    /// FIFO combine mode disabled.
                    FCOMB_0 = 0x0,
                    /// FIFO combine mode enabled on FIFO reads (from transmit shift registers).
                    FCOMB_1 = 0x1,
                    /// FIFO combine mode enabled on FIFO writes (by software).
                    FCOMB_2 = 0x2,
                    /// FIFO combine mode enabled on FIFO reads (from transmit shift registers) and writes (by software).
                    FCOMB_3 = 0x3,
                },
                /// FIFO Continue on Error
                FCONT: enum(u1) {
                    /// On FIFO error, the SAI will continue from the start of the next frame after the FIFO error flag has been cleared.
                    FCONT_0 = 0x0,
                    /// On FIFO error, the SAI will continue from the same word that caused the FIFO error to set after the FIFO warning flag has been cleared.
                    FCONT_1 = 0x1,
                },
                padding: u3 = 0,
            }),
            /// SAI Transmit Configuration 5 Register
            TCR5: mmio.Mmio(packed struct(u32) {
                reserved8: u8 = 0,
                /// First Bit Shifted
                FBT: u5,
                reserved16: u3 = 0,
                /// Word 0 Width
                W0W: u5,
                reserved24: u3 = 0,
                /// Word N Width
                WNW: u5,
                padding: u3 = 0,
            }),
            /// SAI Transmit Data Register
            TDR: [4]mmio.Mmio(packed struct(u32) {
                /// Transmit Data Register
                TDR: u32,
            }),
            reserved64: [16]u8,
            /// SAI Transmit FIFO Register
            TFR: [4]mmio.Mmio(packed struct(u32) {
                /// Read FIFO Pointer
                RFP: u6,
                reserved16: u10 = 0,
                /// Write FIFO Pointer
                WFP: u6,
                reserved31: u9 = 0,
                /// Write Channel Pointer
                WCP: enum(u1) {
                    /// No effect.
                    WCP_0 = 0x0,
                    /// FIFO combine is enabled for FIFO writes and this FIFO will be written on the next FIFO write.
                    WCP_1 = 0x1,
                },
            }),
            reserved96: [16]u8,
            /// SAI Transmit Mask Register
            TMR: mmio.Mmio(packed struct(u32) {
                /// Transmit Word Mask
                TWM: enum(u32) {
                    /// Word N is enabled.
                    TWM_0 = 0x0,
                    /// Word N is masked. The transmit data pins are tri-stated or drive zero when masked.
                    TWM_1 = 0x1,
                    _,
                },
            }),
            reserved136: [36]u8,
            /// SAI Receive Control Register
            RCSR: mmio.Mmio(packed struct(u32) {
                /// FIFO Request DMA Enable
                FRDE: enum(u1) {
                    /// Disables the DMA request.
                    FRDE_0 = 0x0,
                    /// Enables the DMA request.
                    FRDE_1 = 0x1,
                },
                /// FIFO Warning DMA Enable
                FWDE: enum(u1) {
                    /// Disables the DMA request.
                    FWDE_0 = 0x0,
                    /// Enables the DMA request.
                    FWDE_1 = 0x1,
                },
                reserved8: u6 = 0,
                /// FIFO Request Interrupt Enable
                FRIE: enum(u1) {
                    /// Disables the interrupt.
                    FRIE_0 = 0x0,
                    /// Enables the interrupt.
                    FRIE_1 = 0x1,
                },
                /// FIFO Warning Interrupt Enable
                FWIE: enum(u1) {
                    /// Disables the interrupt.
                    FWIE_0 = 0x0,
                    /// Enables the interrupt.
                    FWIE_1 = 0x1,
                },
                /// FIFO Error Interrupt Enable
                FEIE: enum(u1) {
                    /// Disables the interrupt.
                    FEIE_0 = 0x0,
                    /// Enables the interrupt.
                    FEIE_1 = 0x1,
                },
                /// Sync Error Interrupt Enable
                SEIE: enum(u1) {
                    /// Disables interrupt.
                    SEIE_0 = 0x0,
                    /// Enables interrupt.
                    SEIE_1 = 0x1,
                },
                /// Word Start Interrupt Enable
                WSIE: enum(u1) {
                    /// Disables interrupt.
                    WSIE_0 = 0x0,
                    /// Enables interrupt.
                    WSIE_1 = 0x1,
                },
                reserved16: u3 = 0,
                /// FIFO Request Flag
                FRF: enum(u1) {
                    /// Receive FIFO watermark not reached.
                    FRF_0 = 0x0,
                    /// Receive FIFO watermark has been reached.
                    FRF_1 = 0x1,
                },
                /// FIFO Warning Flag
                FWF: enum(u1) {
                    /// No enabled receive FIFO is full.
                    FWF_0 = 0x0,
                    /// Enabled receive FIFO is full.
                    FWF_1 = 0x1,
                },
                /// FIFO Error Flag
                FEF: enum(u1) {
                    /// Receive overflow not detected.
                    FEF_0 = 0x0,
                    /// Receive overflow detected.
                    FEF_1 = 0x1,
                },
                /// Sync Error Flag
                SEF: enum(u1) {
                    /// Sync error not detected.
                    SEF_0 = 0x0,
                    /// Frame sync error detected.
                    SEF_1 = 0x1,
                },
                /// Word Start Flag
                WSF: enum(u1) {
                    /// Start of word not detected.
                    WSF_0 = 0x0,
                    /// Start of word detected.
                    WSF_1 = 0x1,
                },
                reserved24: u3 = 0,
                /// Software Reset
                SR: enum(u1) {
                    /// No effect.
                    SR_0 = 0x0,
                    /// Software reset.
                    SR_1 = 0x1,
                },
                /// FIFO Reset
                FR: enum(u1) {
                    /// No effect.
                    FR_0 = 0x0,
                    /// FIFO reset.
                    FR_1 = 0x1,
                },
                reserved28: u2 = 0,
                /// Bit Clock Enable
                BCE: enum(u1) {
                    /// Receive bit clock is disabled.
                    BCE_0 = 0x0,
                    /// Receive bit clock is enabled.
                    BCE_1 = 0x1,
                },
                /// Debug Enable
                DBGE: enum(u1) {
                    /// Receiver is disabled in Debug mode, after completing the current frame.
                    DBGE_0 = 0x0,
                    /// Receiver is enabled in Debug mode.
                    DBGE_1 = 0x1,
                },
                /// Stop Enable
                STOPE: enum(u1) {
                    /// Receiver disabled in Stop mode.
                    STOPE_0 = 0x0,
                    /// Receiver enabled in Stop mode.
                    STOPE_1 = 0x1,
                },
                /// Receiver Enable
                RE: enum(u1) {
                    /// Receiver is disabled.
                    RE_0 = 0x0,
                    /// Receiver is enabled, or receiver has been disabled and has not yet reached end of frame.
                    RE_1 = 0x1,
                },
            }),
            /// SAI Receive Configuration 1 Register
            RCR1: mmio.Mmio(packed struct(u32) {
                /// Receive FIFO Watermark
                RFW: u5,
                padding: u27 = 0,
            }),
            /// SAI Receive Configuration 2 Register
            RCR2: mmio.Mmio(packed struct(u32) {
                /// Bit Clock Divide
                DIV: u8,
                reserved24: u16 = 0,
                /// Bit Clock Direction
                BCD: enum(u1) {
                    /// Bit clock is generated externally in Slave mode.
                    BCD_0 = 0x0,
                    /// Bit clock is generated internally in Master mode.
                    BCD_1 = 0x1,
                },
                /// Bit Clock Polarity
                BCP: enum(u1) {
                    /// Bit Clock is active high with drive outputs on rising edge and sample inputs on falling edge.
                    BCP_0 = 0x0,
                    /// Bit Clock is active low with drive outputs on falling edge and sample inputs on rising edge.
                    BCP_1 = 0x1,
                },
                /// MCLK Select
                MSEL: enum(u2) {
                    /// Bus Clock selected.
                    MSEL_0 = 0x0,
                    /// Master Clock (MCLK) 1 option selected.
                    MSEL_1 = 0x1,
                    /// Master Clock (MCLK) 2 option selected.
                    MSEL_2 = 0x2,
                    /// Master Clock (MCLK) 3 option selected.
                    MSEL_3 = 0x3,
                },
                /// Bit Clock Input
                BCI: enum(u1) {
                    /// No effect.
                    BCI_0 = 0x0,
                    /// Internal logic is clocked as if bit clock was externally generated.
                    BCI_1 = 0x1,
                },
                /// Bit Clock Swap
                BCS: enum(u1) {
                    /// Use the normal bit clock source.
                    BCS_0 = 0x0,
                    /// Swap the bit clock source.
                    BCS_1 = 0x1,
                },
                /// Synchronous Mode
                SYNC: enum(u2) {
                    /// Asynchronous mode.
                    SYNC_0 = 0x0,
                    /// Synchronous with transmitter.
                    SYNC_1 = 0x1,
                    _,
                },
            }),
            /// SAI Receive Configuration 3 Register
            RCR3: mmio.Mmio(packed struct(u32) {
                /// Word Flag Configuration
                WDFL: u5,
                reserved16: u11 = 0,
                /// Receive Channel Enable
                RCE: u4,
                reserved24: u4 = 0,
                /// Channel FIFO Reset
                CFR: u4,
                padding: u4 = 0,
            }),
            /// SAI Receive Configuration 4 Register
            RCR4: mmio.Mmio(packed struct(u32) {
                /// Frame Sync Direction
                FSD: enum(u1) {
                    /// Frame Sync is generated externally in Slave mode.
                    FSD_0 = 0x0,
                    /// Frame Sync is generated internally in Master mode.
                    FSD_1 = 0x1,
                },
                /// Frame Sync Polarity
                FSP: enum(u1) {
                    /// Frame sync is active high.
                    FSP_0 = 0x0,
                    /// Frame sync is active low.
                    FSP_1 = 0x1,
                },
                /// On Demand Mode
                ONDEM: enum(u1) {
                    /// Internal frame sync is generated continuously.
                    ONDEM_0 = 0x0,
                    /// Internal frame sync is generated when the FIFO warning flag is clear.
                    ONDEM_1 = 0x1,
                },
                /// Frame Sync Early
                FSE: enum(u1) {
                    /// Frame sync asserts with the first bit of the frame.
                    FSE_0 = 0x0,
                    /// Frame sync asserts one bit before the first bit of the frame.
                    FSE_1 = 0x1,
                },
                /// MSB First
                MF: enum(u1) {
                    /// LSB is received first.
                    MF_0 = 0x0,
                    /// MSB is received first.
                    MF_1 = 0x1,
                },
                reserved8: u3 = 0,
                /// Sync Width
                SYWD: u5,
                reserved16: u3 = 0,
                /// Frame Size
                FRSZ: u5,
                reserved24: u3 = 0,
                /// FIFO Packing Mode
                FPACK: enum(u2) {
                    /// FIFO packing is disabled
                    FPACK_0 = 0x0,
                    /// 8-bit FIFO packing is enabled
                    FPACK_2 = 0x2,
                    /// 16-bit FIFO packing is enabled
                    FPACK_3 = 0x3,
                    _,
                },
                /// FIFO Combine Mode
                FCOMB: enum(u2) {
                    /// FIFO combine mode disabled.
                    FCOMB_0 = 0x0,
                    /// FIFO combine mode enabled on FIFO writes (from receive shift registers).
                    FCOMB_1 = 0x1,
                    /// FIFO combine mode enabled on FIFO reads (by software).
                    FCOMB_2 = 0x2,
                    /// FIFO combine mode enabled on FIFO writes (from receive shift registers) and reads (by software).
                    FCOMB_3 = 0x3,
                },
                /// FIFO Continue on Error
                FCONT: enum(u1) {
                    /// On FIFO error, the SAI will continue from the start of the next frame after the FIFO error flag has been cleared.
                    FCONT_0 = 0x0,
                    /// On FIFO error, the SAI will continue from the same word that caused the FIFO error to set after the FIFO warning flag has been cleared.
                    FCONT_1 = 0x1,
                },
                padding: u3 = 0,
            }),
            /// SAI Receive Configuration 5 Register
            RCR5: mmio.Mmio(packed struct(u32) {
                reserved8: u8 = 0,
                /// First Bit Shifted
                FBT: u5,
                reserved16: u3 = 0,
                /// Word 0 Width
                W0W: u5,
                reserved24: u3 = 0,
                /// Word N Width
                WNW: u5,
                padding: u3 = 0,
            }),
            /// SAI Receive Data Register
            RDR: [4]mmio.Mmio(packed struct(u32) {
                /// Receive Data Register
                RDR: u32,
            }),
            reserved192: [16]u8,
            /// SAI Receive FIFO Register
            RFR: [4]mmio.Mmio(packed struct(u32) {
                /// Read FIFO Pointer
                RFP: u6,
                reserved15: u9 = 0,
                /// Receive Channel Pointer
                RCP: enum(u1) {
                    /// No effect.
                    RCP_0 = 0x0,
                    /// FIFO combine is enabled for FIFO reads and this FIFO will be read on the next FIFO read.
                    RCP_1 = 0x1,
                },
                /// Write FIFO Pointer
                WFP: u6,
                padding: u10 = 0,
            }),
            reserved224: [16]u8,
            /// SAI Receive Mask Register
            RMR: mmio.Mmio(packed struct(u32) {
                /// Receive Word Mask
                RWM: enum(u32) {
                    /// Word N is enabled.
                    RWM_0 = 0x0,
                    /// Word N is masked.
                    RWM_1 = 0x1,
                    _,
                },
            }),
        };

        /// SEMC
        pub const SEMC = extern struct {
            /// Module Control Register
            MCR: mmio.Mmio(packed struct(u32) {
                /// Software Reset
                SWRST: u1,
                /// Module Disable
                MDIS: enum(u1) {
                    /// Module enabled
                    MDIS_0 = 0x0,
                    /// Module disabled.
                    MDIS_1 = 0x1,
                },
                /// DQS (read strobe) mode
                DQSMD: enum(u1) {
                    /// Dummy read strobe loopbacked internally
                    DQSMD_0 = 0x0,
                    /// Dummy read strobe loopbacked from DQS pad or DLL delay chain. Details information at descriptions of DQSSEL bit.
                    DQSMD_1 = 0x1,
                },
                reserved6: u3 = 0,
                /// WAIT/RDY# polarity for NOR/PSRAM
                WPOL0: enum(u1) {
                    /// Low active
                    WPOL0_0 = 0x0,
                    /// High active
                    WPOL0_1 = 0x1,
                },
                /// WAIT/RDY# polarity for NAND
                WPOL1: enum(u1) {
                    /// Low active
                    WPOL1_0 = 0x0,
                    /// High active
                    WPOL1_1 = 0x1,
                },
                reserved10: u2 = 0,
                /// Select DQS source when DQSMD and DLLSEL both set.
                DQSSEL: enum(u1) {
                    /// SDRAM/NOR/SRAM read clock source is from DQS pad in synchronous mode.
                    DQSSEL_0 = 0x0,
                    /// SDRAM/NOR/SRAM read clock source is from DLL delay chain in synchronous mode.
                    DQSSEL_1 = 0x1,
                },
                /// Select DLL delay chain clock input.
                DLLSEL: enum(u1) {
                    /// DLL delay chain clock input is from NAND device's DQS pad. For NAND synchronous mode only.
                    DLLSEL_0 = 0x0,
                    /// DLL delay chain clock input is from internal clock. For SDRAM, NOR and SRAM synchronous mode only.
                    DLLSEL_1 = 0x1,
                },
                reserved16: u4 = 0,
                /// Command Execution timeout cycles
                CTO: u8,
                /// Bus timeout cycles
                BTO: enum(u5) {
                    /// 255*1
                    BTO_0 = 0x0,
                    /// 255*2 - 255*2^30
                    BTO_1 = 0x1,
                    /// 255*2 - 255*2^30
                    BTO_2 = 0x2,
                    /// 255*2 - 255*2^30
                    BTO_3 = 0x3,
                    /// 255*2 - 255*2^30
                    BTO_4 = 0x4,
                    /// 255*2 - 255*2^30
                    BTO_5 = 0x5,
                    /// 255*2 - 255*2^30
                    BTO_6 = 0x6,
                    /// 255*2 - 255*2^30
                    BTO_7 = 0x7,
                    /// 255*2 - 255*2^30
                    BTO_8 = 0x8,
                    /// 255*2 - 255*2^30
                    BTO_9 = 0x9,
                    /// 255*2^31
                    BTO_31 = 0x1f,
                    _,
                },
                padding: u3 = 0,
            }),
            /// IO Mux Control Register
            IOCR: mmio.Mmio(packed struct(u32) {
                /// SEMC_A8 output selection
                MUX_A8: enum(u3) {
                    /// SDRAM Address bit (A8)
                    MUX_A8_0 = 0x0,
                    /// NAND CE#
                    MUX_A8_1 = 0x1,
                    /// NOR CE#
                    MUX_A8_2 = 0x2,
                    /// PSRAM CE#
                    MUX_A8_3 = 0x3,
                    /// DBI CSX
                    MUX_A8_4 = 0x4,
                    /// SDRAM Address bit (A8)
                    MUX_A8_5 = 0x5,
                    /// SDRAM Address bit (A8)
                    MUX_A8_6 = 0x6,
                    /// SDRAM Address bit (A8)
                    MUX_A8_7 = 0x7,
                },
                /// SEMC_CSX0 output selection
                MUX_CSX0: enum(u3) {
                    /// NOR/PSRAM Address bit 24 (A24)
                    MUX_CSX0_0 = 0x0,
                    /// SDRAM CS1
                    MUX_CSX0_1 = 0x1,
                    /// SDRAM CS2
                    MUX_CSX0_2 = 0x2,
                    /// SDRAM CS3
                    MUX_CSX0_3 = 0x3,
                    /// NAND CE#
                    MUX_CSX0_4 = 0x4,
                    /// NOR CE#
                    MUX_CSX0_5 = 0x5,
                    /// PSRAM CE#
                    MUX_CSX0_6 = 0x6,
                    /// DBI CSX
                    MUX_CSX0_7 = 0x7,
                },
                /// SEMC_CSX1 output selection
                MUX_CSX1: enum(u3) {
                    /// NOR/PSRAM Address bit 25 (A25)
                    MUX_CSX1_0 = 0x0,
                    /// SDRAM CS1
                    MUX_CSX1_1 = 0x1,
                    /// SDRAM CS2
                    MUX_CSX1_2 = 0x2,
                    /// SDRAM CS3
                    MUX_CSX1_3 = 0x3,
                    /// NAND CE#
                    MUX_CSX1_4 = 0x4,
                    /// NOR CE#
                    MUX_CSX1_5 = 0x5,
                    /// PSRAM CE#
                    MUX_CSX1_6 = 0x6,
                    /// DBI CSX
                    MUX_CSX1_7 = 0x7,
                },
                /// SEMC_CSX2 output selection
                MUX_CSX2: enum(u3) {
                    /// NOR/PSRAM Address bit 26 (A26)
                    MUX_CSX2_0 = 0x0,
                    /// SDRAM CS1
                    MUX_CSX2_1 = 0x1,
                    /// SDRAM CS2
                    MUX_CSX2_2 = 0x2,
                    /// SDRAM CS3
                    MUX_CSX2_3 = 0x3,
                    /// NAND CE#
                    MUX_CSX2_4 = 0x4,
                    /// NOR CE#
                    MUX_CSX2_5 = 0x5,
                    /// PSRAM CE#
                    MUX_CSX2_6 = 0x6,
                    /// DBI CSX
                    MUX_CSX2_7 = 0x7,
                },
                /// SEMC_CSX3 output selection
                MUX_CSX3: enum(u3) {
                    /// NOR/PSRAM Address bit 27 (A27)
                    MUX_CSX3_0 = 0x0,
                    /// SDRAM CS1
                    MUX_CSX3_1 = 0x1,
                    /// SDRAM CS2
                    MUX_CSX3_2 = 0x2,
                    /// SDRAM CS3
                    MUX_CSX3_3 = 0x3,
                    /// NAND CE#
                    MUX_CSX3_4 = 0x4,
                    /// NOR CE#
                    MUX_CSX3_5 = 0x5,
                    /// PSRAM CE#
                    MUX_CSX3_6 = 0x6,
                    /// DBI CSX
                    MUX_CSX3_7 = 0x7,
                },
                /// SEMC_RDY function selection
                MUX_RDY: enum(u3) {
                    /// NAND Ready/Wait# input
                    MUX_RDY_0 = 0x0,
                    /// SDRAM CS1
                    MUX_RDY_1 = 0x1,
                    /// SDRAM CS2
                    MUX_RDY_2 = 0x2,
                    /// SDRAM CS3
                    MUX_RDY_3 = 0x3,
                    /// NOR CE#
                    MUX_RDY_4 = 0x4,
                    /// PSRAM CE#
                    MUX_RDY_5 = 0x5,
                    /// DBI CSX
                    MUX_RDY_6 = 0x6,
                    /// NOR/PSRAM Address bit 27
                    MUX_RDY_7 = 0x7,
                },
                reserved24: u6 = 0,
                /// SEMC_CLKX0 function selection
                MUX_CLKX0: enum(u1) {
                    /// NOR clock
                    MUX_CLKX0_0 = 0x0,
                    /// SRAM clock
                    MUX_CLKX0_1 = 0x1,
                },
                /// SEMC_CLKX1 function selection
                MUX_CLKX1: enum(u1) {
                    /// NOR clock
                    MUX_CLKX1_0 = 0x0,
                    /// SRAM clock
                    MUX_CLKX1_1 = 0x1,
                },
                padding: u6 = 0,
            }),
            /// Master Bus (AXI) Control Register 0
            BMCR0: mmio.Mmio(packed struct(u32) {
                /// Weight of QoS
                WQOS: u4,
                /// Weight of Aging
                WAGE: u4,
                /// Weight of Slave Hit (no read/write switch)
                WSH: u8,
                /// Weight of Slave Hit (Read/Write switch)
                WRWS: u8,
                padding: u8 = 0,
            }),
            /// Master Bus (AXI) Control Register 1
            BMCR1: mmio.Mmio(packed struct(u32) {
                /// Weight of QoS
                WQOS: u4,
                /// Weight of Aging
                WAGE: u4,
                /// Weight of Page Hit
                WPH: u8,
                /// Weight of Read/Write switch
                WRWS: u8,
                /// Weight of Bank Rotation
                WBR: u8,
            }),
            /// Base Register 0 (For SDRAM CS0 device)
            BR0: mmio.Mmio(packed struct(u32) {
                /// Valid
                VLD: u1,
                /// Memory size
                MS: enum(u5) {
                    /// 4KB
                    MS_0 = 0x0,
                    /// 8KB
                    MS_1 = 0x1,
                    /// 16KB
                    MS_2 = 0x2,
                    /// 32KB
                    MS_3 = 0x3,
                    /// 64KB
                    MS_4 = 0x4,
                    /// 128KB
                    MS_5 = 0x5,
                    /// 256KB
                    MS_6 = 0x6,
                    /// 512KB
                    MS_7 = 0x7,
                    /// 1MB
                    MS_8 = 0x8,
                    /// 2MB
                    MS_9 = 0x9,
                    /// 4MB
                    MS_10 = 0xa,
                    /// 8MB
                    MS_11 = 0xb,
                    /// 16MB
                    MS_12 = 0xc,
                    /// 32MB
                    MS_13 = 0xd,
                    /// 64MB
                    MS_14 = 0xe,
                    /// 128MB
                    MS_15 = 0xf,
                    /// 256MB
                    MS_16 = 0x10,
                    /// 512MB
                    MS_17 = 0x11,
                    /// 1GB
                    MS_18 = 0x12,
                    /// 2GB
                    MS_19 = 0x13,
                    /// 4GB
                    MS_20 = 0x14,
                    /// 4GB
                    MS_21 = 0x15,
                    /// 4GB
                    MS_22 = 0x16,
                    /// 4GB
                    MS_23 = 0x17,
                    /// 4GB
                    MS_24 = 0x18,
                    /// 4GB
                    MS_25 = 0x19,
                    /// 4GB
                    MS_26 = 0x1a,
                    /// 4GB
                    MS_27 = 0x1b,
                    /// 4GB
                    MS_28 = 0x1c,
                    /// 4GB
                    MS_29 = 0x1d,
                    /// 4GB
                    MS_30 = 0x1e,
                    /// 4GB
                    MS_31 = 0x1f,
                },
                reserved12: u6 = 0,
                /// Base Address
                BA: u20,
            }),
            /// Base Register 1 (For SDRAM CS1 device)
            BR1: mmio.Mmio(packed struct(u32) {
                /// Valid
                VLD: u1,
                /// Memory size
                MS: enum(u5) {
                    /// 4KB
                    MS_0 = 0x0,
                    /// 8KB
                    MS_1 = 0x1,
                    /// 16KB
                    MS_2 = 0x2,
                    /// 32KB
                    MS_3 = 0x3,
                    /// 64KB
                    MS_4 = 0x4,
                    /// 128KB
                    MS_5 = 0x5,
                    /// 256KB
                    MS_6 = 0x6,
                    /// 512KB
                    MS_7 = 0x7,
                    /// 1MB
                    MS_8 = 0x8,
                    /// 2MB
                    MS_9 = 0x9,
                    /// 4MB
                    MS_10 = 0xa,
                    /// 8MB
                    MS_11 = 0xb,
                    /// 16MB
                    MS_12 = 0xc,
                    /// 32MB
                    MS_13 = 0xd,
                    /// 64MB
                    MS_14 = 0xe,
                    /// 128MB
                    MS_15 = 0xf,
                    /// 256MB
                    MS_16 = 0x10,
                    /// 512MB
                    MS_17 = 0x11,
                    /// 1GB
                    MS_18 = 0x12,
                    /// 2GB
                    MS_19 = 0x13,
                    /// 4GB
                    MS_20 = 0x14,
                    /// 4GB
                    MS_21 = 0x15,
                    /// 4GB
                    MS_22 = 0x16,
                    /// 4GB
                    MS_23 = 0x17,
                    /// 4GB
                    MS_24 = 0x18,
                    /// 4GB
                    MS_25 = 0x19,
                    /// 4GB
                    MS_26 = 0x1a,
                    /// 4GB
                    MS_27 = 0x1b,
                    /// 4GB
                    MS_28 = 0x1c,
                    /// 4GB
                    MS_29 = 0x1d,
                    /// 4GB
                    MS_30 = 0x1e,
                    /// 4GB
                    MS_31 = 0x1f,
                },
                reserved12: u6 = 0,
                /// Base Address
                BA: u20,
            }),
            /// Base Register 2 (For SDRAM CS2 device)
            BR2: mmio.Mmio(packed struct(u32) {
                /// Valid
                VLD: u1,
                /// Memory size
                MS: enum(u5) {
                    /// 4KB
                    MS_0 = 0x0,
                    /// 8KB
                    MS_1 = 0x1,
                    /// 16KB
                    MS_2 = 0x2,
                    /// 32KB
                    MS_3 = 0x3,
                    /// 64KB
                    MS_4 = 0x4,
                    /// 128KB
                    MS_5 = 0x5,
                    /// 256KB
                    MS_6 = 0x6,
                    /// 512KB
                    MS_7 = 0x7,
                    /// 1MB
                    MS_8 = 0x8,
                    /// 2MB
                    MS_9 = 0x9,
                    /// 4MB
                    MS_10 = 0xa,
                    /// 8MB
                    MS_11 = 0xb,
                    /// 16MB
                    MS_12 = 0xc,
                    /// 32MB
                    MS_13 = 0xd,
                    /// 64MB
                    MS_14 = 0xe,
                    /// 128MB
                    MS_15 = 0xf,
                    /// 256MB
                    MS_16 = 0x10,
                    /// 512MB
                    MS_17 = 0x11,
                    /// 1GB
                    MS_18 = 0x12,
                    /// 2GB
                    MS_19 = 0x13,
                    /// 4GB
                    MS_20 = 0x14,
                    /// 4GB
                    MS_21 = 0x15,
                    /// 4GB
                    MS_22 = 0x16,
                    /// 4GB
                    MS_23 = 0x17,
                    /// 4GB
                    MS_24 = 0x18,
                    /// 4GB
                    MS_25 = 0x19,
                    /// 4GB
                    MS_26 = 0x1a,
                    /// 4GB
                    MS_27 = 0x1b,
                    /// 4GB
                    MS_28 = 0x1c,
                    /// 4GB
                    MS_29 = 0x1d,
                    /// 4GB
                    MS_30 = 0x1e,
                    /// 4GB
                    MS_31 = 0x1f,
                },
                reserved12: u6 = 0,
                /// Base Address
                BA: u20,
            }),
            /// Base Register 3 (For SDRAM CS3 device)
            BR3: mmio.Mmio(packed struct(u32) {
                /// Valid
                VLD: u1,
                /// Memory size
                MS: enum(u5) {
                    /// 4KB
                    MS_0 = 0x0,
                    /// 8KB
                    MS_1 = 0x1,
                    /// 16KB
                    MS_2 = 0x2,
                    /// 32KB
                    MS_3 = 0x3,
                    /// 64KB
                    MS_4 = 0x4,
                    /// 128KB
                    MS_5 = 0x5,
                    /// 256KB
                    MS_6 = 0x6,
                    /// 512KB
                    MS_7 = 0x7,
                    /// 1MB
                    MS_8 = 0x8,
                    /// 2MB
                    MS_9 = 0x9,
                    /// 4MB
                    MS_10 = 0xa,
                    /// 8MB
                    MS_11 = 0xb,
                    /// 16MB
                    MS_12 = 0xc,
                    /// 32MB
                    MS_13 = 0xd,
                    /// 64MB
                    MS_14 = 0xe,
                    /// 128MB
                    MS_15 = 0xf,
                    /// 256MB
                    MS_16 = 0x10,
                    /// 512MB
                    MS_17 = 0x11,
                    /// 1GB
                    MS_18 = 0x12,
                    /// 2GB
                    MS_19 = 0x13,
                    /// 4GB
                    MS_20 = 0x14,
                    /// 4GB
                    MS_21 = 0x15,
                    /// 4GB
                    MS_22 = 0x16,
                    /// 4GB
                    MS_23 = 0x17,
                    /// 4GB
                    MS_24 = 0x18,
                    /// 4GB
                    MS_25 = 0x19,
                    /// 4GB
                    MS_26 = 0x1a,
                    /// 4GB
                    MS_27 = 0x1b,
                    /// 4GB
                    MS_28 = 0x1c,
                    /// 4GB
                    MS_29 = 0x1d,
                    /// 4GB
                    MS_30 = 0x1e,
                    /// 4GB
                    MS_31 = 0x1f,
                },
                reserved12: u6 = 0,
                /// Base Address
                BA: u20,
            }),
            /// Base Register 4 (For NAND device)
            BR4: mmio.Mmio(packed struct(u32) {
                /// Valid
                VLD: u1,
                /// Memory size
                MS: enum(u5) {
                    /// 4KB
                    MS_0 = 0x0,
                    /// 8KB
                    MS_1 = 0x1,
                    /// 16KB
                    MS_2 = 0x2,
                    /// 32KB
                    MS_3 = 0x3,
                    /// 64KB
                    MS_4 = 0x4,
                    /// 128KB
                    MS_5 = 0x5,
                    /// 256KB
                    MS_6 = 0x6,
                    /// 512KB
                    MS_7 = 0x7,
                    /// 1MB
                    MS_8 = 0x8,
                    /// 2MB
                    MS_9 = 0x9,
                    /// 4MB
                    MS_10 = 0xa,
                    /// 8MB
                    MS_11 = 0xb,
                    /// 16MB
                    MS_12 = 0xc,
                    /// 32MB
                    MS_13 = 0xd,
                    /// 64MB
                    MS_14 = 0xe,
                    /// 128MB
                    MS_15 = 0xf,
                    /// 256MB
                    MS_16 = 0x10,
                    /// 512MB
                    MS_17 = 0x11,
                    /// 1GB
                    MS_18 = 0x12,
                    /// 2GB
                    MS_19 = 0x13,
                    /// 4GB
                    MS_20 = 0x14,
                    /// 4GB
                    MS_21 = 0x15,
                    /// 4GB
                    MS_22 = 0x16,
                    /// 4GB
                    MS_23 = 0x17,
                    /// 4GB
                    MS_24 = 0x18,
                    /// 4GB
                    MS_25 = 0x19,
                    /// 4GB
                    MS_26 = 0x1a,
                    /// 4GB
                    MS_27 = 0x1b,
                    /// 4GB
                    MS_28 = 0x1c,
                    /// 4GB
                    MS_29 = 0x1d,
                    /// 4GB
                    MS_30 = 0x1e,
                    /// 4GB
                    MS_31 = 0x1f,
                },
                reserved12: u6 = 0,
                /// Base Address
                BA: u20,
            }),
            /// Base Register 5 (For NOR device)
            BR5: mmio.Mmio(packed struct(u32) {
                /// Valid
                VLD: u1,
                /// Memory size
                MS: enum(u5) {
                    /// 4KB
                    MS_0 = 0x0,
                    /// 8KB
                    MS_1 = 0x1,
                    /// 16KB
                    MS_2 = 0x2,
                    /// 32KB
                    MS_3 = 0x3,
                    /// 64KB
                    MS_4 = 0x4,
                    /// 128KB
                    MS_5 = 0x5,
                    /// 256KB
                    MS_6 = 0x6,
                    /// 512KB
                    MS_7 = 0x7,
                    /// 1MB
                    MS_8 = 0x8,
                    /// 2MB
                    MS_9 = 0x9,
                    /// 4MB
                    MS_10 = 0xa,
                    /// 8MB
                    MS_11 = 0xb,
                    /// 16MB
                    MS_12 = 0xc,
                    /// 32MB
                    MS_13 = 0xd,
                    /// 64MB
                    MS_14 = 0xe,
                    /// 128MB
                    MS_15 = 0xf,
                    /// 256MB
                    MS_16 = 0x10,
                    /// 512MB
                    MS_17 = 0x11,
                    /// 1GB
                    MS_18 = 0x12,
                    /// 2GB
                    MS_19 = 0x13,
                    /// 4GB
                    MS_20 = 0x14,
                    /// 4GB
                    MS_21 = 0x15,
                    /// 4GB
                    MS_22 = 0x16,
                    /// 4GB
                    MS_23 = 0x17,
                    /// 4GB
                    MS_24 = 0x18,
                    /// 4GB
                    MS_25 = 0x19,
                    /// 4GB
                    MS_26 = 0x1a,
                    /// 4GB
                    MS_27 = 0x1b,
                    /// 4GB
                    MS_28 = 0x1c,
                    /// 4GB
                    MS_29 = 0x1d,
                    /// 4GB
                    MS_30 = 0x1e,
                    /// 4GB
                    MS_31 = 0x1f,
                },
                reserved12: u6 = 0,
                /// Base Address
                BA: u20,
            }),
            /// Base Register 6 (For PSRAM device)
            BR6: mmio.Mmio(packed struct(u32) {
                /// Valid
                VLD: u1,
                /// Memory size
                MS: enum(u5) {
                    /// 4KB
                    MS_0 = 0x0,
                    /// 8KB
                    MS_1 = 0x1,
                    /// 16KB
                    MS_2 = 0x2,
                    /// 32KB
                    MS_3 = 0x3,
                    /// 64KB
                    MS_4 = 0x4,
                    /// 128KB
                    MS_5 = 0x5,
                    /// 256KB
                    MS_6 = 0x6,
                    /// 512KB
                    MS_7 = 0x7,
                    /// 1MB
                    MS_8 = 0x8,
                    /// 2MB
                    MS_9 = 0x9,
                    /// 4MB
                    MS_10 = 0xa,
                    /// 8MB
                    MS_11 = 0xb,
                    /// 16MB
                    MS_12 = 0xc,
                    /// 32MB
                    MS_13 = 0xd,
                    /// 64MB
                    MS_14 = 0xe,
                    /// 128MB
                    MS_15 = 0xf,
                    /// 256MB
                    MS_16 = 0x10,
                    /// 512MB
                    MS_17 = 0x11,
                    /// 1GB
                    MS_18 = 0x12,
                    /// 2GB
                    MS_19 = 0x13,
                    /// 4GB
                    MS_20 = 0x14,
                    /// 4GB
                    MS_21 = 0x15,
                    /// 4GB
                    MS_22 = 0x16,
                    /// 4GB
                    MS_23 = 0x17,
                    /// 4GB
                    MS_24 = 0x18,
                    /// 4GB
                    MS_25 = 0x19,
                    /// 4GB
                    MS_26 = 0x1a,
                    /// 4GB
                    MS_27 = 0x1b,
                    /// 4GB
                    MS_28 = 0x1c,
                    /// 4GB
                    MS_29 = 0x1d,
                    /// 4GB
                    MS_30 = 0x1e,
                    /// 4GB
                    MS_31 = 0x1f,
                },
                reserved12: u6 = 0,
                /// Base Address
                BA: u20,
            }),
            /// Base Register 7 (For DBI-B (MIPI Display Bus Interface Type B) device)
            BR7: mmio.Mmio(packed struct(u32) {
                /// Valid
                VLD: u1,
                /// Memory size
                MS: enum(u5) {
                    /// 4KB
                    MS_0 = 0x0,
                    /// 8KB
                    MS_1 = 0x1,
                    /// 16KB
                    MS_2 = 0x2,
                    /// 32KB
                    MS_3 = 0x3,
                    /// 64KB
                    MS_4 = 0x4,
                    /// 128KB
                    MS_5 = 0x5,
                    /// 256KB
                    MS_6 = 0x6,
                    /// 512KB
                    MS_7 = 0x7,
                    /// 1MB
                    MS_8 = 0x8,
                    /// 2MB
                    MS_9 = 0x9,
                    /// 4MB
                    MS_10 = 0xa,
                    /// 8MB
                    MS_11 = 0xb,
                    /// 16MB
                    MS_12 = 0xc,
                    /// 32MB
                    MS_13 = 0xd,
                    /// 64MB
                    MS_14 = 0xe,
                    /// 128MB
                    MS_15 = 0xf,
                    /// 256MB
                    MS_16 = 0x10,
                    /// 512MB
                    MS_17 = 0x11,
                    /// 1GB
                    MS_18 = 0x12,
                    /// 2GB
                    MS_19 = 0x13,
                    /// 4GB
                    MS_20 = 0x14,
                    /// 4GB
                    MS_21 = 0x15,
                    /// 4GB
                    MS_22 = 0x16,
                    /// 4GB
                    MS_23 = 0x17,
                    /// 4GB
                    MS_24 = 0x18,
                    /// 4GB
                    MS_25 = 0x19,
                    /// 4GB
                    MS_26 = 0x1a,
                    /// 4GB
                    MS_27 = 0x1b,
                    /// 4GB
                    MS_28 = 0x1c,
                    /// 4GB
                    MS_29 = 0x1d,
                    /// 4GB
                    MS_30 = 0x1e,
                    /// 4GB
                    MS_31 = 0x1f,
                },
                reserved12: u6 = 0,
                /// Base Address
                BA: u20,
            }),
            /// Base Register 8 (For NAND device)
            BR8: mmio.Mmio(packed struct(u32) {
                /// Valid
                VLD: u1,
                /// Memory size
                MS: enum(u5) {
                    /// 4KB
                    MS_0 = 0x0,
                    /// 8KB
                    MS_1 = 0x1,
                    /// 16KB
                    MS_2 = 0x2,
                    /// 32KB
                    MS_3 = 0x3,
                    /// 64KB
                    MS_4 = 0x4,
                    /// 128KB
                    MS_5 = 0x5,
                    /// 256KB
                    MS_6 = 0x6,
                    /// 512KB
                    MS_7 = 0x7,
                    /// 1MB
                    MS_8 = 0x8,
                    /// 2MB
                    MS_9 = 0x9,
                    /// 4MB
                    MS_10 = 0xa,
                    /// 8MB
                    MS_11 = 0xb,
                    /// 16MB
                    MS_12 = 0xc,
                    /// 32MB
                    MS_13 = 0xd,
                    /// 64MB
                    MS_14 = 0xe,
                    /// 128MB
                    MS_15 = 0xf,
                    /// 256MB
                    MS_16 = 0x10,
                    /// 512MB
                    MS_17 = 0x11,
                    /// 1GB
                    MS_18 = 0x12,
                    /// 2GB
                    MS_19 = 0x13,
                    /// 4GB
                    MS_20 = 0x14,
                    /// 4GB
                    MS_21 = 0x15,
                    /// 4GB
                    MS_22 = 0x16,
                    /// 4GB
                    MS_23 = 0x17,
                    /// 4GB
                    MS_24 = 0x18,
                    /// 4GB
                    MS_25 = 0x19,
                    /// 4GB
                    MS_26 = 0x1a,
                    /// 4GB
                    MS_27 = 0x1b,
                    /// 4GB
                    MS_28 = 0x1c,
                    /// 4GB
                    MS_29 = 0x1d,
                    /// 4GB
                    MS_30 = 0x1e,
                    /// 4GB
                    MS_31 = 0x1f,
                },
                reserved12: u6 = 0,
                /// Base Address
                BA: u20,
            }),
            /// DLL Control Register
            DLLCR: mmio.Mmio(packed struct(u32) {
                /// DLL calibration enable.
                DLLEN: u1,
                /// Software could force a reset on DLL by setting this field to 0x1. This will cause the DLL to lose lock and re-calibrate to detect an ref_clock half period phase shift. The reset action is edge triggered, so software need to clear this bit after set this bit (no delay limitation).
                DLLRESET: u1,
                reserved3: u1 = 0,
                /// The delay target for slave delay line is: ((SLVDLYTARGET+1) * 1/32 * clock cycle of reference clock (ipgclock).
                SLVDLYTARGET: u4,
                reserved8: u1 = 0,
                /// Slave clock delay line delay cell number selection override enable.
                OVRDEN: u1,
                /// Slave clock delay line delay cell number selection override value.
                OVRDVAL: u6,
                padding: u17 = 0,
            }),
            /// Interrupt Enable Register
            INTEN: mmio.Mmio(packed struct(u32) {
                /// IP command done interrupt enable
                IPCMDDONEEN: u1,
                /// IP command error interrupt enable
                IPCMDERREN: u1,
                /// AXI command error interrupt enable
                AXICMDERREN: u1,
                /// AXI bus error interrupt enable
                AXIBUSERREN: u1,
                /// This bit enable/disable the NDPAGEEND interrupt generation.
                NDPAGEENDEN: enum(u1) {
                    /// Disable
                    NDPAGEENDEN_0 = 0x0,
                    /// Enable
                    NDPAGEENDEN_1 = 0x1,
                },
                /// This bit enable/disable the NDNOPEND interrupt generation.
                NDNOPENDEN: enum(u1) {
                    /// Disable
                    NDNOPENDEN_0 = 0x0,
                    /// Enable
                    NDNOPENDEN_1 = 0x1,
                },
                padding: u26 = 0,
            }),
            /// Interrupt Enable Register
            INTR: mmio.Mmio(packed struct(u32) {
                /// IP command normal done interrupt
                IPCMDDONE: u1,
                /// IP command error done interrupt
                IPCMDERR: u1,
                /// AXI command error interrupt
                AXICMDERR: u1,
                /// AXI bus error interrupt
                AXIBUSERR: u1,
                /// This interrupt is generated when the last address of one page in NAND device is written by AXI command
                NDPAGEEND: u1,
                /// This interrupt is generated when all pending AXI write command to NAND is finished on NAND interface.
                NDNOPEND: u1,
                padding: u26 = 0,
            }),
            /// SDRAM control register 0
            SDRAMCR0: mmio.Mmio(packed struct(u32) {
                /// Port Size
                PS: enum(u1) {
                    /// 8bit
                    PS_0 = 0x0,
                    /// 16bit
                    PS_1 = 0x1,
                },
                reserved4: u3 = 0,
                /// Burst Length
                BL: enum(u3) {
                    /// 1
                    BL_0 = 0x0,
                    /// 2
                    BL_1 = 0x1,
                    /// 4
                    BL_2 = 0x2,
                    /// 8
                    BL_3 = 0x3,
                    /// 8
                    BL_4 = 0x4,
                    /// 8
                    BL_5 = 0x5,
                    /// 8
                    BL_6 = 0x6,
                    /// 8
                    BL_7 = 0x7,
                },
                /// Column 8 selection bit
                COL8: enum(u1) {
                    /// Column address bit number is decided by COL field.
                    COL8_0 = 0x0,
                    /// Column address bit number is 8. COL field is ignored.
                    COL8_1 = 0x1,
                },
                /// Column address bit number
                COL: enum(u2) {
                    /// 12 bit
                    COL_0 = 0x0,
                    /// 11 bit
                    COL_1 = 0x1,
                    /// 10 bit
                    COL_2 = 0x2,
                    /// 9 bit
                    COL_3 = 0x3,
                },
                /// CAS Latency
                CL: enum(u2) {
                    /// 1
                    CL_0 = 0x0,
                    /// 1
                    CL_1 = 0x1,
                    /// 2
                    CL_2 = 0x2,
                    /// 3
                    CL_3 = 0x3,
                },
                reserved14: u2 = 0,
                /// 2 Bank selection bit
                BANK2: enum(u1) {
                    /// SDRAM device has 4 banks.
                    BANK2_0 = 0x0,
                    /// SDRAM device has 2 banks.
                    BANK2_1 = 0x1,
                },
                padding: u17 = 0,
            }),
            /// SDRAM control register 1
            SDRAMCR1: mmio.Mmio(packed struct(u32) {
                /// PRECHARGE to ACT/Refresh wait time
                PRE2ACT: u4,
                /// ACT to Read/Write wait time
                ACT2RW: u4,
                /// Refresh recovery time
                RFRC: u5,
                /// Write recovery time
                WRC: u3,
                /// CKE OFF minimum time
                CKEOFF: u4,
                /// ACT to Precharge minimum time
                ACT2PRE: u4,
                padding: u8 = 0,
            }),
            /// SDRAM control register 2
            SDRAMCR2: mmio.Mmio(packed struct(u32) {
                /// Self Refresh Recovery time
                SRRC: u8,
                /// Refresh to Refresh wait time
                REF2REF: u8,
                /// ACT to ACT wait time
                ACT2ACT: u8,
                /// SDRAM Idle timeout
                ITO: enum(u8) {
                    /// IDLE timeout period is 256*Prescale period.
                    ITO_0 = 0x0,
                    /// IDLE timeout period is ITO*Prescale period.
                    ITO_1 = 0x1,
                    /// IDLE timeout period is ITO*Prescale period.
                    ITO_2 = 0x2,
                    /// IDLE timeout period is ITO*Prescale period.
                    ITO_3 = 0x3,
                    /// IDLE timeout period is ITO*Prescale period.
                    ITO_4 = 0x4,
                    /// IDLE timeout period is ITO*Prescale period.
                    ITO_5 = 0x5,
                    /// IDLE timeout period is ITO*Prescale period.
                    ITO_6 = 0x6,
                    /// IDLE timeout period is ITO*Prescale period.
                    ITO_7 = 0x7,
                    /// IDLE timeout period is ITO*Prescale period.
                    ITO_8 = 0x8,
                    /// IDLE timeout period is ITO*Prescale period.
                    ITO_9 = 0x9,
                    _,
                },
            }),
            /// SDRAM control register 3
            SDRAMCR3: mmio.Mmio(packed struct(u32) {
                /// Refresh enable
                REN: u1,
                /// Refresh burst length
                REBL: enum(u3) {
                    /// 1
                    REBL_0 = 0x0,
                    /// 2
                    REBL_1 = 0x1,
                    /// 3
                    REBL_2 = 0x2,
                    /// 4
                    REBL_3 = 0x3,
                    /// 5
                    REBL_4 = 0x4,
                    /// 6
                    REBL_5 = 0x5,
                    /// 7
                    REBL_6 = 0x6,
                    /// 8
                    REBL_7 = 0x7,
                },
                reserved8: u4 = 0,
                /// Prescaler timer period
                PRESCALE: enum(u8) {
                    /// 256*16 cycle
                    PRESCALE_0 = 0x0,
                    /// PRESCALE*16 cycle
                    PRESCALE_1 = 0x1,
                    /// PRESCALE*16 cycle
                    PRESCALE_2 = 0x2,
                    /// PRESCALE*16 cycle
                    PRESCALE_3 = 0x3,
                    /// PRESCALE*16 cycle
                    PRESCALE_4 = 0x4,
                    /// PRESCALE*16 cycle
                    PRESCALE_5 = 0x5,
                    /// PRESCALE*16 cycle
                    PRESCALE_6 = 0x6,
                    /// PRESCALE*16 cycle
                    PRESCALE_7 = 0x7,
                    /// PRESCALE*16 cycle
                    PRESCALE_8 = 0x8,
                    /// PRESCALE*16 cycle
                    PRESCALE_9 = 0x9,
                    _,
                },
                /// Refresh timer period
                RT: enum(u8) {
                    /// 256*Prescaler period
                    RT_0 = 0x0,
                    /// RT*Prescaler period
                    RT_1 = 0x1,
                    /// RT*Prescaler period
                    RT_2 = 0x2,
                    /// RT*Prescaler period
                    RT_3 = 0x3,
                    /// RT*Prescaler period
                    RT_4 = 0x4,
                    /// RT*Prescaler period
                    RT_5 = 0x5,
                    /// RT*Prescaler period
                    RT_6 = 0x6,
                    /// RT*Prescaler period
                    RT_7 = 0x7,
                    /// RT*Prescaler period
                    RT_8 = 0x8,
                    /// RT*Prescaler period
                    RT_9 = 0x9,
                    _,
                },
                /// Refresh urgent threshold
                UT: enum(u8) {
                    /// 256*Prescaler period
                    UT_0 = 0x0,
                    /// UT*Prescaler period
                    UT_1 = 0x1,
                    /// UT*Prescaler period
                    UT_2 = 0x2,
                    /// UT*Prescaler period
                    UT_3 = 0x3,
                    /// UT*Prescaler period
                    UT_4 = 0x4,
                    /// UT*Prescaler period
                    UT_5 = 0x5,
                    /// UT*Prescaler period
                    UT_6 = 0x6,
                    /// UT*Prescaler period
                    UT_7 = 0x7,
                    /// UT*Prescaler period
                    UT_8 = 0x8,
                    /// UT*Prescaler period
                    UT_9 = 0x9,
                    _,
                },
            }),
            /// NAND control register 0
            NANDCR0: mmio.Mmio(packed struct(u32) {
                /// Port Size
                PS: enum(u1) {
                    /// 8bit
                    PS_0 = 0x0,
                    /// 16bit
                    PS_1 = 0x1,
                },
                /// Select NAND controller mode.
                SYNCEN: enum(u1) {
                    /// Asynchronous mode is enabled.
                    SYNCEN_0 = 0x0,
                    /// Synchronous mode is enabled.
                    SYNCEN_1 = 0x1,
                },
                reserved4: u2 = 0,
                /// Burst Length
                BL: enum(u3) {
                    /// 1
                    BL_0 = 0x0,
                    /// 2
                    BL_1 = 0x1,
                    /// 4
                    BL_2 = 0x2,
                    /// 8
                    BL_3 = 0x3,
                    /// 16
                    BL_4 = 0x4,
                    /// 32
                    BL_5 = 0x5,
                    /// 64
                    BL_6 = 0x6,
                    /// 64
                    BL_7 = 0x7,
                },
                /// EDO mode enabled
                EDO: enum(u1) {
                    /// EDO mode disabled
                    EDO_0 = 0x0,
                    /// EDO mode enabled
                    EDO_1 = 0x1,
                },
                /// Column address bit number
                COL: enum(u3) {
                    /// 16
                    COL_0 = 0x0,
                    /// 15
                    COL_1 = 0x1,
                    /// 14
                    COL_2 = 0x2,
                    /// 13
                    COL_3 = 0x3,
                    /// 12
                    COL_4 = 0x4,
                    /// 11
                    COL_5 = 0x5,
                    /// 10
                    COL_6 = 0x6,
                    /// 9
                    COL_7 = 0x7,
                },
                padding: u21 = 0,
            }),
            /// NAND control register 1
            NANDCR1: mmio.Mmio(packed struct(u32) {
                /// CE setup time
                CES: u4,
                /// CE hold time
                CEH: u4,
                /// WE# LOW time
                WEL: u4,
                /// WE# HIGH time
                WEH: u4,
                /// RE# LOW time
                REL: u4,
                /// RE# HIGH time
                REH: u4,
                /// Turnaround time
                TA: u4,
                /// CE# interval time
                CEITV: u4,
            }),
            /// NAND control register 2
            NANDCR2: mmio.Mmio(packed struct(u32) {
                /// WE# HIGH to RE# LOW wait time
                TWHR: u6,
                /// RE# HIGH to WE# LOW wait time
                TRHW: u6,
                /// ALE to WRITE Data start wait time
                TADL: u6,
                /// Ready to RE# LOW min wait time
                TRR: u6,
                /// WE# HIGH to busy wait time
                TWB: u6,
                padding: u2 = 0,
            }),
            /// NAND control register 3
            NANDCR3: mmio.Mmio(packed struct(u32) {
                /// NAND option bit 1
                NDOPT1: u1,
                /// NAND option bit 2
                NDOPT2: u1,
                /// NAND option bit 3
                NDOPT3: u1,
                /// NAND CLE Option
                CLE: u1,
                reserved16: u12 = 0,
                /// Read Data Setup cycle time.
                RDS: u4,
                /// Read Data Hold cycle time.
                RDH: u4,
                /// Write Data Setup cycle time.
                WDS: u4,
                /// Write Data Hold cycle time.
                WDH: u4,
            }),
            /// NOR control register 0
            NORCR0: mmio.Mmio(packed struct(u32) {
                /// Port Size
                PS: enum(u1) {
                    /// 8bit
                    PS_0 = 0x0,
                    /// 16bit
                    PS_1 = 0x1,
                },
                /// Select NOR controller mode.
                SYNCEN: enum(u1) {
                    /// Asynchronous mode is enabled.
                    SYNCEN_0 = 0x0,
                    /// Synchronous mode is enabled.
                    SYNCEN_1 = 0x1,
                },
                reserved4: u2 = 0,
                /// Burst Length
                BL: enum(u3) {
                    /// 1
                    BL_0 = 0x0,
                    /// 2
                    BL_1 = 0x1,
                    /// 4
                    BL_2 = 0x2,
                    /// 8
                    BL_3 = 0x3,
                    /// 16
                    BL_4 = 0x4,
                    /// 32
                    BL_5 = 0x5,
                    /// 64
                    BL_6 = 0x6,
                    /// 64
                    BL_7 = 0x7,
                },
                reserved8: u1 = 0,
                /// Address Mode
                AM: enum(u2) {
                    /// Address/Data MUX mode
                    AM_0 = 0x0,
                    /// Advanced Address/Data MUX mode
                    AM_1 = 0x1,
                    /// Address/Data non-MUX mode
                    AM_2 = 0x2,
                    /// Address/Data non-MUX mode
                    AM_3 = 0x3,
                },
                /// ADV# polarity
                ADVP: enum(u1) {
                    /// ADV# is Low Active. In ASYNC mode, device sample address with ADV# rise edge; In SYNC mode, device sample address when ADV# is LOW.
                    ADVP_0 = 0x0,
                    /// ADV# is High Active. In ASYNC mode, device sample address with ADV# fall edge; In SYNC mode, device sample address when ADV# is HIGH.
                    ADVP_1 = 0x1,
                },
                /// ADV# level control during address hold state
                ADVH: enum(u1) {
                    /// ADV# is high during address hold state.
                    ADVH_0 = 0x0,
                    /// ADV# is low during address hold state.
                    ADVH_1 = 0x1,
                },
                /// Column Address bit width
                COL: enum(u4) {
                    /// 12 Bits
                    COL_0 = 0x0,
                    /// 11 Bits
                    COL_1 = 0x1,
                    /// 10 Bits
                    COL_2 = 0x2,
                    /// 9 Bits
                    COL_3 = 0x3,
                    /// 8 Bits
                    COL_4 = 0x4,
                    /// 7 Bits
                    COL_5 = 0x5,
                    /// 6 Bits
                    COL_6 = 0x6,
                    /// 5 Bits
                    COL_7 = 0x7,
                    /// 4 Bits
                    COL_8 = 0x8,
                    /// 3 Bits
                    COL_9 = 0x9,
                    /// 2 Bits
                    COL_10 = 0xa,
                    /// 12 Bits
                    COL_11 = 0xb,
                    /// 12 Bits
                    COL_12 = 0xc,
                    /// 12 Bits
                    COL_13 = 0xd,
                    /// 12 Bits
                    COL_14 = 0xe,
                    /// 12 Bits
                    COL_15 = 0xf,
                },
                padding: u16 = 0,
            }),
            /// NOR control register 1
            NORCR1: mmio.Mmio(packed struct(u32) {
                /// CE setup time cycle
                CES: u4,
                /// CE hold min time (CEH+1) cycle
                CEH: u4,
                /// Address setup time
                AS: u4,
                /// Address hold time
                AH: u4,
                /// WE LOW time (WEL+1) cycle
                WEL: u4,
                /// WE HIGH time (WEH+1) cycle
                WEH: u4,
                /// RE LOW time (REL+1) cycle
                REL: u4,
                /// RE HIGH time (REH+1) cycle
                REH: u4,
            }),
            /// NOR control register 2
            NORCR2: mmio.Mmio(packed struct(u32) {
                reserved8: u8 = 0,
                /// Turnaround time cycle
                TA: u4,
                /// Address to write data hold time cycle
                AWDH: u4,
                /// Latency count
                LC: u4,
                /// Read cycle time
                RD: u4,
                /// CE# interval min time
                CEITV: u4,
                /// Read cycle hold time
                RDH: u4,
            }),
            /// NOR control register 3
            NORCR3: mmio.Mmio(packed struct(u32) {
                /// Address setup time for synchronous read
                ASSR: u4,
                /// Address hold time for synchronous read
                AHSR: u4,
                padding: u24 = 0,
            }),
            /// SRAM control register 0
            SRAMCR0: mmio.Mmio(packed struct(u32) {
                /// Port Size
                PS: enum(u1) {
                    /// 8bit
                    PS_0 = 0x0,
                    /// 16bit
                    PS_1 = 0x1,
                },
                /// Select SRAM controller mode.
                SYNCEN: enum(u1) {
                    /// Asynchronous mode is enabled.
                    SYNCEN_0 = 0x0,
                    /// Synchronous mode is enabled.
                    SYNCEN_1 = 0x1,
                },
                reserved4: u2 = 0,
                /// Burst Length
                BL: enum(u3) {
                    /// 1
                    BL_0 = 0x0,
                    /// 2
                    BL_1 = 0x1,
                    /// 4
                    BL_2 = 0x2,
                    /// 8
                    BL_3 = 0x3,
                    /// 16
                    BL_4 = 0x4,
                    /// 32
                    BL_5 = 0x5,
                    /// 64
                    BL_6 = 0x6,
                    /// 64
                    BL_7 = 0x7,
                },
                reserved8: u1 = 0,
                /// Address Mode
                AM: enum(u2) {
                    /// Address/Data MUX mode
                    AM_0 = 0x0,
                    /// Advanced Address/Data MUX mode
                    AM_1 = 0x1,
                    /// Address/Data non-MUX mode
                    AM_2 = 0x2,
                    /// Address/Data non-MUX mode
                    AM_3 = 0x3,
                },
                /// ADV# polarity
                ADVP: enum(u1) {
                    /// ADV# is Low Active. In ASYNC mode, device sample address with ADV# rise edge; In SYNC mode, device sample address when ADV# is LOW.
                    ADVP_0 = 0x0,
                    /// ADV# is High Active. In ASYNC mode, device sample address with ADV# fall edge; In SYNC mode, device sample address when ADV# is HIGH.
                    ADVP_1 = 0x1,
                },
                /// ADV# level control during address hold state
                ADVH: enum(u1) {
                    /// ADV# is high during address hold state.
                    ADVH_0 = 0x0,
                    /// ADV# is low during address hold state.
                    ADVH_1 = 0x1,
                },
                /// Column Address bit width
                COL: enum(u4) {
                    /// 12 Bits
                    COL_0 = 0x0,
                    /// 11 Bits
                    COL_1 = 0x1,
                    /// 10 Bits
                    COL_2 = 0x2,
                    /// 9 Bits
                    COL_3 = 0x3,
                    /// 8 Bits
                    COL_4 = 0x4,
                    /// 7 Bits
                    COL_5 = 0x5,
                    /// 6 Bits
                    COL_6 = 0x6,
                    /// 5 Bits
                    COL_7 = 0x7,
                    /// 4 Bits
                    COL_8 = 0x8,
                    /// 3 Bits
                    COL_9 = 0x9,
                    /// 2 Bits
                    COL_10 = 0xa,
                    /// 12 Bits
                    COL_11 = 0xb,
                    /// 12 Bits
                    COL_12 = 0xc,
                    /// 12 Bits
                    COL_13 = 0xd,
                    /// 12 Bits
                    COL_14 = 0xe,
                    /// 12 Bits
                    COL_15 = 0xf,
                },
                padding: u16 = 0,
            }),
            /// SRAM control register 1
            SRAMCR1: mmio.Mmio(packed struct(u32) {
                /// CE setup time cycle
                CES: u4,
                /// CE hold min time
                CEH: u4,
                /// Address setup time
                AS: u4,
                /// Address hold time
                AH: u4,
                /// WE LOW time (WEL+1) cycle
                WEL: u4,
                /// WE HIGH time (WEH+1) cycle
                WEH: u4,
                /// RE LOW time (REL+1) cycle
                REL: u4,
                /// RE HIGH time (REH+1) cycle
                REH: u4,
            }),
            /// SRAM control register 2
            SRAMCR2: mmio.Mmio(packed struct(u32) {
                /// Write Data setup time (WDS+1) cycle
                WDS: u4,
                /// Write Data hold time WDH cycle
                WDH: u4,
                /// Turnaround time cycle
                TA: u4,
                /// Address to write data hold time cycle
                AWDH: u4,
                /// Latency count
                LC: u4,
                /// Read cycle time
                RD: u4,
                /// CE# interval min time
                CEITV: u4,
                /// Read cycle hold time
                RDH: u4,
            }),
            /// SRAM control register 3
            SRAMCR3: u32,
            /// DBI-B control register 0
            DBICR0: mmio.Mmio(packed struct(u32) {
                /// Port Size
                PS: enum(u1) {
                    /// 8bit
                    PS_0 = 0x0,
                    /// 16bit
                    PS_1 = 0x1,
                },
                reserved4: u3 = 0,
                /// Burst Length
                BL: enum(u3) {
                    /// 1
                    BL_0 = 0x0,
                    /// 2
                    BL_1 = 0x1,
                    /// 4
                    BL_2 = 0x2,
                    /// 8
                    BL_3 = 0x3,
                    /// 16
                    BL_4 = 0x4,
                    /// 32
                    BL_5 = 0x5,
                    /// 64
                    BL_6 = 0x6,
                    /// 64
                    BL_7 = 0x7,
                },
                reserved12: u5 = 0,
                /// Column Address bit width
                COL: enum(u4) {
                    /// 12 Bits
                    COL_0 = 0x0,
                    /// 11 Bits
                    COL_1 = 0x1,
                    /// 10 Bits
                    COL_2 = 0x2,
                    /// 9 Bits
                    COL_3 = 0x3,
                    /// 8 Bits
                    COL_4 = 0x4,
                    /// 7 Bits
                    COL_5 = 0x5,
                    /// 6 Bits
                    COL_6 = 0x6,
                    /// 5 Bits
                    COL_7 = 0x7,
                    /// 4 Bits
                    COL_8 = 0x8,
                    /// 3 Bits
                    COL_9 = 0x9,
                    /// 2 Bits
                    COL_10 = 0xa,
                    /// 12 Bits
                    COL_11 = 0xb,
                    /// 12 Bits
                    COL_12 = 0xc,
                    /// 12 Bits
                    COL_13 = 0xd,
                    /// 12 Bits
                    COL_14 = 0xe,
                    /// 12 Bits
                    COL_15 = 0xf,
                },
                padding: u16 = 0,
            }),
            /// DBI-B control register 1
            DBICR1: mmio.Mmio(packed struct(u32) {
                /// CSX Setup Time
                CES: u4,
                /// CSX Hold Time
                CEH: u4,
                /// WRX Low Time
                WEL: u4,
                /// WRX High Time
                WEH: u4,
                /// RDX Low Time
                REL: u6,
                /// RDX High Time
                REH: u6,
                /// CSX interval min time
                CEITV: u4,
            }),
            reserved144: [8]u8,
            /// IP Command control register 0
            IPCR0: mmio.Mmio(packed struct(u32) {
                /// Slave address
                SA: u32,
            }),
            /// IP Command control register 1
            IPCR1: mmio.Mmio(packed struct(u32) {
                /// Data Size in Byte
                DATSZ: enum(u3) {
                    /// 4
                    DATSZ_0 = 0x0,
                    /// 1
                    DATSZ_1 = 0x1,
                    /// 2
                    DATSZ_2 = 0x2,
                    /// 3
                    DATSZ_3 = 0x3,
                    /// 4
                    DATSZ_4 = 0x4,
                    /// 4
                    DATSZ_5 = 0x5,
                    /// 4
                    DATSZ_6 = 0x6,
                    /// 4
                    DATSZ_7 = 0x7,
                },
                reserved8: u5 = 0,
                /// NAND Extended Address
                NAND_EXT_ADDR: u8,
                padding: u16 = 0,
            }),
            /// IP Command control register 2
            IPCR2: mmio.Mmio(packed struct(u32) {
                /// Byte Mask for Byte 0 (IPTXD bit 7:0)
                BM0: enum(u1) {
                    /// Byte Unmasked
                    BM0_0 = 0x0,
                    /// Byte Masked
                    BM0_1 = 0x1,
                },
                /// Byte Mask for Byte 1 (IPTXD bit 15:8)
                BM1: enum(u1) {
                    /// Byte Unmasked
                    BM1_0 = 0x0,
                    /// Byte Masked
                    BM1_1 = 0x1,
                },
                /// Byte Mask for Byte 2 (IPTXD bit 23:16)
                BM2: enum(u1) {
                    /// Byte Unmasked
                    BM2_0 = 0x0,
                    /// Byte Masked
                    BM2_1 = 0x1,
                },
                /// Byte Mask for Byte 3 (IPTXD bit 31:24)
                BM3: enum(u1) {
                    /// Byte Unmasked
                    BM3_0 = 0x0,
                    /// Byte Masked
                    BM3_1 = 0x1,
                },
                padding: u28 = 0,
            }),
            /// IP Command register
            IPCMD: mmio.Mmio(packed struct(u32) {
                /// SDRAM Commands: 0x8: READ 0x9: WRITE 0xA: MODESET 0xB: ACTIVE 0xC: AUTO REFRESH 0xD: SELF REFRESH 0xE: PRECHARGE 0xF: PRECHARGE ALL Others: RSVD SELF REFRESH will be sent to all SDRAM devices because they shared same SEMC_CLK pin
                CMD: u16,
                /// This field should be written with 0xA55A when trigging an IP command for all device types
                KEY: u16,
            }),
            /// TX DATA register (for IP Command)
            IPTXDAT: mmio.Mmio(packed struct(u32) {
                /// no description available
                DAT: u32,
            }),
            reserved176: [12]u8,
            /// RX DATA register (for IP Command)
            IPRXDAT: mmio.Mmio(packed struct(u32) {
                /// no description available
                DAT: u32,
            }),
            reserved192: [12]u8,
            /// Status register 0
            STS0: mmio.Mmio(packed struct(u32) {
                /// Indicating whether SEMC is in IDLE state.
                IDLE: u1,
                /// Indicating NAND device Ready/WAIT# pin level.
                NARDY: enum(u1) {
                    /// NAND device is not ready
                    NARDY_0 = 0x0,
                    /// NAND device is ready
                    NARDY_1 = 0x1,
                },
                padding: u30 = 0,
            }),
            /// Status register 1
            STS1: u32,
            /// Status register 2
            STS2: mmio.Mmio(packed struct(u32) {
                reserved3: u3 = 0,
                /// This field indicating whether there is pending AXI command (write) to NAND device.
                NDWRPEND: enum(u1) {
                    /// No pending
                    NDWRPEND_0 = 0x0,
                    /// Pending
                    NDWRPEND_1 = 0x1,
                },
                padding: u28 = 0,
            }),
            /// Status register 3
            STS3: u32,
            /// Status register 4
            STS4: u32,
            /// Status register 5
            STS5: u32,
            /// Status register 6
            STS6: u32,
            /// Status register 7
            STS7: u32,
            /// Status register 8
            STS8: u32,
            /// Status register 9
            STS9: u32,
            /// Status register 10
            STS10: u32,
            /// Status register 11
            STS11: u32,
            /// Status register 12
            STS12: mmio.Mmio(packed struct(u32) {
                /// This field indicating the last write address (AXI command) to NAND device (without base address in SEMC_BR4).
                NDADDR: u32,
            }),
            /// Status register 13
            STS13: mmio.Mmio(packed struct(u32) {
                /// Sample clock slave delay line locked.
                SLVLOCK: u1,
                /// Sample clock reference delay line locked.
                REFLOCK: u1,
                /// Sample clock slave delay line delay cell number selection .
                SLVSEL: u6,
                /// Sample clock reference delay line delay cell number selection.
                REFSEL: u6,
                padding: u18 = 0,
            }),
            /// Status register 14
            STS14: u32,
            /// Status register 15
            STS15: u32,
        };

        /// SNVS
        pub const SNVS = extern struct {
            /// SNVS_HP Lock Register
            HPLR: mmio.Mmio(packed struct(u32) {
                /// Zeroizable Master Key Write Soft Lock When set, prevents any writes (software and hardware) to the ZMK registers and the ZMK_HWP, ZMK_VAL, and ZMK_ECC_EN fields of the LPMKCR
                ZMK_WSL: enum(u1) {
                    /// Write access is allowed
                    ZMK_WSL_0 = 0x0,
                    /// Write access is not allowed
                    ZMK_WSL_1 = 0x1,
                },
                /// Zeroizable Master Key Read Soft Lock When set, prevents any software reads to the ZMK Registers and ZMK_ECC_VALUE field of the LPMKCR
                ZMK_RSL: enum(u1) {
                    /// Read access is allowed (only in software Programming mode)
                    ZMK_RSL_0 = 0x0,
                    /// Read access is not allowed
                    ZMK_RSL_1 = 0x1,
                },
                /// Secure Real Time Counter Soft Lock When set, prevents any writes to the SRTC Registers, SRTC_ENV, and SRTC_INV_EN bits
                SRTC_SL: enum(u1) {
                    /// Write access is allowed
                    SRTC_SL_0 = 0x0,
                    /// Write access is not allowed
                    SRTC_SL_1 = 0x1,
                },
                /// LP Calibration Soft Lock When set, prevents any writes to the LP Calibration Value (LPCALB_VAL) and LP Calibration Enable (LPCALB_EN)
                LPCALB_SL: enum(u1) {
                    /// Write access is allowed
                    LPCALB_SL_0 = 0x0,
                    /// Write access is not allowed
                    LPCALB_SL_1 = 0x1,
                },
                /// Monotonic Counter Soft Lock When set, prevents any writes (increments) to the MC Registers and MC_ENV bit
                MC_SL: enum(u1) {
                    /// Write access (increment) is allowed
                    MC_SL_0 = 0x0,
                    /// Write access (increment) is not allowed
                    MC_SL_1 = 0x1,
                },
                /// General Purpose Register Soft Lock When set, prevents any writes to the GPR
                GPR_SL: enum(u1) {
                    /// Write access is allowed
                    GPR_SL_0 = 0x0,
                    /// Write access is not allowed
                    GPR_SL_1 = 0x1,
                },
                /// LP Security Violation Control Register Soft Lock When set, prevents any writes to the LPSVCR
                LPSVCR_SL: enum(u1) {
                    /// Write access is allowed
                    LPSVCR_SL_0 = 0x0,
                    /// Write access is not allowed
                    LPSVCR_SL_1 = 0x1,
                },
                reserved8: u1 = 0,
                /// LP Tamper Detectors Configuration Register Soft Lock When set, prevents any writes to the LPTDCR
                LPTDCR_SL: enum(u1) {
                    /// Write access is allowed
                    LPTDCR_SL_0 = 0x0,
                    /// Write access is not allowed
                    LPTDCR_SL_1 = 0x1,
                },
                /// Master Key Select Soft Lock When set, prevents any writes to the MASTER_KEY_SEL field of the LPMKCR
                MKS_SL: enum(u1) {
                    /// Write access is allowed
                    MKS_SL_0 = 0x0,
                    /// Write access is not allowed
                    MKS_SL_1 = 0x1,
                },
                reserved16: u6 = 0,
                /// HP Security Violation Control Register Lock When set, prevents any writes to the HPSVCR
                HPSVCR_L: enum(u1) {
                    /// Write access is allowed
                    HPSVCR_L_0 = 0x0,
                    /// Write access is not allowed
                    HPSVCR_L_1 = 0x1,
                },
                /// HP Security Interrupt Control Register Lock When set, prevents any writes to the HPSICR
                HPSICR_L: enum(u1) {
                    /// Write access is allowed
                    HPSICR_L_0 = 0x0,
                    /// Write access is not allowed
                    HPSICR_L_1 = 0x1,
                },
                /// High Assurance Counter Lock When set, prevents any writes to HPHACIVR, HPHACR, and HAC_EN bit of HPCOMR
                HAC_L: enum(u1) {
                    /// Write access is allowed
                    HAC_L_0 = 0x0,
                    /// Write access is not allowed
                    HAC_L_1 = 0x1,
                },
                padding: u13 = 0,
            }),
            /// SNVS_HP Command Register
            HPCOMR: mmio.Mmio(packed struct(u32) {
                /// SSM State Transition Transition state of the system security monitor
                SSM_ST: u1,
                /// SSM Secure to Trusted State Transition Disable When set, disables the SSM transition from secure to trusted state
                SSM_ST_DIS: enum(u1) {
                    /// Secure to Trusted State transition is enabled
                    SSM_ST_DIS_0 = 0x0,
                    /// Secure to Trusted State transition is disabled
                    SSM_ST_DIS_1 = 0x1,
                },
                /// SSM Soft Fail to Non-Secure State Transition Disable When set, it disables the SSM transition from soft fail to non-secure state
                SSM_SFNS_DIS: enum(u1) {
                    /// Soft Fail to Non-Secure State transition is enabled
                    SSM_SFNS_DIS_0 = 0x0,
                    /// Soft Fail to Non-Secure State transition is disabled
                    SSM_SFNS_DIS_1 = 0x1,
                },
                reserved4: u1 = 0,
                /// LP Software Reset When set to 1, most registers in the SNVS_LP section are reset, but the following registers are not reset by an LP software reset: Secure Real Time Counter Time Alarm Register This bit cannot be set when the LP_SWR_DIS bit is set
                LP_SWR: enum(u1) {
                    /// No Action
                    LP_SWR_0 = 0x0,
                    /// Reset LP section
                    LP_SWR_1 = 0x1,
                },
                /// LP Software Reset Disable When set, disables the LP software reset
                LP_SWR_DIS: enum(u1) {
                    /// LP software reset is enabled
                    LP_SWR_DIS_0 = 0x0,
                    /// LP software reset is disabled
                    LP_SWR_DIS_1 = 0x1,
                },
                reserved8: u2 = 0,
                /// Software Security Violation When set, the system security monitor treats this bit as a non-fatal security violation
                SW_SV: u1,
                /// Software Fatal Security Violation When set, the system security monitor treats this bit as a fatal security violation
                SW_FSV: u1,
                /// LP Software Security Violation When set, SNVS_LP treats this bit as a security violation
                SW_LPSV: u1,
                reserved12: u1 = 0,
                /// Program Zeroizable Master Key This bit activates ZMK hardware programming mechanism
                PROG_ZMK: enum(u1) {
                    /// No Action
                    PROG_ZMK_0 = 0x0,
                    /// Activate hardware key programming mechanism
                    PROG_ZMK_1 = 0x1,
                },
                /// Master Key Select Enable When not set, the one time programmable (OTP) master key is selected by default
                MKS_EN: enum(u1) {
                    /// OTP master key is selected as an SNVS master key
                    MKS_EN_0 = 0x0,
                    /// SNVS master key is selected according to the setting of the MASTER_KEY_SEL field of LPMKCR
                    MKS_EN_1 = 0x1,
                },
                reserved16: u2 = 0,
                /// High Assurance Counter Enable This bit controls the SSM transition from the soft fail to the hard fail state
                HAC_EN: enum(u1) {
                    /// High Assurance Counter is disabled
                    HAC_EN_0 = 0x0,
                    /// High Assurance Counter is enabled
                    HAC_EN_1 = 0x1,
                },
                /// High Assurance Counter Load When set, it loads the High Assurance Counter Register with the value of the High Assurance Counter Load Register
                HAC_LOAD: enum(u1) {
                    /// No Action
                    HAC_LOAD_0 = 0x0,
                    /// Load the HAC
                    HAC_LOAD_1 = 0x1,
                },
                /// High Assurance Counter Clear When set, it clears the High Assurance Counter Register
                HAC_CLEAR: enum(u1) {
                    /// No Action
                    HAC_CLEAR_0 = 0x0,
                    /// Clear the HAC
                    HAC_CLEAR_1 = 0x1,
                },
                /// High Assurance Counter Stop This bit can be set only when SSM is in soft fail state
                HAC_STOP: u1,
                reserved31: u11 = 0,
                /// Non-Privileged Software Access Enable When set, allows non-privileged software to access all SNVS registers, including those that are privileged software read/write access only
                NPSWA_EN: u1,
            }),
            /// SNVS_HP Control Register
            HPCR: mmio.Mmio(packed struct(u32) {
                /// HP Real Time Counter Enable
                RTC_EN: enum(u1) {
                    /// RTC is disabled
                    RTC_EN_0 = 0x0,
                    /// RTC is enabled
                    RTC_EN_1 = 0x1,
                },
                /// HP Time Alarm Enable When set, the time alarm interrupt is generated if the value in the HP Time Alarm Registers is equal to the value of the HP Real Time Counter
                HPTA_EN: enum(u1) {
                    /// HP Time Alarm Interrupt is disabled
                    HPTA_EN_0 = 0x0,
                    /// HP Time Alarm Interrupt is enabled
                    HPTA_EN_1 = 0x1,
                },
                /// Disable periodic interrupt in the functional interrupt
                DIS_PI: enum(u1) {
                    /// Periodic interrupt will trigger a functional interrupt
                    DIS_PI_0 = 0x0,
                    /// Disable periodic interrupt in the function interrupt
                    DIS_PI_1 = 0x1,
                },
                /// HP Periodic Interrupt Enable The periodic interrupt can be generated only if the HP Real Time Counter is enabled
                PI_EN: enum(u1) {
                    /// HP Periodic Interrupt is disabled
                    PI_EN_0 = 0x0,
                    /// HP Periodic Interrupt is enabled
                    PI_EN_1 = 0x1,
                },
                /// Periodic Interrupt Frequency Defines frequency of the periodic interrupt
                PI_FREQ: enum(u4) {
                    /// - bit 0 of the HPRTCLR is selected as a source of the periodic interrupt
                    PI_FREQ_0 = 0x0,
                    /// - bit 1 of the HPRTCLR is selected as a source of the periodic interrupt
                    PI_FREQ_1 = 0x1,
                    /// - bit 2 of the HPRTCLR is selected as a source of the periodic interrupt
                    PI_FREQ_2 = 0x2,
                    /// - bit 3 of the HPRTCLR is selected as a source of the periodic interrupt
                    PI_FREQ_3 = 0x3,
                    /// - bit 4 of the HPRTCLR is selected as a source of the periodic interrupt
                    PI_FREQ_4 = 0x4,
                    /// - bit 5 of the HPRTCLR is selected as a source of the periodic interrupt
                    PI_FREQ_5 = 0x5,
                    /// - bit 6 of the HPRTCLR is selected as a source of the periodic interrupt
                    PI_FREQ_6 = 0x6,
                    /// - bit 7 of the HPRTCLR is selected as a source of the periodic interrupt
                    PI_FREQ_7 = 0x7,
                    /// - bit 8 of the HPRTCLR is selected as a source of the periodic interrupt
                    PI_FREQ_8 = 0x8,
                    /// - bit 9 of the HPRTCLR is selected as a source of the periodic interrupt
                    PI_FREQ_9 = 0x9,
                    /// - bit 10 of the HPRTCLR is selected as a source of the periodic interrupt
                    PI_FREQ_10 = 0xa,
                    /// - bit 11 of the HPRTCLR is selected as a source of the periodic interrupt
                    PI_FREQ_11 = 0xb,
                    /// - bit 12 of the HPRTCLR is selected as a source of the periodic interrupt
                    PI_FREQ_12 = 0xc,
                    /// - bit 13 of the HPRTCLR is selected as a source of the periodic interrupt
                    PI_FREQ_13 = 0xd,
                    /// - bit 14 of the HPRTCLR is selected as a source of the periodic interrupt
                    PI_FREQ_14 = 0xe,
                    /// - bit 15 of the HPRTCLR is selected as a source of the periodic interrupt
                    PI_FREQ_15 = 0xf,
                },
                /// HP Real Time Counter Calibration Enabled Indicates that the time calibration mechanism is enabled.
                HPCALB_EN: enum(u1) {
                    /// HP Timer calibration disabled
                    HPCALB_EN_0 = 0x0,
                    /// HP Timer calibration enabled
                    HPCALB_EN_1 = 0x1,
                },
                reserved10: u1 = 0,
                /// HP Calibration Value Defines signed calibration value for the HP Real Time Counter
                HPCALB_VAL: enum(u5) {
                    /// +0 counts per each 32768 ticks of the counter
                    HPCALB_VAL_0 = 0x0,
                    /// +1 counts per each 32768 ticks of the counter
                    HPCALB_VAL_1 = 0x1,
                    /// +2 counts per each 32768 ticks of the counter
                    HPCALB_VAL_2 = 0x2,
                    /// +15 counts per each 32768 ticks of the counter
                    HPCALB_VAL_15 = 0xf,
                    /// -16 counts per each 32768 ticks of the counter
                    HPCALB_VAL_16 = 0x10,
                    /// -15 counts per each 32768 ticks of the counter
                    HPCALB_VAL_17 = 0x11,
                    /// -2 counts per each 32768 ticks of the counter
                    HPCALB_VAL_30 = 0x1e,
                    /// -1 counts per each 32768 ticks of the counter
                    HPCALB_VAL_31 = 0x1f,
                    _,
                },
                reserved16: u1 = 0,
                /// HP Time Synchronize
                HP_TS: enum(u1) {
                    /// No Action
                    HP_TS_0 = 0x0,
                    /// Synchronize the HP Time Counter to the LP Time Counter
                    HP_TS_1 = 0x1,
                },
                reserved24: u7 = 0,
                /// Button Configuration
                BTN_CONFIG: u3,
                /// Button interrupt mask
                BTN_MASK: u1,
                padding: u4 = 0,
            }),
            /// SNVS_HP Security Interrupt Control Register
            HPSICR: mmio.Mmio(packed struct(u32) {
                /// Security Violation 0 Interrupt Enable Setting this bit to 1 enables generation of the security interrupt to the host processor upon detection of the Security Violation 0 security violation
                SV0_EN: enum(u1) {
                    /// Security Violation 0 Interrupt is Disabled
                    SV0_EN_0 = 0x0,
                    /// Security Violation 0 Interrupt is Enabled
                    SV0_EN_1 = 0x1,
                },
                /// Security Violation 1 Interrupt Enable Setting this bit to 1 enables generation of the security interrupt to the host processor upon detection of the Security Violation 1 security violation
                SV1_EN: enum(u1) {
                    /// Security Violation 1 Interrupt is Disabled
                    SV1_EN_0 = 0x0,
                    /// Security Violation 1 Interrupt is Enabled
                    SV1_EN_1 = 0x1,
                },
                /// Security Violation 2 Interrupt Enable Setting this bit to 1 enables generation of the security interrupt to the host processor upon detection of the Security Violation 2 security violation
                SV2_EN: enum(u1) {
                    /// Security Violation 2 Interrupt is Disabled
                    SV2_EN_0 = 0x0,
                    /// Security Violation 2 Interrupt is Enabled
                    SV2_EN_1 = 0x1,
                },
                /// Security Violation 3 Interrupt Enable Setting this bit to 1 enables generation of the security interrupt to the host processor upon detection of the Security Violation 3 security violation
                SV3_EN: enum(u1) {
                    /// Security Violation 3 Interrupt is Disabled
                    SV3_EN_0 = 0x0,
                    /// Security Violation 3 Interrupt is Enabled
                    SV3_EN_1 = 0x1,
                },
                /// Security Violation 4 Interrupt Enable Setting this bit to 1 enables generation of the security interrupt to the host processor upon detection of the Security Violation 4 security violation
                SV4_EN: enum(u1) {
                    /// Security Violation 4 Interrupt is Disabled
                    SV4_EN_0 = 0x0,
                    /// Security Violation 4 Interrupt is Enabled
                    SV4_EN_1 = 0x1,
                },
                /// Security Violation 5 Interrupt Enable Setting this bit to 1 enables generation of the security interrupt to the host processor upon detection of the Security Violation 5 security violation
                SV5_EN: enum(u1) {
                    /// Security Violation 5 Interrupt is Disabled
                    SV5_EN_0 = 0x0,
                    /// Security Violation 5 Interrupt is Enabled
                    SV5_EN_1 = 0x1,
                },
                reserved31: u25 = 0,
                /// LP Security Violation Interrupt Enable This bit enables generating of the security interrupt to the host processor upon security violation signal from the LP section
                LPSVI_EN: enum(u1) {
                    /// LP Security Violation Interrupt is Disabled
                    LPSVI_EN_0 = 0x0,
                    /// LP Security Violation Interrupt is Enabled
                    LPSVI_EN_1 = 0x1,
                },
            }),
            /// SNVS_HP Security Violation Control Register
            HPSVCR: mmio.Mmio(packed struct(u32) {
                /// Security Violation 0 Security Violation Configuration This field configures the Security Violation 0 Security Violation Input
                SV0_CFG: enum(u1) {
                    /// Security Violation 0 is a non-fatal violation
                    SV0_CFG_0 = 0x0,
                    /// Security Violation 0 is a fatal violation
                    SV0_CFG_1 = 0x1,
                },
                /// Security Violation 1 Security Violation Configuration This field configures the Security Violation 1 Security Violation Input
                SV1_CFG: enum(u1) {
                    /// Security Violation 1 is a non-fatal violation
                    SV1_CFG_0 = 0x0,
                    /// Security Violation 1 is a fatal violation
                    SV1_CFG_1 = 0x1,
                },
                /// Security Violation 2 Security Violation Configuration This field configures the Security Violation 2 Security Violation Input
                SV2_CFG: enum(u1) {
                    /// Security Violation 2 is a non-fatal violation
                    SV2_CFG_0 = 0x0,
                    /// Security Violation 2 is a fatal violation
                    SV2_CFG_1 = 0x1,
                },
                /// Security Violation 3 Security Violation Configuration This field configures the Security Violation 3 Security Violation Input
                SV3_CFG: enum(u1) {
                    /// Security Violation 3 is a non-fatal violation
                    SV3_CFG_0 = 0x0,
                    /// Security Violation 3 is a fatal violation
                    SV3_CFG_1 = 0x1,
                },
                /// Security Violation 4 Security Violation Configuration This field configures the Security Violation 4 Security Violation Input
                SV4_CFG: enum(u1) {
                    /// Security Violation 4 is a non-fatal violation
                    SV4_CFG_0 = 0x0,
                    /// Security Violation 4 is a fatal violation
                    SV4_CFG_1 = 0x1,
                },
                padding: u27 = 0,
            }),
            /// SNVS_HP Status Register
            HPSR: mmio.Mmio(packed struct(u32) {
                /// HP Time Alarm Indicates that the HP Time Alarm has occurred since this bit was last cleared.
                HPTA: enum(u1) {
                    /// No time alarm interrupt occurred.
                    HPTA_0 = 0x0,
                    /// A time alarm interrupt occurred.
                    HPTA_1 = 0x1,
                },
                /// Periodic Interrupt Indicates that periodic interrupt has occurred since this bit was last cleared.
                PI: enum(u1) {
                    /// No periodic interrupt occurred.
                    PI_0 = 0x0,
                    /// A periodic interrupt occurred.
                    PI_1 = 0x1,
                },
                reserved4: u2 = 0,
                /// Low Power Disable If 1, the low power section has been disabled by means of an input signal to SNVS
                LPDIS: u1,
                reserved6: u1 = 0,
                /// Button Value of the BTN input
                BTN: u1,
                /// Button Interrupt Signal ipi_snvs_btn_int_b was asserted.
                BI: u1,
                /// System Security Monitor State This field contains the encoded state of the SSM's state machine
                SSM_STATE: enum(u4) {
                    /// Init
                    SSM_STATE_0 = 0x0,
                    /// Hard Fail
                    SSM_STATE_1 = 0x1,
                    /// Soft Fail
                    SSM_STATE_3 = 0x3,
                    /// Init Intermediate (transition state between Init and Check - SSM stays in this state only one clock cycle)
                    SSM_STATE_8 = 0x8,
                    /// Check
                    SSM_STATE_9 = 0x9,
                    /// Non-Secure
                    SSM_STATE_11 = 0xb,
                    /// Trusted
                    SSM_STATE_13 = 0xd,
                    /// Secure
                    SSM_STATE_15 = 0xf,
                    _,
                },
                reserved16: u4 = 0,
                /// One Time Programmable Master Key Syndrome In the case of a single-bit error, the eight lower bits of this value indicate the bit number of error location
                OTPMK_SYNDROME: u9,
                reserved27: u2 = 0,
                /// One Time Programmable Master Key is Equal to Zero
                OTPMK_ZERO: enum(u1) {
                    /// The OTPMK is not zero.
                    OTPMK_ZERO_0 = 0x0,
                    /// The OTPMK is zero.
                    OTPMK_ZERO_1 = 0x1,
                },
                reserved31: u3 = 0,
                /// Zeroizable Master Key is Equal to Zero
                ZMK_ZERO: enum(u1) {
                    /// The ZMK is not zero.
                    ZMK_ZERO_0 = 0x0,
                    /// The ZMK is zero.
                    ZMK_ZERO_1 = 0x1,
                },
            }),
            /// SNVS_HP Security Violation Status Register
            HPSVSR: mmio.Mmio(packed struct(u32) {
                /// Security Violation 0 security violation was detected.
                SV0: enum(u1) {
                    /// No Security Violation 0 security violation was detected.
                    SV0_0 = 0x0,
                    /// Security Violation 0 security violation was detected.
                    SV0_1 = 0x1,
                },
                /// Security Violation 1 security violation was detected.
                SV1: enum(u1) {
                    /// No Security Violation 1 security violation was detected.
                    SV1_0 = 0x0,
                    /// Security Violation 1 security violation was detected.
                    SV1_1 = 0x1,
                },
                /// Security Violation 2 security violation was detected.
                SV2: enum(u1) {
                    /// No Security Violation 2 security violation was detected.
                    SV2_0 = 0x0,
                    /// Security Violation 2 security violation was detected.
                    SV2_1 = 0x1,
                },
                /// Security Violation 3 security violation was detected.
                SV3: enum(u1) {
                    /// No Security Violation 3 security violation was detected.
                    SV3_0 = 0x0,
                    /// Security Violation 3 security violation was detected.
                    SV3_1 = 0x1,
                },
                /// Security Violation 4 security violation was detected.
                SV4: enum(u1) {
                    /// No Security Violation 4 security violation was detected.
                    SV4_0 = 0x0,
                    /// Security Violation 4 security violation was detected.
                    SV4_1 = 0x1,
                },
                /// Security Violation 5 security violation was detected.
                SV5: enum(u1) {
                    /// No Security Violation 5 security violation was detected.
                    SV5_0 = 0x0,
                    /// Security Violation 5 security violation was detected.
                    SV5_1 = 0x1,
                },
                reserved13: u7 = 0,
                /// Software Security Violation This bit is a read-only copy of the SW_SV bit in the HP Command Register
                SW_SV: u1,
                /// Software Fatal Security Violation This bit is a read-only copy of the SW_FSV bit in the HP Command Register
                SW_FSV: u1,
                /// LP Software Security Violation This bit is a read-only copy of the SW_LPSV bit in the HP Command Register
                SW_LPSV: u1,
                /// Zeroizable Master Key Syndrome The ZMK syndrome indicates the single-bit error location and parity for the ZMK register
                ZMK_SYNDROME: u9,
                reserved27: u2 = 0,
                /// Zeroizable Master Key Error Correcting Code Check Failure When set, this bit triggers a bad key violation to the SSM and a security violation to the SNVS_LP section, which clears security sensitive data
                ZMK_ECC_FAIL: enum(u1) {
                    /// ZMK ECC Failure was not detected.
                    ZMK_ECC_FAIL_0 = 0x0,
                    /// ZMK ECC Failure was detected.
                    ZMK_ECC_FAIL_1 = 0x1,
                },
                reserved31: u3 = 0,
                /// LP Security Violation A security volation was detected in the SNVS low power section.
                LP_SEC_VIO: u1,
            }),
            /// SNVS_HP High Assurance Counter IV Register
            HPHACIVR: mmio.Mmio(packed struct(u32) {
                /// High Assurance Counter Initial Value This register is used to set the starting count value to the high assurance counter
                HAC_COUNTER_IV: u32,
            }),
            /// SNVS_HP High Assurance Counter Register
            HPHACR: mmio.Mmio(packed struct(u32) {
                /// High Assurance Counter When the HAC_EN bit is set and the SSM is in the soft fail state, this counter starts to count down with the system clock
                HAC_COUNTER: u32,
            }),
            /// SNVS_HP Real Time Counter MSB Register
            HPRTCMR: mmio.Mmio(packed struct(u32) {
                /// HP Real Time Counter The most-significant 15 bits of the RTC
                RTC: u15,
                padding: u17 = 0,
            }),
            /// SNVS_HP Real Time Counter LSB Register
            HPRTCLR: mmio.Mmio(packed struct(u32) {
                /// HP Real Time Counter least-significant 32 bits
                RTC: u32,
            }),
            /// SNVS_HP Time Alarm MSB Register
            HPTAMR: mmio.Mmio(packed struct(u32) {
                /// HP Time Alarm, most-significant 15 bits
                HPTA_MS: u15,
                padding: u17 = 0,
            }),
            /// SNVS_HP Time Alarm LSB Register
            HPTALR: mmio.Mmio(packed struct(u32) {
                /// HP Time Alarm, 32 least-significant bits
                HPTA_LS: u32,
            }),
            /// SNVS_LP Lock Register
            LPLR: mmio.Mmio(packed struct(u32) {
                /// Zeroizable Master Key Write Hard Lock When set, prevents any writes (software and hardware) to the ZMK registers and ZMK_HWP, ZMK_VAL, and ZMK_ECC_EN fields of the LPMKCR
                ZMK_WHL: enum(u1) {
                    /// Write access is allowed.
                    ZMK_WHL_0 = 0x0,
                    /// Write access is not allowed.
                    ZMK_WHL_1 = 0x1,
                },
                /// Zeroizable Master Key Read Hard Lock When set, prevents any software reads to the ZMK registers and ZMK_ECC_VALUE field of the LPMKCR
                ZMK_RHL: enum(u1) {
                    /// Read access is allowed (only in software programming mode).
                    ZMK_RHL_0 = 0x0,
                    /// Read access is not allowed.
                    ZMK_RHL_1 = 0x1,
                },
                /// Secure Real Time Counter Hard Lock When set, prevents any writes to the SRTC registers, SRTC_ENV, and SRTC_INV_EN bits
                SRTC_HL: enum(u1) {
                    /// Write access is allowed.
                    SRTC_HL_0 = 0x0,
                    /// Write access is not allowed.
                    SRTC_HL_1 = 0x1,
                },
                /// LP Calibration Hard Lock When set, prevents any writes to the LP Calibration Value (LPCALB_VAL) and LP Calibration Enable (LPCALB_EN)
                LPCALB_HL: enum(u1) {
                    /// Write access is allowed.
                    LPCALB_HL_0 = 0x0,
                    /// Write access is not allowed.
                    LPCALB_HL_1 = 0x1,
                },
                /// Monotonic Counter Hard Lock When set, prevents any writes (increments) to the MC Registers and MC_ENV bit
                MC_HL: enum(u1) {
                    /// Write access (increment) is allowed.
                    MC_HL_0 = 0x0,
                    /// Write access (increment) is not allowed.
                    MC_HL_1 = 0x1,
                },
                /// General Purpose Register Hard Lock When set, prevents any writes to the GPR
                GPR_HL: enum(u1) {
                    /// Write access is allowed.
                    GPR_HL_0 = 0x0,
                    /// Write access is not allowed.
                    GPR_HL_1 = 0x1,
                },
                /// LP Security Violation Control Register Hard Lock When set, prevents any writes to the LPSVCR
                LPSVCR_HL: enum(u1) {
                    /// Write access is allowed.
                    LPSVCR_HL_0 = 0x0,
                    /// Write access is not allowed.
                    LPSVCR_HL_1 = 0x1,
                },
                reserved8: u1 = 0,
                /// LP Tamper Detectors Configuration Register Hard Lock When set, prevents any writes to the LPTDCR
                LPTDCR_HL: enum(u1) {
                    /// Write access is allowed.
                    LPTDCR_HL_0 = 0x0,
                    /// Write access is not allowed.
                    LPTDCR_HL_1 = 0x1,
                },
                /// Master Key Select Hard Lock When set, prevents any writes to the MASTER_KEY_SEL field of the LP Master Key Control Register
                MKS_HL: enum(u1) {
                    /// Write access is allowed.
                    MKS_HL_0 = 0x0,
                    /// Write access is not allowed.
                    MKS_HL_1 = 0x1,
                },
                padding: u22 = 0,
            }),
            /// SNVS_LP Control Register
            LPCR: mmio.Mmio(packed struct(u32) {
                /// Secure Real Time Counter Enabled and Valid When set, the SRTC becomes operational
                SRTC_ENV: enum(u1) {
                    /// SRTC is disabled or invalid.
                    SRTC_ENV_0 = 0x0,
                    /// SRTC is enabled and valid.
                    SRTC_ENV_1 = 0x1,
                },
                /// LP Time Alarm Enable When set, the SNVS functional interrupt is asserted if the LP Time Alarm Register is equal to the 32 MSBs of the secure real time counter
                LPTA_EN: enum(u1) {
                    /// LP time alarm interrupt is disabled.
                    LPTA_EN_0 = 0x0,
                    /// LP time alarm interrupt is enabled.
                    LPTA_EN_1 = 0x1,
                },
                /// Monotonic Counter Enabled and Valid When set, the MC can be incremented (by write transaction to the LPSMCMR or LPSMCLR)
                MC_ENV: enum(u1) {
                    /// MC is disabled or invalid.
                    MC_ENV_0 = 0x0,
                    /// MC is enabled and valid.
                    MC_ENV_1 = 0x1,
                },
                /// LP Wake-Up Interrupt Enable This interrupt line should be connected to the external pin and is intended to inform the external chip about an SNVS_LP event (tamper event, MC rollover, SRTC rollover, or time alarm )
                LPWUI_EN: u1,
                /// If this bit is 1, in the case of a security violation the SRTC stops counting and the SRTC is invalidated (SRTC_ENV bit is cleared)
                SRTC_INV_EN: enum(u1) {
                    /// SRTC stays valid in the case of security violation.
                    SRTC_INV_EN_0 = 0x0,
                    /// SRTC is invalidated in the case of security violation.
                    SRTC_INV_EN_1 = 0x1,
                },
                /// Dumb PMIC Enabled When set, software can control the system power
                DP_EN: enum(u1) {
                    /// Smart PMIC enabled.
                    DP_EN_0 = 0x0,
                    /// Dumb PMIC enabled.
                    DP_EN_1 = 0x1,
                },
                /// Turn off System Power Asserting this bit causes a signal to be sent to the Power Management IC to turn off the system power
                TOP: enum(u1) {
                    /// Leave system power on.
                    TOP_0 = 0x0,
                    /// Turn off system power.
                    TOP_1 = 0x1,
                },
                /// Power Glitch Enable By default the detection of a power glitch does not cause the pmic_en_b signal to be asserted
                PWR_GLITCH_EN: u1,
                /// LP Calibration Enable When set, enables the SRTC calibration mechanism
                LPCALB_EN: enum(u1) {
                    /// SRTC Time calibration is disabled.
                    LPCALB_EN_0 = 0x0,
                    /// SRTC Time calibration is enabled.
                    LPCALB_EN_1 = 0x1,
                },
                reserved10: u1 = 0,
                /// LP Calibration Value Defines signed calibration value for SRTC
                LPCALB_VAL: enum(u5) {
                    /// +0 counts per each 32768 ticks of the counter clock
                    LPCALB_VAL_0 = 0x0,
                    /// +1 counts per each 32768 ticks of the counter clock
                    LPCALB_VAL_1 = 0x1,
                    /// +2 counts per each 32768 ticks of the counter clock
                    LPCALB_VAL_2 = 0x2,
                    /// +15 counts per each 32768 ticks of the counter clock
                    LPCALB_VAL_15 = 0xf,
                    /// -16 counts per each 32768 ticks of the counter clock
                    LPCALB_VAL_16 = 0x10,
                    /// -15 counts per each 32768 ticks of the counter clock
                    LPCALB_VAL_17 = 0x11,
                    /// -2 counts per each 32768 ticks of the counter clock
                    LPCALB_VAL_30 = 0x1e,
                    /// -1 counts per each 32768 ticks of the counter clock
                    LPCALB_VAL_31 = 0x1f,
                    _,
                },
                reserved16: u1 = 0,
                /// This field configures the button press time out values for the PMIC Logic
                BTN_PRESS_TIME: u2,
                /// This field configures the amount of debounce time for the BTN input signal
                DEBOUNCE: u2,
                /// The ON_TIME field is used to configure the period of time after BTN is asserted before pmic_en_b is asserted to turn on the SoC power
                ON_TIME: u2,
                /// PMIC On Request Enable The value written to PK_EN will be asserted on output signal snvs_lp_pk_en
                PK_EN: u1,
                /// PMIC On Request Override The value written to PK_OVERRIDE will be asserted on output signal snvs_lp_pk_override
                PK_OVERRIDE: u1,
                /// General Purpose Registers Zeroization Disable
                GPR_Z_DIS: u1,
                padding: u7 = 0,
            }),
            /// SNVS_LP Master Key Control Register
            LPMKCR: mmio.Mmio(packed struct(u32) {
                reserved2: u2 = 0,
                /// Zeroizable Master Key hardware Programming mode When set, only the hardware key programming mechanism can set the ZMK and software cannot read it
                ZMK_HWP: enum(u1) {
                    /// ZMK is in the software programming mode.
                    ZMK_HWP_0 = 0x0,
                    /// ZMK is in the hardware programming mode.
                    ZMK_HWP_1 = 0x1,
                },
                /// Zeroizable Master Key Valid When set, the ZMK value can be selected by the master key control block for use by cryptographic modules
                ZMK_VAL: enum(u1) {
                    /// ZMK is not valid.
                    ZMK_VAL_0 = 0x0,
                    /// ZMK is valid.
                    ZMK_VAL_1 = 0x1,
                },
                /// Zeroizable Master Key Error Correcting Code Check Enable Writing one to this field automatically calculates and sets the ZMK ECC value in the ZMK_ECC_VALUE field of this register
                ZMK_ECC_EN: enum(u1) {
                    /// ZMK ECC check is disabled.
                    ZMK_ECC_EN_0 = 0x0,
                    /// ZMK ECC check is enabled.
                    ZMK_ECC_EN_1 = 0x1,
                },
                reserved7: u2 = 0,
                /// Zeroizable Master Key Error Correcting Code Value This field is automatically calculated and set when one is written into ZMK_ECC_EN bit of this register
                ZMK_ECC_VALUE: u9,
                padding: u16 = 0,
            }),
            /// SNVS_LP Security Violation Control Register
            LPSVCR: mmio.Mmio(packed struct(u32) {
                /// Security Violation 0 Enable This bit enables Security Violation 0 Input
                SV0_EN: enum(u1) {
                    /// Security Violation 0 is disabled in the LP domain.
                    SV0_EN_0 = 0x0,
                    /// Security Violation 0 is enabled in the LP domain.
                    SV0_EN_1 = 0x1,
                },
                /// Security Violation 1 Enable This bit enables Security Violation 1 Input
                SV1_EN: enum(u1) {
                    /// Security Violation 1 is disabled in the LP domain.
                    SV1_EN_0 = 0x0,
                    /// Security Violation 1 is enabled in the LP domain.
                    SV1_EN_1 = 0x1,
                },
                /// Security Violation 2 Enable This bit enables Security Violation 2 Input
                SV2_EN: enum(u1) {
                    /// Security Violation 2 is disabled in the LP domain.
                    SV2_EN_0 = 0x0,
                    /// Security Violation 2 is enabled in the LP domain.
                    SV2_EN_1 = 0x1,
                },
                /// Security Violation 3 Enable This bit enables Security Violation 3 Input
                SV3_EN: enum(u1) {
                    /// Security Violation 3 is disabled in the LP domain.
                    SV3_EN_0 = 0x0,
                    /// Security Violation 3 is enabled in the LP domain.
                    SV3_EN_1 = 0x1,
                },
                /// Security Violation 4 Enable This bit enables Security Violation 4 Input
                SV4_EN: enum(u1) {
                    /// Security Violation 4 is disabled in the LP domain.
                    SV4_EN_0 = 0x0,
                    /// Security Violation 4 is enabled in the LP domain.
                    SV4_EN_1 = 0x1,
                },
                /// Security Violation 5 Enable This bit enables Security Violation 5 Input
                SV5_EN: enum(u1) {
                    /// Security Violation 5 is disabled in the LP domain.
                    SV5_EN_0 = 0x0,
                    /// Security Violation 5 is enabled in the LP domain.
                    SV5_EN_1 = 0x1,
                },
                padding: u26 = 0,
            }),
            reserved72: [4]u8,
            /// SNVS_LP Tamper Detectors Configuration Register
            LPTDCR: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// SRTC Rollover Enable When set, an SRTC rollover event generates an LP security violation.
                SRTCR_EN: enum(u1) {
                    /// SRTC rollover is disabled.
                    SRTCR_EN_0 = 0x0,
                    /// SRTC rollover is enabled.
                    SRTCR_EN_1 = 0x1,
                },
                /// MC Rollover Enable When set, an MC Rollover event generates an LP security violation.
                MCR_EN: enum(u1) {
                    /// MC rollover is disabled.
                    MCR_EN_0 = 0x0,
                    /// MC rollover is enabled.
                    MCR_EN_1 = 0x1,
                },
                reserved9: u6 = 0,
                /// External Tampering 1 Enable When set, external tampering 1 detection generates an LP security violation
                ET1_EN: enum(u1) {
                    /// External tamper 1 is disabled.
                    ET1_EN_0 = 0x0,
                    /// External tamper 1 is enabled.
                    ET1_EN_1 = 0x1,
                },
                reserved11: u1 = 0,
                /// External Tampering 1 Polarity This bit is used to determine the polarity of external tamper 1.
                ET1P: enum(u1) {
                    /// External tamper 1 is active low.
                    ET1P_0 = 0x0,
                    /// External tamper 1 is active high.
                    ET1P_1 = 0x1,
                },
                reserved14: u2 = 0,
                /// System Power Fail Detector (PFD) Observability Flop The asynchronous reset input of this flop is connected directly to the inverted output of the PFD analog circuitry (external to the SNVS block)
                PFD_OBSERV: u1,
                /// Power On Reset (POR) Observability Flop The asynchronous reset input of this flop is connected directly to the output of the POR analog circuitry (external to the SNVS
                POR_OBSERV: u1,
                reserved28: u12 = 0,
                /// Oscillator Bypass When OSCB=1 the osc_bypass signal is asserted
                OSCB: enum(u1) {
                    /// Normal SRTC clock oscillator not bypassed.
                    OSCB_0 = 0x0,
                    /// Normal SRTC clock oscillator bypassed. Alternate clock can drive the SRTC clock source.
                    OSCB_1 = 0x1,
                },
                padding: u3 = 0,
            }),
            /// SNVS_LP Status Register
            LPSR: mmio.Mmio(packed struct(u32) {
                /// LP Time Alarm
                LPTA: enum(u1) {
                    /// No time alarm interrupt occurred.
                    LPTA_0 = 0x0,
                    /// A time alarm interrupt occurred.
                    LPTA_1 = 0x1,
                },
                /// Secure Real Time Counter Rollover
                SRTCR: enum(u1) {
                    /// SRTC has not reached its maximum value.
                    SRTCR_0 = 0x0,
                    /// SRTC has reached its maximum value.
                    SRTCR_1 = 0x1,
                },
                /// Monotonic Counter Rollover
                MCR: enum(u1) {
                    /// MC has not reached its maximum value.
                    MCR_0 = 0x0,
                    /// MC has reached its maximum value.
                    MCR_1 = 0x1,
                },
                /// Power Supply Glitch Detected 0 No power supply glitch. 1 Power supply glitch is detected.
                PGD: u1,
                reserved9: u5 = 0,
                /// External Tampering 1 Detected
                ET1D: enum(u1) {
                    /// External tampering 1 not detected.
                    ET1D_0 = 0x0,
                    /// External tampering 1 detected.
                    ET1D_1 = 0x1,
                },
                reserved16: u6 = 0,
                /// External Security Violation Detected Indicates that a security violation is detected on one of the HP security violation ports
                ESVD: enum(u1) {
                    /// No external security violation.
                    ESVD_0 = 0x0,
                    /// External security violation is detected.
                    ESVD_1 = 0x1,
                },
                /// Emergency Off This bit is set when a power off is requested.
                EO: enum(u1) {
                    /// Emergency off was not detected.
                    EO_0 = 0x0,
                    /// Emergency off was detected.
                    EO_1 = 0x1,
                },
                /// Set Power Off The SPO bit is set when the power button is pressed longer than the configured debounce time
                SPO: enum(u1) {
                    /// Set Power Off was not detected.
                    SPO_0 = 0x0,
                    /// Set Power Off was detected.
                    SPO_1 = 0x1,
                },
                reserved20: u1 = 0,
                /// Scan Exit Detected
                SED: enum(u1) {
                    /// Scan exit was not detected.
                    SED_0 = 0x0,
                    /// Scan exit was detected.
                    SED_1 = 0x1,
                },
                reserved30: u9 = 0,
                /// LP Section is Non-Secured Indicates that LP section was provisioned/programmed in the non-secure state
                LPNS: enum(u1) {
                    /// LP section was not programmed in the non-secure state.
                    LPNS_0 = 0x0,
                    /// LP section was programmed in the non-secure state.
                    LPNS_1 = 0x1,
                },
                /// LP Section is Secured Indicates that the LP section is provisioned/programmed in the secure or trusted state
                LPS: enum(u1) {
                    /// LP section was not programmed in secure or trusted state.
                    LPS_0 = 0x0,
                    /// LP section was programmed in secure or trusted state.
                    LPS_1 = 0x1,
                },
            }),
            /// SNVS_LP Secure Real Time Counter MSB Register
            LPSRTCMR: mmio.Mmio(packed struct(u32) {
                /// LP Secure Real Time Counter The most-significant 15 bits of the SRTC
                SRTC: u15,
                padding: u17 = 0,
            }),
            /// SNVS_LP Secure Real Time Counter LSB Register
            LPSRTCLR: mmio.Mmio(packed struct(u32) {
                /// LP Secure Real Time Counter least-significant 32 bits This register can be programmed only when SRTC is not active and not locked, meaning the SRTC_ENV, SRTC_SL, and SRTC_HL bits are not set
                SRTC: u32,
            }),
            /// SNVS_LP Time Alarm Register
            LPTAR: mmio.Mmio(packed struct(u32) {
                /// LP Time Alarm This register can be programmed only when the LP time alarm is disabled (LPTA_EN bit is not set)
                LPTA: u32,
            }),
            /// SNVS_LP Secure Monotonic Counter MSB Register
            LPSMCMR: mmio.Mmio(packed struct(u32) {
                /// Monotonic Counter most-significant 16 Bits The MC is incremented by one when: A write transaction to the LPSMCMR or LPSMCLR register is detected
                MON_COUNTER: u16,
                /// Monotonic Counter Era Bits These bits are inputs to the module and typically connect to fuses
                MC_ERA_BITS: u16,
            }),
            /// SNVS_LP Secure Monotonic Counter LSB Register
            LPSMCLR: mmio.Mmio(packed struct(u32) {
                /// Monotonic Counter bits The MC is incremented by one when: A write transaction to the LPSMCMR or LPSMCLR Register is detected
                MON_COUNTER: u32,
            }),
            /// SNVS_LP Power Glitch Detector Register
            LPPGDR: mmio.Mmio(packed struct(u32) {
                /// Power Glitch Detector Value
                PGD: u32,
            }),
            /// SNVS_LP General Purpose Register 0 (legacy alias)
            LPGPR0_legacy_alias: mmio.Mmio(packed struct(u32) {
                /// General Purpose Register When GPR_SL or GPR_HL bit is set, the register cannot be programmed.
                GPR: u32,
            }),
            /// SNVS_LP Zeroizable Master Key Register
            LPZMKR: [8]mmio.Mmio(packed struct(u32) {
                /// Zeroizable Master Key Each of these registers contains 32 bits of the 256-bit ZMK value
                ZMK: u32,
            }),
            reserved144: [4]u8,
            /// SNVS_LP General Purpose Registers 0 .. 3
            LPGPR_alias: [4]mmio.Mmio(packed struct(u32) {
                /// General Purpose Register When GPR_SL or GPR_HL bit is set, the register cannot be programmed.
                GPR: u32,
            }),
            reserved256: [96]u8,
            /// SNVS_LP General Purpose Registers 0 .. 7
            LPGPR: [8]mmio.Mmio(packed struct(u32) {
                /// General Purpose Register When GPR_SL or GPR_HL bit is set, the register cannot be programmed.
                GPR: u32,
            }),
            reserved3064: [2776]u8,
            /// SNVS_HP Version ID Register 1
            HPVIDR1: mmio.Mmio(packed struct(u32) {
                /// SNVS block minor version number
                MINOR_REV: u8,
                /// SNVS block major version number
                MAJOR_REV: u8,
                /// SNVS block ID
                IP_ID: u16,
            }),
            /// SNVS_HP Version ID Register 2
            HPVIDR2: mmio.Mmio(packed struct(u32) {
                /// SNVS Configuration Options
                CONFIG_OPT: u8,
                /// SNVS ECO Revision
                ECO_REV: u8,
                /// SNVS Integration Options
                INTG_OPT: u8,
                /// IP Era 00h - Era 1 or 2 03h - Era 3 04h - Era 4 05h - Era 5
                IP_ERA: u8,
            }),
        };

        /// SPDIF
        pub const SPDIF = extern struct {
            /// SPDIF Configuration Register
            SCR: mmio.Mmio(packed struct(u32) {
                /// no description available
                USrc_Sel: enum(u2) {
                    /// No embedded U channel
                    USrc_Sel_0 = 0x0,
                    /// U channel from SPDIF receive block (CD mode)
                    USrc_Sel_1 = 0x1,
                    /// U channel from on chip transmitter
                    USrc_Sel_3 = 0x3,
                    _,
                },
                /// no description available
                TxSel: enum(u3) {
                    /// Off and output 0
                    TxSel_0 = 0x0,
                    /// Feed-through SPDIFIN
                    TxSel_1 = 0x1,
                    /// Tx Normal operation
                    TxSel_5 = 0x5,
                    _,
                },
                /// no description available
                ValCtrl: enum(u1) {
                    /// Outgoing Validity always set
                    ValCtrl_0 = 0x0,
                    /// Outgoing Validity always clear
                    ValCtrl_1 = 0x1,
                },
                reserved8: u2 = 0,
                /// DMA Transmit Request Enable (Tx FIFO empty)
                DMA_TX_En: u1,
                /// DMA Receive Request Enable (RX FIFO full)
                DMA_Rx_En: u1,
                /// no description available
                TxFIFO_Ctrl: enum(u2) {
                    /// Send out digital zero on SPDIF Tx
                    TxFIFO_Ctrl_0 = 0x0,
                    /// Tx Normal operation
                    TxFIFO_Ctrl_1 = 0x1,
                    /// Reset to 1 sample remaining
                    TxFIFO_Ctrl_2 = 0x2,
                    _,
                },
                /// When write 1 to this bit, it will cause SPDIF software reset
                soft_reset: u1,
                /// When write 1 to this bit, it will cause SPDIF enter low-power mode
                LOW_POWER: u1,
                reserved15: u1 = 0,
                /// no description available
                TxFIFOEmpty_Sel: enum(u2) {
                    /// Empty interrupt if 0 sample in Tx left and right FIFOs
                    TxFIFOEmpty_Sel_0 = 0x0,
                    /// Empty interrupt if at most 4 sample in Tx left and right FIFOs
                    TxFIFOEmpty_Sel_1 = 0x1,
                    /// Empty interrupt if at most 8 sample in Tx left and right FIFOs
                    TxFIFOEmpty_Sel_2 = 0x2,
                    /// Empty interrupt if at most 12 sample in Tx left and right FIFOs
                    TxFIFOEmpty_Sel_3 = 0x3,
                },
                /// no description available
                TxAutoSync: enum(u1) {
                    /// Tx FIFO auto sync off
                    TxAutoSync_0 = 0x0,
                    /// Tx FIFO auto sync on
                    TxAutoSync_1 = 0x1,
                },
                /// no description available
                RxAutoSync: enum(u1) {
                    /// Rx FIFO auto sync off
                    RxAutoSync_0 = 0x0,
                    /// RxFIFO auto sync on
                    RxAutoSync_1 = 0x1,
                },
                /// no description available
                RxFIFOFull_Sel: enum(u2) {
                    /// Full interrupt if at least 1 sample in Rx left and right FIFOs
                    RxFIFOFull_Sel_0 = 0x0,
                    /// Full interrupt if at least 4 sample in Rx left and right FIFOs
                    RxFIFOFull_Sel_1 = 0x1,
                    /// Full interrupt if at least 8 sample in Rx left and right FIFOs
                    RxFIFOFull_Sel_2 = 0x2,
                    /// Full interrupt if at least 16 sample in Rx left and right FIFO
                    RxFIFOFull_Sel_3 = 0x3,
                },
                /// no description available
                RxFIFO_Rst: enum(u1) {
                    /// Normal operation
                    RxFIFO_Rst_0 = 0x0,
                    /// Reset register to 1 sample remaining
                    RxFIFO_Rst_1 = 0x1,
                },
                /// no description available
                RxFIFO_Off_On: enum(u1) {
                    /// SPDIF Rx FIFO is on
                    RxFIFO_Off_On_0 = 0x0,
                    /// SPDIF Rx FIFO is off. Does not accept data from interface
                    RxFIFO_Off_On_1 = 0x1,
                },
                /// no description available
                RxFIFO_Ctrl: enum(u1) {
                    /// Normal operation
                    RxFIFO_Ctrl_0 = 0x0,
                    /// Always read zero from Rx data register
                    RxFIFO_Ctrl_1 = 0x1,
                },
                padding: u8 = 0,
            }),
            /// CDText Control Register
            SRCD: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// no description available
                USyncMode: enum(u1) {
                    /// Non-CD data
                    USyncMode_0 = 0x0,
                    /// CD user channel subcode
                    USyncMode_1 = 0x1,
                },
                padding: u30 = 0,
            }),
            /// PhaseConfig Register
            SRPC: mmio.Mmio(packed struct(u32) {
                reserved3: u3 = 0,
                /// Gain selection:
                GainSel: enum(u3) {
                    /// 24*(2**10)
                    GainSel_0 = 0x0,
                    /// 16*(2**10)
                    GainSel_1 = 0x1,
                    /// 12*(2**10)
                    GainSel_2 = 0x2,
                    /// 8*(2**10)
                    GainSel_3 = 0x3,
                    /// 6*(2**10)
                    GainSel_4 = 0x4,
                    /// 4*(2**10)
                    GainSel_5 = 0x5,
                    /// 3*(2**10)
                    GainSel_6 = 0x6,
                    _,
                },
                /// LOCK bit to show that the internal DPLL is locked, read only
                LOCK: u1,
                /// Clock source selection, all other settings not shown are reserved:
                ClkSrc_Sel: enum(u4) {
                    /// if (DPLL Locked) SPDIF_RxClk else REF_CLK_32K (XTALOSC)
                    ClkSrc_Sel_0 = 0x0,
                    /// if (DPLL Locked) SPDIF_RxClk else tx_clk (SPDIF0_CLK_ROOT)
                    ClkSrc_Sel_1 = 0x1,
                    /// if (DPLL Locked) SPDIF_RxClk else SPDIF_EXT_CLK
                    ClkSrc_Sel_3 = 0x3,
                    /// REF_CLK_32K (XTALOSC)
                    ClkSrc_Sel_5 = 0x5,
                    /// tx_clk (SPDIF0_CLK_ROOT)
                    ClkSrc_Sel_6 = 0x6,
                    /// SPDIF_EXT_CLK
                    ClkSrc_Sel_8 = 0x8,
                    _,
                },
                padding: u21 = 0,
            }),
            /// InterruptEn Register
            SIE: mmio.Mmio(packed struct(u32) {
                /// SPDIF Rx FIFO full, can't be cleared with reg. IntClear. To clear it, read from Rx FIFO.
                RxFIFOFul: u1,
                /// SPDIF Tx FIFO empty, can't be cleared with reg. IntClear. To clear it, write toTx FIFO.
                TxEm: u1,
                /// SPDIF receiver loss of lock
                LockLoss: u1,
                /// Rx FIFO resync
                RxFIFOResyn: u1,
                /// Rx FIFO underrun/overrun
                RxFIFOUnOv: u1,
                /// U/Q Channel framing error
                UQErr: u1,
                /// U/Q Channel sync found
                UQSync: u1,
                /// Q Channel receive register overrun
                QRxOv: u1,
                /// Q Channel receive register full, can't be cleared with reg
                QRxFul: u1,
                /// U Channel receive register overrun
                URxOv: u1,
                /// U Channel receive register full, can't be cleared with reg
                URxFul: u1,
                reserved14: u3 = 0,
                /// SPDIF receiver found parity bit error
                BitErr: u1,
                /// SPDIF receiver found illegal symbol
                SymErr: u1,
                /// SPDIF validity flag no good
                ValNoGood: u1,
                /// SPDIF receive change in value of control channel
                CNew: u1,
                /// SPDIF Tx FIFO resync
                TxResyn: u1,
                /// SPDIF Tx FIFO under/overrun
                TxUnOv: u1,
                /// SPDIF receiver's DPLL is locked
                Lock: u1,
                padding: u11 = 0,
            }),
            /// InterruptClear Register
            SIC: mmio.Mmio(packed struct(u32) {
                reserved2: u2 = 0,
                /// SPDIF receiver loss of lock
                LockLoss: u1,
                /// Rx FIFO resync
                RxFIFOResyn: u1,
                /// Rx FIFO underrun/overrun
                RxFIFOUnOv: u1,
                /// U/Q Channel framing error
                UQErr: u1,
                /// U/Q Channel sync found
                UQSync: u1,
                /// Q Channel receive register overrun
                QRxOv: u1,
                reserved9: u1 = 0,
                /// U Channel receive register overrun
                URxOv: u1,
                reserved14: u4 = 0,
                /// SPDIF receiver found parity bit error
                BitErr: u1,
                /// SPDIF receiver found illegal symbol
                SymErr: u1,
                /// SPDIF validity flag no good
                ValNoGood: u1,
                /// SPDIF receive change in value of control channel
                CNew: u1,
                /// SPDIF Tx FIFO resync
                TxResyn: u1,
                /// SPDIF Tx FIFO under/overrun
                TxUnOv: u1,
                /// SPDIF receiver's DPLL is locked
                Lock: u1,
                padding: u11 = 0,
            }),
            /// SPDIFRxLeft Register
            SRL: mmio.Mmio(packed struct(u32) {
                /// Processor receive SPDIF data left
                RxDataLeft: u24,
                padding: u8 = 0,
            }),
            /// SPDIFRxRight Register
            SRR: mmio.Mmio(packed struct(u32) {
                /// Processor receive SPDIF data right
                RxDataRight: u24,
                padding: u8 = 0,
            }),
            /// SPDIFRxCChannel_h Register
            SRCSH: mmio.Mmio(packed struct(u32) {
                /// SPDIF receive C channel register, contains first 24 bits of C channel without interpretation
                RxCChannel_h: u24,
                padding: u8 = 0,
            }),
            /// SPDIFRxCChannel_l Register
            SRCSL: mmio.Mmio(packed struct(u32) {
                /// SPDIF receive C channel register, contains next 24 bits of C channel without interpretation
                RxCChannel_l: u24,
                padding: u8 = 0,
            }),
            /// UchannelRx Register
            SRU: mmio.Mmio(packed struct(u32) {
                /// SPDIF receive U channel register, contains next 3 U channel bytes
                RxUChannel: u24,
                padding: u8 = 0,
            }),
            /// QchannelRx Register
            SRQ: mmio.Mmio(packed struct(u32) {
                /// SPDIF receive Q channel register, contains next 3 Q channel bytes
                RxQChannel: u24,
                padding: u8 = 0,
            }),
            /// SPDIFTxLeft Register
            STL: mmio.Mmio(packed struct(u32) {
                /// SPDIF transmit left channel data. It is write-only, and always returns zeros when read
                TxDataLeft: u24,
                padding: u8 = 0,
            }),
            /// SPDIFTxRight Register
            STR: mmio.Mmio(packed struct(u32) {
                /// SPDIF transmit right channel data. It is write-only, and always returns zeros when read
                TxDataRight: u24,
                padding: u8 = 0,
            }),
            /// SPDIFTxCChannelCons_h Register
            STCSCH: mmio.Mmio(packed struct(u32) {
                /// SPDIF transmit Cons
                TxCChannelCons_h: u24,
                padding: u8 = 0,
            }),
            /// SPDIFTxCChannelCons_l Register
            STCSCL: mmio.Mmio(packed struct(u32) {
                /// SPDIF transmit Cons
                TxCChannelCons_l: u24,
                padding: u8 = 0,
            }),
            reserved68: [8]u8,
            /// FreqMeas Register
            SRFM: mmio.Mmio(packed struct(u32) {
                /// Frequency measurement data
                FreqMeas: u24,
                padding: u8 = 0,
            }),
            reserved80: [8]u8,
            /// SPDIFTxClk Register
            STC: mmio.Mmio(packed struct(u32) {
                /// Divider factor (1-128)
                TxClk_DF: enum(u7) {
                    /// divider factor is 1
                    TxClk_DF_0 = 0x0,
                    /// divider factor is 2
                    TxClk_DF_1 = 0x1,
                    /// divider factor is 128
                    TxClk_DF_127 = 0x7f,
                    _,
                },
                /// Spdif transfer clock enable. When data is going to be transfered, this bit should be set to1.
                tx_all_clk_en: enum(u1) {
                    /// disable transfer clock.
                    tx_all_clk_en_0 = 0x0,
                    /// enable transfer clock.
                    tx_all_clk_en_1 = 0x1,
                },
                /// no description available
                TxClk_Source: enum(u3) {
                    /// XTALOSC input (XTALOSC clock)
                    TxClk_Source_0 = 0x0,
                    /// tx_clk input (from SPDIF0_CLK_ROOT. See CCM.)
                    TxClk_Source_1 = 0x1,
                    /// tx_clk1 (from SAI1)
                    TxClk_Source_2 = 0x2,
                    /// tx_clk2 SPDIF_EXT_CLK, from pads
                    TxClk_Source_3 = 0x3,
                    /// tx_clk3 (from SAI2)
                    TxClk_Source_4 = 0x4,
                    /// ipg_clk input (frequency divided)
                    TxClk_Source_5 = 0x5,
                    /// tx_clk4 (from SAI3)
                    TxClk_Source_6 = 0x6,
                    _,
                },
                /// system clock divider factor, 2~512.
                SYSCLK_DF: enum(u9) {
                    /// no clock signal
                    SYSCLK_DF_0 = 0x0,
                    /// divider factor is 2
                    SYSCLK_DF_1 = 0x1,
                    /// divider factor is 512
                    SYSCLK_DF_511 = 0x1ff,
                    _,
                },
                padding: u12 = 0,
            }),
        };

        /// SRC
        pub const SRC = extern struct {
            /// SRC Control Register
            SCR: mmio.Mmio(packed struct(u32) {
                reserved7: u7 = 0,
                /// Mask wdog_rst_b source
                mask_wdog_rst: enum(u4) {
                    /// wdog_rst_b is masked
                    mask_wdog_rst_5 = 0x5,
                    /// wdog_rst_b is not masked (default)
                    mask_wdog_rst_10 = 0xa,
                    _,
                },
                reserved13: u2 = 0,
                /// Software reset for core0 only
                core0_rst: enum(u1) {
                    /// do not assert core0 reset
                    core0_rst_0 = 0x0,
                    /// assert core0 reset
                    core0_rst_1 = 0x1,
                },
                reserved17: u3 = 0,
                /// Software reset for core0 debug only
                core0_dbg_rst: enum(u1) {
                    /// do not assert core0 debug reset
                    core0_dbg_rst_0 = 0x0,
                    /// assert core0 debug reset
                    core0_dbg_rst_1 = 0x1,
                },
                reserved25: u7 = 0,
                /// Do not assert debug resets after power gating event of core
                dbg_rst_msk_pg: enum(u1) {
                    /// do not mask core debug resets (debug resets will be asserted after power gating event)
                    dbg_rst_msk_pg_0 = 0x0,
                    /// mask core debug resets (debug resets won't be asserted after power gating event)
                    dbg_rst_msk_pg_1 = 0x1,
                },
                reserved28: u2 = 0,
                /// Mask wdog3_rst_b source
                mask_wdog3_rst: enum(u4) {
                    /// wdog3_rst_b is masked
                    mask_wdog3_rst_5 = 0x5,
                    /// wdog3_rst_b is not masked
                    mask_wdog3_rst_10 = 0xa,
                    _,
                },
            }),
            /// SRC Boot Mode Register 1
            SBMR1: mmio.Mmio(packed struct(u32) {
                /// Refer to fusemap.
                BOOT_CFG1: u8,
                /// Refer to fusemap.
                BOOT_CFG2: u8,
                /// Refer to fusemap.
                BOOT_CFG3: u8,
                /// Refer to fusemap.
                BOOT_CFG4: u8,
            }),
            /// SRC Reset Status Register
            SRSR: mmio.Mmio(packed struct(u32) {
                /// Indicates whether reset was the result of ipp_reset_b pin (Power-up sequence)
                ipp_reset_b: enum(u1) {
                    /// Reset is not a result of ipp_reset_b pin.
                    ipp_reset_b_0 = 0x0,
                    /// Reset is a result of ipp_reset_b pin.
                    ipp_reset_b_1 = 0x1,
                },
                /// Indicates a reset has been caused by CPU lockup or software setting of SYSRESETREQ bit in Application Interrupt and Reset Control Register of the ARM core
                lockup_sysresetreq: enum(u1) {
                    /// Reset is not a result of the mentioned case.
                    lockup_sysresetreq_0 = 0x0,
                    /// Reset is a result of the mentioned case.
                    lockup_sysresetreq_1 = 0x1,
                },
                /// Indicates whether the reset was the result of the csu_reset_b input.
                csu_reset_b: enum(u1) {
                    /// Reset is not a result of the csu_reset_b event.
                    csu_reset_b_0 = 0x0,
                    /// Reset is a result of the csu_reset_b event.
                    csu_reset_b_1 = 0x1,
                },
                /// Indicates whether the reset was the result of the ipp_user_reset_b qualified reset.
                ipp_user_reset_b: enum(u1) {
                    /// Reset is not a result of the ipp_user_reset_b qualified as COLD reset event.
                    ipp_user_reset_b_0 = 0x0,
                    /// Reset is a result of the ipp_user_reset_b qualified as COLD reset event.
                    ipp_user_reset_b_1 = 0x1,
                },
                /// IC Watchdog Time-out reset
                wdog_rst_b: enum(u1) {
                    /// Reset is not a result of the watchdog time-out event.
                    wdog_rst_b_0 = 0x0,
                    /// Reset is a result of the watchdog time-out event.
                    wdog_rst_b_1 = 0x1,
                },
                /// HIGH - Z JTAG reset. Indicates whether the reset was the result of HIGH-Z reset from JTAG.
                jtag_rst_b: enum(u1) {
                    /// Reset is not a result of HIGH-Z reset from JTAG.
                    jtag_rst_b_0 = 0x0,
                    /// Reset is a result of HIGH-Z reset from JTAG.
                    jtag_rst_b_1 = 0x1,
                },
                /// JTAG software reset. Indicates whether the reset was the result of software reset from JTAG.
                jtag_sw_rst: enum(u1) {
                    /// Reset is not a result of software reset from JTAG.
                    jtag_sw_rst_0 = 0x0,
                    /// Reset is a result of software reset from JTAG.
                    jtag_sw_rst_1 = 0x1,
                },
                /// IC Watchdog3 Time-out reset
                wdog3_rst_b: enum(u1) {
                    /// Reset is not a result of the watchdog3 time-out event.
                    wdog3_rst_b_0 = 0x0,
                    /// Reset is a result of the watchdog3 time-out event.
                    wdog3_rst_b_1 = 0x1,
                },
                /// Temper Sensor software reset
                tempsense_rst_b: enum(u1) {
                    /// Reset is not a result of software reset from Temperature Sensor.
                    tempsense_rst_b_0 = 0x0,
                    /// Reset is a result of software reset from Temperature Sensor.
                    tempsense_rst_b_1 = 0x1,
                },
                padding: u23 = 0,
            }),
            reserved28: [16]u8,
            /// SRC Boot Mode Register 2
            SBMR2: mmio.Mmio(packed struct(u32) {
                /// SECONFIG[1] shows the state of the SECONFIG[1] fuse
                SEC_CONFIG: u2,
                reserved3: u1 = 0,
                /// DIR_BT_DIS shows the state of the DIR_BT_DIS fuse
                DIR_BT_DIS: u1,
                /// BT_FUSE_SEL (connected to gpio bt_fuse_sel) shows the state of the BT_FUSE_SEL fuse
                BT_FUSE_SEL: u1,
                reserved24: u19 = 0,
                /// BMOD[1:0] shows the latched state of the BOOT_MODE1 and BOOT_MODE0 signals on the rising edge of POR_B
                BMOD: u2,
                padding: u6 = 0,
            }),
            /// SRC General Purpose Register 1
            GPR1: mmio.Mmio(packed struct(u32) {
                /// Holds entry function for core0 for waking-up from low power mode
                PERSISTENT_ENTRY0: u32,
            }),
            /// SRC General Purpose Register 2
            GPR2: mmio.Mmio(packed struct(u32) {
                /// Holds argument of entry function for core0 for waking-up from low power mode
                PERSISTENT_ARG0: u32,
            }),
            /// SRC General Purpose Register 3
            GPR3: u32,
            /// SRC General Purpose Register 4
            GPR4: u32,
            /// SRC General Purpose Register 5
            GPR5: u32,
            /// SRC General Purpose Register 6
            GPR6: u32,
            /// SRC General Purpose Register 7
            GPR7: u32,
            /// SRC General Purpose Register 8
            GPR8: u32,
            /// SRC General Purpose Register 9
            GPR9: u32,
            /// SRC General Purpose Register 10
            GPR10: u32,
        };

        /// System Control Block
        pub const SystemControl = extern struct {
            reserved8: [8]u8,
            /// Auxiliary Control Register,
            ACTLR: mmio.Mmio(packed struct(u32) {
                reserved2: u2 = 0,
                /// Disables folding of IT instructions.
                DISFOLD: enum(u1) {
                    /// Normal operation.
                    DISFOLD_0 = 0x0,
                    _,
                },
                reserved10: u7 = 0,
                /// Disables FPU exception outputs.
                FPEXCODIS: enum(u1) {
                    /// Normal operation.
                    FPEXCODIS_0 = 0x0,
                    /// FPU exception outputs are disabled.
                    FPEXCODIS_1 = 0x1,
                },
                /// Disables dynamic read allocate mode for Write-Back Write-Allocate memory regions.
                DISRAMODE: enum(u1) {
                    /// Normal operation.
                    DISRAMODE_0 = 0x0,
                    /// Dynamic disabled.
                    DISRAMODE_1 = 0x1,
                },
                /// Disables ITM and DWT ATB flush.
                DISITMATBFLUSH: enum(u1) {
                    /// ITM and DWT ATB flush disabled, this bit is always 1.
                    DISITMATBFLUSH_1 = 0x1,
                    _,
                },
                /// Disables BTAC read.
                DISBTACREAD: enum(u1) {
                    /// Normal operation.
                    DISBTACREAD_0 = 0x0,
                    /// BTAC is not used and only static branch prediction can occur.
                    DISBTACREAD_1 = 0x1,
                },
                /// Disables BTAC allocate.
                DISBTACALLOC: enum(u1) {
                    /// Normal operation.
                    DISBTACALLOC_0 = 0x0,
                    /// No new entries are allocated in Branch Target Address Cache (BTAC), but existing entries can be updated.
                    DISBTACALLOC_1 = 0x1,
                },
                /// Disables critical AXI Read-Under-Read.
                DISCRITAXIRUR: enum(u1) {
                    /// Normal operation.
                    DISCRITAXIRUR_0 = 0x0,
                    /// An AXI read to Strongly-Ordered or Device memory, or an LDREX to Shareable memory, is not put on AXI if there are any outstanding reads on AXI. Transactions on AXI cannot be interrupted. This bit might reduce the time that these transactions are in progress and might improve worst case interrupt latency. Performance is decreased when this bit is set.
                    DISCRITAXIRUR_1 = 0x1,
                },
                /// Disables dual-issued.
                DISDI: enum(u5) {
                    /// Normal operation.
                    DISDI_0 = 0x0,
                    /// Nothing can be dual-issued when this instruction type is in channel 0.
                    DISDI_1 = 0x1,
                    _,
                },
                /// Disables dual-issued.
                DISISSCH1: enum(u5) {
                    /// Normal operation.
                    DISISSCH1_0 = 0x0,
                    /// Nothing can be dual-issued when this instruction type is in channel 1.
                    DISISSCH1_1 = 0x1,
                    _,
                },
                /// Disables dynamic allocation of ADD and SUB instructions
                DISDYNADD: enum(u1) {
                    /// Normal operation. Some ADD and SUB instrctions are resolved in EX1.
                    DISDYNADD_0 = 0x0,
                    /// All ADD and SUB instructions are resolved in EX2.
                    DISDYNADD_1 = 0x1,
                },
                /// Disables critical AXI read-under-write
                DISCRITAXIRUW: enum(u1) {
                    /// Normal operation. This is backwards compatible with r0.
                    DISCRITAXIRUW_0 = 0x0,
                    /// AXI reads to DEV/SO memory. Exclusive reads to Shareable memory are not initiated on the AXIM AR channel until all outstanding stores on AXI are complete.
                    DISCRITAXIRUW_1 = 0x1,
                },
                /// Disables critical AXI read-under-write
                DISFPUISSOPT: enum(u1) {
                    /// Normal operation.
                    DISFPUISSOPT_0 = 0x0,
                    _,
                },
                padding: u3 = 0,
            }),
            reserved3328: [3316]u8,
            /// CPUID Base Register
            CPUID: mmio.Mmio(packed struct(u32) {
                /// Indicates patch release: 0x0 = Patch 0
                REVISION: u4,
                /// Indicates part number
                PARTNO: u12,
                /// ARCHITECTURE
                ARCHITECTURE: u4,
                /// Indicates processor revision: 0x2 = Revision 2
                VARIANT: u4,
                /// Implementer code
                IMPLEMENTER: u8,
            }),
            /// Interrupt Control and State Register
            ICSR: mmio.Mmio(packed struct(u32) {
                /// Active exception number
                VECTACTIVE: u9,
                reserved11: u2 = 0,
                /// Indicates whether there are preempted active exceptions
                RETTOBASE: enum(u1) {
                    /// there are preempted active exceptions to execute
                    RETTOBASE_0 = 0x0,
                    /// there are no active exceptions, or the currently-executing exception is the only active exception
                    RETTOBASE_1 = 0x1,
                },
                /// Exception number of the highest priority pending enabled exception
                VECTPENDING: u9,
                reserved22: u1 = 0,
                /// Interrupt pending flag, excluding NMI and Faults
                ISRPENDING: enum(u1) {
                    /// No external interrupt pending.
                    ISRPENDING_0 = 0x0,
                    /// External interrupt pending.
                    ISRPENDING_1 = 0x1,
                },
                reserved25: u2 = 0,
                /// SysTick exception clear-pending bit
                PENDSTCLR: enum(u1) {
                    /// no effect
                    PENDSTCLR_0 = 0x0,
                    /// removes the pending state from the SysTick exception
                    PENDSTCLR_1 = 0x1,
                },
                /// SysTick exception set-pending bit
                PENDSTSET: enum(u1) {
                    /// write: no effect; read: SysTick exception is not pending
                    PENDSTSET_0 = 0x0,
                    /// write: changes SysTick exception state to pending; read: SysTick exception is pending
                    PENDSTSET_1 = 0x1,
                },
                /// PendSV clear-pending bit
                PENDSVCLR: enum(u1) {
                    /// no effect
                    PENDSVCLR_0 = 0x0,
                    /// removes the pending state from the PendSV exception
                    PENDSVCLR_1 = 0x1,
                },
                /// PendSV set-pending bit
                PENDSVSET: enum(u1) {
                    /// write: no effect; read: PendSV exception is not pending
                    PENDSVSET_0 = 0x0,
                    /// write: changes PendSV exception state to pending; read: PendSV exception is pending
                    PENDSVSET_1 = 0x1,
                },
                reserved31: u2 = 0,
                /// NMI set-pending bit
                NMIPENDSET: enum(u1) {
                    /// write: no effect; read: NMI exception is not pending
                    NMIPENDSET_0 = 0x0,
                    /// write: changes NMI exception state to pending; read: NMI exception is pending
                    NMIPENDSET_1 = 0x1,
                },
            }),
            /// Vector Table Offset Register
            VTOR: mmio.Mmio(packed struct(u32) {
                reserved7: u7 = 0,
                /// Vector table base offset
                TBLOFF: u25,
            }),
            /// Application Interrupt and Reset Control Register
            AIRCR: mmio.Mmio(packed struct(u32) {
                /// Writing 1 to this bit causes a local system reset
                VECTRESET: enum(u1) {
                    /// No change
                    VECTRESET_0 = 0x0,
                    /// Causes a local system reset
                    VECTRESET_1 = 0x1,
                },
                /// Writing 1 to this bit clears all active state information for fixed and configurable exceptions.
                VECTCLRACTIVE: enum(u1) {
                    /// No change
                    VECTCLRACTIVE_0 = 0x0,
                    /// Clears all active state information for fixed and configurable exceptions
                    VECTCLRACTIVE_1 = 0x1,
                },
                /// System reset request
                SYSRESETREQ: enum(u1) {
                    /// no system reset request
                    SYSRESETREQ_0 = 0x0,
                    /// asserts a signal to the outer system that requests a reset
                    SYSRESETREQ_1 = 0x1,
                },
                reserved8: u5 = 0,
                /// Interrupt priority grouping field. This field determines the split of group priority from subpriority.
                PRIGROUP: u3,
                reserved15: u4 = 0,
                /// Data endianness
                ENDIANNESS: enum(u1) {
                    /// Little-endian
                    ENDIANNESS_0 = 0x0,
                    /// Big-endian
                    ENDIANNESS_1 = 0x1,
                },
                /// Register key
                VECTKEY: u16,
            }),
            /// System Control Register
            SCR: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// Indicates sleep-on-exit when returning from Handler mode to Thread mode
                SLEEPONEXIT: enum(u1) {
                    /// o not sleep when returning to Thread mode
                    SLEEPONEXIT_0 = 0x0,
                    /// enter sleep, or deep sleep, on return from an ISR
                    SLEEPONEXIT_1 = 0x1,
                },
                /// Controls whether the processor uses sleep or deep sleep as its low power mode
                SLEEPDEEP: enum(u1) {
                    /// sleep
                    SLEEPDEEP_0 = 0x0,
                    /// deep sleep
                    SLEEPDEEP_1 = 0x1,
                },
                reserved4: u1 = 0,
                /// Send Event on Pending bit
                SEVONPEND: enum(u1) {
                    /// only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded
                    SEVONPEND_0 = 0x0,
                    /// enabled events and all interrupts, including disabled interrupts, can wakeup the processor
                    SEVONPEND_1 = 0x1,
                },
                padding: u27 = 0,
            }),
            /// Configuration and Control Register
            CCR: mmio.Mmio(packed struct(u32) {
                /// Indicates how the processor enters Thread mode
                NONBASETHRDENA: enum(u1) {
                    /// processor can enter Thread mode only when no exception is active
                    NONBASETHRDENA_0 = 0x0,
                    /// processor can enter Thread mode from any level under the control of an EXC_RETURN value
                    NONBASETHRDENA_1 = 0x1,
                },
                /// Enables unprivileged software access to the STIR
                USERSETMPEND: enum(u1) {
                    /// disable
                    USERSETMPEND_0 = 0x0,
                    /// enable
                    USERSETMPEND_1 = 0x1,
                },
                reserved3: u1 = 0,
                /// Enables unaligned access traps
                UNALIGN_TRP: enum(u1) {
                    /// do not trap unaligned halfword and word accesses
                    UNALIGN_TRP_0 = 0x0,
                    /// trap unaligned halfword and word accesses
                    UNALIGN_TRP_1 = 0x1,
                },
                /// Enables faulting or halting when the processor executes an SDIV or UDIV instruction with a divisor of 0
                DIV_0_TRP: enum(u1) {
                    /// do not trap divide by 0
                    DIV_0_TRP_0 = 0x0,
                    /// trap divide by 0
                    DIV_0_TRP_1 = 0x1,
                },
                reserved8: u3 = 0,
                /// Enables handlers with priority -1 or -2 to ignore data BusFaults caused by load and store instructions.
                BFHFNMIGN: enum(u1) {
                    /// data bus faults caused by load and store instructions cause a lock-up
                    BFHFNMIGN_0 = 0x0,
                    /// handlers running at priority -1 and -2 ignore data bus faults caused by load and store instructions
                    BFHFNMIGN_1 = 0x1,
                },
                /// Indicates stack alignment on exception entry
                STKALIGN: enum(u1) {
                    /// 4-byte aligned
                    STKALIGN_0 = 0x0,
                    /// 8-byte aligned
                    STKALIGN_1 = 0x1,
                },
                reserved16: u6 = 0,
                /// Enables L1 data cache.
                DC: enum(u1) {
                    /// L1 data cache disabled
                    DC_0 = 0x0,
                    /// L1 data cache enabled
                    DC_1 = 0x1,
                },
                /// Enables L1 instruction cache.
                IC: enum(u1) {
                    /// L1 instruction cache disabled
                    IC_0 = 0x0,
                    /// L1 instruction cache enabled
                    IC_1 = 0x1,
                },
                /// Always reads-as-one. It indicates branch prediction is enabled.
                BP: u1,
                padding: u13 = 0,
            }),
            /// System Handler Priority Register 1
            SHPR1: mmio.Mmio(packed struct(u32) {
                /// Priority of system handler 4, MemManage
                PRI_4: u8,
                /// Priority of system handler 5, BusFault
                PRI_5: u8,
                /// Priority of system handler 6, UsageFault
                PRI_6: u8,
                padding: u8 = 0,
            }),
            /// System Handler Priority Register 2
            SHPR2: mmio.Mmio(packed struct(u32) {
                reserved24: u24 = 0,
                /// Priority of system handler 11, SVCall
                PRI_11: u8,
            }),
            /// System Handler Priority Register 3
            SHPR3: mmio.Mmio(packed struct(u32) {
                reserved16: u16 = 0,
                /// Priority of system handler 14, PendSV
                PRI_14: u8,
                /// Priority of system handler 15, SysTick exception
                PRI_15: u8,
            }),
            /// System Handler Control and State Register
            SHCSR: mmio.Mmio(packed struct(u32) {
                /// MemManage exception active bit
                MEMFAULTACT: enum(u1) {
                    /// exception is not active
                    MEMFAULTACT_0 = 0x0,
                    /// exception is active
                    MEMFAULTACT_1 = 0x1,
                },
                /// BusFault exception active bit
                BUSFAULTACT: enum(u1) {
                    /// exception is not active
                    BUSFAULTACT_0 = 0x0,
                    /// exception is active
                    BUSFAULTACT_1 = 0x1,
                },
                reserved3: u1 = 0,
                /// UsageFault exception active bit
                USGFAULTACT: enum(u1) {
                    /// exception is not active
                    USGFAULTACT_0 = 0x0,
                    /// exception is active
                    USGFAULTACT_1 = 0x1,
                },
                reserved7: u3 = 0,
                /// SVCall active bit
                SVCALLACT: enum(u1) {
                    /// exception is not active
                    SVCALLACT_0 = 0x0,
                    /// exception is active
                    SVCALLACT_1 = 0x1,
                },
                /// Debug monitor active bit
                MONITORACT: enum(u1) {
                    /// exception is not active
                    MONITORACT_0 = 0x0,
                    /// exception is active
                    MONITORACT_1 = 0x1,
                },
                reserved10: u1 = 0,
                /// PendSV exception active bit
                PENDSVACT: enum(u1) {
                    /// exception is not active
                    PENDSVACT_0 = 0x0,
                    /// exception is active
                    PENDSVACT_1 = 0x1,
                },
                /// SysTick exception active bit
                SYSTICKACT: enum(u1) {
                    /// exception is not active
                    SYSTICKACT_0 = 0x0,
                    /// exception is active
                    SYSTICKACT_1 = 0x1,
                },
                /// UsageFault exception pending bit
                USGFAULTPENDED: enum(u1) {
                    /// exception is not pending
                    USGFAULTPENDED_0 = 0x0,
                    /// exception is pending
                    USGFAULTPENDED_1 = 0x1,
                },
                /// MemManage exception pending bit
                MEMFAULTPENDED: enum(u1) {
                    /// exception is not pending
                    MEMFAULTPENDED_0 = 0x0,
                    /// exception is pending
                    MEMFAULTPENDED_1 = 0x1,
                },
                /// BusFault exception pending bit
                BUSFAULTPENDED: enum(u1) {
                    /// exception is not pending
                    BUSFAULTPENDED_0 = 0x0,
                    /// exception is pending
                    BUSFAULTPENDED_1 = 0x1,
                },
                /// SVCall pending bit
                SVCALLPENDED: enum(u1) {
                    /// exception is not pending
                    SVCALLPENDED_0 = 0x0,
                    /// exception is pending
                    SVCALLPENDED_1 = 0x1,
                },
                /// MemManage enable bit
                MEMFAULTENA: enum(u1) {
                    /// disable the exception
                    MEMFAULTENA_0 = 0x0,
                    /// enable the exception
                    MEMFAULTENA_1 = 0x1,
                },
                /// BusFault enable bit
                BUSFAULTENA: enum(u1) {
                    /// disable the exception
                    BUSFAULTENA_0 = 0x0,
                    /// enable the exception
                    BUSFAULTENA_1 = 0x1,
                },
                /// UsageFault enable bit
                USGFAULTENA: enum(u1) {
                    /// disable the exception
                    USGFAULTENA_0 = 0x0,
                    /// enable the exception
                    USGFAULTENA_1 = 0x1,
                },
                padding: u13 = 0,
            }),
            /// Configurable Fault Status Register
            CFSR: mmio.Mmio(packed struct(u32) {
                /// Instruction access violation flag
                IACCVIOL: enum(u1) {
                    /// no instruction access violation fault
                    IACCVIOL_0 = 0x0,
                    /// the processor attempted an instruction fetch from a location that does not permit execution
                    IACCVIOL_1 = 0x1,
                },
                /// Data access violation flag
                DACCVIOL: enum(u1) {
                    /// no data access violation fault
                    DACCVIOL_0 = 0x0,
                    /// the processor attempted a load or store at a location that does not permit the operation
                    DACCVIOL_1 = 0x1,
                },
                reserved3: u1 = 0,
                /// MemManage fault on unstacking for a return from exception
                MUNSTKERR: enum(u1) {
                    /// no unstacking fault
                    MUNSTKERR_0 = 0x0,
                    /// unstack for an exception return has caused one or more access violations
                    MUNSTKERR_1 = 0x1,
                },
                /// MemManage fault on stacking for exception entry
                MSTKERR: enum(u1) {
                    /// no stacking fault
                    MSTKERR_0 = 0x0,
                    /// stacking for an exception entry has caused one or more access violations
                    MSTKERR_1 = 0x1,
                },
                /// MemManage fault occurred during floating-point lazy state preservation
                MLSPERR: enum(u1) {
                    /// No MemManage fault occurred during floating-point lazy state preservation
                    MLSPERR_0 = 0x0,
                    /// A MemManage fault occurred during floating-point lazy state preservation
                    MLSPERR_1 = 0x1,
                },
                reserved7: u1 = 0,
                /// MemManage Fault Address Register (MMFAR) valid flag
                MMARVALID: enum(u1) {
                    /// value in MMAR is not a valid fault address
                    MMARVALID_0 = 0x0,
                    /// MMAR holds a valid fault address
                    MMARVALID_1 = 0x1,
                },
                /// Instruction bus error
                IBUSERR: enum(u1) {
                    /// no instruction bus error
                    IBUSERR_0 = 0x0,
                    /// instruction bus error
                    IBUSERR_1 = 0x1,
                },
                /// Precise data bus error
                PRECISERR: enum(u1) {
                    /// no precise data bus error
                    PRECISERR_0 = 0x0,
                    /// a data bus error has occurred, and the PC value stacked for the exception return points to the instruction that caused the fault
                    PRECISERR_1 = 0x1,
                },
                /// Imprecise data bus error
                IMPRECISERR: enum(u1) {
                    /// no imprecise data bus error
                    IMPRECISERR_0 = 0x0,
                    /// a data bus error has occurred, but the return address in the stack frame is not related to the instruction that caused the error
                    IMPRECISERR_1 = 0x1,
                },
                /// BusFault on unstacking for a return from exception
                UNSTKERR: enum(u1) {
                    /// no unstacking fault
                    UNSTKERR_0 = 0x0,
                    /// unstack for an exception return has caused one or more BusFaults
                    UNSTKERR_1 = 0x1,
                },
                /// BusFault on stacking for exception entry
                STKERR: enum(u1) {
                    /// no stacking fault
                    STKERR_0 = 0x0,
                    /// stacking for an exception entry has caused one or more BusFaults
                    STKERR_1 = 0x1,
                },
                /// Bus fault occurred during floating-point lazy state preservation
                LSPERR: enum(u1) {
                    /// No bus fault occurred during floating-point lazy state preservation
                    LSPERR_0 = 0x0,
                    /// A bus fault occurred during floating-point lazy state preservation
                    LSPERR_1 = 0x1,
                },
                reserved15: u1 = 0,
                /// BusFault Address Register (BFAR) valid flag
                BFARVALID: enum(u1) {
                    /// value in BFAR is not a valid fault address
                    BFARVALID_0 = 0x0,
                    /// BFAR holds a valid fault address
                    BFARVALID_1 = 0x1,
                },
                /// Undefined instruction UsageFault
                UNDEFINSTR: enum(u1) {
                    /// no undefined instruction UsageFault
                    UNDEFINSTR_0 = 0x0,
                    /// the processor has attempted to execute an undefined instruction
                    UNDEFINSTR_1 = 0x1,
                },
                /// Invalid state UsageFault
                INVSTATE: enum(u1) {
                    /// no invalid state UsageFault
                    INVSTATE_0 = 0x0,
                    /// the processor has attempted to execute an instruction that makes illegal use of the EPSR
                    INVSTATE_1 = 0x1,
                },
                /// Invalid PC load UsageFault, caused by an invalid PC load by EXC_RETURN
                INVPC: enum(u1) {
                    /// no invalid PC load UsageFault
                    INVPC_0 = 0x0,
                    /// the processor has attempted an illegal load of EXC_RETURN to the PC
                    INVPC_1 = 0x1,
                },
                /// No coprocessor UsageFault
                NOCP: enum(u1) {
                    /// no UsageFault caused by attempting to access a coprocessor
                    NOCP_0 = 0x0,
                    /// the processor has attempted to access a coprocessor
                    NOCP_1 = 0x1,
                },
                reserved24: u4 = 0,
                /// Unaligned access UsageFault
                UNALIGNED: enum(u1) {
                    /// no unaligned access fault, or unaligned access trapping not enabled
                    UNALIGNED_0 = 0x0,
                    /// the processor has made an unaligned memory access
                    UNALIGNED_1 = 0x1,
                },
                /// Divide by zero UsageFault
                DIVBYZERO: enum(u1) {
                    /// no divide by zero fault, or divide by zero trapping not enabled
                    DIVBYZERO_0 = 0x0,
                    /// the processor has executed an SDIV or UDIV instruction with a divisor of 0
                    DIVBYZERO_1 = 0x1,
                },
                padding: u6 = 0,
            }),
            /// HardFault Status register
            HFSR: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// Indicates a BusFault on a vector table read during exception processing.
                VECTTBL: enum(u1) {
                    /// no BusFault on vector table read
                    VECTTBL_0 = 0x0,
                    /// BusFault on vector table read
                    VECTTBL_1 = 0x1,
                },
                reserved30: u28 = 0,
                /// Indicates a forced hard fault, generated by escalation of a fault with configurable priority that cannot be handles, either because of priority or because it is disabled.
                FORCED: enum(u1) {
                    /// no forced HardFault
                    FORCED_0 = 0x0,
                    /// forced HardFault
                    FORCED_1 = 0x1,
                },
                /// Reserved for Debug use. When writing to the register you must write 0 to this bit, otherwise behavior is Unpredictable.
                DEBUGEVT: enum(u1) {
                    /// No Debug event has occurred.
                    DEBUGEVT_0 = 0x0,
                    /// Debug event has occurred. The Debug Fault Status Register has been updated.
                    DEBUGEVT_1 = 0x1,
                },
            }),
            /// Debug Fault Status Register
            DFSR: mmio.Mmio(packed struct(u32) {
                /// Indicates a debug event generated by either a C_HALT or C_STEP request, triggered by a write to the DHCSR or a step request triggered by setting DEMCR.MON_STEP to 1.
                HALTED: enum(u1) {
                    /// No active halt request debug event
                    HALTED_0 = 0x0,
                    /// Halt request debug event active
                    HALTED_1 = 0x1,
                },
                /// Debug event generated by BKPT instruction execution or a breakpoint match in FPB
                BKPT: enum(u1) {
                    /// No current breakpoint debug event
                    BKPT_0 = 0x0,
                    /// At least one current breakpoint debug event
                    BKPT_1 = 0x1,
                },
                /// Debug event generated by the DWT
                DWTTRAP: enum(u1) {
                    /// No current debug events generated by the DWT
                    DWTTRAP_0 = 0x0,
                    /// At least one current debug event generated by the DWT
                    DWTTRAP_1 = 0x1,
                },
                /// Indicates triggering of a Vector catch
                VCATCH: enum(u1) {
                    /// No Vector catch triggered
                    VCATCH_0 = 0x0,
                    /// Vector catch triggered
                    VCATCH_1 = 0x1,
                },
                /// Debug event generated because of the assertion of an external debug request
                EXTERNAL: enum(u1) {
                    /// No external debug request debug event
                    EXTERNAL_0 = 0x0,
                    /// External debug request debug event
                    EXTERNAL_1 = 0x1,
                },
                padding: u27 = 0,
            }),
            /// MemManage Fault Address Register
            MMFAR: mmio.Mmio(packed struct(u32) {
                /// Address of MemManage fault location
                ADDRESS: u32,
            }),
            /// BusFault Address Register
            BFAR: mmio.Mmio(packed struct(u32) {
                /// Address of the BusFault location
                ADDRESS: u32,
            }),
            reserved3392: [4]u8,
            /// Processor Feature Register 0
            ID_PFR0: mmio.Mmio(packed struct(u32) {
                /// ARM instruction set support
                STATE0: enum(u4) {
                    /// ARMv7-M unused
                    STATE0_0 = 0x0,
                    /// ARMv7-M unused
                    STATE0_1 = 0x1,
                    /// ARMv7-M unused
                    STATE0_2 = 0x2,
                    /// Support for Thumb encoding including Thumb-2 technology, with all basic 16-bit and 32-bit instructions.
                    STATE0_3 = 0x3,
                    _,
                },
                /// Thumb instruction set support
                STATE1: enum(u4) {
                    /// The processor does not support the ARM instruction set.
                    STATE1_0 = 0x0,
                    /// ARMv7-M unused
                    STATE1_1 = 0x1,
                    _,
                },
                /// ARMv7-M unused
                STATE2: u4,
                /// ARMv7-M unused
                STATE3: u4,
                padding: u16 = 0,
            }),
            /// Processor Feature Register 1
            ID_PFR1: mmio.Mmio(packed struct(u32) {
                reserved8: u8 = 0,
                /// M profile programmers' model
                PROGMODEL: enum(u4) {
                    /// ARMv7-M unused
                    PROGMODEL_0 = 0x0,
                    /// Two-stack programmers' model supported
                    PROGMODEL_2 = 0x2,
                    _,
                },
                padding: u20 = 0,
            }),
            /// Debug Feature Register
            ID_DFR0: mmio.Mmio(packed struct(u32) {
                reserved20: u20 = 0,
                /// Support for memory-mapped debug model for M profile processors
                DEBUGMODEL: enum(u4) {
                    /// Not supported
                    DEBUGMODEL_0 = 0x0,
                    /// Support for M profile Debug architecture, with memory-mapped access.
                    DEBUGMODEL_1 = 0x1,
                    _,
                },
                padding: u8 = 0,
            }),
            /// Auxiliary Feature Register
            ID_AFR0: mmio.Mmio(packed struct(u32) {
                /// Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
                IMPLEMENTATION_DEFINED0: u4,
                /// Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
                IMPLEMENTATION_DEFINED1: u4,
                /// Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
                IMPLEMENTATION_DEFINED2: u4,
                /// Gives information about the IMPLEMENTATION DEFINED features of a processor implementation.
                IMPLEMENTATION_DEFINED3: u4,
                padding: u16 = 0,
            }),
            /// Memory Model Feature Register 0
            ID_MMFR0: mmio.Mmio(packed struct(u32) {
                reserved4: u4 = 0,
                /// Indicates support for a PMSA
                PMSASUPPORT: enum(u4) {
                    /// Not supported
                    PMSASUPPORT_0 = 0x0,
                    /// ARMv7-M unused
                    PMSASUPPORT_1 = 0x1,
                    /// ARMv7-M unused
                    PMSASUPPORT_2 = 0x2,
                    /// PMSAv7, providing support for a base region and subregions.
                    PMSASUPPORT_3 = 0x3,
                    _,
                },
                /// Indicates the outermost shareability domain implemented
                OUTERMOST_SHAREABILITY: enum(u4) {
                    /// Implemented as Non-cacheable
                    OUTERMOST_SHAREABILITY_0 = 0x0,
                    /// ARMv7-M unused
                    OUTERMOST_SHAREABILITY_1 = 0x1,
                    /// ARMv7-M unused
                    OUTERMOST_SHAREABILITY_2 = 0x2,
                    /// ARMv7-M unused
                    OUTERMOST_SHAREABILITY_3 = 0x3,
                    /// ARMv7-M unused
                    OUTERMOST_SHAREABILITY_4 = 0x4,
                    /// ARMv7-M unused
                    OUTERMOST_SHAREABILITY_5 = 0x5,
                    /// ARMv7-M unused
                    OUTERMOST_SHAREABILITY_6 = 0x6,
                    /// ARMv7-M unused
                    OUTERMOST_SHAREABILITY_7 = 0x7,
                    /// ARMv7-M unused
                    OUTERMOST_SHAREABILITY_8 = 0x8,
                    /// ARMv7-M unused
                    OUTERMOST_SHAREABILITY_9 = 0x9,
                    /// ARMv7-M unused
                    OUTERMOST_SHAREABILITY_10 = 0xa,
                    /// ARMv7-M unused
                    OUTERMOST_SHAREABILITY_11 = 0xb,
                    /// ARMv7-M unused
                    OUTERMOST_SHAREABILITY_12 = 0xc,
                    /// ARMv7-M unused
                    OUTERMOST_SHAREABILITY_13 = 0xd,
                    /// ARMv7-M unused
                    OUTERMOST_SHAREABILITY_14 = 0xe,
                    /// Shareability ignored.
                    OUTERMOST_SHAREABILITY_15 = 0xf,
                },
                /// Indicates the number of shareability levels implemented
                SHAREABILITY_LEVELS: enum(u4) {
                    /// One level of shareability implemented
                    SHAREABILITY_LEVELS_0 = 0x0,
                    /// ARMv7-M unused
                    SHAREABILITY_LEVELS_1 = 0x1,
                    _,
                },
                /// Indicates the support for Tightly Coupled Memory
                TCM_SUPPORT: enum(u4) {
                    /// No tightly coupled memories implemented.
                    TCM_SUPPORT_0 = 0x0,
                    /// Tightly coupled memories implemented with IMPLEMENTATION DEFINED control.
                    TCM_SUPPORT_1 = 0x1,
                    /// ARMv7-M unused
                    TCM_SUPPORT_2 = 0x2,
                    _,
                },
                /// Indicates the support for Auxiliary registers
                AUXILIARY_REGISTERS: enum(u4) {
                    /// Not supported
                    AUXILIARY_REGISTERS_0 = 0x0,
                    /// Support for Auxiliary Control Register only.
                    AUXILIARY_REGISTERS_1 = 0x1,
                    /// ARMv7-M unused
                    AUXILIARY_REGISTERS_2 = 0x2,
                    _,
                },
                padding: u8 = 0,
            }),
            /// Memory Model Feature Register 1
            ID_MMFR1: mmio.Mmio(packed struct(u32) {
                /// Gives information about the implemented memory model and memory management support.
                ID_MMFR1: u32,
            }),
            /// Memory Model Feature Register 2
            ID_MMFR2: mmio.Mmio(packed struct(u32) {
                reserved24: u24 = 0,
                /// Indicates the support for Wait For Interrupt (WFI) stalling
                WFI_STALL: enum(u4) {
                    /// Not supported
                    WFI_STALL_0 = 0x0,
                    /// Support for WFI stalling
                    WFI_STALL_1 = 0x1,
                    _,
                },
                padding: u4 = 0,
            }),
            /// Memory Model Feature Register 3
            ID_MMFR3: mmio.Mmio(packed struct(u32) {
                /// Gives information about the implemented memory model and memory management support.
                ID_MMFR3: u32,
            }),
            /// Instruction Set Attributes Register 0
            ID_ISAR0: mmio.Mmio(packed struct(u32) {
                reserved4: u4 = 0,
                /// Indicates the supported Bit Counting instructions
                BITCOUNT_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused
                    BITCOUNT_INSTRS_0 = 0x0,
                    /// Adds support for the CLZ instruction
                    BITCOUNT_INSTRS_1 = 0x1,
                    _,
                },
                /// Indicates the supported BitField instructions
                BITFIELD_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused
                    BITFIELD_INSTRS_0 = 0x0,
                    /// Adds support for the BFC, BFI, SBFX, and UBFX instructions
                    BITFIELD_INSTRS_1 = 0x1,
                    _,
                },
                /// Indicates the supported combined Compare and Branch instructions
                CMPBRANCH_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused
                    CMPBRANCH_INSTRS_0 = 0x0,
                    /// Adds support for the CBNZ and CBZ instructions
                    CMPBRANCH_INSTRS_1 = 0x1,
                    _,
                },
                /// Indicates the supported Coprocessor instructions
                COPROC_INSTRS: enum(u4) {
                    /// None supported, except for separately attributed architectures, for example the Floating-point extension
                    COPROC_INSTRS_0 = 0x0,
                    /// Adds support for generic CDP, LDC, MCR, MRC, and STC instructions
                    COPROC_INSTRS_1 = 0x1,
                    /// As for 1, and adds support for generic CDP2, LDC2, MCR2, MRC2, and STC2 instructions
                    COPROC_INSTRS_2 = 0x2,
                    /// As for 2, and adds support for generic MCRR and MRRC instructions
                    COPROC_INSTRS_3 = 0x3,
                    /// As for 3, and adds support for generic MCRR2 and MRRC2 instructions
                    COPROC_INSTRS_4 = 0x4,
                    _,
                },
                /// Indicates the supported Debug instructions
                DEBUG_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused
                    DEBUG_INSTRS_0 = 0x0,
                    /// Adds support for the BKPT instruction
                    DEBUG_INSTRS_1 = 0x1,
                    _,
                },
                /// Indicates the supported Divide instructions
                DIVIDE_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused
                    DIVIDE_INSTRS_0 = 0x0,
                    /// Adds support for the SDIV and UDIV instructions
                    DIVIDE_INSTRS_1 = 0x1,
                    _,
                },
                padding: u4 = 0,
            }),
            /// Instruction Set Attributes Register 1
            ID_ISAR1: mmio.Mmio(packed struct(u32) {
                reserved12: u12 = 0,
                /// Indicates the supported Extend instructions
                EXTEND_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused
                    EXTEND_INSTRS_0 = 0x0,
                    /// Adds support for the SXTB, SXTH, UXTB, and UXTH instructions
                    EXTEND_INSTRS_1 = 0x1,
                    /// As for 1, and adds support for the SXTAB, SXTAB16, SXTAH, SXTB16, UXTAB, UXTAB16, UXTAH, and UXTB16 instructions
                    EXTEND_INSTRS_2 = 0x2,
                    _,
                },
                /// Indicates the supported IfThen instructions
                IFTHEN_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused
                    IFTHEN_INSTRS_0 = 0x0,
                    /// Adds support for the IT instructions, and for the IT bits in the PSRs
                    IFTHEN_INSTRS_1 = 0x1,
                    _,
                },
                /// Indicates the support for data-processing instructions with long immediate
                IMMEDIATE_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused
                    IMMEDIATE_INSTRS_0 = 0x0,
                    /// Adds support for the ADDW, MOVW, MOVT, and SUBW instructions
                    IMMEDIATE_INSTRS_1 = 0x1,
                    _,
                },
                /// Indicates the supported Interworking instructions
                INTERWORK_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused
                    INTERWORK_INSTRS_0 = 0x0,
                    /// Adds support for the BX instruction, and the T bit in the PSR
                    INTERWORK_INSTRS_1 = 0x1,
                    /// As for 1, and adds support for the BLX instruction, and PC loads have BX-like behavior
                    INTERWORK_INSTRS_2 = 0x2,
                    /// ARMv7-M unused
                    INTERWORK_INSTRS_3 = 0x3,
                    _,
                },
                padding: u4 = 0,
            }),
            /// Instruction Set Attributes Register 2
            ID_ISAR2: mmio.Mmio(packed struct(u32) {
                /// Indicates the supported additional load and store instructions
                LOADSTORE_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused
                    LOADSTORE_INSTRS_0 = 0x0,
                    /// Adds support for the LDRD and STRD instructions
                    LOADSTORE_INSTRS_1 = 0x1,
                    _,
                },
                /// Indicates the supported Memory Hint instructions
                MEMHINT_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused.
                    MEMHINT_INSTRS_0 = 0x0,
                    /// Adds support for the PLD instruction, ARMv7-M unused.
                    MEMHINT_INSTRS_1 = 0x1,
                    /// As for 1, ARMv7-M unused.
                    MEMHINT_INSTRS_2 = 0x2,
                    /// As for 1 or 2, and adds support for the PLI instruction.
                    MEMHINT_INSTRS_3 = 0x3,
                    _,
                },
                /// Indicates the support for multi-access interruptible instructions
                MULTIACCESSINT_INSTRS: enum(u4) {
                    /// None supported. This means the LDM and STM instructions are not interruptible. ARMv7-M unused.
                    MULTIACCESSINT_INSTRS_0 = 0x0,
                    /// LDM and STM instructions are restartable.
                    MULTIACCESSINT_INSTRS_1 = 0x1,
                    /// LDM and STM instructions are continuable.
                    MULTIACCESSINT_INSTRS_2 = 0x2,
                    _,
                },
                /// Indicates the supported additional Multiply instructions
                MULT_INSTRS: enum(u4) {
                    /// None supported. This means only MUL is supported. ARMv7-M unused.
                    MULT_INSTRS_0 = 0x0,
                    /// Adds support for the MLA instruction, ARMv7-M unused.
                    MULT_INSTRS_1 = 0x1,
                    /// As for 1, and adds support for the MLS instruction.
                    MULT_INSTRS_2 = 0x2,
                    _,
                },
                /// Indicates the supported advanced signed Multiply instructions
                MULTS_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused
                    MULTS_INSTRS_0 = 0x0,
                    /// Adds support for the SMULL and SMLAL instructions
                    MULTS_INSTRS_1 = 0x1,
                    /// As for 1, and adds support for the SMLABB, SMLABT, SMLALBB, SMLALBT, SMLALTB, SMLALTT, SMLATB, SMLATT, SMLAWB, SMLAWT, SMULBB, SMULBT, SMULTB, SMULTT, SMULWB, and SMULWT instructions.
                    MULTS_INSTRS_2 = 0x2,
                    /// As for 2, and adds support for the SMLAD, SMLADX, SMLALD, SMLALDX, SMLSD, SMLSDX, SMLSLD, SMLSLDX, SMMLA, SMMLAR, SMMLS, SMMLSR, SMMUL, SMMULR, SMUAD, SMUADX, SMUSD, and SMUSDX instructions.
                    MULTS_INSTRS_3 = 0x3,
                    _,
                },
                /// Indicates the supported advanced unsigned Multiply instructions
                MULTU_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused
                    MULTU_INSTRS_0 = 0x0,
                    /// Adds support for the UMULL and UMLAL instructions.
                    MULTU_INSTRS_1 = 0x1,
                    /// As for 1, and adds support for the UMAAL instruction.
                    MULTU_INSTRS_2 = 0x2,
                    _,
                },
                reserved28: u4 = 0,
                /// Indicates the supported Reversal instructions
                REVERSAL_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused
                    REVERSAL_INSTRS_0 = 0x0,
                    /// Adds support for the REV, REV16, and REVSH instructions, ARMv7-M unused.
                    REVERSAL_INSTRS_1 = 0x1,
                    /// As for 1, and adds support for the RBIT instruction.
                    REVERSAL_INSTRS_2 = 0x2,
                    _,
                },
            }),
            /// Instruction Set Attributes Register 3
            ID_ISAR3: mmio.Mmio(packed struct(u32) {
                /// Indicates the supported Saturate instructions
                SATURATE_INSTRS: enum(u4) {
                    /// None supported
                    SATURATE_INSTRS_0 = 0x0,
                    /// Adds support for the QADD, QDADD, QDSUB, and QSUB instructions, and for the Q bit in the PSRs.
                    SATURATE_INSTRS_1 = 0x1,
                    _,
                },
                /// Indicates the supported SIMD instructions
                SIMD_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused.
                    SIMD_INSTRS_0 = 0x0,
                    /// Adds support for the SSAT and USAT instructions, and for the Q bit in the PSRs.
                    SIMD_INSTRS_1 = 0x1,
                    /// As for 1, and adds support for the PKHBT, PKHTB, QADD16, QADD8, QASX, QSUB16, QSUB8, QSAX, SADD16, SADD8, SASX, SEL, SHADD16, SHADD8, SHASX, SHSUB16, SHSUB8, SHSAX, SSAT16, SSUB16, SSUB8, SSAX, SXTAB16, SXTB16, UADD16, UADD8, UASX, UHADD16, UHADD8, UHASX, UHSUB16, UHSUB8, UHSAX, UQADD16, UQADD8, UQASX, UQSUB16, UQSUB8, UQSAX, USAD8, USADA8, USAT16, USUB16, USUB8, USAX, UXTAB16, and UXTB16 instructions. Also adds support for the GE[3:0] bits in the PSRs.
                    SIMD_INSTRS_3 = 0x3,
                    _,
                },
                /// Indicates the supported SVC instructions
                SVC_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused.
                    SVC_INSTRS_0 = 0x0,
                    /// Adds support for the SVC instruction.
                    SVC_INSTRS_1 = 0x1,
                    _,
                },
                /// Together with the ID_ISAR4[SYNCHPRIM_INSTRS_FRAC] indicates the supported Synchronization Primitives
                SYNCHPRIM_INSTRS: u4,
                /// Indicates the supported Table Branch instructions
                TABBRANCH_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused.
                    TABBRANCH_INSTRS_0 = 0x0,
                    /// Adds support for the TBB and TBH instructions.
                    TABBRANCH_INSTRS_1 = 0x1,
                    _,
                },
                /// Indicates the supported non flag-setting MOV instructions
                THUMBCOPY_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused.
                    THUMBCOPY_INSTRS_0 = 0x0,
                    /// Adds support for encoding T1 of the MOV (register) instruction copying from a low register to a low register.
                    THUMBCOPY_INSTRS_1 = 0x1,
                    _,
                },
                /// Indicates the supported non flag-setting MOV instructions
                TRUENOP_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused.
                    TRUENOP_INSTRS_0 = 0x0,
                    /// Adds support for encoding T1 of the MOV (register) instruction copying from a low register to a low register.
                    TRUENOP_INSTRS_1 = 0x1,
                    _,
                },
                padding: u4 = 0,
            }),
            /// Instruction Set Attributes Register 4
            ID_ISAR4: mmio.Mmio(packed struct(u32) {
                /// Indicates the supported unprivileged instructions. These are the instruction variants indicated by a T suffix.
                UNPRIV_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused.
                    UNPRIV_INSTRS_0 = 0x0,
                    /// Adds support for the LDRBT, LDRT, STRBT, and STRT instructions.
                    UNPRIV_INSTRS_1 = 0x1,
                    /// As for 1, and adds support for the LDRHT, LDRSBT, LDRSHT, and STRHT instructions.
                    UNPRIV_INSTRS_2 = 0x2,
                    _,
                },
                /// Indicates the support for instructions with shifts
                WITHSHIFTS_INSTRS: enum(u4) {
                    /// Nonzero shifts supported only in MOV and shift instructions.
                    WITHSHIFTS_INSTRS_0 = 0x0,
                    /// Adds support for shifts of loads and stores over the range LSL 0-3.
                    WITHSHIFTS_INSTRS_1 = 0x1,
                    /// As for 1, and adds support for other constant shift options, on loads, stores, and other instructions.
                    WITHSHIFTS_INSTRS_3 = 0x3,
                    /// ARMv7-M unused.
                    WITHSHIFTS_INSTRS_4 = 0x4,
                    _,
                },
                /// Indicates the support for Writeback addressing modes
                WRITEBACK_INSTRS: enum(u4) {
                    /// Basic support. Only the LDM, STM, PUSH, and POP instructions support writeback addressing modes. ARMv7-M unused.
                    WRITEBACK_INSTRS_0 = 0x0,
                    /// Adds support for all of the writeback addressing modes defined in the ARMv7-M architecture.
                    WRITEBACK_INSTRS_1 = 0x1,
                    _,
                },
                reserved16: u4 = 0,
                /// Indicates the supported Barrier instructions
                BARRIER_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused.
                    BARRIER_INSTRS_0 = 0x0,
                    /// Adds support for the DMB, DSB, and ISB barrier instructions.
                    BARRIER_INSTRS_1 = 0x1,
                    _,
                },
                /// Together with the ID_ISAR3[SYNCHPRIM_INSTRS] indicates the supported Synchronization Primitives
                SYNCHPRIM_INSTRS_FRAC: u4,
                /// Indicates the supported M profile instructions to modify the PSRs
                PSR_M_INSTRS: enum(u4) {
                    /// None supported, ARMv7-M unused.
                    PSR_M_INSTRS_0 = 0x0,
                    /// Adds support for the M-profile forms of the CPS, MRS, and MSR instructions, to access the PSRs.
                    PSR_M_INSTRS_1 = 0x1,
                    _,
                },
                padding: u4 = 0,
            }),
            reserved3448: [4]u8,
            /// Cache Level ID register
            CLIDR: mmio.Mmio(packed struct(u32) {
                /// Indicate the type of cache implemented at level 1.
                CL1: enum(u3) {
                    /// No cache
                    CL1_0 = 0x0,
                    /// Instruction cache only
                    CL1_1 = 0x1,
                    /// Data cache only
                    CL1_2 = 0x2,
                    /// Separate instruction and data caches
                    CL1_3 = 0x3,
                    /// Unified cache
                    CL1_4 = 0x4,
                    _,
                },
                /// Indicate the type of cache implemented at level 2.
                CL2: enum(u3) {
                    /// No cache
                    CL2_0 = 0x0,
                    /// Instruction cache only
                    CL2_1 = 0x1,
                    /// Data cache only
                    CL2_2 = 0x2,
                    /// Separate instruction and data caches
                    CL2_3 = 0x3,
                    /// Unified cache
                    CL2_4 = 0x4,
                    _,
                },
                /// Indicate the type of cache implemented at level 3.
                CL3: enum(u3) {
                    /// No cache
                    CL3_0 = 0x0,
                    /// Instruction cache only
                    CL3_1 = 0x1,
                    /// Data cache only
                    CL3_2 = 0x2,
                    /// Separate instruction and data caches
                    CL3_3 = 0x3,
                    /// Unified cache
                    CL3_4 = 0x4,
                    _,
                },
                /// Indicate the type of cache implemented at level 4.
                CL4: enum(u3) {
                    /// No cache
                    CL4_0 = 0x0,
                    /// Instruction cache only
                    CL4_1 = 0x1,
                    /// Data cache only
                    CL4_2 = 0x2,
                    /// Separate instruction and data caches
                    CL4_3 = 0x3,
                    /// Unified cache
                    CL4_4 = 0x4,
                    _,
                },
                /// Indicate the type of cache implemented at level 5.
                CL5: enum(u3) {
                    /// No cache
                    CL5_0 = 0x0,
                    /// Instruction cache only
                    CL5_1 = 0x1,
                    /// Data cache only
                    CL5_2 = 0x2,
                    /// Separate instruction and data caches
                    CL5_3 = 0x3,
                    /// Unified cache
                    CL5_4 = 0x4,
                    _,
                },
                /// Indicate the type of cache implemented at level 6.
                CL6: enum(u3) {
                    /// No cache
                    CL6_0 = 0x0,
                    /// Instruction cache only
                    CL6_1 = 0x1,
                    /// Data cache only
                    CL6_2 = 0x2,
                    /// Separate instruction and data caches
                    CL6_3 = 0x3,
                    /// Unified cache
                    CL6_4 = 0x4,
                    _,
                },
                /// Indicate the type of cache implemented at level 7.
                CL7: enum(u3) {
                    /// No cache
                    CL7_0 = 0x0,
                    /// Instruction cache only
                    CL7_1 = 0x1,
                    /// Data cache only
                    CL7_2 = 0x2,
                    /// Separate instruction and data caches
                    CL7_3 = 0x3,
                    /// Unified cache
                    CL7_4 = 0x4,
                    _,
                },
                /// Level of Unification Inner Shareable for the cache hierarchy. This field is RAZ.
                LOUIS: enum(u3) {
                    /// 0
                    LOUIS_0 = 0x0,
                    /// 1
                    LOUIS_1 = 0x1,
                    /// 2
                    LOUIS_2 = 0x2,
                    /// 3
                    LOUIS_3 = 0x3,
                    /// 4
                    LOUIS_4 = 0x4,
                    /// 5
                    LOUIS_5 = 0x5,
                    /// 6
                    LOUIS_6 = 0x6,
                    /// 7
                    LOUIS_7 = 0x7,
                },
                /// Level of Coherency for the cache hierarchy
                LOC: enum(u3) {
                    /// 0
                    LOC_0 = 0x0,
                    /// 1
                    LOC_1 = 0x1,
                    /// 2
                    LOC_2 = 0x2,
                    /// 3
                    LOC_3 = 0x3,
                    /// 4
                    LOC_4 = 0x4,
                    /// 5
                    LOC_5 = 0x5,
                    /// 6
                    LOC_6 = 0x6,
                    /// 7
                    LOC_7 = 0x7,
                },
                /// Level of Unification for the cache hierarchy
                LOU: enum(u3) {
                    /// 0
                    LOU_0 = 0x0,
                    /// 1
                    LOU_1 = 0x1,
                    /// 2
                    LOU_2 = 0x2,
                    /// 3
                    LOU_3 = 0x3,
                    /// 4
                    LOU_4 = 0x4,
                    /// 5
                    LOU_5 = 0x5,
                    /// 6
                    LOU_6 = 0x6,
                    /// 7
                    LOU_7 = 0x7,
                },
                padding: u2 = 0,
            }),
            /// Cache Type register
            CTR: mmio.Mmio(packed struct(u32) {
                /// Log2 of the number of words in the smallest cache line of all the instruction caches that are controlled by the processor.
                IMINLINE: u4,
                reserved16: u12 = 0,
                /// Log2 of the number of words in the smallest cache line of all the data caches and unified caches that are controlled by the processor.
                DMINLINE: u4,
                /// Exclusives Reservation Granule. The maximum size of the reservation granule that has been implemented for the Load-Exclusive and Store-Exclusive instructions, encoded as Log2 of the number of words.
                ERG: u4,
                /// Cache Write-back Granule. The maximum size of memory that can be overwritten as a result of the eviction of a cache entry that has had a memory location in it modified, encoded as Log2 of the number of words.
                CWG: u4,
                reserved29: u1 = 0,
                /// Indicates the implemented CTR format.
                FORMAT: enum(u3) {
                    /// ARMv7 format.
                    FORMAT_4 = 0x4,
                    _,
                },
            }),
            /// Cache Size ID Register
            CCSIDR: mmio.Mmio(packed struct(u32) {
                /// (Log2(Number of words in cache line)) - 2.
                LINESIZE: enum(u3) {
                    /// The line length of 4 words.
                    LINESIZE_0 = 0x0,
                    /// The line length of 8 words.
                    LINESIZE_1 = 0x1,
                    /// The line length of 16 words.
                    LINESIZE_2 = 0x2,
                    /// The line length of 32 words.
                    LINESIZE_3 = 0x3,
                    /// The line length of 64 words.
                    LINESIZE_4 = 0x4,
                    /// The line length of 128 words.
                    LINESIZE_5 = 0x5,
                    /// The line length of 256 words.
                    LINESIZE_6 = 0x6,
                    /// The line length of 512 words.
                    LINESIZE_7 = 0x7,
                },
                /// (Associativity of cache) - 1, therefore a value of 0 indicates an associativity of 1. The associativity does not have to be a power of 2.
                ASSOCIATIVITY: u10,
                /// (Number of sets in cache) - 1, therefore a value of 0 indicates 1 set in the cache. The number of sets does not have to be a power of 2.
                NUMSETS: u15,
                /// Indicates whether the cache level supports write-allocation
                WA: enum(u1) {
                    /// Feature not supported
                    WA_0 = 0x0,
                    /// Feature supported
                    WA_1 = 0x1,
                },
                /// Indicates whether the cache level supports read-allocation
                RA: enum(u1) {
                    /// Feature not supported
                    RA_0 = 0x0,
                    /// Feature supported
                    RA_1 = 0x1,
                },
                /// Indicates whether the cache level supports write-back
                WB: enum(u1) {
                    /// Feature not supported
                    WB_0 = 0x0,
                    /// Feature supported
                    WB_1 = 0x1,
                },
                /// Indicates whether the cache level supports write-through
                WT: enum(u1) {
                    /// Feature not supported
                    WT_0 = 0x0,
                    /// Feature supported
                    WT_1 = 0x1,
                },
            }),
            /// Cache Size Selection Register
            CSSELR: mmio.Mmio(packed struct(u32) {
                /// Instruction not data bit
                IND: enum(u1) {
                    /// Data or unified cache.
                    IND_0 = 0x0,
                    /// Instruction cache.
                    IND_1 = 0x1,
                },
                /// Cache level of required cache
                LEVEL: enum(u3) {
                    /// Level 1 cache.
                    LEVEL_0 = 0x0,
                    /// Level 2 cache.
                    LEVEL_1 = 0x1,
                    /// Level 3 cache.
                    LEVEL_2 = 0x2,
                    /// Level 4 cache.
                    LEVEL_3 = 0x3,
                    /// Level 5 cache.
                    LEVEL_4 = 0x4,
                    /// Level 6 cache.
                    LEVEL_5 = 0x5,
                    /// Level 7 cache.
                    LEVEL_6 = 0x6,
                    _,
                },
                padding: u28 = 0,
            }),
            /// Coprocessor Access Control Register
            CPACR: mmio.Mmio(packed struct(u32) {
                /// Access privileges for coprocessor 0.
                CP0: enum(u2) {
                    /// Access denied. Any attempted access generates a NOCP UsageFault.
                    CP0_0 = 0x0,
                    /// Privileged access only. An unprivileged access generates a NOCP UsageFault.
                    CP0_1 = 0x1,
                    /// Full access.
                    CP0_3 = 0x3,
                    _,
                },
                /// Access privileges for coprocessor 1.
                CP1: enum(u2) {
                    /// Access denied. Any attempted access generates a NOCP UsageFault.
                    CP1_0 = 0x0,
                    /// Privileged access only. An unprivileged access generates a NOCP UsageFault.
                    CP1_1 = 0x1,
                    /// Full access.
                    CP1_3 = 0x3,
                    _,
                },
                /// Access privileges for coprocessor 2.
                CP2: enum(u2) {
                    /// Access denied. Any attempted access generates a NOCP UsageFault.
                    CP2_0 = 0x0,
                    /// Privileged access only. An unprivileged access generates a NOCP UsageFault.
                    CP2_1 = 0x1,
                    /// Full access.
                    CP2_3 = 0x3,
                    _,
                },
                /// Access privileges for coprocessor 3.
                CP3: enum(u2) {
                    /// Access denied. Any attempted access generates a NOCP UsageFault.
                    CP3_0 = 0x0,
                    /// Privileged access only. An unprivileged access generates a NOCP UsageFault.
                    CP3_1 = 0x1,
                    /// Full access.
                    CP3_3 = 0x3,
                    _,
                },
                /// Access privileges for coprocessor 4.
                CP4: enum(u2) {
                    /// Access denied. Any attempted access generates a NOCP UsageFault.
                    CP4_0 = 0x0,
                    /// Privileged access only. An unprivileged access generates a NOCP UsageFault.
                    CP4_1 = 0x1,
                    /// Full access.
                    CP4_3 = 0x3,
                    _,
                },
                /// Access privileges for coprocessor 5.
                CP5: enum(u2) {
                    /// Access denied. Any attempted access generates a NOCP UsageFault.
                    CP5_0 = 0x0,
                    /// Privileged access only. An unprivileged access generates a NOCP UsageFault.
                    CP5_1 = 0x1,
                    /// Full access.
                    CP5_3 = 0x3,
                    _,
                },
                /// Access privileges for coprocessor 6.
                CP6: enum(u2) {
                    /// Access denied. Any attempted access generates a NOCP UsageFault.
                    CP6_0 = 0x0,
                    /// Privileged access only. An unprivileged access generates a NOCP UsageFault.
                    CP6_1 = 0x1,
                    /// Full access.
                    CP6_3 = 0x3,
                    _,
                },
                /// Access privileges for coprocessor 7.
                CP7: enum(u2) {
                    /// Access denied. Any attempted access generates a NOCP UsageFault.
                    CP7_0 = 0x0,
                    /// Privileged access only. An unprivileged access generates a NOCP UsageFault.
                    CP7_1 = 0x1,
                    /// Full access.
                    CP7_3 = 0x3,
                    _,
                },
                reserved20: u4 = 0,
                /// Access privileges for coprocessor 10.
                CP10: enum(u2) {
                    /// Access denied. Any attempted access generates a NOCP UsageFault.
                    CP10_0 = 0x0,
                    /// Privileged access only. An unprivileged access generates a NOCP UsageFault.
                    CP10_1 = 0x1,
                    /// Full access.
                    CP10_3 = 0x3,
                    _,
                },
                /// Access privileges for coprocessor 11.
                CP11: enum(u2) {
                    /// Access denied. Any attempted access generates a NOCP UsageFault.
                    CP11_0 = 0x0,
                    /// Privileged access only. An unprivileged access generates a NOCP UsageFault.
                    CP11_1 = 0x1,
                    /// Full access.
                    CP11_3 = 0x3,
                    _,
                },
                padding: u8 = 0,
            }),
            reserved3840: [372]u8,
            /// Instruction cache invalidate all to Point of Unification (PoU)
            STIR: mmio.Mmio(packed struct(u32) {
                /// Indicates the interrupt to be triggered
                INTID: u9,
                padding: u23 = 0,
            }),
            reserved3920: [76]u8,
            /// Instruction cache invalidate all to Point of Unification (PoU)
            ICIALLU: mmio.Mmio(packed struct(u32) {
                /// I-cache invalidate all to PoU
                ICIALLU: u32,
            }),
            reserved3928: [4]u8,
            /// Instruction cache invalidate by address to PoU
            ICIMVAU: mmio.Mmio(packed struct(u32) {
                /// I-cache invalidate by MVA to PoU
                ICIMVAU: u32,
            }),
            /// Data cache invalidate by address to Point of Coherency (PoC)
            DCIMVAC: mmio.Mmio(packed struct(u32) {
                /// D-cache invalidate by MVA to PoC
                DCIMVAC: u32,
            }),
            /// Data cache invalidate by set/way
            DCISW: mmio.Mmio(packed struct(u32) {
                /// D-cache invalidate by set-way
                DCISW: u32,
            }),
            /// Data cache by address to PoU
            DCCMVAU: mmio.Mmio(packed struct(u32) {
                /// D-cache clean by MVA to PoU
                DCCMVAU: u32,
            }),
            /// Data cache clean by address to PoC
            DCCMVAC: mmio.Mmio(packed struct(u32) {
                /// D-cache clean by MVA to PoC
                DCCMVAC: u32,
            }),
            /// Data cache clean by set/way
            DCCSW: mmio.Mmio(packed struct(u32) {
                /// D-cache clean by set-way
                DCCSW: u32,
            }),
            /// Data cache clean and invalidate by address to PoC
            DCCIMVAC: mmio.Mmio(packed struct(u32) {
                /// D-cache clean and invalidate by MVA to PoC
                DCCIMVAC: u32,
            }),
            /// Data cache clean and invalidate by set/way
            DCCISW: mmio.Mmio(packed struct(u32) {
                /// D-cache clean and invalidate by set-way
                DCCISW: u32,
            }),
            reserved3984: [24]u8,
            /// Instruction Tightly-Coupled Memory Control Register
            CM7_ITCMCR: mmio.Mmio(packed struct(u32) {
                /// TCM enable. When a TCM is disabled all accesses are made to the AXIM interface.
                EN: enum(u1) {
                    /// TCM disabled.
                    EN_0 = 0x0,
                    /// TCM enabled.
                    EN_1 = 0x1,
                },
                /// Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that are not the full width of the TCM RAM, use a RMW sequence.
                RMW: enum(u1) {
                    /// RMW disabled.
                    RMW_0 = 0x0,
                    /// RMW enabled.
                    RMW_1 = 0x1,
                },
                /// Retry phase enable. When enabled the processor guarantees to honor the retry output on the corresponding TCM interface, re-executing the instruction which carried out the TCM access.
                RETEN: enum(u1) {
                    /// Retry phase disabled.
                    RETEN_0 = 0x0,
                    /// Retry phase enabled.
                    RETEN_1 = 0x1,
                },
                /// TCM size. Indicates the size of the relevant TCM.
                SZ: enum(u4) {
                    /// No TCM implemented.
                    SZ_0 = 0x0,
                    /// 4KB.
                    SZ_3 = 0x3,
                    /// 8KB.
                    SZ_4 = 0x4,
                    /// 16KB.
                    SZ_5 = 0x5,
                    /// 32KB.
                    SZ_6 = 0x6,
                    /// 64KB.
                    SZ_7 = 0x7,
                    /// 128KB.
                    SZ_8 = 0x8,
                    /// 256KB.
                    SZ_9 = 0x9,
                    /// 512KB.
                    SZ_10 = 0xa,
                    /// 1MB.
                    SZ_11 = 0xb,
                    /// 2MB.
                    SZ_12 = 0xc,
                    /// 4MB.
                    SZ_13 = 0xd,
                    /// 8MB.
                    SZ_14 = 0xe,
                    /// 16MB.
                    SZ_15 = 0xf,
                    _,
                },
                padding: u25 = 0,
            }),
            /// Data Tightly-Coupled Memory Control Register
            CM7_DTCMCR: mmio.Mmio(packed struct(u32) {
                /// TCM enable. When a TCM is disabled all accesses are made to the AXIM interface.
                EN: enum(u1) {
                    /// TCM disabled.
                    EN_0 = 0x0,
                    /// TCM enabled.
                    EN_1 = 0x1,
                },
                /// Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that are not the full width of the TCM RAM, use a RMW sequence.
                RMW: enum(u1) {
                    /// RMW disabled.
                    RMW_0 = 0x0,
                    /// RMW enabled.
                    RMW_1 = 0x1,
                },
                /// Retry phase enable. When enabled the processor guarantees to honor the retry output on the corresponding TCM interface, re-executing the instruction which carried out the TCM access.
                RETEN: enum(u1) {
                    /// Retry phase disabled.
                    RETEN_0 = 0x0,
                    /// Retry phase enabled.
                    RETEN_1 = 0x1,
                },
                /// TCM size. Indicates the size of the relevant TCM.
                SZ: enum(u4) {
                    /// No TCM implemented.
                    SZ_0 = 0x0,
                    /// 4KB.
                    SZ_3 = 0x3,
                    /// 8KB.
                    SZ_4 = 0x4,
                    /// 16KB.
                    SZ_5 = 0x5,
                    /// 32KB.
                    SZ_6 = 0x6,
                    /// 64KB.
                    SZ_7 = 0x7,
                    /// 128KB.
                    SZ_8 = 0x8,
                    /// 256KB.
                    SZ_9 = 0x9,
                    /// 512KB.
                    SZ_10 = 0xa,
                    /// 1MB.
                    SZ_11 = 0xb,
                    /// 2MB.
                    SZ_12 = 0xc,
                    /// 4MB.
                    SZ_13 = 0xd,
                    /// 8MB.
                    SZ_14 = 0xe,
                    /// 16MB.
                    SZ_15 = 0xf,
                    _,
                },
                padding: u25 = 0,
            }),
            /// AHBP Control Register
            CM7_AHBPCR: mmio.Mmio(packed struct(u32) {
                /// AHBP enable.
                EN: enum(u1) {
                    /// AHBP disabled. When disabled all accesses are made to the AXIM interface.
                    EN_0 = 0x0,
                    /// AHBP enabled.
                    EN_1 = 0x1,
                },
                /// AHBP size.
                SZ: enum(u3) {
                    /// 0MB. AHBP disabled.
                    SZ_0 = 0x0,
                    /// 64MB.
                    SZ_1 = 0x1,
                    /// 128MB.
                    SZ_2 = 0x2,
                    /// 256MB.
                    SZ_3 = 0x3,
                    /// 512MB.
                    SZ_4 = 0x4,
                    _,
                },
                padding: u28 = 0,
            }),
            /// L1 Cache Control Register
            CM7_CACR: mmio.Mmio(packed struct(u32) {
                /// Shared cacheable-is-WT for data cache. Enables limited cache coherency usage.
                SIWT: enum(u1) {
                    /// Normal Cacheable Shared locations are treated as being Non-cacheable. Default mode of operation for Shared memory.
                    SIWT_0 = 0x0,
                    /// Normal Cacheable shared locations are treated as Write-Through.
                    SIWT_1 = 0x1,
                },
                /// Enables ECC in the instruction and data cache.
                ECCDIS: enum(u1) {
                    /// Enables ECC in the instruction and data cache.
                    ECCDIS_0 = 0x0,
                    /// Disables ECC in the instruction and data cache.
                    ECCDIS_1 = 0x1,
                },
                /// Enables Force Write-Through in the data cache.
                FORCEWT: enum(u1) {
                    /// Disables Force Write-Through.
                    FORCEWT_0 = 0x0,
                    /// Enables Force Write-Through. All Cacheable memory regions are treated as Write-Through.
                    FORCEWT_1 = 0x1,
                },
                padding: u29 = 0,
            }),
            /// AHB Slave Control Register
            CM7_AHBSCR: mmio.Mmio(packed struct(u32) {
                /// AHBS prioritization control.
                CTL: enum(u2) {
                    /// AHBS access priority demoted. This is the reset value.
                    CTL_0 = 0x0,
                    /// Software access priority demoted.
                    CTL_1 = 0x1,
                    /// AHBS access priority demoted by initializing the fairness counter to the CM7_AHBSCR[INITCOUNT] value when the software execution priority is higher than or equal to the threshold level programed in CM7_AHBSCR[TPRI].
                    CTL_2 = 0x2,
                    /// AHBSPRI signal has control of access priority.
                    CTL_3 = 0x3,
                },
                /// Threshold execution priority for AHBS traffic demotion.
                TPRI: u9,
                /// Fairness counter initialization value.
                INITCOUNT: u5,
                padding: u16 = 0,
            }),
            reserved4008: [4]u8,
            /// Auxiliary Bus Fault Status Register
            CM7_ABFSR: mmio.Mmio(packed struct(u32) {
                /// Asynchronous fault on ITCM interface.
                ITCM: u1,
                /// Asynchronous fault on DTCM interface.
                DTCM: u1,
                /// Asynchronous fault on AHBP interface.
                AHBP: u1,
                /// Asynchronous fault on AXIM interface.
                AXIM: u1,
                /// Asynchronous fault on EPPB interface.
                EPPB: u1,
                reserved8: u3 = 0,
                /// Indicates the type of fault on the AXIM interface. Only valid when AXIM is 1.
                AXIMTYPE: enum(u2) {
                    /// OKAY.
                    AXIMTYPE_0 = 0x0,
                    /// EXOKAY.
                    AXIMTYPE_1 = 0x1,
                    /// SLVERR.
                    AXIMTYPE_2 = 0x2,
                    /// DECERR.
                    AXIMTYPE_3 = 0x3,
                },
                padding: u22 = 0,
            }),
        };

        /// Temperature Monitor
        pub const TEMPMON = extern struct {
            reserved384: [384]u8,
            /// Tempsensor Control Register 0
            TEMPSENSE0: mmio.Mmio(packed struct(u32) {
                /// This bit powers down the temperature sensor.
                POWER_DOWN: enum(u1) {
                    /// Enable power to the temperature sensor.
                    POWER_UP = 0x0,
                    /// Power down the temperature sensor.
                    POWER_DOWN = 0x1,
                },
                /// Starts the measurement process
                MEASURE_TEMP: enum(u1) {
                    /// Do not start the measurement process.
                    STOP = 0x0,
                    /// Start the measurement process.
                    START = 0x1,
                },
                /// Indicates that the latest temp is valid
                FINISHED: enum(u1) {
                    /// Last measurement is not ready yet.
                    INVALID = 0x0,
                    /// Last measurement is valid.
                    VALID = 0x1,
                },
                reserved8: u5 = 0,
                /// This bit field contains the last measured temperature count.
                TEMP_CNT: u12,
                /// This bit field contains the temperature count (raw sensor output) that will generate a high alarm when TEMP_CNT is smaller than this field
                ALARM_VALUE: u12,
            }),
            /// Tempsensor Control Register 0
            TEMPSENSE0_SET: mmio.Mmio(packed struct(u32) {
                /// This bit powers down the temperature sensor.
                POWER_DOWN: enum(u1) {
                    /// Enable power to the temperature sensor.
                    POWER_UP = 0x0,
                    /// Power down the temperature sensor.
                    POWER_DOWN = 0x1,
                },
                /// Starts the measurement process
                MEASURE_TEMP: enum(u1) {
                    /// Do not start the measurement process.
                    STOP = 0x0,
                    /// Start the measurement process.
                    START = 0x1,
                },
                /// Indicates that the latest temp is valid
                FINISHED: enum(u1) {
                    /// Last measurement is not ready yet.
                    INVALID = 0x0,
                    /// Last measurement is valid.
                    VALID = 0x1,
                },
                reserved8: u5 = 0,
                /// This bit field contains the last measured temperature count.
                TEMP_CNT: u12,
                /// This bit field contains the temperature count (raw sensor output) that will generate a high alarm when TEMP_CNT is smaller than this field
                ALARM_VALUE: u12,
            }),
            /// Tempsensor Control Register 0
            TEMPSENSE0_CLR: mmio.Mmio(packed struct(u32) {
                /// This bit powers down the temperature sensor.
                POWER_DOWN: enum(u1) {
                    /// Enable power to the temperature sensor.
                    POWER_UP = 0x0,
                    /// Power down the temperature sensor.
                    POWER_DOWN = 0x1,
                },
                /// Starts the measurement process
                MEASURE_TEMP: enum(u1) {
                    /// Do not start the measurement process.
                    STOP = 0x0,
                    /// Start the measurement process.
                    START = 0x1,
                },
                /// Indicates that the latest temp is valid
                FINISHED: enum(u1) {
                    /// Last measurement is not ready yet.
                    INVALID = 0x0,
                    /// Last measurement is valid.
                    VALID = 0x1,
                },
                reserved8: u5 = 0,
                /// This bit field contains the last measured temperature count.
                TEMP_CNT: u12,
                /// This bit field contains the temperature count (raw sensor output) that will generate a high alarm when TEMP_CNT is smaller than this field
                ALARM_VALUE: u12,
            }),
            /// Tempsensor Control Register 0
            TEMPSENSE0_TOG: mmio.Mmio(packed struct(u32) {
                /// This bit powers down the temperature sensor.
                POWER_DOWN: enum(u1) {
                    /// Enable power to the temperature sensor.
                    POWER_UP = 0x0,
                    /// Power down the temperature sensor.
                    POWER_DOWN = 0x1,
                },
                /// Starts the measurement process
                MEASURE_TEMP: enum(u1) {
                    /// Do not start the measurement process.
                    STOP = 0x0,
                    /// Start the measurement process.
                    START = 0x1,
                },
                /// Indicates that the latest temp is valid
                FINISHED: enum(u1) {
                    /// Last measurement is not ready yet.
                    INVALID = 0x0,
                    /// Last measurement is valid.
                    VALID = 0x1,
                },
                reserved8: u5 = 0,
                /// This bit field contains the last measured temperature count.
                TEMP_CNT: u12,
                /// This bit field contains the temperature count (raw sensor output) that will generate a high alarm when TEMP_CNT is smaller than this field
                ALARM_VALUE: u12,
            }),
            /// Tempsensor Control Register 1
            TEMPSENSE1: mmio.Mmio(packed struct(u32) {
                /// This bits determines how many RTC clocks to wait before automatically repeating a temperature measurement
                MEASURE_FREQ: u16,
                padding: u16 = 0,
            }),
            /// Tempsensor Control Register 1
            TEMPSENSE1_SET: mmio.Mmio(packed struct(u32) {
                /// This bits determines how many RTC clocks to wait before automatically repeating a temperature measurement
                MEASURE_FREQ: u16,
                padding: u16 = 0,
            }),
            /// Tempsensor Control Register 1
            TEMPSENSE1_CLR: mmio.Mmio(packed struct(u32) {
                /// This bits determines how many RTC clocks to wait before automatically repeating a temperature measurement
                MEASURE_FREQ: u16,
                padding: u16 = 0,
            }),
            /// Tempsensor Control Register 1
            TEMPSENSE1_TOG: mmio.Mmio(packed struct(u32) {
                /// This bits determines how many RTC clocks to wait before automatically repeating a temperature measurement
                MEASURE_FREQ: u16,
                padding: u16 = 0,
            }),
            reserved656: [240]u8,
            /// Tempsensor Control Register 2
            TEMPSENSE2: mmio.Mmio(packed struct(u32) {
                /// This bit field contains the temperature count that will generate a low alarm interrupt when the field is exceeded by TEMP_CNT
                LOW_ALARM_VALUE: u12,
                reserved16: u4 = 0,
                /// This bit field contains the temperature count that will generate a panic interrupt when TEMP_CNT is smaller than this field
                PANIC_ALARM_VALUE: u12,
                padding: u4 = 0,
            }),
            /// Tempsensor Control Register 2
            TEMPSENSE2_SET: mmio.Mmio(packed struct(u32) {
                /// This bit field contains the temperature count that will generate a low alarm interrupt when the field is exceeded by TEMP_CNT
                LOW_ALARM_VALUE: u12,
                reserved16: u4 = 0,
                /// This bit field contains the temperature count that will generate a panic interrupt when TEMP_CNT is smaller than this field
                PANIC_ALARM_VALUE: u12,
                padding: u4 = 0,
            }),
            /// Tempsensor Control Register 2
            TEMPSENSE2_CLR: mmio.Mmio(packed struct(u32) {
                /// This bit field contains the temperature count that will generate a low alarm interrupt when the field is exceeded by TEMP_CNT
                LOW_ALARM_VALUE: u12,
                reserved16: u4 = 0,
                /// This bit field contains the temperature count that will generate a panic interrupt when TEMP_CNT is smaller than this field
                PANIC_ALARM_VALUE: u12,
                padding: u4 = 0,
            }),
            /// Tempsensor Control Register 2
            TEMPSENSE2_TOG: mmio.Mmio(packed struct(u32) {
                /// This bit field contains the temperature count that will generate a low alarm interrupt when the field is exceeded by TEMP_CNT
                LOW_ALARM_VALUE: u12,
                reserved16: u4 = 0,
                /// This bit field contains the temperature count that will generate a panic interrupt when TEMP_CNT is smaller than this field
                PANIC_ALARM_VALUE: u12,
                padding: u4 = 0,
            }),
        };

        /// Quad Timer
        pub const TMR1 = extern struct {
            reserved30: [30]u8,
            /// Timer Channel Enable Register
            ENBL: mmio.Mmio(packed struct(u16) {
                /// Timer Channel Enable
                ENBL: enum(u4) {
                    /// Timer channel is disabled.
                    ENBL_0 = 0x0,
                    /// Timer channel is enabled. (default)
                    ENBL_1 = 0x1,
                    _,
                },
                padding: u12 = 0,
            }),
        };

        /// TRNG
        pub const TRNG = extern struct {
            /// Miscellaneous Control Register
            MCTL: mmio.Mmio(packed struct(u32) {
                /// Sample Mode
                SAMP_MODE: enum(u2) {
                    /// use Von Neumann data into both Entropy shifter and Statistical Checker
                    SAMP_MODE_0 = 0x0,
                    /// use raw data into both Entropy shifter and Statistical Checker
                    SAMP_MODE_1 = 0x1,
                    /// use Von Neumann data into Entropy shifter. Use raw data into Statistical Checker
                    SAMP_MODE_2 = 0x2,
                    /// undefined/reserved.
                    SAMP_MODE_3 = 0x3,
                },
                /// Oscillator Divide
                OSC_DIV: enum(u2) {
                    /// use ring oscillator with no divide
                    OSC_DIV_0 = 0x0,
                    /// use ring oscillator divided-by-2
                    OSC_DIV_1 = 0x1,
                    /// use ring oscillator divided-by-4
                    OSC_DIV_2 = 0x2,
                    /// use ring oscillator divided-by-8
                    OSC_DIV_3 = 0x3,
                },
                /// This bit is unused. Always reads zero.
                UNUSED4: u1,
                /// This bit is unused. Always reads zero.
                UNUSED5: u1,
                /// Reset Defaults
                RST_DEF: u1,
                /// Force System Clock
                FOR_SCLK: u1,
                /// Read only: Frequency Count Fail
                FCT_FAIL: u1,
                /// Read only: Frequency Count Valid. Indicates that a valid frequency count may be read from FRQCNT.
                FCT_VAL: u1,
                /// Read only: Entropy Valid
                ENT_VAL: u1,
                /// Read only: Test point inside ring oscillator.
                TST_OUT: u1,
                /// Read: Error status
                ERR: u1,
                /// TRNG_OK_TO_STOP
                TSTOP_OK: u1,
                /// Long run count continues between entropy generations
                LRUN_CONT: u1,
                reserved16: u1 = 0,
                /// Programming Mode Select
                PRGM: u1,
                padding: u15 = 0,
            }),
            /// Statistical Check Miscellaneous Register
            SCMISC: mmio.Mmio(packed struct(u32) {
                /// LONG RUN MAX LIMIT
                LRUN_MAX: u8,
                reserved16: u8 = 0,
                /// RETRY COUNT
                RTY_CT: u4,
                padding: u12 = 0,
            }),
            /// Poker Range Register
            PKRRNG: mmio.Mmio(packed struct(u32) {
                /// Poker Range
                PKR_RNG: u16,
                padding: u16 = 0,
            }),
            /// Poker Maximum Limit Register
            PKRMAX: mmio.Mmio(packed struct(u32) {
                /// Poker Maximum Limit.
                PKR_MAX: u24,
                padding: u8 = 0,
            }),
            /// Seed Control Register
            SDCTL: mmio.Mmio(packed struct(u32) {
                /// Sample Size
                SAMP_SIZE: u16,
                /// Entropy Delay
                ENT_DLY: u16,
            }),
            /// Sparse Bit Limit Register
            SBLIM: mmio.Mmio(packed struct(u32) {
                /// Sparse Bit Limit
                SB_LIM: u10,
                padding: u22 = 0,
            }),
            /// Frequency Count Minimum Limit Register
            FRQMIN: mmio.Mmio(packed struct(u32) {
                /// Frequency Count Minimum Limit
                FRQ_MIN: u22,
                padding: u10 = 0,
            }),
            /// Frequency Count Register
            FRQCNT: mmio.Mmio(packed struct(u32) {
                /// Frequency Count
                FRQ_CT: u22,
                padding: u10 = 0,
            }),
            /// Statistical Check Monobit Count Register
            SCMC: mmio.Mmio(packed struct(u32) {
                /// Monobit Count
                MONO_CT: u16,
                padding: u16 = 0,
            }),
            /// Statistical Check Run Length 1 Count Register
            SCR1C: mmio.Mmio(packed struct(u32) {
                /// Runs of Zero, Length 1 Count
                R1_0_CT: u15,
                reserved16: u1 = 0,
                /// Runs of One, Length 1 Count
                R1_1_CT: u15,
                padding: u1 = 0,
            }),
            /// Statistical Check Run Length 2 Count Register
            SCR2C: mmio.Mmio(packed struct(u32) {
                /// Runs of Zero, Length 2 Count
                R2_0_CT: u14,
                reserved16: u2 = 0,
                /// Runs of One, Length 2 Count
                R2_1_CT: u14,
                padding: u2 = 0,
            }),
            /// Statistical Check Run Length 3 Count Register
            SCR3C: mmio.Mmio(packed struct(u32) {
                /// Runs of Zeroes, Length 3 Count
                R3_0_CT: u13,
                reserved16: u3 = 0,
                /// Runs of Ones, Length 3 Count
                R3_1_CT: u13,
                padding: u3 = 0,
            }),
            /// Statistical Check Run Length 4 Count Register
            SCR4C: mmio.Mmio(packed struct(u32) {
                /// Runs of Zero, Length 4 Count
                R4_0_CT: u12,
                reserved16: u4 = 0,
                /// Runs of One, Length 4 Count
                R4_1_CT: u12,
                padding: u4 = 0,
            }),
            /// Statistical Check Run Length 5 Count Register
            SCR5C: mmio.Mmio(packed struct(u32) {
                /// Runs of Zero, Length 5 Count
                R5_0_CT: u11,
                reserved16: u5 = 0,
                /// Runs of One, Length 5 Count
                R5_1_CT: u11,
                padding: u5 = 0,
            }),
            /// Statistical Check Run Length 6+ Count Register
            SCR6PC: mmio.Mmio(packed struct(u32) {
                /// Runs of Zero, Length 6+ Count
                R6P_0_CT: u11,
                reserved16: u5 = 0,
                /// Runs of One, Length 6+ Count
                R6P_1_CT: u11,
                padding: u5 = 0,
            }),
            /// Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                /// Test Fail, 1-Bit Run, Sampling 0s. If TF1BR0=1, the 1-Bit Run, Sampling 0s Test has failed.
                TF1BR0: u1,
                /// Test Fail, 1-Bit Run, Sampling 1s. If TF1BR1=1, the 1-Bit Run, Sampling 1s Test has failed.
                TF1BR1: u1,
                /// Test Fail, 2-Bit Run, Sampling 0s. If TF2BR0=1, the 2-Bit Run, Sampling 0s Test has failed.
                TF2BR0: u1,
                /// Test Fail, 2-Bit Run, Sampling 1s. If TF2BR1=1, the 2-Bit Run, Sampling 1s Test has failed.
                TF2BR1: u1,
                /// Test Fail, 3-Bit Run, Sampling 0s. If TF3BR0=1, the 3-Bit Run, Sampling 0s Test has failed.
                TF3BR0: u1,
                /// Test Fail, 3-Bit Run, Sampling 1s. If TF3BR1=1, the 3-Bit Run, Sampling 1s Test has failed.
                TF3BR1: u1,
                /// Test Fail, 4-Bit Run, Sampling 0s. If TF4BR0=1, the 4-Bit Run, Sampling 0s Test has failed.
                TF4BR0: u1,
                /// Test Fail, 4-Bit Run, Sampling 1s. If TF4BR1=1, the 4-Bit Run, Sampling 1s Test has failed.
                TF4BR1: u1,
                /// Test Fail, 5-Bit Run, Sampling 0s. If TF5BR0=1, the 5-Bit Run, Sampling 0s Test has failed.
                TF5BR0: u1,
                /// Test Fail, 5-Bit Run, Sampling 1s. If TF5BR1=1, the 5-Bit Run, Sampling 1s Test has failed.
                TF5BR1: u1,
                /// Test Fail, 6 Plus Bit Run, Sampling 0s
                TF6PBR0: u1,
                /// Test Fail, 6 Plus Bit Run, Sampling 1s
                TF6PBR1: u1,
                /// Test Fail, Sparse Bit. If TFSB=1, the Sparse Bit Test has failed.
                TFSB: u1,
                /// Test Fail, Long Run. If TFLR=1, the Long Run Test has failed.
                TFLR: u1,
                /// Test Fail, Poker. If TFP=1, the Poker Test has failed.
                TFP: u1,
                /// Test Fail, Mono Bit. If TFMB=1, the Mono Bit Test has failed.
                TFMB: u1,
                /// RETRY COUNT
                RETRY_CT: u4,
                padding: u12 = 0,
            }),
            /// Entropy Read Register
            ENT: [16]mmio.Mmio(packed struct(u32) {
                /// Entropy Value
                ENT: u32,
            }),
            /// Statistical Check Poker Count 1 and 0 Register
            PKRCNT10: mmio.Mmio(packed struct(u32) {
                /// Poker 0h Count
                PKR_0_CT: u16,
                /// Poker 1h Count
                PKR_1_CT: u16,
            }),
            /// Statistical Check Poker Count 3 and 2 Register
            PKRCNT32: mmio.Mmio(packed struct(u32) {
                /// Poker 2h Count
                PKR_2_CT: u16,
                /// Poker 3h Count
                PKR_3_CT: u16,
            }),
            /// Statistical Check Poker Count 5 and 4 Register
            PKRCNT54: mmio.Mmio(packed struct(u32) {
                /// Poker 4h Count
                PKR_4_CT: u16,
                /// Poker 5h Count
                PKR_5_CT: u16,
            }),
            /// Statistical Check Poker Count 7 and 6 Register
            PKRCNT76: mmio.Mmio(packed struct(u32) {
                /// Poker 6h Count
                PKR_6_CT: u16,
                /// Poker 7h Count
                PKR_7_CT: u16,
            }),
            /// Statistical Check Poker Count 9 and 8 Register
            PKRCNT98: mmio.Mmio(packed struct(u32) {
                /// Poker 8h Count
                PKR_8_CT: u16,
                /// Poker 9h Count
                PKR_9_CT: u16,
            }),
            /// Statistical Check Poker Count B and A Register
            PKRCNTBA: mmio.Mmio(packed struct(u32) {
                /// Poker Ah Count
                PKR_A_CT: u16,
                /// Poker Bh Count
                PKR_B_CT: u16,
            }),
            /// Statistical Check Poker Count D and C Register
            PKRCNTDC: mmio.Mmio(packed struct(u32) {
                /// Poker Ch Count
                PKR_C_CT: u16,
                /// Poker Dh Count
                PKR_D_CT: u16,
            }),
            /// Statistical Check Poker Count F and E Register
            PKRCNTFE: mmio.Mmio(packed struct(u32) {
                /// Poker Eh Count
                PKR_E_CT: u16,
                /// Poker Fh Count
                PKR_F_CT: u16,
            }),
            /// Security Configuration Register
            SEC_CFG: mmio.Mmio(packed struct(u32) {
                /// This bit is unused. Ignore.
                UNUSED0: u1,
                /// If set, the TRNG registers cannot be programmed
                NO_PRGM: enum(u1) {
                    /// Programability of registers controlled only by the Miscellaneous Control Register's access mode bit.
                    NO_PRGM_0 = 0x0,
                    /// Overides Miscellaneous Control Register access mode and prevents TRNG register programming.
                    NO_PRGM_1 = 0x1,
                },
                /// This bit is unused. Ignore.
                UNUSED2: u1,
                padding: u29 = 0,
            }),
            /// Interrupt Control Register
            INT_CTRL: mmio.Mmio(packed struct(u32) {
                /// Bit position that can be cleared if corresponding bit of INT_STATUS register has been asserted.
                HW_ERR: enum(u1) {
                    /// Corresponding bit of INT_STATUS register cleared.
                    HW_ERR_0 = 0x0,
                    /// Corresponding bit of INT_STATUS register active.
                    HW_ERR_1 = 0x1,
                },
                /// Same behavior as bit 0 of this register.
                ENT_VAL: enum(u1) {
                    /// Same behavior as bit 0 of this register.
                    ENT_VAL_0 = 0x0,
                    /// Same behavior as bit 0 of this register.
                    ENT_VAL_1 = 0x1,
                },
                /// Same behavior as bit 0 of this register.
                FRQ_CT_FAIL: enum(u1) {
                    /// Same behavior as bit 0 of this register.
                    FRQ_CT_FAIL_0 = 0x0,
                    /// Same behavior as bit 0 of this register.
                    FRQ_CT_FAIL_1 = 0x1,
                },
                padding: u29 = 0,
            }),
            /// Mask Register
            INT_MASK: mmio.Mmio(packed struct(u32) {
                /// Bit position that can be cleared if corresponding bit of INT_STATUS has been asserted.
                HW_ERR: enum(u1) {
                    /// Corresponding interrupt of INT_STATUS is masked.
                    HW_ERR_0 = 0x0,
                    /// Corresponding bit of INT_STATUS is active.
                    HW_ERR_1 = 0x1,
                },
                /// Same behavior as bit 0 of this register.
                ENT_VAL: enum(u1) {
                    /// Same behavior as bit 0 of this register.
                    ENT_VAL_0 = 0x0,
                    /// Same behavior as bit 0 of this register.
                    ENT_VAL_1 = 0x1,
                },
                /// Same behavior as bit 0 of this register.
                FRQ_CT_FAIL: enum(u1) {
                    /// Same behavior as bit 0 of this register.
                    FRQ_CT_FAIL_0 = 0x0,
                    /// Same behavior as bit 0 of this register.
                    FRQ_CT_FAIL_1 = 0x1,
                },
                padding: u29 = 0,
            }),
            /// Interrupt Status Register
            INT_STATUS: mmio.Mmio(packed struct(u32) {
                /// Read: Error status
                HW_ERR: enum(u1) {
                    /// no error
                    HW_ERR_0 = 0x0,
                    /// error detected.
                    HW_ERR_1 = 0x1,
                },
                /// Read only: Entropy Valid
                ENT_VAL: enum(u1) {
                    /// Busy generation entropy. Any value read is invalid.
                    ENT_VAL_0 = 0x0,
                    /// TRNG can be stopped and entropy is valid if read.
                    ENT_VAL_1 = 0x1,
                },
                /// Read only: Frequency Count Fail
                FRQ_CT_FAIL: enum(u1) {
                    /// No hardware nor self test frequency errors.
                    FRQ_CT_FAIL_0 = 0x0,
                    /// The frequency counter has detected a failure.
                    FRQ_CT_FAIL_1 = 0x1,
                },
                padding: u29 = 0,
            }),
            reserved240: [64]u8,
            /// Version ID Register (MS)
            VID1: mmio.Mmio(packed struct(u32) {
                /// Shows the IP's Minor revision of the TRNG.
                MIN_REV: enum(u8) {
                    /// Minor revision number for TRNG.
                    MIN_REV_0 = 0x0,
                    _,
                },
                /// Shows the IP's Major revision of the TRNG.
                MAJ_REV: enum(u8) {
                    /// Major revision number for TRNG.
                    MAJ_REV_1 = 0x1,
                    _,
                },
                /// Shows the IP ID.
                IP_ID: enum(u16) {
                    /// ID for TRNG.
                    IP_ID_48 = 0x30,
                    _,
                },
            }),
            /// Version ID Register (LS)
            VID2: mmio.Mmio(packed struct(u32) {
                /// Shows the IP's Configuaration options for the TRNG.
                CONFIG_OPT: enum(u8) {
                    /// TRNG_CONFIG_OPT for TRNG.
                    CONFIG_OPT_0 = 0x0,
                    _,
                },
                /// Shows the IP's ECO revision of the TRNG.
                ECO_REV: enum(u8) {
                    /// TRNG_ECO_REV for TRNG.
                    ECO_REV_0 = 0x0,
                    _,
                },
                /// Shows the integration options for the TRNG.
                INTG_OPT: enum(u8) {
                    /// INTG_OPT for TRNG.
                    INTG_OPT_0 = 0x0,
                    _,
                },
                /// Shows the compile options for the TRNG.
                ERA: enum(u8) {
                    /// COMPILE_OPT for TRNG.
                    ERA_0 = 0x0,
                    _,
                },
            }),
        };

        /// Touch Screen Controller
        pub const TSC = extern struct {
            /// no description available
            BASIC_SETTING: mmio.Mmio(packed struct(u32) {
                /// Auto Measure
                AUTO_MEASURE: enum(u1) {
                    /// Disable Auto Measure
                    AUTO_MEASURE_0 = 0x0,
                    /// Auto Measure
                    AUTO_MEASURE_1 = 0x1,
                },
                reserved4: u3 = 0,
                /// 4/5 Wire detection
                _4_5_WIRE: enum(u1) {
                    /// 4-Wire Detection Mode
                    @"4_5_WIRE_0" = 0x0,
                    /// 5-Wire Detection Mode
                    @"4_5_WIRE_1" = 0x1,
                },
                reserved8: u3 = 0,
                /// Measure Delay Time
                MEASURE_DELAY_TIME: u24,
            }),
            reserved16: [12]u8,
            /// no description available
            PRE_CHARGE_TIME: mmio.Mmio(packed struct(u32) {
                /// Before detection, the top screen needs some time before being pulled up to a high voltage.
                PRE_CHARGE_TIME: u32,
            }),
            reserved32: [12]u8,
            /// Flow Control
            FLOW_CONTROL: mmio.Mmio(packed struct(u32) {
                /// Soft Reset
                SW_RST: u1,
                reserved4: u3 = 0,
                /// Start Measure
                START_MEASURE: enum(u1) {
                    /// Do not start measure for now
                    START_MEASURE_0 = 0x0,
                    /// Start measure the X/Y coordinate value
                    START_MEASURE_1 = 0x1,
                },
                reserved8: u3 = 0,
                /// Drop Measure
                DROP_MEASURE: enum(u1) {
                    /// Do not drop measure for now
                    DROP_MEASURE_0 = 0x0,
                    /// Drop the measure and controller return to idle status
                    DROP_MEASURE_1 = 0x1,
                },
                reserved12: u3 = 0,
                /// Start Sense
                START_SENSE: enum(u1) {
                    /// Stay at idle status
                    START_SENSE_0 = 0x0,
                    /// Start sense detection and (if auto_measure set to 1) measure after detect a touch
                    START_SENSE_1 = 0x1,
                },
                reserved16: u3 = 0,
                /// This bit is for SW disable registers
                DISABLE: enum(u1) {
                    /// Leave HW state machine control
                    DISABLE_0 = 0x0,
                    /// SW set to idle status
                    DISABLE_1 = 0x1,
                },
                padding: u15 = 0,
            }),
            reserved48: [12]u8,
            /// Measure Value
            MEASEURE_VALUE: mmio.Mmio(packed struct(u32) {
                /// Y Value
                Y_VALUE: u12,
                reserved16: u4 = 0,
                /// X Value
                X_VALUE: u12,
                padding: u4 = 0,
            }),
            reserved64: [12]u8,
            /// Interrupt Enable
            INT_EN: mmio.Mmio(packed struct(u32) {
                /// Measure Interrupt Enable
                MEASURE_INT_EN: enum(u1) {
                    /// Disable measure interrupt
                    MEASURE_INT_EN_0 = 0x0,
                    /// Enable measure interrupt
                    MEASURE_INT_EN_1 = 0x1,
                },
                reserved4: u3 = 0,
                /// Detect Interrupt Enable
                DETECT_INT_EN: enum(u1) {
                    /// Disable detect interrupt
                    DETECT_INT_EN_0 = 0x0,
                    /// Enable detect interrupt
                    DETECT_INT_EN_1 = 0x1,
                },
                reserved12: u7 = 0,
                /// Idle Software Interrupt Enable
                IDLE_SW_INT_EN: enum(u1) {
                    /// Disable idle software interrupt
                    IDLE_SW_INT_EN_0 = 0x0,
                    /// Enable idle software interrupt
                    IDLE_SW_INT_EN_1 = 0x1,
                },
                padding: u19 = 0,
            }),
            reserved80: [12]u8,
            /// Interrupt Signal Enable
            INT_SIG_EN: mmio.Mmio(packed struct(u32) {
                /// Measure Signal Enable
                MEASURE_SIG_EN: u1,
                reserved4: u3 = 0,
                /// Detect Signal Enable
                DETECT_SIG_EN: enum(u1) {
                    /// Disable detect signal
                    DETECT_SIG_EN_0 = 0x0,
                    /// Enable detect signal
                    DETECT_SIG_EN_1 = 0x1,
                },
                reserved8: u3 = 0,
                /// Valid Signal Enable
                VALID_SIG_EN: enum(u1) {
                    /// Disable valid signal
                    VALID_SIG_EN_0 = 0x0,
                    /// Enable valid signal
                    VALID_SIG_EN_1 = 0x1,
                },
                reserved12: u3 = 0,
                /// Idle Software Signal Enable
                IDLE_SW_SIG_EN: enum(u1) {
                    /// Disable idle software signal
                    IDLE_SW_SIG_EN_0 = 0x0,
                    /// Enable idle software signal
                    IDLE_SW_SIG_EN_1 = 0x1,
                },
                padding: u19 = 0,
            }),
            reserved96: [12]u8,
            /// Intterrupt Status
            INT_STATUS: mmio.Mmio(packed struct(u32) {
                /// Measure Signal
                MEASURE: enum(u1) {
                    /// Does not exist a measure signal
                    MEASURE_0 = 0x0,
                    /// Exist a measure signal
                    MEASURE_1 = 0x1,
                },
                reserved4: u3 = 0,
                /// Detect Signal
                DETECT: enum(u1) {
                    /// Does not exist a detect signal
                    DETECT_0 = 0x0,
                    /// Exist detect signal
                    DETECT_1 = 0x1,
                },
                reserved8: u3 = 0,
                /// Valid Signal
                VALID: enum(u1) {
                    /// There is no touch detected after measurement, indicates that the measured value is not valid
                    VALID_0 = 0x0,
                    /// There is touch detection after measurement, indicates that the measure is valid
                    VALID_1 = 0x1,
                },
                reserved12: u3 = 0,
                /// Idle Software
                IDLE_SW: enum(u1) {
                    /// Haven't return to idle status
                    IDLE_SW_0 = 0x0,
                    /// Already return to idle status
                    IDLE_SW_1 = 0x1,
                },
                padding: u19 = 0,
            }),
            reserved112: [12]u8,
            /// no description available
            DEBUG_MODE: mmio.Mmio(packed struct(u32) {
                /// ADC Conversion Value
                ADC_CONV_VALUE: u12,
                /// ADC COCO Signal
                ADC_COCO: u1,
                reserved16: u3 = 0,
                /// Hardware Trigger Select Signal
                EXT_HWTS: u5,
                reserved24: u3 = 0,
                /// Trigger
                TRIGGER: enum(u1) {
                    /// No hardware trigger signal
                    TRIGGER_0 = 0x0,
                    /// Hardware trigger signal, the signal must last at least 1 ips clock period
                    TRIGGER_1 = 0x1,
                },
                /// ADC Coco Clear
                ADC_COCO_CLEAR: enum(u1) {
                    /// No ADC COCO clear
                    ADC_COCO_CLEAR_0 = 0x0,
                    /// Set ADC COCO clear
                    ADC_COCO_CLEAR_1 = 0x1,
                },
                /// ADC COCO Clear Disable
                ADC_COCO_CLEAR_DISABLE: enum(u1) {
                    /// Allow TSC hardware generates ADC COCO clear
                    ADC_COCO_CLEAR_DISABLE_0 = 0x0,
                    /// Prevent TSC from generate ADC COCO clear signal
                    ADC_COCO_CLEAR_DISABLE_1 = 0x1,
                },
                reserved28: u1 = 0,
                /// Debug Enable
                DEBUG_EN: enum(u1) {
                    /// Enable debug mode
                    DEBUG_EN_0 = 0x0,
                    /// Disable debug mode
                    DEBUG_EN_1 = 0x1,
                },
                padding: u3 = 0,
            }),
            reserved128: [12]u8,
            /// no description available
            DEBUG_MODE2: mmio.Mmio(packed struct(u32) {
                /// XPUL Wire Pull Down Switch
                XPUL_PULL_DOWN: enum(u1) {
                    /// Close the switch
                    XPUL_PULL_DOWN_0 = 0x0,
                    /// Open up the switch
                    XPUL_PULL_DOWN_1 = 0x1,
                },
                /// XPUL Wire Pull Up Switch
                XPUL_PULL_UP: enum(u1) {
                    /// Close the switch
                    XPUL_PULL_UP_0 = 0x0,
                    /// Open up the switch
                    XPUL_PULL_UP_1 = 0x1,
                },
                /// XPUL Wire 200K Pull Up Switch
                XPUL_200K_PULL_UP: enum(u1) {
                    /// Close the switch
                    XPUL_200K_PULL_UP_0 = 0x0,
                    /// Open up the switch
                    XPUL_200K_PULL_UP_1 = 0x1,
                },
                /// XNUR Wire Pull Down Switch
                XNUR_PULL_DOWN: enum(u1) {
                    /// Close the switch
                    XNUR_PULL_DOWN_0 = 0x0,
                    /// Open up the switch
                    XNUR_PULL_DOWN_1 = 0x1,
                },
                /// XNUR Wire Pull Up Switch
                XNUR_PULL_UP: enum(u1) {
                    /// Close the switch
                    XNUR_PULL_UP_0 = 0x0,
                    /// Open up the switch
                    XNUR_PULL_UP_1 = 0x1,
                },
                /// XNUR Wire 200K Pull Up Switch
                XNUR_200K_PULL_UP: enum(u1) {
                    /// Close the switch
                    XNUR_200K_PULL_UP_0 = 0x0,
                    /// Open up the switch
                    XNUR_200K_PULL_UP_1 = 0x1,
                },
                /// YPLL Wire Pull Down Switch
                YPLL_PULL_DOWN: enum(u1) {
                    /// Close the switch
                    YPLL_PULL_DOWN_0 = 0x0,
                    /// Open up the switch
                    YPLL_PULL_DOWN_1 = 0x1,
                },
                /// YPLL Wire Pull Up Switch
                YPLL_PULL_UP: enum(u1) {
                    /// Close the switch
                    YPLL_PULL_UP_0 = 0x0,
                    /// Open the switch
                    YPLL_PULL_UP_1 = 0x1,
                },
                /// YPLL Wire 200K Pull Up Switch
                YPLL_200K_PULL_UP: enum(u1) {
                    /// Close the switch
                    YPLL_200K_PULL_UP_0 = 0x0,
                    /// Open up the switch
                    YPLL_200K_PULL_UP_1 = 0x1,
                },
                /// YNLR Wire Pull Down Switch
                YNLR_PULL_DOWN: enum(u1) {
                    /// Close the switch
                    YNLR_PULL_DOWN_0 = 0x0,
                    /// Open up the switch
                    YNLR_PULL_DOWN_1 = 0x1,
                },
                /// YNLR Wire Pull Up Switch
                YNLR_PULL_UP: enum(u1) {
                    /// Close the switch
                    YNLR_PULL_UP_0 = 0x0,
                    /// Open up the switch
                    YNLR_PULL_UP_1 = 0x1,
                },
                /// YNLR Wire 200K Pull Up Switch
                YNLR_200K_PULL_UP: enum(u1) {
                    /// Close the switch
                    YNLR_200K_PULL_UP_0 = 0x0,
                    /// Open up the switch
                    YNLR_200K_PULL_UP_1 = 0x1,
                },
                /// Wiper Wire Pull Down Switch
                WIPER_PULL_DOWN: enum(u1) {
                    /// Close the switch
                    WIPER_PULL_DOWN_0 = 0x0,
                    /// Open up the switch
                    WIPER_PULL_DOWN_1 = 0x1,
                },
                /// Wiper Wire Pull Up Switch
                WIPER_PULL_UP: enum(u1) {
                    /// Close the switch
                    WIPER_PULL_UP_0 = 0x0,
                    /// Open up the switch
                    WIPER_PULL_UP_1 = 0x1,
                },
                /// Wiper Wire 200K Pull Up Switch
                WIPER_200K_PULL_UP: enum(u1) {
                    /// Close the switch
                    WIPER_200K_PULL_UP_0 = 0x0,
                    /// Open up the switch
                    WIPER_200K_PULL_UP_1 = 0x1,
                },
                reserved16: u1 = 0,
                /// Detect Four Wire
                DETECT_FOUR_WIRE: enum(u1) {
                    /// No detect signal
                    DETECT_FOUR_WIRE_0 = 0x0,
                    /// Yes, there is a detect on the touch screen.
                    DETECT_FOUR_WIRE_1 = 0x1,
                },
                /// Detect Five Wire
                DETECT_FIVE_WIRE: enum(u1) {
                    /// No detect signal
                    DETECT_FIVE_WIRE_0 = 0x0,
                    /// Yes, there is a detect on the touch screen.
                    DETECT_FIVE_WIRE_1 = 0x1,
                },
                reserved20: u2 = 0,
                /// State Machine
                STATE_MACHINE: enum(u3) {
                    /// Idle
                    STATE_MACHINE_0 = 0x0,
                    /// Pre-charge
                    STATE_MACHINE_1 = 0x1,
                    /// Detect
                    STATE_MACHINE_2 = 0x2,
                    /// X-measure
                    STATE_MACHINE_3 = 0x3,
                    /// Y-measure
                    STATE_MACHINE_4 = 0x4,
                    /// Pre-charge
                    STATE_MACHINE_5 = 0x5,
                    /// Detect
                    STATE_MACHINE_6 = 0x6,
                    _,
                },
                /// Intermediate State
                INTERMEDIATE: enum(u1) {
                    /// Not in intermedia
                    INTERMEDIATE_0 = 0x0,
                    /// Intermedia
                    INTERMEDIATE_1 = 0x1,
                },
                /// Detect Enable Four Wire
                DETECT_ENABLE_FOUR_WIRE: enum(u1) {
                    /// Do not read four wire detect value, read default value from analogue
                    DETECT_ENABLE_FOUR_WIRE_0 = 0x0,
                    /// Read four wire detect status from analogue
                    DETECT_ENABLE_FOUR_WIRE_1 = 0x1,
                },
                reserved28: u3 = 0,
                /// Detect Enable Five Wire
                DETECT_ENABLE_FIVE_WIRE: enum(u1) {
                    /// Do not read five wire detect value, read default value from analogue
                    DETECT_ENABLE_FIVE_WIRE_0 = 0x0,
                    /// Read five wire detect status from analogue
                    DETECT_ENABLE_FIVE_WIRE_1 = 0x1,
                },
                /// This field indicates glitch threshold
                DE_GLITCH: enum(u2) {
                    /// Normal function: 0x1fff ipg clock cycles; Low power mode: 0x9 low power clock cycles
                    DE_GLITCH_0 = 0x0,
                    /// Normal function: 0xfff ipg clock cycles; Low power mode: :0x7 low power clock cycles
                    DE_GLITCH_1 = 0x1,
                    /// Normal function: 0x7ff ipg clock cycles; Low power mode:0x5 low power clock cycles
                    DE_GLITCH_2 = 0x2,
                    /// Normal function: 0x3 ipg clock cycles; Low power mode:0x3 low power clock cycles
                    DE_GLITCH_3 = 0x3,
                },
                padding: u1 = 0,
            }),
        };

        /// USB
        pub const USB1 = extern struct {
            /// Identification register
            ID: mmio.Mmio(packed struct(u32) {
                /// Configuration number
                ID: u6,
                reserved8: u2 = 0,
                /// Complement version of ID
                NID: u6,
                reserved16: u2 = 0,
                /// Revision number of the controller core.
                REVISION: u8,
                padding: u8 = 0,
            }),
            /// Hardware General
            HWGENERAL: mmio.Mmio(packed struct(u32) {
                reserved4: u4 = 0,
                /// Data width of the transciever connected to the controller core. PHYW bit reset value is
                PHYW: enum(u2) {
                    /// 8 bit wide data bus Software non-programmable
                    PHYW_0 = 0x0,
                    /// 16 bit wide data bus Software non-programmable
                    PHYW_1 = 0x1,
                    /// Reset to 8 bit wide data bus Software programmable
                    PHYW_2 = 0x2,
                    /// Reset to 16 bit wide data bus Software programmable
                    PHYW_3 = 0x3,
                },
                /// Transciever type
                PHYM: enum(u3) {
                    /// UTMI/UMTI+
                    PHYM_0 = 0x0,
                    /// ULPI DDR
                    PHYM_1 = 0x1,
                    /// ULPI
                    PHYM_2 = 0x2,
                    /// Serial Only
                    PHYM_3 = 0x3,
                    /// Software programmable - reset to UTMI/UTMI+
                    PHYM_4 = 0x4,
                    /// Software programmable - reset to ULPI DDR
                    PHYM_5 = 0x5,
                    /// Software programmable - reset to ULPI
                    PHYM_6 = 0x6,
                    /// Software programmable - reset to Serial
                    PHYM_7 = 0x7,
                },
                /// Serial interface mode capability
                SM: enum(u2) {
                    /// No Serial Engine, always use parallel signalling.
                    SM_0 = 0x0,
                    /// Serial Engine present, always use serial signalling for FS/LS.
                    SM_1 = 0x1,
                    /// Software programmable - Reset to use parallel signalling for FS/LS
                    SM_2 = 0x2,
                    /// Software programmable - Reset to use serial signalling for FS/LS
                    SM_3 = 0x3,
                },
                padding: u21 = 0,
            }),
            /// Host Hardware Parameters
            HWHOST: mmio.Mmio(packed struct(u32) {
                /// Host Capable. Indicating whether host operation mode is supported or not.
                HC: enum(u1) {
                    /// Not supported
                    HC_0 = 0x0,
                    /// Supported
                    HC_1 = 0x1,
                },
                /// The Nmber of downstream ports supported by the host controller is (NPORT+1)
                NPORT: u3,
                padding: u28 = 0,
            }),
            /// Device Hardware Parameters
            HWDEVICE: mmio.Mmio(packed struct(u32) {
                /// Device Capable. Indicating whether device operation mode is supported or not.
                DC: enum(u1) {
                    /// Not supported
                    DC_0 = 0x0,
                    /// Supported
                    DC_1 = 0x1,
                },
                /// Device Endpoint Number
                DEVEP: u5,
                padding: u26 = 0,
            }),
            /// TX Buffer Hardware Parameters
            HWTXBUF: mmio.Mmio(packed struct(u32) {
                /// Default burst size for memory to TX buffer transfer
                TXBURST: u8,
                reserved16: u8 = 0,
                /// TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes
                TXCHANADD: u8,
                padding: u8 = 0,
            }),
            /// RX Buffer Hardware Parameters
            HWRXBUF: mmio.Mmio(packed struct(u32) {
                /// Default burst size for memory to RX buffer transfer
                RXBURST: u8,
                /// Buffer total size for all receive endpoints is (2^RXADD)
                RXADD: u8,
                padding: u16 = 0,
            }),
            reserved128: [104]u8,
            /// General Purpose Timer #0 Load
            GPTIMER0LD: mmio.Mmio(packed struct(u32) {
                /// General Purpose Timer Load Value These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'
                GPTLD: u24,
                padding: u8 = 0,
            }),
            /// General Purpose Timer #0 Controller
            GPTIMER0CTRL: mmio.Mmio(packed struct(u32) {
                /// General Purpose Timer Counter. This field is the count value of the countdown timer.
                GPTCNT: u24,
                /// General Purpose Timer Mode In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is reset by software; In repeat mode, the timer will count down to zero, generate an interrupt and automatically reload the counter value from GPTLD bits to start again
                GPTMODE: enum(u1) {
                    /// One Shot Mode
                    GPTMODE_0 = 0x0,
                    /// Repeat Mode
                    GPTMODE_1 = 0x1,
                },
                reserved30: u5 = 0,
                /// General Purpose Timer Reset
                GPTRST: enum(u1) {
                    /// No action
                    GPTRST_0 = 0x0,
                    /// Load counter value from GPTLD bits in n_GPTIMER0LD
                    GPTRST_1 = 0x1,
                },
                /// General Purpose Timer Run GPTCNT bits are not effected when setting or clearing this bit.
                GPTRUN: enum(u1) {
                    /// Stop counting
                    GPTRUN_0 = 0x0,
                    /// Run
                    GPTRUN_1 = 0x1,
                },
            }),
            /// General Purpose Timer #1 Load
            GPTIMER1LD: mmio.Mmio(packed struct(u32) {
                /// General Purpose Timer Load Value These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'
                GPTLD: u24,
                padding: u8 = 0,
            }),
            /// General Purpose Timer #1 Controller
            GPTIMER1CTRL: mmio.Mmio(packed struct(u32) {
                /// General Purpose Timer Counter. This field is the count value of the countdown timer.
                GPTCNT: u24,
                /// General Purpose Timer Mode In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is reset by software
                GPTMODE: enum(u1) {
                    /// One Shot Mode
                    GPTMODE_0 = 0x0,
                    /// Repeat Mode
                    GPTMODE_1 = 0x1,
                },
                reserved30: u5 = 0,
                /// General Purpose Timer Reset
                GPTRST: enum(u1) {
                    /// No action
                    GPTRST_0 = 0x0,
                    /// Load counter value from GPTLD bits in USB_n_GPTIMER0LD
                    GPTRST_1 = 0x1,
                },
                /// General Purpose Timer Run GPTCNT bits are not effected when setting or clearing this bit.
                GPTRUN: enum(u1) {
                    /// Stop counting
                    GPTRUN_0 = 0x0,
                    /// Run
                    GPTRUN_1 = 0x1,
                },
            }),
            /// System Bus Config
            SBUSCFG: mmio.Mmio(packed struct(u32) {
                /// AHB master interface Burst configuration These bits control AHB master transfer type sequence (or priority)
                AHBBRST: enum(u3) {
                    /// Incremental burst of unspecified length only
                    AHBBRST_0 = 0x0,
                    /// INCR4 burst, then single transfer
                    AHBBRST_1 = 0x1,
                    /// INCR8 burst, INCR4 burst, then single transfer
                    AHBBRST_2 = 0x2,
                    /// INCR16 burst, INCR8 burst, INCR4 burst, then single transfer
                    AHBBRST_3 = 0x3,
                    /// INCR4 burst, then incremental burst of unspecified length
                    AHBBRST_5 = 0x5,
                    /// INCR8 burst, INCR4 burst, then incremental burst of unspecified length
                    AHBBRST_6 = 0x6,
                    /// INCR16 burst, INCR8 burst, INCR4 burst, then incremental burst of unspecified length
                    AHBBRST_7 = 0x7,
                    _,
                },
                padding: u29 = 0,
            }),
            reserved256: [108]u8,
            /// Capability Registers Length
            CAPLENGTH: mmio.Mmio(packed struct(u8) {
                /// These bits are used as an offset to add to register base to find the beginning of the Operational Register
                CAPLENGTH: u8,
            }),
            reserved258: [1]u8,
            /// Host Controller Interface Version
            HCIVERSION: mmio.Mmio(packed struct(u16) {
                /// Host Controller Interface Version Number Default value is '10h', which means EHCI rev1.0.
                HCIVERSION: u16,
            }),
            /// Host Controller Structural Parameters
            HCSPARAMS: mmio.Mmio(packed struct(u32) {
                /// Number of downstream ports
                N_PORTS: u4,
                /// Port Power Control This field indicates whether the host controller implementation includes port power control
                PPC: u1,
                reserved8: u3 = 0,
                /// Number of Ports per Companion Controller This field indicates the number of ports supported per internal Companion Controller
                N_PCC: u4,
                /// Number of Companion Controller (N_CC)
                N_CC: enum(u4) {
                    /// There is no internal Companion Controller and port-ownership hand-off is not supported.
                    N_CC_0 = 0x0,
                    /// There are internal companion controller(s) and port-ownership hand-offs is supported.
                    N_CC_1 = 0x1,
                    _,
                },
                /// Port Indicators (P INDICATOR) This bit indicates whether the ports support port indicator control
                PI: u1,
                reserved20: u3 = 0,
                /// Number of Ports per Transaction Translator (N_PTT)
                N_PTT: u4,
                /// Number of Transaction Translators (N_TT)
                N_TT: u4,
                padding: u4 = 0,
            }),
            /// Host Controller Capability Parameters
            HCCPARAMS: mmio.Mmio(packed struct(u32) {
                /// 64-bit Addressing Capability This bit is set '0b' in all controller core, no 64-bit addressing capability is supported
                ADC: u1,
                /// Programmable Frame List Flag If this bit is set to zero, then the system software must use a frame list length of 1024 elements with this host controller
                PFL: u1,
                /// Asynchronous Schedule Park Capability If this bit is set to a one, then the host controller supports the park feature for high-speed queue heads in the Asynchronous Schedule
                ASP: u1,
                reserved4: u1 = 0,
                /// Isochronous Scheduling Threshold
                IST: u4,
                /// EHCI Extended Capabilities Pointer
                EECP: u8,
                padding: u16 = 0,
            }),
            reserved288: [20]u8,
            /// Device Controller Interface Version
            DCIVERSION: mmio.Mmio(packed struct(u16) {
                /// Device Controller Interface Version Number Default value is '01h', which means rev0.1.
                DCIVERSION: u16,
            }),
            reserved292: [2]u8,
            /// Device Controller Capability Parameters
            DCCPARAMS: mmio.Mmio(packed struct(u32) {
                /// Device Endpoint Number This field indicates the number of endpoints built into the device controller
                DEN: u5,
                reserved7: u2 = 0,
                /// Device Capable When this bit is 1, this controller is capable of operating as a USB 2.0 device.
                DC: u1,
                /// Host Capable When this bit is 1, this controller is capable of operating as an EHCI compatible USB 2
                HC: u1,
                padding: u23 = 0,
            }),
            reserved320: [24]u8,
            /// USB Command Register
            USBCMD: mmio.Mmio(packed struct(u32) {
                /// Run/Stop (RS) - Read/Write
                RS: u1,
                /// Controller Reset (RESET) - Read/Write
                RST: u1,
                /// See description at bit 15
                FS_1: u2,
                /// Periodic Schedule Enable- Read/Write
                PSE: enum(u1) {
                    /// Do not process the Periodic Schedule
                    PSE_0 = 0x0,
                    /// Use the PERIODICLISTBASE register to access the Periodic Schedule.
                    PSE_1 = 0x1,
                },
                /// Asynchronous Schedule Enable - Read/Write
                ASE: enum(u1) {
                    /// Do not process the Asynchronous Schedule.
                    ASE_0 = 0x0,
                    /// Use the ASYNCLISTADDR register to access the Asynchronous Schedule.
                    ASE_1 = 0x1,
                },
                /// Interrupt on Async Advance Doorbell - Read/Write
                IAA: u1,
                reserved8: u1 = 0,
                /// Asynchronous Schedule Park Mode Count - Read/Write
                ASP: u2,
                reserved11: u1 = 0,
                /// Asynchronous Schedule Park Mode Enable - Read/Write
                ASPE: u1,
                /// Add dTD TripWire - Read/Write
                ATDTW: u1,
                /// Setup TripWire - Read/Write
                SUTW: u1,
                reserved15: u1 = 0,
                /// See also bits 3-2 Frame List Size - (Read/Write or Read Only)
                FS_2: enum(u1) {
                    /// 1024 elements (4096 bytes) Default value
                    FS_2_0 = 0x0,
                    /// 512 elements (2048 bytes)
                    FS_2_1 = 0x1,
                },
                /// Interrupt Threshold Control -Read/Write
                ITC: enum(u8) {
                    /// Immediate (no threshold)
                    ITC_0 = 0x0,
                    /// 1 micro-frame
                    ITC_1 = 0x1,
                    /// 2 micro-frames
                    ITC_2 = 0x2,
                    /// 4 micro-frames
                    ITC_4 = 0x4,
                    /// 8 micro-frames
                    ITC_8 = 0x8,
                    /// 16 micro-frames
                    ITC_16 = 0x10,
                    /// 32 micro-frames
                    ITC_32 = 0x20,
                    /// 64 micro-frames
                    ITC_64 = 0x40,
                    _,
                },
                padding: u8 = 0,
            }),
            /// USB Status Register
            USBSTS: mmio.Mmio(packed struct(u32) {
                /// USB Interrupt (USBINT) - R/WC
                UI: u1,
                /// USB Error Interrupt (USBERRINT) - R/WC
                UEI: u1,
                /// Port Change Detect - R/WC
                PCI: u1,
                /// Frame List Rollover - R/WC
                FRI: u1,
                /// System Error- R/WC
                SEI: u1,
                /// Interrupt on Async Advance - R/WC
                AAI: u1,
                /// USB Reset Received - R/WC
                URI: u1,
                /// SOF Received - R/WC
                SRI: u1,
                /// DCSuspend - R/WC
                SLI: u1,
                reserved10: u1 = 0,
                /// ULPI Interrupt - R/WC
                ULPII: u1,
                reserved12: u1 = 0,
                /// HCHaIted - Read Only
                HCH: u1,
                /// Reclamation - Read Only
                RCL: u1,
                /// Periodic Schedule Status - Read Only
                PS: u1,
                /// Asynchronous Schedule Status - Read Only
                AS: u1,
                /// NAK Interrupt Bit--RO
                NAKI: u1,
                reserved24: u7 = 0,
                /// General Purpose Timer Interrupt 0(GPTINT0)--R/WC
                TI0: u1,
                /// General Purpose Timer Interrupt 1(GPTINT1)--R/WC
                TI1: u1,
                padding: u6 = 0,
            }),
            /// Interrupt Enable Register
            USBINTR: mmio.Mmio(packed struct(u32) {
                /// USB Interrupt Enable When this bit is one and the UI bit in n_USBSTS register is a one the controller will issue an interrupt
                UE: u1,
                /// USB Error Interrupt Enable When this bit is one and the UEI bit in n_USBSTS register is a one the controller will issue an interrupt
                UEE: u1,
                /// Port Change Detect Interrupt Enable When this bit is one and the PCI bit in n_USBSTS register is a one the controller will issue an interrupt
                PCE: u1,
                /// Frame List Rollover Interrupt Enable When this bit is one and the FRI bit in n_USBSTS register is a one the controller will issue an interrupt
                FRE: u1,
                /// System Error Interrupt Enable When this bit is one and the SEI bit in n_USBSTS register is a one the controller will issue an interrupt
                SEE: u1,
                /// Async Advance Interrupt Enable When this bit is one and the AAI bit in n_USBSTS register is a one the controller will issue an interrupt
                AAE: u1,
                /// USB Reset Interrupt Enable When this bit is one and the URI bit in n_USBSTS register is a one the controller will issue an interrupt
                URE: u1,
                /// SOF Received Interrupt Enable When this bit is one and the SRI bit in n_USBSTS register is a one the controller will issue an interrupt
                SRE: u1,
                /// Sleep Interrupt Enable When this bit is one and the SLI bit in n_n_USBSTS register is a one the controller will issue an interrupt
                SLE: u1,
                reserved10: u1 = 0,
                /// ULPI Interrupt Enable When this bit is one and the UPLII bit in n_USBSTS register is a one the controller will issue an interrupt
                ULPIE: u1,
                reserved16: u5 = 0,
                /// NAK Interrupt Enable When this bit is one and the NAKI bit in n_USBSTS register is a one the controller will issue an interrupt
                NAKE: u1,
                reserved18: u1 = 0,
                /// USB Host Asynchronous Interrupt Enable When this bit is one, and the UAI bit in the n_USBSTS register is one, host controller will issue an interrupt at the next interrupt threshold
                UAIE: u1,
                /// USB Host Periodic Interrupt Enable When this bit is one, and the UPI bit in the n_USBSTS register is one, host controller will issue an interrupt at the next interrupt threshold
                UPIE: u1,
                reserved24: u4 = 0,
                /// General Purpose Timer #0 Interrupt Enable When this bit is one and the TI0 bit in n_USBSTS register is a one the controller will issue an interrupt
                TIE0: u1,
                /// General Purpose Timer #1 Interrupt Enable When this bit is one and the TI1 bit in n_USBSTS register is a one the controller will issue an interrupt
                TIE1: u1,
                padding: u6 = 0,
            }),
            /// USB Frame Index
            FRINDEX: mmio.Mmio(packed struct(u32) {
                /// Frame Index
                FRINDEX: enum(u14) {
                    /// (1024) 12
                    FRINDEX_0 = 0x0,
                    /// (512) 11
                    FRINDEX_1 = 0x1,
                    /// (256) 10
                    FRINDEX_2 = 0x2,
                    /// (128) 9
                    FRINDEX_3 = 0x3,
                    /// (64) 8
                    FRINDEX_4 = 0x4,
                    /// (32) 7
                    FRINDEX_5 = 0x5,
                    /// (16) 6
                    FRINDEX_6 = 0x6,
                    /// (8) 5
                    FRINDEX_7 = 0x7,
                    _,
                },
                padding: u18 = 0,
            }),
            reserved340: [4]u8,
            /// Device Address
            DEVICEADDR: mmio.Mmio(packed struct(u32) {
                reserved24: u24 = 0,
                /// Device Address Advance
                USBADRA: u1,
                /// Device Address. These bits correspond to the USB device address
                USBADR: u7,
            }),
            /// Next Asynch. Address
            ASYNCLISTADDR: mmio.Mmio(packed struct(u32) {
                reserved5: u5 = 0,
                /// Link Pointer Low (LPL)
                ASYBASE: u27,
            }),
            reserved352: [4]u8,
            /// Programmable Burst Size
            BURSTSIZE: mmio.Mmio(packed struct(u32) {
                /// Programmable RX Burst Size
                RXPBURST: u8,
                /// Programmable TX Burst Size
                TXPBURST: u9,
                padding: u15 = 0,
            }),
            /// TX FIFO Fill Tuning
            TXFILLTUNING: mmio.Mmio(packed struct(u32) {
                /// Scheduler Overhead
                TXSCHOH: u8,
                /// Scheduler Health Counter
                TXSCHHEALTH: u5,
                reserved16: u3 = 0,
                /// FIFO Burst Threshold
                TXFIFOTHRES: u6,
                padding: u10 = 0,
            }),
            reserved376: [16]u8,
            /// Endpoint NAK
            ENDPTNAK: mmio.Mmio(packed struct(u32) {
                /// RX Endpoint NAK - R/WC
                EPRN: u8,
                reserved16: u8 = 0,
                /// TX Endpoint NAK - R/WC
                EPTN: u8,
                padding: u8 = 0,
            }),
            /// Endpoint NAK Enable
            ENDPTNAKEN: mmio.Mmio(packed struct(u32) {
                /// RX Endpoint NAK Enable - R/W
                EPRNE: u8,
                reserved16: u8 = 0,
                /// TX Endpoint NAK Enable - R/W
                EPTNE: u8,
                padding: u8 = 0,
            }),
            /// Configure Flag Register
            CONFIGFLAG: mmio.Mmio(packed struct(u32) {
                /// Configure Flag Host software sets this bit as the last action in its process of configuring the Host Controller
                CF: enum(u1) {
                    /// Port routing control logic default-routes each port to an implementation dependent classic host controller.
                    CF_0 = 0x0,
                    /// Port routing control logic default-routes all ports to this host controller.
                    CF_1 = 0x1,
                },
                padding: u31 = 0,
            }),
            /// Port Status & Control
            PORTSC1: mmio.Mmio(packed struct(u32) {
                /// Current Connect Status-Read Only
                CCS: u1,
                /// Connect Status Change-R/WC
                CSC: u1,
                /// Port Enabled/Disabled-Read/Write
                PE: u1,
                /// Port Enable/Disable Change-R/WC
                PEC: u1,
                /// Over-current Active-Read Only
                OCA: enum(u1) {
                    /// This port does not have an over-current condition.
                    OCA_0 = 0x0,
                    /// This port currently has an over-current condition
                    OCA_1 = 0x1,
                },
                /// Over-current Change-R/WC
                OCC: u1,
                /// Force Port Resume -Read/Write
                FPR: u1,
                /// Suspend - Read/Write or Read Only
                SUSP: u1,
                /// Port Reset - Read/Write or Read Only
                PR: u1,
                /// High-Speed Port - Read Only
                HSP: u1,
                /// Line Status-Read Only
                LS: enum(u2) {
                    /// SE0
                    LS_0 = 0x0,
                    /// K-state
                    LS_1 = 0x1,
                    /// J-state
                    LS_2 = 0x2,
                    /// Undefined
                    LS_3 = 0x3,
                },
                /// Port Power (PP)-Read/Write or Read Only
                PP: u1,
                /// Port Owner-Read/Write
                PO: u1,
                /// Port Indicator Control - Read/Write
                PIC: enum(u2) {
                    /// Port indicators are off
                    PIC_0 = 0x0,
                    /// Amber
                    PIC_1 = 0x1,
                    /// Green
                    PIC_2 = 0x2,
                    /// Undefined
                    PIC_3 = 0x3,
                },
                /// Port Test Control - Read/Write
                PTC: enum(u4) {
                    /// TEST_MODE_DISABLE
                    PTC_0 = 0x0,
                    /// J_STATE
                    PTC_1 = 0x1,
                    /// K_STATE
                    PTC_2 = 0x2,
                    /// SE0 (host) / NAK (device)
                    PTC_3 = 0x3,
                    /// Packet
                    PTC_4 = 0x4,
                    /// FORCE_ENABLE_HS
                    PTC_5 = 0x5,
                    /// FORCE_ENABLE_FS
                    PTC_6 = 0x6,
                    /// FORCE_ENABLE_LS
                    PTC_7 = 0x7,
                    _,
                },
                /// Wake on Connect Enable (WKCNNT_E) - Read/Write
                WKCN: u1,
                /// Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write
                WKDC: u1,
                /// Wake on Over-current Enable (WKOC_E) - Read/Write
                WKOC: u1,
                /// PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write
                PHCD: enum(u1) {
                    /// Enable PHY clock
                    PHCD_0 = 0x0,
                    /// Disable PHY clock
                    PHCD_1 = 0x1,
                },
                /// Port Force Full Speed Connect - Read/Write
                PFSC: enum(u1) {
                    /// Normal operation
                    PFSC_0 = 0x0,
                    /// Forced to full speed
                    PFSC_1 = 0x1,
                },
                /// See description at bits 31-30
                PTS_2: u1,
                /// Port Speed - Read Only. This register field indicates the speed at which the port is operating.
                PSPD: enum(u2) {
                    /// Full Speed
                    PSPD_0 = 0x0,
                    /// Low Speed
                    PSPD_1 = 0x1,
                    /// High Speed
                    PSPD_2 = 0x2,
                    /// Undefined
                    PSPD_3 = 0x3,
                },
                /// Parallel Transceiver Width This bit has no effect if serial interface engine is used
                PTW: enum(u1) {
                    /// Select the 8-bit UTMI interface [60MHz]
                    PTW_0 = 0x0,
                    /// Select the 16-bit UTMI interface [30MHz]
                    PTW_1 = 0x1,
                },
                /// Serial Transceiver Select 1 Serial Interface Engine is selected 0 Parallel Interface signals is selected Serial Interface Engine can be used in combination with UTMI+/ULPI physical interface to provide FS/LS signaling instead of the parallel interface signals
                STS: u1,
                /// All USB port interface modes are listed in this field description, but not all are supported
                PTS_1: u2,
            }),
            reserved420: [28]u8,
            /// On-The-Go Status & control
            OTGSC: mmio.Mmio(packed struct(u32) {
                /// VBUS_Discharge - Read/Write. Setting this bit causes VBus to discharge through a resistor.
                VD: u1,
                /// VBUS Charge - Read/Write
                VC: u1,
                reserved3: u1 = 0,
                /// OTG Termination - Read/Write
                OT: u1,
                /// Data Pulsing - Read/Write
                DP: u1,
                /// ID Pullup - Read/Write This bit provide control over the ID pull-up resistor; 0 = off, 1 = on [default]
                IDPU: u1,
                reserved8: u2 = 0,
                /// USB ID - Read Only. 0 = A device, 1 = B device
                ID: u1,
                /// A VBus Valid - Read Only. Indicates VBus is above the A VBus valid threshold.
                AVV: u1,
                /// A Session Valid - Read Only. Indicates VBus is above the A session valid threshold.
                ASV: u1,
                /// B Session Valid - Read Only. Indicates VBus is above the B session valid threshold.
                BSV: u1,
                /// B Session End - Read Only. Indicates VBus is below the B session end threshold.
                BSE: u1,
                /// 1 millisecond timer toggle - Read Only. This bit toggles once per millisecond.
                TOG_1MS: u1,
                /// Data Bus Pulsing Status - Read Only
                DPS: u1,
                reserved16: u1 = 0,
                /// USB ID Interrupt Status - Read/Write
                IDIS: u1,
                /// A VBus Valid Interrupt Status - Read/Write to Clear
                AVVIS: u1,
                /// A Session Valid Interrupt Status - Read/Write to Clear
                ASVIS: u1,
                /// B Session Valid Interrupt Status - Read/Write to Clear
                BSVIS: u1,
                /// B Session End Interrupt Status - Read/Write to Clear
                BSEIS: u1,
                /// 1 millisecond timer Interrupt Status - Read/Write to Clear
                STATUS_1MS: u1,
                /// Data Pulse Interrupt Status - Read/Write to Clear
                DPIS: u1,
                reserved24: u1 = 0,
                /// USB ID Interrupt Enable - Read/Write. Setting this bit enables the USB ID interrupt.
                IDIE: u1,
                /// A VBus Valid Interrupt Enable - Read/Write. Setting this bit enables the A VBus valid interrupt.
                AVVIE: u1,
                /// A Session Valid Interrupt Enable - Read/Write
                ASVIE: u1,
                /// B Session Valid Interrupt Enable - Read/Write
                BSVIE: u1,
                /// B Session End Interrupt Enable - Read/Write. Setting this bit enables the B session end interrupt.
                BSEIE: u1,
                /// 1 millisecond timer Interrupt Enable - Read/Write
                EN_1MS: u1,
                /// Data Pulse Interrupt Enable
                DPIE: u1,
                padding: u1 = 0,
            }),
            /// USB Device Mode
            USBMODE: mmio.Mmio(packed struct(u32) {
                /// Controller Mode - R/WO
                CM: enum(u2) {
                    /// Idle [Default for combination host/device]
                    CM_0 = 0x0,
                    /// Device Controller [Default for device only controller]
                    CM_2 = 0x2,
                    /// Host Controller [Default for host only controller]
                    CM_3 = 0x3,
                    _,
                },
                /// Endian Select - Read/Write
                ES: enum(u1) {
                    /// Little Endian [Default]
                    ES_0 = 0x0,
                    /// Big Endian
                    ES_1 = 0x1,
                },
                /// Setup Lockout Mode
                SLOM: enum(u1) {
                    /// Setup Lockouts On (default);
                    SLOM_0 = 0x0,
                    /// Setup Lockouts Off (DCD requires use of Setup Data Buffer Tripwire in USBCMDUSB Command Register .
                    SLOM_1 = 0x1,
                },
                /// Stream Disable Mode
                SDIS: u1,
                padding: u27 = 0,
            }),
            /// Endpoint Setup Status
            ENDPTSETUPSTAT: mmio.Mmio(packed struct(u32) {
                /// Setup Endpoint Status
                ENDPTSETUPSTAT: u16,
                padding: u16 = 0,
            }),
            /// Endpoint Prime
            ENDPTPRIME: mmio.Mmio(packed struct(u32) {
                /// Prime Endpoint Receive Buffer - R/WS
                PERB: u8,
                reserved16: u8 = 0,
                /// Prime Endpoint Transmit Buffer - R/WS
                PETB: u8,
                padding: u8 = 0,
            }),
            /// Endpoint Flush
            ENDPTFLUSH: mmio.Mmio(packed struct(u32) {
                /// Flush Endpoint Receive Buffer - R/WS
                FERB: u8,
                reserved16: u8 = 0,
                /// Flush Endpoint Transmit Buffer - R/WS
                FETB: u8,
                padding: u8 = 0,
            }),
            /// Endpoint Status
            ENDPTSTAT: mmio.Mmio(packed struct(u32) {
                /// Endpoint Receive Buffer Ready -- Read Only
                ERBR: u8,
                reserved16: u8 = 0,
                /// Endpoint Transmit Buffer Ready -- Read Only
                ETBR: u8,
                padding: u8 = 0,
            }),
            /// Endpoint Complete
            ENDPTCOMPLETE: mmio.Mmio(packed struct(u32) {
                /// Endpoint Receive Complete Event - RW/C
                ERCE: u8,
                reserved16: u8 = 0,
                /// Endpoint Transmit Complete Event - R/WC
                ETCE: u8,
                padding: u8 = 0,
            }),
            /// Endpoint Control0
            ENDPTCTRL0: mmio.Mmio(packed struct(u32) {
                /// RX Endpoint Stall - Read/Write 0 End Point OK
                RXS: u1,
                reserved2: u1 = 0,
                /// RX Endpoint Type - Read/Write 00 Control Endpoint0 is fixed as a Control End Point.
                RXT: u2,
                reserved7: u3 = 0,
                /// RX Endpoint Enable 1 Enabled Endpoint0 is always enabled.
                RXE: u1,
                reserved16: u8 = 0,
                /// TX Endpoint Stall - Read/Write 0 End Point OK [Default] 1 End Point Stalled Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host
                TXS: u1,
                reserved18: u1 = 0,
                /// TX Endpoint Type - Read/Write 00 - Control Endpoint0 is fixed as a Control End Point.
                TXT: u2,
                reserved23: u3 = 0,
                /// TX Endpoint Enable 1 Enabled Endpoint0 is always enabled.
                TXE: u1,
                padding: u8 = 0,
            }),
            /// Endpoint Control 1
            ENDPTCTRL1: mmio.Mmio(packed struct(u32) {
                /// RX Endpoint Stall - Read/Write 0 End Point OK
                RXS: u1,
                /// RX Endpoint Data Sink - Read/Write 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero
                RXD: u1,
                /// RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt
                RXT: u2,
                reserved5: u1 = 0,
                /// RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero
                RXI: u1,
                /// RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device
                RXR: u1,
                /// RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured
                RXE: u1,
                reserved16: u8 = 0,
                /// TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit will be cleared automatically upon receipt of a SETUP request if this Endpoint is configured as a Control Endpoint and this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit is cleared
                TXS: u1,
                /// TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0
                TXD: u1,
                /// TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt
                TXT: u2,
                reserved21: u1 = 0,
                /// TX Data Toggle Inhibit 0 PID Sequencing Enabled
                TXI: u1,
                /// TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device
                TXR: u1,
                /// TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured
                TXE: u1,
                padding: u8 = 0,
            }),
            /// Endpoint Control 2
            ENDPTCTRL2: mmio.Mmio(packed struct(u32) {
                /// RX Endpoint Stall - Read/Write 0 End Point OK
                RXS: u1,
                /// RX Endpoint Data Sink - Read/Write 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero
                RXD: u1,
                /// RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt
                RXT: u2,
                reserved5: u1 = 0,
                /// RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero
                RXI: u1,
                /// RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device
                RXR: u1,
                /// RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured
                RXE: u1,
                reserved16: u8 = 0,
                /// TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit will be cleared automatically upon receipt of a SETUP request if this Endpoint is configured as a Control Endpoint and this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit is cleared
                TXS: u1,
                /// TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0
                TXD: u1,
                /// TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt
                TXT: u2,
                reserved21: u1 = 0,
                /// TX Data Toggle Inhibit 0 PID Sequencing Enabled
                TXI: u1,
                /// TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device
                TXR: u1,
                /// TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured
                TXE: u1,
                padding: u8 = 0,
            }),
            /// Endpoint Control 3
            ENDPTCTRL3: mmio.Mmio(packed struct(u32) {
                /// RX Endpoint Stall - Read/Write 0 End Point OK
                RXS: u1,
                /// RX Endpoint Data Sink - Read/Write 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero
                RXD: u1,
                /// RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt
                RXT: u2,
                reserved5: u1 = 0,
                /// RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero
                RXI: u1,
                /// RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device
                RXR: u1,
                /// RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured
                RXE: u1,
                reserved16: u8 = 0,
                /// TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit will be cleared automatically upon receipt of a SETUP request if this Endpoint is configured as a Control Endpoint and this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit is cleared
                TXS: u1,
                /// TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0
                TXD: u1,
                /// TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt
                TXT: u2,
                reserved21: u1 = 0,
                /// TX Data Toggle Inhibit 0 PID Sequencing Enabled
                TXI: u1,
                /// TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device
                TXR: u1,
                /// TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured
                TXE: u1,
                padding: u8 = 0,
            }),
            /// Endpoint Control 4
            ENDPTCTRL4: mmio.Mmio(packed struct(u32) {
                /// RX Endpoint Stall - Read/Write 0 End Point OK
                RXS: u1,
                /// RX Endpoint Data Sink - Read/Write 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero
                RXD: u1,
                /// RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt
                RXT: u2,
                reserved5: u1 = 0,
                /// RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero
                RXI: u1,
                /// RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device
                RXR: u1,
                /// RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured
                RXE: u1,
                reserved16: u8 = 0,
                /// TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit will be cleared automatically upon receipt of a SETUP request if this Endpoint is configured as a Control Endpoint and this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit is cleared
                TXS: u1,
                /// TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0
                TXD: u1,
                /// TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt
                TXT: u2,
                reserved21: u1 = 0,
                /// TX Data Toggle Inhibit 0 PID Sequencing Enabled
                TXI: u1,
                /// TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device
                TXR: u1,
                /// TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured
                TXE: u1,
                padding: u8 = 0,
            }),
            /// Endpoint Control 5
            ENDPTCTRL5: mmio.Mmio(packed struct(u32) {
                /// RX Endpoint Stall - Read/Write 0 End Point OK
                RXS: u1,
                /// RX Endpoint Data Sink - Read/Write 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero
                RXD: u1,
                /// RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt
                RXT: u2,
                reserved5: u1 = 0,
                /// RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero
                RXI: u1,
                /// RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device
                RXR: u1,
                /// RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured
                RXE: u1,
                reserved16: u8 = 0,
                /// TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit will be cleared automatically upon receipt of a SETUP request if this Endpoint is configured as a Control Endpoint and this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit is cleared
                TXS: u1,
                /// TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0
                TXD: u1,
                /// TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt
                TXT: u2,
                reserved21: u1 = 0,
                /// TX Data Toggle Inhibit 0 PID Sequencing Enabled
                TXI: u1,
                /// TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device
                TXR: u1,
                /// TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured
                TXE: u1,
                padding: u8 = 0,
            }),
            /// Endpoint Control 6
            ENDPTCTRL6: mmio.Mmio(packed struct(u32) {
                /// RX Endpoint Stall - Read/Write 0 End Point OK
                RXS: u1,
                /// RX Endpoint Data Sink - Read/Write 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero
                RXD: u1,
                /// RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt
                RXT: u2,
                reserved5: u1 = 0,
                /// RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero
                RXI: u1,
                /// RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device
                RXR: u1,
                /// RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured
                RXE: u1,
                reserved16: u8 = 0,
                /// TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit will be cleared automatically upon receipt of a SETUP request if this Endpoint is configured as a Control Endpoint and this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit is cleared
                TXS: u1,
                /// TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0
                TXD: u1,
                /// TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt
                TXT: u2,
                reserved21: u1 = 0,
                /// TX Data Toggle Inhibit 0 PID Sequencing Enabled
                TXI: u1,
                /// TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device
                TXR: u1,
                /// TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured
                TXE: u1,
                padding: u8 = 0,
            }),
            /// Endpoint Control 7
            ENDPTCTRL7: mmio.Mmio(packed struct(u32) {
                /// RX Endpoint Stall - Read/Write 0 End Point OK
                RXS: u1,
                /// RX Endpoint Data Sink - Read/Write 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero
                RXD: u1,
                /// RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt
                RXT: u2,
                reserved5: u1 = 0,
                /// RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero
                RXI: u1,
                /// RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device
                RXR: u1,
                /// RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured
                RXE: u1,
                reserved16: u8 = 0,
                /// TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit will be cleared automatically upon receipt of a SETUP request if this Endpoint is configured as a Control Endpoint and this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit is cleared
                TXS: u1,
                /// TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0
                TXD: u1,
                /// TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt
                TXT: u2,
                reserved21: u1 = 0,
                /// TX Data Toggle Inhibit 0 PID Sequencing Enabled
                TXI: u1,
                /// TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device
                TXR: u1,
                /// TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured
                TXE: u1,
                padding: u8 = 0,
            }),
        };

        /// USB
        pub const USBNC1 = extern struct {
            reserved2048: [2048]u8,
            /// USB OTG1 Control Register
            USB_OTG1_CTRL: mmio.Mmio(packed struct(u32) {
                reserved7: u7 = 0,
                /// Disable OTG1 Overcurrent Detection
                OVER_CUR_DIS: enum(u1) {
                    /// Enables overcurrent detection
                    OVER_CUR_DIS_0 = 0x0,
                    /// Disables overcurrent detection
                    OVER_CUR_DIS_1 = 0x1,
                },
                /// OTG1 Polarity of Overcurrent The polarity of OTG1 port overcurrent event
                OVER_CUR_POL: enum(u1) {
                    /// High active (high on this signal represents an overcurrent condition)
                    OVER_CUR_POL_0 = 0x0,
                    /// Low active (low on this signal represents an overcurrent condition)
                    OVER_CUR_POL_1 = 0x1,
                },
                /// OTG1 Power Polarity This bit should be set according to PMIC Power Pin polarity.
                PWR_POL: enum(u1) {
                    /// PMIC Power Pin is Low active.
                    PWR_POL_0 = 0x0,
                    /// PMIC Power Pin is High active.
                    PWR_POL_1 = 0x1,
                },
                /// OTG1 Wake-up Interrupt Enable This bit enables or disables the OTG1 wake-up interrupt
                WIE: enum(u1) {
                    /// Interrupt Disabled
                    WIE_0 = 0x0,
                    /// Interrupt Enabled
                    WIE_1 = 0x1,
                },
                reserved14: u3 = 0,
                /// OTG1 Software Wake-up Enable
                WKUP_SW_EN: enum(u1) {
                    /// Disable
                    WKUP_SW_EN_0 = 0x0,
                    /// Enable
                    WKUP_SW_EN_1 = 0x1,
                },
                /// OTG1 Software Wake-up
                WKUP_SW: enum(u1) {
                    /// Inactive
                    WKUP_SW_0 = 0x0,
                    /// Force wake-up
                    WKUP_SW_1 = 0x1,
                },
                /// OTG1 Wake-up on ID change enable
                WKUP_ID_EN: enum(u1) {
                    /// Disable
                    WKUP_ID_EN_0 = 0x0,
                    /// Enable
                    WKUP_ID_EN_1 = 0x1,
                },
                /// OTG1 wake-up on VBUS change enable
                WKUP_VBUS_EN: enum(u1) {
                    /// Disable
                    WKUP_VBUS_EN_0 = 0x0,
                    /// Enable
                    WKUP_VBUS_EN_1 = 0x1,
                },
                reserved29: u11 = 0,
                /// Wake-up on DPDM change enable
                WKUP_DPDM_EN: enum(u1) {
                    /// DPDM changes wake-up to be disabled only when VBUS is 0.
                    WKUP_DPDM_EN_0 = 0x0,
                    /// (Default) DPDM changes wake-up to be enabled, it is for device only.
                    WKUP_DPDM_EN_1 = 0x1,
                },
                reserved31: u1 = 0,
                /// OTG1 Wake-up Interrupt Request This bit indicates that a wake-up interrupt request is received on the OTG1 port
                WIR: enum(u1) {
                    /// No wake-up interrupt request received
                    WIR_0 = 0x0,
                    /// Wake-up Interrupt Request received
                    WIR_1 = 0x1,
                },
            }),
            reserved2072: [20]u8,
            /// OTG1 UTMI PHY Control 0 Register
            USB_OTG1_PHY_CTRL_0: mmio.Mmio(packed struct(u32) {
                reserved31: u31 = 0,
                /// Indicating whether OTG1 UTMI PHY clock is valid
                UTMI_CLK_VLD: enum(u1) {
                    /// Invalid
                    UTMI_CLK_VLD_0 = 0x0,
                    /// Valid
                    UTMI_CLK_VLD_1 = 0x1,
                },
            }),
        };

        /// USBPHY Register Reference Index
        pub const USBPHY1 = extern struct {
            /// USB PHY Power-Down Register
            PWD: mmio.Mmio(packed struct(u32) {
                /// Reserved.
                RSVD0: u10,
                /// 0 = Normal operation
                TXPWDFS: u1,
                /// 0 = Normal operation
                TXPWDIBIAS: u1,
                /// 0 = Normal operation
                TXPWDV2I: u1,
                /// Reserved.
                RSVD1: u4,
                /// 0 = Normal operation
                RXPWDENV: u1,
                /// 0 = Normal operation
                RXPWD1PT1: u1,
                /// 0 = Normal operation
                RXPWDDIFF: u1,
                /// 0 = Normal operation
                RXPWDRX: u1,
                /// Reserved.
                RSVD2: u11,
            }),
            /// USB PHY Power-Down Register
            PWD_SET: mmio.Mmio(packed struct(u32) {
                /// Reserved.
                RSVD0: u10,
                /// 0 = Normal operation
                TXPWDFS: u1,
                /// 0 = Normal operation
                TXPWDIBIAS: u1,
                /// 0 = Normal operation
                TXPWDV2I: u1,
                /// Reserved.
                RSVD1: u4,
                /// 0 = Normal operation
                RXPWDENV: u1,
                /// 0 = Normal operation
                RXPWD1PT1: u1,
                /// 0 = Normal operation
                RXPWDDIFF: u1,
                /// 0 = Normal operation
                RXPWDRX: u1,
                /// Reserved.
                RSVD2: u11,
            }),
            /// USB PHY Power-Down Register
            PWD_CLR: mmio.Mmio(packed struct(u32) {
                /// Reserved.
                RSVD0: u10,
                /// 0 = Normal operation
                TXPWDFS: u1,
                /// 0 = Normal operation
                TXPWDIBIAS: u1,
                /// 0 = Normal operation
                TXPWDV2I: u1,
                /// Reserved.
                RSVD1: u4,
                /// 0 = Normal operation
                RXPWDENV: u1,
                /// 0 = Normal operation
                RXPWD1PT1: u1,
                /// 0 = Normal operation
                RXPWDDIFF: u1,
                /// 0 = Normal operation
                RXPWDRX: u1,
                /// Reserved.
                RSVD2: u11,
            }),
            /// USB PHY Power-Down Register
            PWD_TOG: mmio.Mmio(packed struct(u32) {
                /// Reserved.
                RSVD0: u10,
                /// 0 = Normal operation
                TXPWDFS: u1,
                /// 0 = Normal operation
                TXPWDIBIAS: u1,
                /// 0 = Normal operation
                TXPWDV2I: u1,
                /// Reserved.
                RSVD1: u4,
                /// 0 = Normal operation
                RXPWDENV: u1,
                /// 0 = Normal operation
                RXPWD1PT1: u1,
                /// 0 = Normal operation
                RXPWDDIFF: u1,
                /// 0 = Normal operation
                RXPWDRX: u1,
                /// Reserved.
                RSVD2: u11,
            }),
            /// USB PHY Transmitter Control Register
            TX: mmio.Mmio(packed struct(u32) {
                /// Resistor Trimming Code: 0000 = 0.16% 0111 = Nominal 1111 = +25%
                D_CAL: u4,
                /// Reserved. Note: This bit should remain clear.
                RSVD0: u4,
                /// Decode to select a 45-Ohm resistance to the USB_DN output pin
                TXCAL45DN: u4,
                /// Reserved. Note: This bit should remain clear.
                RSVD1: u4,
                /// Decode to select a 45-Ohm resistance to the USB_DP output pin
                TXCAL45DP: u4,
                /// Reserved.
                RSVD2: u6,
                /// Controls the edge-rate of the current sensing transistors used in HS transmit
                USBPHY_TX_EDGECTRL: u3,
                /// Reserved.
                RSVD5: u3,
            }),
            /// USB PHY Transmitter Control Register
            TX_SET: mmio.Mmio(packed struct(u32) {
                /// Resistor Trimming Code: 0000 = 0.16% 0111 = Nominal 1111 = +25%
                D_CAL: u4,
                /// Reserved. Note: This bit should remain clear.
                RSVD0: u4,
                /// Decode to select a 45-Ohm resistance to the USB_DN output pin
                TXCAL45DN: u4,
                /// Reserved. Note: This bit should remain clear.
                RSVD1: u4,
                /// Decode to select a 45-Ohm resistance to the USB_DP output pin
                TXCAL45DP: u4,
                /// Reserved.
                RSVD2: u6,
                /// Controls the edge-rate of the current sensing transistors used in HS transmit
                USBPHY_TX_EDGECTRL: u3,
                /// Reserved.
                RSVD5: u3,
            }),
            /// USB PHY Transmitter Control Register
            TX_CLR: mmio.Mmio(packed struct(u32) {
                /// Resistor Trimming Code: 0000 = 0.16% 0111 = Nominal 1111 = +25%
                D_CAL: u4,
                /// Reserved. Note: This bit should remain clear.
                RSVD0: u4,
                /// Decode to select a 45-Ohm resistance to the USB_DN output pin
                TXCAL45DN: u4,
                /// Reserved. Note: This bit should remain clear.
                RSVD1: u4,
                /// Decode to select a 45-Ohm resistance to the USB_DP output pin
                TXCAL45DP: u4,
                /// Reserved.
                RSVD2: u6,
                /// Controls the edge-rate of the current sensing transistors used in HS transmit
                USBPHY_TX_EDGECTRL: u3,
                /// Reserved.
                RSVD5: u3,
            }),
            /// USB PHY Transmitter Control Register
            TX_TOG: mmio.Mmio(packed struct(u32) {
                /// Resistor Trimming Code: 0000 = 0.16% 0111 = Nominal 1111 = +25%
                D_CAL: u4,
                /// Reserved. Note: This bit should remain clear.
                RSVD0: u4,
                /// Decode to select a 45-Ohm resistance to the USB_DN output pin
                TXCAL45DN: u4,
                /// Reserved. Note: This bit should remain clear.
                RSVD1: u4,
                /// Decode to select a 45-Ohm resistance to the USB_DP output pin
                TXCAL45DP: u4,
                /// Reserved.
                RSVD2: u6,
                /// Controls the edge-rate of the current sensing transistors used in HS transmit
                USBPHY_TX_EDGECTRL: u3,
                /// Reserved.
                RSVD5: u3,
            }),
            /// USB PHY Receiver Control Register
            RX: mmio.Mmio(packed struct(u32) {
                /// The ENVADJ field adjusts the trip point for the envelope detector
                ENVADJ: u3,
                /// Reserved.
                RSVD0: u1,
                /// The DISCONADJ field adjusts the trip point for the disconnect detector: 000 = Trip-Level Voltage is 0
                DISCONADJ: u3,
                /// Reserved.
                RSVD1: u15,
                /// 0 = Normal operation
                RXDBYPASS: u1,
                /// Reserved.
                RSVD2: u9,
            }),
            /// USB PHY Receiver Control Register
            RX_SET: mmio.Mmio(packed struct(u32) {
                /// The ENVADJ field adjusts the trip point for the envelope detector
                ENVADJ: u3,
                /// Reserved.
                RSVD0: u1,
                /// The DISCONADJ field adjusts the trip point for the disconnect detector: 000 = Trip-Level Voltage is 0
                DISCONADJ: u3,
                /// Reserved.
                RSVD1: u15,
                /// 0 = Normal operation
                RXDBYPASS: u1,
                /// Reserved.
                RSVD2: u9,
            }),
            /// USB PHY Receiver Control Register
            RX_CLR: mmio.Mmio(packed struct(u32) {
                /// The ENVADJ field adjusts the trip point for the envelope detector
                ENVADJ: u3,
                /// Reserved.
                RSVD0: u1,
                /// The DISCONADJ field adjusts the trip point for the disconnect detector: 000 = Trip-Level Voltage is 0
                DISCONADJ: u3,
                /// Reserved.
                RSVD1: u15,
                /// 0 = Normal operation
                RXDBYPASS: u1,
                /// Reserved.
                RSVD2: u9,
            }),
            /// USB PHY Receiver Control Register
            RX_TOG: mmio.Mmio(packed struct(u32) {
                /// The ENVADJ field adjusts the trip point for the envelope detector
                ENVADJ: u3,
                /// Reserved.
                RSVD0: u1,
                /// The DISCONADJ field adjusts the trip point for the disconnect detector: 000 = Trip-Level Voltage is 0
                DISCONADJ: u3,
                /// Reserved.
                RSVD1: u15,
                /// 0 = Normal operation
                RXDBYPASS: u1,
                /// Reserved.
                RSVD2: u9,
            }),
            /// USB PHY General Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                /// Enable OTG_ID_CHG_IRQ.
                ENOTG_ID_CHG_IRQ: u1,
                /// For host mode, enables high-speed disconnect detector
                ENHOSTDISCONDETECT: u1,
                /// Enables interrupt for detection of disconnection to Device when in high-speed host mode
                ENIRQHOSTDISCON: u1,
                /// Indicates that the device has disconnected in high-speed mode
                HOSTDISCONDETECT_IRQ: u1,
                /// For device mode, enables 200-KOhm pullups for detecting connectivity to the host.
                ENDEVPLUGINDETECT: u1,
                /// For device mode, if this bit is cleared to 0, then it trips the interrupt if the device is plugged in
                DEVPLUGIN_POLARITY: u1,
                /// OTG ID change interrupt. Indicates the value of ID pin changed.
                OTG_ID_CHG_IRQ: u1,
                /// Enables circuit to detect resistance of MiniAB ID pin.
                ENOTGIDDETECT: u1,
                /// Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it
                RESUMEIRQSTICKY: u1,
                /// Enables interrupt for detection of a non-J state on the USB line
                ENIRQRESUMEDETECT: u1,
                /// Indicates that the host is sending a wake-up after suspend
                RESUME_IRQ: u1,
                /// Enables interrupt for the detection of connectivity to the USB line.
                ENIRQDEVPLUGIN: u1,
                /// Indicates that the device is connected
                DEVPLUGIN_IRQ: u1,
                /// Enables the LRADC to monitor USB_DP and USB_DM. This is for use in non-USB modes only.
                DATA_ON_LRADC: u1,
                /// Enables UTMI+ Level2. This should be enabled if needs to support LS device
                ENUTMILEVEL2: u1,
                /// Enables UTMI+ Level3
                ENUTMILEVEL3: u1,
                /// Enables interrupt for the wakeup events.
                ENIRQWAKEUP: u1,
                /// Indicates that there is a wakeup event
                WAKEUP_IRQ: u1,
                /// Enables the feature to auto-enable the POWER bit of HW_CLKCTRL_PLLxCTRL0 if there is wakeup event if USB is suspended
                ENAUTO_PWRON_PLL: u1,
                /// Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended
                ENAUTOCLR_CLKGATE: u1,
                /// Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD if there is wakeup event while USB is suspended
                ENAUTOCLR_PHY_PWD: u1,
                /// Enables the feature to wakeup USB if DP/DM is toggled when USB is suspended
                ENDPDMCHG_WKUP: u1,
                /// Enables the feature to wakeup USB if ID is toggled when USB is suspended.
                ENIDCHG_WKUP: u1,
                /// Enables the feature to wakeup USB if VBUS is toggled when USB is suspended.
                ENVBUSCHG_WKUP: u1,
                /// Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet.
                FSDLL_RST_EN: u1,
                /// Reserved.
                RSVD1: u2,
                /// Almost same as OTGID_STATUS in USBPHYx_STATUS Register
                OTG_ID_VALUE: u1,
                /// Forces the next FS packet that is transmitted to have a EOP with LS timing
                HOST_FORCE_LS_SE0: u1,
                /// Used by the PHY to indicate a powered-down state
                UTMI_SUSPENDM: u1,
                /// Gate UTMI Clocks
                CLKGATE: u1,
                /// Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, USBPHYx_RX, and USBPHYx_CTRL registers
                SFTRST: u1,
            }),
            /// USB PHY General Control Register
            CTRL_SET: mmio.Mmio(packed struct(u32) {
                /// Enable OTG_ID_CHG_IRQ.
                ENOTG_ID_CHG_IRQ: u1,
                /// For host mode, enables high-speed disconnect detector
                ENHOSTDISCONDETECT: u1,
                /// Enables interrupt for detection of disconnection to Device when in high-speed host mode
                ENIRQHOSTDISCON: u1,
                /// Indicates that the device has disconnected in high-speed mode
                HOSTDISCONDETECT_IRQ: u1,
                /// For device mode, enables 200-KOhm pullups for detecting connectivity to the host.
                ENDEVPLUGINDETECT: u1,
                /// For device mode, if this bit is cleared to 0, then it trips the interrupt if the device is plugged in
                DEVPLUGIN_POLARITY: u1,
                /// OTG ID change interrupt. Indicates the value of ID pin changed.
                OTG_ID_CHG_IRQ: u1,
                /// Enables circuit to detect resistance of MiniAB ID pin.
                ENOTGIDDETECT: u1,
                /// Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it
                RESUMEIRQSTICKY: u1,
                /// Enables interrupt for detection of a non-J state on the USB line
                ENIRQRESUMEDETECT: u1,
                /// Indicates that the host is sending a wake-up after suspend
                RESUME_IRQ: u1,
                /// Enables interrupt for the detection of connectivity to the USB line.
                ENIRQDEVPLUGIN: u1,
                /// Indicates that the device is connected
                DEVPLUGIN_IRQ: u1,
                /// Enables the LRADC to monitor USB_DP and USB_DM. This is for use in non-USB modes only.
                DATA_ON_LRADC: u1,
                /// Enables UTMI+ Level2. This should be enabled if needs to support LS device
                ENUTMILEVEL2: u1,
                /// Enables UTMI+ Level3
                ENUTMILEVEL3: u1,
                /// Enables interrupt for the wakeup events.
                ENIRQWAKEUP: u1,
                /// Indicates that there is a wakeup event
                WAKEUP_IRQ: u1,
                /// Enables the feature to auto-enable the POWER bit of HW_CLKCTRL_PLLxCTRL0 if there is wakeup event if USB is suspended
                ENAUTO_PWRON_PLL: u1,
                /// Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended
                ENAUTOCLR_CLKGATE: u1,
                /// Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD if there is wakeup event while USB is suspended
                ENAUTOCLR_PHY_PWD: u1,
                /// Enables the feature to wakeup USB if DP/DM is toggled when USB is suspended
                ENDPDMCHG_WKUP: u1,
                /// Enables the feature to wakeup USB if ID is toggled when USB is suspended.
                ENIDCHG_WKUP: u1,
                /// Enables the feature to wakeup USB if VBUS is toggled when USB is suspended.
                ENVBUSCHG_WKUP: u1,
                /// Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet.
                FSDLL_RST_EN: u1,
                /// Reserved.
                RSVD1: u2,
                /// Almost same as OTGID_STATUS in USBPHYx_STATUS Register
                OTG_ID_VALUE: u1,
                /// Forces the next FS packet that is transmitted to have a EOP with LS timing
                HOST_FORCE_LS_SE0: u1,
                /// Used by the PHY to indicate a powered-down state
                UTMI_SUSPENDM: u1,
                /// Gate UTMI Clocks
                CLKGATE: u1,
                /// Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, USBPHYx_RX, and USBPHYx_CTRL registers
                SFTRST: u1,
            }),
            /// USB PHY General Control Register
            CTRL_CLR: mmio.Mmio(packed struct(u32) {
                /// Enable OTG_ID_CHG_IRQ.
                ENOTG_ID_CHG_IRQ: u1,
                /// For host mode, enables high-speed disconnect detector
                ENHOSTDISCONDETECT: u1,
                /// Enables interrupt for detection of disconnection to Device when in high-speed host mode
                ENIRQHOSTDISCON: u1,
                /// Indicates that the device has disconnected in high-speed mode
                HOSTDISCONDETECT_IRQ: u1,
                /// For device mode, enables 200-KOhm pullups for detecting connectivity to the host.
                ENDEVPLUGINDETECT: u1,
                /// For device mode, if this bit is cleared to 0, then it trips the interrupt if the device is plugged in
                DEVPLUGIN_POLARITY: u1,
                /// OTG ID change interrupt. Indicates the value of ID pin changed.
                OTG_ID_CHG_IRQ: u1,
                /// Enables circuit to detect resistance of MiniAB ID pin.
                ENOTGIDDETECT: u1,
                /// Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it
                RESUMEIRQSTICKY: u1,
                /// Enables interrupt for detection of a non-J state on the USB line
                ENIRQRESUMEDETECT: u1,
                /// Indicates that the host is sending a wake-up after suspend
                RESUME_IRQ: u1,
                /// Enables interrupt for the detection of connectivity to the USB line.
                ENIRQDEVPLUGIN: u1,
                /// Indicates that the device is connected
                DEVPLUGIN_IRQ: u1,
                /// Enables the LRADC to monitor USB_DP and USB_DM. This is for use in non-USB modes only.
                DATA_ON_LRADC: u1,
                /// Enables UTMI+ Level2. This should be enabled if needs to support LS device
                ENUTMILEVEL2: u1,
                /// Enables UTMI+ Level3
                ENUTMILEVEL3: u1,
                /// Enables interrupt for the wakeup events.
                ENIRQWAKEUP: u1,
                /// Indicates that there is a wakeup event
                WAKEUP_IRQ: u1,
                /// Enables the feature to auto-enable the POWER bit of HW_CLKCTRL_PLLxCTRL0 if there is wakeup event if USB is suspended
                ENAUTO_PWRON_PLL: u1,
                /// Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended
                ENAUTOCLR_CLKGATE: u1,
                /// Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD if there is wakeup event while USB is suspended
                ENAUTOCLR_PHY_PWD: u1,
                /// Enables the feature to wakeup USB if DP/DM is toggled when USB is suspended
                ENDPDMCHG_WKUP: u1,
                /// Enables the feature to wakeup USB if ID is toggled when USB is suspended.
                ENIDCHG_WKUP: u1,
                /// Enables the feature to wakeup USB if VBUS is toggled when USB is suspended.
                ENVBUSCHG_WKUP: u1,
                /// Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet.
                FSDLL_RST_EN: u1,
                /// Reserved.
                RSVD1: u2,
                /// Almost same as OTGID_STATUS in USBPHYx_STATUS Register
                OTG_ID_VALUE: u1,
                /// Forces the next FS packet that is transmitted to have a EOP with LS timing
                HOST_FORCE_LS_SE0: u1,
                /// Used by the PHY to indicate a powered-down state
                UTMI_SUSPENDM: u1,
                /// Gate UTMI Clocks
                CLKGATE: u1,
                /// Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, USBPHYx_RX, and USBPHYx_CTRL registers
                SFTRST: u1,
            }),
            /// USB PHY General Control Register
            CTRL_TOG: mmio.Mmio(packed struct(u32) {
                /// Enable OTG_ID_CHG_IRQ.
                ENOTG_ID_CHG_IRQ: u1,
                /// For host mode, enables high-speed disconnect detector
                ENHOSTDISCONDETECT: u1,
                /// Enables interrupt for detection of disconnection to Device when in high-speed host mode
                ENIRQHOSTDISCON: u1,
                /// Indicates that the device has disconnected in high-speed mode
                HOSTDISCONDETECT_IRQ: u1,
                /// For device mode, enables 200-KOhm pullups for detecting connectivity to the host.
                ENDEVPLUGINDETECT: u1,
                /// For device mode, if this bit is cleared to 0, then it trips the interrupt if the device is plugged in
                DEVPLUGIN_POLARITY: u1,
                /// OTG ID change interrupt. Indicates the value of ID pin changed.
                OTG_ID_CHG_IRQ: u1,
                /// Enables circuit to detect resistance of MiniAB ID pin.
                ENOTGIDDETECT: u1,
                /// Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it
                RESUMEIRQSTICKY: u1,
                /// Enables interrupt for detection of a non-J state on the USB line
                ENIRQRESUMEDETECT: u1,
                /// Indicates that the host is sending a wake-up after suspend
                RESUME_IRQ: u1,
                /// Enables interrupt for the detection of connectivity to the USB line.
                ENIRQDEVPLUGIN: u1,
                /// Indicates that the device is connected
                DEVPLUGIN_IRQ: u1,
                /// Enables the LRADC to monitor USB_DP and USB_DM. This is for use in non-USB modes only.
                DATA_ON_LRADC: u1,
                /// Enables UTMI+ Level2. This should be enabled if needs to support LS device
                ENUTMILEVEL2: u1,
                /// Enables UTMI+ Level3
                ENUTMILEVEL3: u1,
                /// Enables interrupt for the wakeup events.
                ENIRQWAKEUP: u1,
                /// Indicates that there is a wakeup event
                WAKEUP_IRQ: u1,
                /// Enables the feature to auto-enable the POWER bit of HW_CLKCTRL_PLLxCTRL0 if there is wakeup event if USB is suspended
                ENAUTO_PWRON_PLL: u1,
                /// Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended
                ENAUTOCLR_CLKGATE: u1,
                /// Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD if there is wakeup event while USB is suspended
                ENAUTOCLR_PHY_PWD: u1,
                /// Enables the feature to wakeup USB if DP/DM is toggled when USB is suspended
                ENDPDMCHG_WKUP: u1,
                /// Enables the feature to wakeup USB if ID is toggled when USB is suspended.
                ENIDCHG_WKUP: u1,
                /// Enables the feature to wakeup USB if VBUS is toggled when USB is suspended.
                ENVBUSCHG_WKUP: u1,
                /// Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet.
                FSDLL_RST_EN: u1,
                /// Reserved.
                RSVD1: u2,
                /// Almost same as OTGID_STATUS in USBPHYx_STATUS Register
                OTG_ID_VALUE: u1,
                /// Forces the next FS packet that is transmitted to have a EOP with LS timing
                HOST_FORCE_LS_SE0: u1,
                /// Used by the PHY to indicate a powered-down state
                UTMI_SUSPENDM: u1,
                /// Gate UTMI Clocks
                CLKGATE: u1,
                /// Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, USBPHYx_RX, and USBPHYx_CTRL registers
                SFTRST: u1,
            }),
            /// USB PHY Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                /// Reserved.
                RSVD0: u3,
                /// Indicates that the device has disconnected while in high-speed host mode.
                HOSTDISCONDETECT_STATUS: u1,
                /// Reserved.
                RSVD1: u2,
                /// Indicates that the device has been connected on the USB_DP and USB_DM lines.
                DEVPLUGIN_STATUS: u1,
                /// Reserved.
                RSVD2: u1,
                /// Indicates the results of ID pin on MiniAB plug
                OTGID_STATUS: u1,
                /// Reserved.
                RSVD3: u1,
                /// Indicates that the host is sending a wake-up after suspend and has triggered an interrupt.
                RESUME_STATUS: u1,
                /// Reserved.
                RSVD4: u21,
            }),
            reserved80: [12]u8,
            /// USB PHY Debug Register
            DEBUG: mmio.Mmio(packed struct(u32) {
                /// Once OTG ID from USBPHYx_STATUS_OTGID_STATUS, use this to hold the value
                OTGIDPIOLOCK: u1,
                /// Use holding registers to assist in timing for external UTMI interface.
                DEBUG_INTERFACE_HOLD: u1,
                /// Set bit 3 to 1 to pull down 15-KOhm on USB_DP line
                HSTPULLDOWN: u2,
                /// Set bit 5 to 1 to override the control of the USB_DP 15-KOhm pulldown
                ENHSTPULLDOWN: u2,
                /// Reserved.
                RSVD0: u2,
                /// Delay in between the end of transmit to the beginning of receive
                TX2RXCOUNT: u4,
                /// Set this bit to allow a countdown to transition in between TX and RX.
                ENTX2RXCOUNT: u1,
                /// Reserved.
                RSVD1: u3,
                /// Delay in between the detection of squelch to the reset of high-speed RX.
                SQUELCHRESETCOUNT: u5,
                /// Reserved.
                RSVD2: u3,
                /// Set bit to allow squelch to reset high-speed receive.
                ENSQUELCHRESET: u1,
                /// Duration of RESET in terms of the number of 480-MHz cycles.
                SQUELCHRESETLENGTH: u4,
                /// Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1.
                HOST_RESUME_DEBUG: u1,
                /// Gate Test Clocks
                CLKGATE: u1,
                /// Reserved.
                RSVD3: u1,
            }),
            /// USB PHY Debug Register
            DEBUG_SET: mmio.Mmio(packed struct(u32) {
                /// Once OTG ID from USBPHYx_STATUS_OTGID_STATUS, use this to hold the value
                OTGIDPIOLOCK: u1,
                /// Use holding registers to assist in timing for external UTMI interface.
                DEBUG_INTERFACE_HOLD: u1,
                /// Set bit 3 to 1 to pull down 15-KOhm on USB_DP line
                HSTPULLDOWN: u2,
                /// Set bit 5 to 1 to override the control of the USB_DP 15-KOhm pulldown
                ENHSTPULLDOWN: u2,
                /// Reserved.
                RSVD0: u2,
                /// Delay in between the end of transmit to the beginning of receive
                TX2RXCOUNT: u4,
                /// Set this bit to allow a countdown to transition in between TX and RX.
                ENTX2RXCOUNT: u1,
                /// Reserved.
                RSVD1: u3,
                /// Delay in between the detection of squelch to the reset of high-speed RX.
                SQUELCHRESETCOUNT: u5,
                /// Reserved.
                RSVD2: u3,
                /// Set bit to allow squelch to reset high-speed receive.
                ENSQUELCHRESET: u1,
                /// Duration of RESET in terms of the number of 480-MHz cycles.
                SQUELCHRESETLENGTH: u4,
                /// Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1.
                HOST_RESUME_DEBUG: u1,
                /// Gate Test Clocks
                CLKGATE: u1,
                /// Reserved.
                RSVD3: u1,
            }),
            /// USB PHY Debug Register
            DEBUG_CLR: mmio.Mmio(packed struct(u32) {
                /// Once OTG ID from USBPHYx_STATUS_OTGID_STATUS, use this to hold the value
                OTGIDPIOLOCK: u1,
                /// Use holding registers to assist in timing for external UTMI interface.
                DEBUG_INTERFACE_HOLD: u1,
                /// Set bit 3 to 1 to pull down 15-KOhm on USB_DP line
                HSTPULLDOWN: u2,
                /// Set bit 5 to 1 to override the control of the USB_DP 15-KOhm pulldown
                ENHSTPULLDOWN: u2,
                /// Reserved.
                RSVD0: u2,
                /// Delay in between the end of transmit to the beginning of receive
                TX2RXCOUNT: u4,
                /// Set this bit to allow a countdown to transition in between TX and RX.
                ENTX2RXCOUNT: u1,
                /// Reserved.
                RSVD1: u3,
                /// Delay in between the detection of squelch to the reset of high-speed RX.
                SQUELCHRESETCOUNT: u5,
                /// Reserved.
                RSVD2: u3,
                /// Set bit to allow squelch to reset high-speed receive.
                ENSQUELCHRESET: u1,
                /// Duration of RESET in terms of the number of 480-MHz cycles.
                SQUELCHRESETLENGTH: u4,
                /// Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1.
                HOST_RESUME_DEBUG: u1,
                /// Gate Test Clocks
                CLKGATE: u1,
                /// Reserved.
                RSVD3: u1,
            }),
            /// USB PHY Debug Register
            DEBUG_TOG: mmio.Mmio(packed struct(u32) {
                /// Once OTG ID from USBPHYx_STATUS_OTGID_STATUS, use this to hold the value
                OTGIDPIOLOCK: u1,
                /// Use holding registers to assist in timing for external UTMI interface.
                DEBUG_INTERFACE_HOLD: u1,
                /// Set bit 3 to 1 to pull down 15-KOhm on USB_DP line
                HSTPULLDOWN: u2,
                /// Set bit 5 to 1 to override the control of the USB_DP 15-KOhm pulldown
                ENHSTPULLDOWN: u2,
                /// Reserved.
                RSVD0: u2,
                /// Delay in between the end of transmit to the beginning of receive
                TX2RXCOUNT: u4,
                /// Set this bit to allow a countdown to transition in between TX and RX.
                ENTX2RXCOUNT: u1,
                /// Reserved.
                RSVD1: u3,
                /// Delay in between the detection of squelch to the reset of high-speed RX.
                SQUELCHRESETCOUNT: u5,
                /// Reserved.
                RSVD2: u3,
                /// Set bit to allow squelch to reset high-speed receive.
                ENSQUELCHRESET: u1,
                /// Duration of RESET in terms of the number of 480-MHz cycles.
                SQUELCHRESETLENGTH: u4,
                /// Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1.
                HOST_RESUME_DEBUG: u1,
                /// Gate Test Clocks
                CLKGATE: u1,
                /// Reserved.
                RSVD3: u1,
            }),
            /// UTMI Debug Status Register 0
            DEBUG0_STATUS: mmio.Mmio(packed struct(u32) {
                /// Running count of the failed pseudo-random generator loopback
                LOOP_BACK_FAIL_COUNT: u16,
                /// Running count of the UTMI_RXERROR.
                UTMI_RXERROR_FAIL_COUNT: u10,
                /// Running count of the squelch reset instead of normal end for HS RX.
                SQUELCH_COUNT: u6,
            }),
            reserved112: [12]u8,
            /// UTMI Debug Status Register 1
            DEBUG1: mmio.Mmio(packed struct(u32) {
                /// Reserved. Note: This bit should remain clear.
                RSVD0: u13,
                /// Delay increment of the rise of squelch: 00 = Delay is nominal 01 = Delay is +20% 10 = Delay is -20% 11 = Delay is -40%
                ENTAILADJVD: u2,
                /// Reserved.
                RSVD1: u17,
            }),
            /// UTMI Debug Status Register 1
            DEBUG1_SET: mmio.Mmio(packed struct(u32) {
                /// Reserved. Note: This bit should remain clear.
                RSVD0: u13,
                /// Delay increment of the rise of squelch: 00 = Delay is nominal 01 = Delay is +20% 10 = Delay is -20% 11 = Delay is -40%
                ENTAILADJVD: u2,
                /// Reserved.
                RSVD1: u17,
            }),
            /// UTMI Debug Status Register 1
            DEBUG1_CLR: mmio.Mmio(packed struct(u32) {
                /// Reserved. Note: This bit should remain clear.
                RSVD0: u13,
                /// Delay increment of the rise of squelch: 00 = Delay is nominal 01 = Delay is +20% 10 = Delay is -20% 11 = Delay is -40%
                ENTAILADJVD: u2,
                /// Reserved.
                RSVD1: u17,
            }),
            /// UTMI Debug Status Register 1
            DEBUG1_TOG: mmio.Mmio(packed struct(u32) {
                /// Reserved. Note: This bit should remain clear.
                RSVD0: u13,
                /// Delay increment of the rise of squelch: 00 = Delay is nominal 01 = Delay is +20% 10 = Delay is -20% 11 = Delay is -40%
                ENTAILADJVD: u2,
                /// Reserved.
                RSVD1: u17,
            }),
            /// UTMI RTL Version
            VERSION: mmio.Mmio(packed struct(u32) {
                /// Fixed read-only value reflecting the stepping of the RTL version.
                STEP: u16,
                /// Fixed read-only value reflecting the MINOR field of the RTL version.
                MINOR: u8,
                /// Fixed read-only value reflecting the MAJOR field of the RTL version.
                MAJOR: u8,
            }),
        };

        /// USB Analog
        pub const USB_ANALOG = extern struct {
            reserved416: [416]u8,
            /// USB VBUS Detect Register
            USB1_VBUS_DETECT: mmio.Mmio(packed struct(u32) {
                /// Set the threshold for the VBUSVALID comparator
                VBUSVALID_THRESH: enum(u3) {
                    /// 4.0V
                    @"4V0" = 0x0,
                    /// 4.1V
                    @"4V1" = 0x1,
                    /// 4.2V
                    @"4V2" = 0x2,
                    /// 4.3V
                    @"4V3" = 0x3,
                    /// 4.4V (default)
                    @"4V4" = 0x4,
                    /// 4.5V
                    @"4V5" = 0x5,
                    /// 4.6V
                    @"4V6" = 0x6,
                    /// 4.7V
                    @"4V7" = 0x7,
                },
                reserved20: u17 = 0,
                /// Powers up comparators for vbus_valid detector.
                VBUSVALID_PWRUP_CMPS: u1,
                reserved26: u5 = 0,
                /// USB OTG discharge VBUS.
                DISCHARGE_VBUS: u1,
                /// USB OTG charge VBUS.
                CHARGE_VBUS: u1,
                padding: u4 = 0,
            }),
            /// USB VBUS Detect Register
            USB1_VBUS_DETECT_SET: mmio.Mmio(packed struct(u32) {
                /// Set the threshold for the VBUSVALID comparator
                VBUSVALID_THRESH: enum(u3) {
                    /// 4.0V
                    @"4V0" = 0x0,
                    /// 4.1V
                    @"4V1" = 0x1,
                    /// 4.2V
                    @"4V2" = 0x2,
                    /// 4.3V
                    @"4V3" = 0x3,
                    /// 4.4V (default)
                    @"4V4" = 0x4,
                    /// 4.5V
                    @"4V5" = 0x5,
                    /// 4.6V
                    @"4V6" = 0x6,
                    /// 4.7V
                    @"4V7" = 0x7,
                },
                reserved20: u17 = 0,
                /// Powers up comparators for vbus_valid detector.
                VBUSVALID_PWRUP_CMPS: u1,
                reserved26: u5 = 0,
                /// USB OTG discharge VBUS.
                DISCHARGE_VBUS: u1,
                /// USB OTG charge VBUS.
                CHARGE_VBUS: u1,
                padding: u4 = 0,
            }),
            /// USB VBUS Detect Register
            USB1_VBUS_DETECT_CLR: mmio.Mmio(packed struct(u32) {
                /// Set the threshold for the VBUSVALID comparator
                VBUSVALID_THRESH: enum(u3) {
                    /// 4.0V
                    @"4V0" = 0x0,
                    /// 4.1V
                    @"4V1" = 0x1,
                    /// 4.2V
                    @"4V2" = 0x2,
                    /// 4.3V
                    @"4V3" = 0x3,
                    /// 4.4V (default)
                    @"4V4" = 0x4,
                    /// 4.5V
                    @"4V5" = 0x5,
                    /// 4.6V
                    @"4V6" = 0x6,
                    /// 4.7V
                    @"4V7" = 0x7,
                },
                reserved20: u17 = 0,
                /// Powers up comparators for vbus_valid detector.
                VBUSVALID_PWRUP_CMPS: u1,
                reserved26: u5 = 0,
                /// USB OTG discharge VBUS.
                DISCHARGE_VBUS: u1,
                /// USB OTG charge VBUS.
                CHARGE_VBUS: u1,
                padding: u4 = 0,
            }),
            /// USB VBUS Detect Register
            USB1_VBUS_DETECT_TOG: mmio.Mmio(packed struct(u32) {
                /// Set the threshold for the VBUSVALID comparator
                VBUSVALID_THRESH: enum(u3) {
                    /// 4.0V
                    @"4V0" = 0x0,
                    /// 4.1V
                    @"4V1" = 0x1,
                    /// 4.2V
                    @"4V2" = 0x2,
                    /// 4.3V
                    @"4V3" = 0x3,
                    /// 4.4V (default)
                    @"4V4" = 0x4,
                    /// 4.5V
                    @"4V5" = 0x5,
                    /// 4.6V
                    @"4V6" = 0x6,
                    /// 4.7V
                    @"4V7" = 0x7,
                },
                reserved20: u17 = 0,
                /// Powers up comparators for vbus_valid detector.
                VBUSVALID_PWRUP_CMPS: u1,
                reserved26: u5 = 0,
                /// USB OTG discharge VBUS.
                DISCHARGE_VBUS: u1,
                /// USB OTG charge VBUS.
                CHARGE_VBUS: u1,
                padding: u4 = 0,
            }),
            /// USB Charger Detect Register
            USB1_CHRG_DETECT: mmio.Mmio(packed struct(u32) {
                reserved18: u18 = 0,
                /// Check the contact of USB plug
                CHK_CONTACT: enum(u1) {
                    /// Do not check the contact of USB plug.
                    NO_CHECK = 0x0,
                    /// Check whether the USB plug has been in contact with each other
                    CHECK = 0x1,
                },
                /// Check the charger connection
                CHK_CHRG_B: enum(u1) {
                    /// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
                    CHECK = 0x0,
                    /// Do not check whether a charger is connected to the USB port.
                    NO_CHECK = 0x1,
                },
                /// Control the charger detector.
                EN_B: enum(u1) {
                    /// Enable the charger detector.
                    ENABLE = 0x0,
                    /// Disable the charger detector.
                    DISABLE = 0x1,
                },
                padding: u11 = 0,
            }),
            /// USB Charger Detect Register
            USB1_CHRG_DETECT_SET: mmio.Mmio(packed struct(u32) {
                reserved18: u18 = 0,
                /// Check the contact of USB plug
                CHK_CONTACT: enum(u1) {
                    /// Do not check the contact of USB plug.
                    NO_CHECK = 0x0,
                    /// Check whether the USB plug has been in contact with each other
                    CHECK = 0x1,
                },
                /// Check the charger connection
                CHK_CHRG_B: enum(u1) {
                    /// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
                    CHECK = 0x0,
                    /// Do not check whether a charger is connected to the USB port.
                    NO_CHECK = 0x1,
                },
                /// Control the charger detector.
                EN_B: enum(u1) {
                    /// Enable the charger detector.
                    ENABLE = 0x0,
                    /// Disable the charger detector.
                    DISABLE = 0x1,
                },
                padding: u11 = 0,
            }),
            /// USB Charger Detect Register
            USB1_CHRG_DETECT_CLR: mmio.Mmio(packed struct(u32) {
                reserved18: u18 = 0,
                /// Check the contact of USB plug
                CHK_CONTACT: enum(u1) {
                    /// Do not check the contact of USB plug.
                    NO_CHECK = 0x0,
                    /// Check whether the USB plug has been in contact with each other
                    CHECK = 0x1,
                },
                /// Check the charger connection
                CHK_CHRG_B: enum(u1) {
                    /// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
                    CHECK = 0x0,
                    /// Do not check whether a charger is connected to the USB port.
                    NO_CHECK = 0x1,
                },
                /// Control the charger detector.
                EN_B: enum(u1) {
                    /// Enable the charger detector.
                    ENABLE = 0x0,
                    /// Disable the charger detector.
                    DISABLE = 0x1,
                },
                padding: u11 = 0,
            }),
            /// USB Charger Detect Register
            USB1_CHRG_DETECT_TOG: mmio.Mmio(packed struct(u32) {
                reserved18: u18 = 0,
                /// Check the contact of USB plug
                CHK_CONTACT: enum(u1) {
                    /// Do not check the contact of USB plug.
                    NO_CHECK = 0x0,
                    /// Check whether the USB plug has been in contact with each other
                    CHECK = 0x1,
                },
                /// Check the charger connection
                CHK_CHRG_B: enum(u1) {
                    /// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
                    CHECK = 0x0,
                    /// Do not check whether a charger is connected to the USB port.
                    NO_CHECK = 0x1,
                },
                /// Control the charger detector.
                EN_B: enum(u1) {
                    /// Enable the charger detector.
                    ENABLE = 0x0,
                    /// Disable the charger detector.
                    DISABLE = 0x1,
                },
                padding: u11 = 0,
            }),
            /// USB VBUS Detect Status Register
            USB1_VBUS_DETECT_STAT: mmio.Mmio(packed struct(u32) {
                /// Session End for USB OTG
                SESSEND: u1,
                /// Indicates VBus is valid for a B-peripheral
                BVALID: u1,
                /// Indicates VBus is valid for a A-peripheral
                AVALID: u1,
                /// VBus valid for USB OTG
                VBUS_VALID: u1,
                padding: u28 = 0,
            }),
            reserved464: [12]u8,
            /// USB Charger Detect Status Register
            USB1_CHRG_DETECT_STAT: mmio.Mmio(packed struct(u32) {
                /// State of the USB plug contact detector.
                PLUG_CONTACT: enum(u1) {
                    /// The USB plug has not made contact.
                    NO_CONTACT = 0x0,
                    /// The USB plug has made good contact.
                    GOOD_CONTACT = 0x1,
                },
                /// State of charger detection. This bit is a read only version of the state of the analog signal.
                CHRG_DETECTED: enum(u1) {
                    /// The USB port is not connected to a charger.
                    CHARGER_NOT_PRESENT = 0x0,
                    /// A charger (either a dedicated charger or a host charger) is connected to the USB port.
                    CHARGER_PRESENT = 0x1,
                },
                /// DM line state output of the charger detector.
                DM_STATE: u1,
                /// DP line state output of the charger detector.
                DP_STATE: u1,
                padding: u28 = 0,
            }),
            reserved480: [12]u8,
            /// USB Loopback Test Register
            USB1_LOOPBACK: mmio.Mmio(packed struct(u32) {
                /// Setting this bit can enable 1
                UTMI_TESTSTART: u1,
                padding: u31 = 0,
            }),
            /// USB Loopback Test Register
            USB1_LOOPBACK_SET: mmio.Mmio(packed struct(u32) {
                /// Setting this bit can enable 1
                UTMI_TESTSTART: u1,
                padding: u31 = 0,
            }),
            /// USB Loopback Test Register
            USB1_LOOPBACK_CLR: mmio.Mmio(packed struct(u32) {
                /// Setting this bit can enable 1
                UTMI_TESTSTART: u1,
                padding: u31 = 0,
            }),
            /// USB Loopback Test Register
            USB1_LOOPBACK_TOG: mmio.Mmio(packed struct(u32) {
                /// Setting this bit can enable 1
                UTMI_TESTSTART: u1,
                padding: u31 = 0,
            }),
            /// USB Misc Register
            USB1_MISC: mmio.Mmio(packed struct(u32) {
                /// Use external resistor to generate the current bias for the high speed transmitter
                HS_USE_EXTERNAL_R: u1,
                /// Enable the deglitching circuit of the USB PLL output.
                EN_DEGLITCH: u1,
                reserved30: u28 = 0,
                /// Enables the clk to the UTMI block.
                EN_CLK_UTMI: u1,
                padding: u1 = 0,
            }),
            /// USB Misc Register
            USB1_MISC_SET: mmio.Mmio(packed struct(u32) {
                /// Use external resistor to generate the current bias for the high speed transmitter
                HS_USE_EXTERNAL_R: u1,
                /// Enable the deglitching circuit of the USB PLL output.
                EN_DEGLITCH: u1,
                reserved30: u28 = 0,
                /// Enables the clk to the UTMI block.
                EN_CLK_UTMI: u1,
                padding: u1 = 0,
            }),
            /// USB Misc Register
            USB1_MISC_CLR: mmio.Mmio(packed struct(u32) {
                /// Use external resistor to generate the current bias for the high speed transmitter
                HS_USE_EXTERNAL_R: u1,
                /// Enable the deglitching circuit of the USB PLL output.
                EN_DEGLITCH: u1,
                reserved30: u28 = 0,
                /// Enables the clk to the UTMI block.
                EN_CLK_UTMI: u1,
                padding: u1 = 0,
            }),
            /// USB Misc Register
            USB1_MISC_TOG: mmio.Mmio(packed struct(u32) {
                /// Use external resistor to generate the current bias for the high speed transmitter
                HS_USE_EXTERNAL_R: u1,
                /// Enable the deglitching circuit of the USB PLL output.
                EN_DEGLITCH: u1,
                reserved30: u28 = 0,
                /// Enables the clk to the UTMI block.
                EN_CLK_UTMI: u1,
                padding: u1 = 0,
            }),
            /// USB VBUS Detect Register
            USB2_VBUS_DETECT: mmio.Mmio(packed struct(u32) {
                /// Set the threshold for the VBUSVALID comparator
                VBUSVALID_THRESH: enum(u3) {
                    /// 4.0V
                    @"4V0" = 0x0,
                    /// 4.1V
                    @"4V1" = 0x1,
                    /// 4.2V
                    @"4V2" = 0x2,
                    /// 4.3V
                    @"4V3" = 0x3,
                    /// 4.4V (default)
                    @"4V4" = 0x4,
                    /// 4.5V
                    @"4V5" = 0x5,
                    /// 4.6V
                    @"4V6" = 0x6,
                    /// 4.7V
                    @"4V7" = 0x7,
                },
                reserved20: u17 = 0,
                /// Powers up comparators for vbus_valid detector.
                VBUSVALID_PWRUP_CMPS: u1,
                reserved26: u5 = 0,
                /// USB OTG discharge VBUS.
                DISCHARGE_VBUS: u1,
                /// USB OTG charge VBUS.
                CHARGE_VBUS: u1,
                padding: u4 = 0,
            }),
            /// USB VBUS Detect Register
            USB2_VBUS_DETECT_SET: mmio.Mmio(packed struct(u32) {
                /// Set the threshold for the VBUSVALID comparator
                VBUSVALID_THRESH: enum(u3) {
                    /// 4.0V
                    @"4V0" = 0x0,
                    /// 4.1V
                    @"4V1" = 0x1,
                    /// 4.2V
                    @"4V2" = 0x2,
                    /// 4.3V
                    @"4V3" = 0x3,
                    /// 4.4V (default)
                    @"4V4" = 0x4,
                    /// 4.5V
                    @"4V5" = 0x5,
                    /// 4.6V
                    @"4V6" = 0x6,
                    /// 4.7V
                    @"4V7" = 0x7,
                },
                reserved20: u17 = 0,
                /// Powers up comparators for vbus_valid detector.
                VBUSVALID_PWRUP_CMPS: u1,
                reserved26: u5 = 0,
                /// USB OTG discharge VBUS.
                DISCHARGE_VBUS: u1,
                /// USB OTG charge VBUS.
                CHARGE_VBUS: u1,
                padding: u4 = 0,
            }),
            /// USB VBUS Detect Register
            USB2_VBUS_DETECT_CLR: mmio.Mmio(packed struct(u32) {
                /// Set the threshold for the VBUSVALID comparator
                VBUSVALID_THRESH: enum(u3) {
                    /// 4.0V
                    @"4V0" = 0x0,
                    /// 4.1V
                    @"4V1" = 0x1,
                    /// 4.2V
                    @"4V2" = 0x2,
                    /// 4.3V
                    @"4V3" = 0x3,
                    /// 4.4V (default)
                    @"4V4" = 0x4,
                    /// 4.5V
                    @"4V5" = 0x5,
                    /// 4.6V
                    @"4V6" = 0x6,
                    /// 4.7V
                    @"4V7" = 0x7,
                },
                reserved20: u17 = 0,
                /// Powers up comparators for vbus_valid detector.
                VBUSVALID_PWRUP_CMPS: u1,
                reserved26: u5 = 0,
                /// USB OTG discharge VBUS.
                DISCHARGE_VBUS: u1,
                /// USB OTG charge VBUS.
                CHARGE_VBUS: u1,
                padding: u4 = 0,
            }),
            /// USB VBUS Detect Register
            USB2_VBUS_DETECT_TOG: mmio.Mmio(packed struct(u32) {
                /// Set the threshold for the VBUSVALID comparator
                VBUSVALID_THRESH: enum(u3) {
                    /// 4.0V
                    @"4V0" = 0x0,
                    /// 4.1V
                    @"4V1" = 0x1,
                    /// 4.2V
                    @"4V2" = 0x2,
                    /// 4.3V
                    @"4V3" = 0x3,
                    /// 4.4V (default)
                    @"4V4" = 0x4,
                    /// 4.5V
                    @"4V5" = 0x5,
                    /// 4.6V
                    @"4V6" = 0x6,
                    /// 4.7V
                    @"4V7" = 0x7,
                },
                reserved20: u17 = 0,
                /// Powers up comparators for vbus_valid detector.
                VBUSVALID_PWRUP_CMPS: u1,
                reserved26: u5 = 0,
                /// USB OTG discharge VBUS.
                DISCHARGE_VBUS: u1,
                /// USB OTG charge VBUS.
                CHARGE_VBUS: u1,
                padding: u4 = 0,
            }),
            /// USB Charger Detect Register
            USB2_CHRG_DETECT: mmio.Mmio(packed struct(u32) {
                reserved18: u18 = 0,
                /// Check the contact of USB plug
                CHK_CONTACT: enum(u1) {
                    /// Do not check the contact of USB plug.
                    NO_CHECK = 0x0,
                    /// Check whether the USB plug has been in contact with each other
                    CHECK = 0x1,
                },
                /// Check the charger connection
                CHK_CHRG_B: enum(u1) {
                    /// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
                    CHECK = 0x0,
                    /// Do not check whether a charger is connected to the USB port.
                    NO_CHECK = 0x1,
                },
                /// Control the charger detector.
                EN_B: enum(u1) {
                    /// Enable the charger detector.
                    ENABLE = 0x0,
                    /// Disable the charger detector.
                    DISABLE = 0x1,
                },
                padding: u11 = 0,
            }),
            /// USB Charger Detect Register
            USB2_CHRG_DETECT_SET: mmio.Mmio(packed struct(u32) {
                reserved18: u18 = 0,
                /// Check the contact of USB plug
                CHK_CONTACT: enum(u1) {
                    /// Do not check the contact of USB plug.
                    NO_CHECK = 0x0,
                    /// Check whether the USB plug has been in contact with each other
                    CHECK = 0x1,
                },
                /// Check the charger connection
                CHK_CHRG_B: enum(u1) {
                    /// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
                    CHECK = 0x0,
                    /// Do not check whether a charger is connected to the USB port.
                    NO_CHECK = 0x1,
                },
                /// Control the charger detector.
                EN_B: enum(u1) {
                    /// Enable the charger detector.
                    ENABLE = 0x0,
                    /// Disable the charger detector.
                    DISABLE = 0x1,
                },
                padding: u11 = 0,
            }),
            /// USB Charger Detect Register
            USB2_CHRG_DETECT_CLR: mmio.Mmio(packed struct(u32) {
                reserved18: u18 = 0,
                /// Check the contact of USB plug
                CHK_CONTACT: enum(u1) {
                    /// Do not check the contact of USB plug.
                    NO_CHECK = 0x0,
                    /// Check whether the USB plug has been in contact with each other
                    CHECK = 0x1,
                },
                /// Check the charger connection
                CHK_CHRG_B: enum(u1) {
                    /// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
                    CHECK = 0x0,
                    /// Do not check whether a charger is connected to the USB port.
                    NO_CHECK = 0x1,
                },
                /// Control the charger detector.
                EN_B: enum(u1) {
                    /// Enable the charger detector.
                    ENABLE = 0x0,
                    /// Disable the charger detector.
                    DISABLE = 0x1,
                },
                padding: u11 = 0,
            }),
            /// USB Charger Detect Register
            USB2_CHRG_DETECT_TOG: mmio.Mmio(packed struct(u32) {
                reserved18: u18 = 0,
                /// Check the contact of USB plug
                CHK_CONTACT: enum(u1) {
                    /// Do not check the contact of USB plug.
                    NO_CHECK = 0x0,
                    /// Check whether the USB plug has been in contact with each other
                    CHECK = 0x1,
                },
                /// Check the charger connection
                CHK_CHRG_B: enum(u1) {
                    /// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
                    CHECK = 0x0,
                    /// Do not check whether a charger is connected to the USB port.
                    NO_CHECK = 0x1,
                },
                /// Control the charger detector.
                EN_B: enum(u1) {
                    /// Enable the charger detector.
                    ENABLE = 0x0,
                    /// Disable the charger detector.
                    DISABLE = 0x1,
                },
                padding: u11 = 0,
            }),
            /// USB VBUS Detect Status Register
            USB2_VBUS_DETECT_STAT: mmio.Mmio(packed struct(u32) {
                /// Session End for USB OTG
                SESSEND: u1,
                /// Indicates VBus is valid for a B-peripheral
                BVALID: u1,
                /// Indicates VBus is valid for a A-peripheral
                AVALID: u1,
                /// VBus valid for USB OTG
                VBUS_VALID: u1,
                padding: u28 = 0,
            }),
            reserved560: [12]u8,
            /// USB Charger Detect Status Register
            USB2_CHRG_DETECT_STAT: mmio.Mmio(packed struct(u32) {
                /// State of the USB plug contact detector.
                PLUG_CONTACT: enum(u1) {
                    /// The USB plug has not made contact.
                    NO_CONTACT = 0x0,
                    /// The USB plug has made good contact.
                    GOOD_CONTACT = 0x1,
                },
                /// State of charger detection. This bit is a read only version of the state of the analog signal.
                CHRG_DETECTED: enum(u1) {
                    /// The USB port is not connected to a charger.
                    CHARGER_NOT_PRESENT = 0x0,
                    /// A charger (either a dedicated charger or a host charger) is connected to the USB port.
                    CHARGER_PRESENT = 0x1,
                },
                /// DM line state output of the charger detector.
                DM_STATE: u1,
                /// DP line state output of the charger detector.
                DP_STATE: u1,
                padding: u28 = 0,
            }),
            reserved576: [12]u8,
            /// USB Loopback Test Register
            USB2_LOOPBACK: mmio.Mmio(packed struct(u32) {
                /// Setting this bit can enable 1
                UTMI_TESTSTART: u1,
                padding: u31 = 0,
            }),
            /// USB Loopback Test Register
            USB2_LOOPBACK_SET: mmio.Mmio(packed struct(u32) {
                /// Setting this bit can enable 1
                UTMI_TESTSTART: u1,
                padding: u31 = 0,
            }),
            /// USB Loopback Test Register
            USB2_LOOPBACK_CLR: mmio.Mmio(packed struct(u32) {
                /// Setting this bit can enable 1
                UTMI_TESTSTART: u1,
                padding: u31 = 0,
            }),
            /// USB Loopback Test Register
            USB2_LOOPBACK_TOG: mmio.Mmio(packed struct(u32) {
                /// Setting this bit can enable 1
                UTMI_TESTSTART: u1,
                padding: u31 = 0,
            }),
            /// USB Misc Register
            USB2_MISC: mmio.Mmio(packed struct(u32) {
                /// Use external resistor to generate the current bias for the high speed transmitter
                HS_USE_EXTERNAL_R: u1,
                /// Enable the deglitching circuit of the USB PLL output.
                EN_DEGLITCH: u1,
                reserved30: u28 = 0,
                /// Enables the clk to the UTMI block.
                EN_CLK_UTMI: u1,
                padding: u1 = 0,
            }),
            /// USB Misc Register
            USB2_MISC_SET: mmio.Mmio(packed struct(u32) {
                /// Use external resistor to generate the current bias for the high speed transmitter
                HS_USE_EXTERNAL_R: u1,
                /// Enable the deglitching circuit of the USB PLL output.
                EN_DEGLITCH: u1,
                reserved30: u28 = 0,
                /// Enables the clk to the UTMI block.
                EN_CLK_UTMI: u1,
                padding: u1 = 0,
            }),
            /// USB Misc Register
            USB2_MISC_CLR: mmio.Mmio(packed struct(u32) {
                /// Use external resistor to generate the current bias for the high speed transmitter
                HS_USE_EXTERNAL_R: u1,
                /// Enable the deglitching circuit of the USB PLL output.
                EN_DEGLITCH: u1,
                reserved30: u28 = 0,
                /// Enables the clk to the UTMI block.
                EN_CLK_UTMI: u1,
                padding: u1 = 0,
            }),
            /// USB Misc Register
            USB2_MISC_TOG: mmio.Mmio(packed struct(u32) {
                /// Use external resistor to generate the current bias for the high speed transmitter
                HS_USE_EXTERNAL_R: u1,
                /// Enable the deglitching circuit of the USB PLL output.
                EN_DEGLITCH: u1,
                reserved30: u28 = 0,
                /// Enables the clk to the UTMI block.
                EN_CLK_UTMI: u1,
                padding: u1 = 0,
            }),
            /// Chip Silicon Version
            DIGPROG: mmio.Mmio(packed struct(u32) {
                /// Chip silicon revision
                SILICON_REVISION: enum(u32) {
                    /// Silicon revision 1.0
                    SILICON_REVISION_7077888 = 0x6c0000,
                    _,
                },
            }),
        };

        /// uSDHC
        pub const USDHC1 = extern struct {
            /// DMA System Address
            DS_ADDR: mmio.Mmio(packed struct(u32) {
                /// DS_ADDR
                DS_ADDR: u32,
            }),
            /// Block Attributes
            BLK_ATT: mmio.Mmio(packed struct(u32) {
                /// Block Size
                BLKSIZE: enum(u13) {
                    /// No data transfer
                    BLKSIZE_0 = 0x0,
                    /// 1 Byte
                    BLKSIZE_1 = 0x1,
                    /// 2 Bytes
                    BLKSIZE_2 = 0x2,
                    /// 3 Bytes
                    BLKSIZE_3 = 0x3,
                    /// 4 Bytes
                    BLKSIZE_4 = 0x4,
                    /// 511 Bytes
                    BLKSIZE_511 = 0x1ff,
                    /// 512 Bytes
                    BLKSIZE_512 = 0x200,
                    /// 2048 Bytes
                    BLKSIZE_2048 = 0x800,
                    /// 4096 Bytes
                    BLKSIZE_4096 = 0x1000,
                    _,
                },
                reserved16: u3 = 0,
                /// Block Count
                BLKCNT: enum(u16) {
                    /// Stop Count
                    BLKCNT_0 = 0x0,
                    /// 1 block
                    BLKCNT_1 = 0x1,
                    /// 2 blocks
                    BLKCNT_2 = 0x2,
                    /// 65535 blocks
                    BLKCNT_65535 = 0xffff,
                    _,
                },
            }),
            /// Command Argument
            CMD_ARG: mmio.Mmio(packed struct(u32) {
                /// Command Argument
                CMDARG: u32,
            }),
            /// Command Transfer Type
            CMD_XFR_TYP: mmio.Mmio(packed struct(u32) {
                reserved16: u16 = 0,
                /// Response Type Select
                RSPTYP: enum(u2) {
                    /// No Response
                    RSPTYP_0 = 0x0,
                    /// Response Length 136
                    RSPTYP_1 = 0x1,
                    /// Response Length 48
                    RSPTYP_2 = 0x2,
                    /// Response Length 48, check Busy after response
                    RSPTYP_3 = 0x3,
                },
                reserved19: u1 = 0,
                /// Command CRC Check Enable
                CCCEN: enum(u1) {
                    /// Disable
                    CCCEN_0 = 0x0,
                    /// Enable
                    CCCEN_1 = 0x1,
                },
                /// Command Index Check Enable
                CICEN: enum(u1) {
                    /// Disable
                    CICEN_0 = 0x0,
                    /// Enable
                    CICEN_1 = 0x1,
                },
                /// Data Present Select
                DPSEL: enum(u1) {
                    /// No Data Present
                    DPSEL_0 = 0x0,
                    /// Data Present
                    DPSEL_1 = 0x1,
                },
                /// Command Type
                CMDTYP: enum(u2) {
                    /// Normal Other commands
                    CMDTYP_0 = 0x0,
                    /// Suspend CMD52 for writing Bus Suspend in CCCR
                    CMDTYP_1 = 0x1,
                    /// Resume CMD52 for writing Function Select in CCCR
                    CMDTYP_2 = 0x2,
                    /// Abort CMD12, CMD52 for writing I/O Abort in CCCR
                    CMDTYP_3 = 0x3,
                },
                /// Command Index
                CMDINX: u6,
                padding: u2 = 0,
            }),
            /// Command Response0
            CMD_RSP0: mmio.Mmio(packed struct(u32) {
                /// Command Response 0
                CMDRSP0: u32,
            }),
            /// Command Response1
            CMD_RSP1: mmio.Mmio(packed struct(u32) {
                /// Command Response 1
                CMDRSP1: u32,
            }),
            /// Command Response2
            CMD_RSP2: mmio.Mmio(packed struct(u32) {
                /// Command Response 2
                CMDRSP2: u32,
            }),
            /// Command Response3
            CMD_RSP3: mmio.Mmio(packed struct(u32) {
                /// Command Response 3
                CMDRSP3: u32,
            }),
            /// Data Buffer Access Port
            DATA_BUFF_ACC_PORT: mmio.Mmio(packed struct(u32) {
                /// Data Content
                DATCONT: u32,
            }),
            /// Present State
            PRES_STATE: mmio.Mmio(packed struct(u32) {
                /// Command Inhibit (CMD)
                CIHB: enum(u1) {
                    /// Can issue command using only CMD line
                    CIHB_0 = 0x0,
                    /// Cannot issue command
                    CIHB_1 = 0x1,
                },
                /// Command Inhibit (DATA)
                CDIHB: enum(u1) {
                    /// Can issue command which uses the DATA line
                    CDIHB_0 = 0x0,
                    /// Cannot issue command which uses the DATA line
                    CDIHB_1 = 0x1,
                },
                /// Data Line Active
                DLA: enum(u1) {
                    /// DATA Line Inactive
                    DLA_0 = 0x0,
                    /// DATA Line Active
                    DLA_1 = 0x1,
                },
                /// SD Clock Stable
                SDSTB: enum(u1) {
                    /// Clock is changing frequency and not stable.
                    SDSTB_0 = 0x0,
                    /// Clock is stable.
                    SDSTB_1 = 0x1,
                },
                /// IPG_CLK Gated Off Internally
                IPGOFF: enum(u1) {
                    /// IPG_CLK is active.
                    IPGOFF_0 = 0x0,
                    /// IPG_CLK is gated off.
                    IPGOFF_1 = 0x1,
                },
                /// HCLK Gated Off Internally
                HCKOFF: enum(u1) {
                    /// HCLK is active.
                    HCKOFF_0 = 0x0,
                    /// HCLK is gated off.
                    HCKOFF_1 = 0x1,
                },
                /// IPG_PERCLK Gated Off Internally
                PEROFF: enum(u1) {
                    /// IPG_PERCLK is active.
                    PEROFF_0 = 0x0,
                    /// IPG_PERCLK is gated off.
                    PEROFF_1 = 0x1,
                },
                /// SD Clock Gated Off Internally
                SDOFF: enum(u1) {
                    /// SD Clock is active.
                    SDOFF_0 = 0x0,
                    /// SD Clock is gated off.
                    SDOFF_1 = 0x1,
                },
                /// Write Transfer Active
                WTA: enum(u1) {
                    /// No valid data
                    WTA_0 = 0x0,
                    /// Transferring data
                    WTA_1 = 0x1,
                },
                /// Read Transfer Active
                RTA: enum(u1) {
                    /// No valid data
                    RTA_0 = 0x0,
                    /// Transferring data
                    RTA_1 = 0x1,
                },
                /// Buffer Write Enable
                BWEN: enum(u1) {
                    /// Write disable
                    BWEN_0 = 0x0,
                    /// Write enable
                    BWEN_1 = 0x1,
                },
                /// Buffer Read Enable
                BREN: enum(u1) {
                    /// Read disable
                    BREN_0 = 0x0,
                    /// Read enable
                    BREN_1 = 0x1,
                },
                /// Re-Tuning Request (only for SD3.0 SDR104 mode and EMMC HS200 mode)
                RTR: enum(u1) {
                    /// Fixed or well tuned sampling clock
                    RTR_0 = 0x0,
                    /// Sampling clock needs re-tuning
                    RTR_1 = 0x1,
                },
                reserved15: u2 = 0,
                /// Tape Select Change Done
                TSCD: enum(u1) {
                    /// Delay cell select change is not finished.
                    TSCD_0 = 0x0,
                    /// Delay cell select change is finished.
                    TSCD_1 = 0x1,
                },
                /// Card Inserted
                CINST: enum(u1) {
                    /// Power on Reset or No Card
                    CINST_0 = 0x0,
                    /// Card Inserted
                    CINST_1 = 0x1,
                },
                reserved18: u1 = 0,
                /// Card Detect Pin Level
                CDPL: enum(u1) {
                    /// No card present (CD_B = 1)
                    CDPL_0 = 0x0,
                    /// Card present (CD_B = 0)
                    CDPL_1 = 0x1,
                },
                /// Write Protect Switch Pin Level
                WPSPL: enum(u1) {
                    /// Write protected (WP = 1)
                    WPSPL_0 = 0x0,
                    /// Write enabled (WP = 0)
                    WPSPL_1 = 0x1,
                },
                reserved23: u3 = 0,
                /// CMD Line Signal Level
                CLSL: u1,
                /// DATA[7:0] Line Signal Level
                DLSL: enum(u8) {
                    /// Data 0 line signal level
                    DATA0 = 0x0,
                    /// Data 1 line signal level
                    DATA1 = 0x1,
                    /// Data 2 line signal level
                    DATA2 = 0x2,
                    /// Data 3 line signal level
                    DATA3 = 0x3,
                    /// Data 4 line signal level
                    DATA4 = 0x4,
                    /// Data 5 line signal level
                    DATA5 = 0x5,
                    /// Data 6 line signal level
                    DATA6 = 0x6,
                    /// Data 7 line signal level
                    DATA7 = 0x7,
                    _,
                },
            }),
            /// Protocol Control
            PROT_CTRL: mmio.Mmio(packed struct(u32) {
                /// LED Control
                LCTL: enum(u1) {
                    /// LED off
                    LCTL_0 = 0x0,
                    /// LED on
                    LCTL_1 = 0x1,
                },
                /// Data Transfer Width
                DTW: enum(u2) {
                    /// 1-bit mode
                    DTW_0 = 0x0,
                    /// 4-bit mode
                    DTW_1 = 0x1,
                    /// 8-bit mode
                    DTW_2 = 0x2,
                    _,
                },
                /// DATA3 as Card Detection Pin
                D3CD: enum(u1) {
                    /// DATA3 does not monitor Card Insertion
                    D3CD_0 = 0x0,
                    /// DATA3 as Card Detection Pin
                    D3CD_1 = 0x1,
                },
                /// Endian Mode
                EMODE: enum(u2) {
                    /// Big Endian Mode
                    EMODE_0 = 0x0,
                    /// Half Word Big Endian Mode
                    EMODE_1 = 0x1,
                    /// Little Endian Mode
                    EMODE_2 = 0x2,
                    _,
                },
                /// Card Detect Test Level
                CDTL: enum(u1) {
                    /// Card Detect Test Level is 0, no card inserted
                    CDTL_0 = 0x0,
                    /// Card Detect Test Level is 1, card inserted
                    CDTL_1 = 0x1,
                },
                /// Card Detect Signal Selection
                CDSS: enum(u1) {
                    /// Card Detection Level is selected (for normal purpose).
                    CDSS_0 = 0x0,
                    /// Card Detection Test Level is selected (for test purpose).
                    CDSS_1 = 0x1,
                },
                /// DMA Select
                DMASEL: enum(u2) {
                    /// No DMA or Simple DMA is selected
                    DMASEL_0 = 0x0,
                    /// ADMA1 is selected
                    DMASEL_1 = 0x1,
                    /// ADMA2 is selected
                    DMASEL_2 = 0x2,
                    _,
                },
                reserved16: u6 = 0,
                /// Stop At Block Gap Request
                SABGREQ: enum(u1) {
                    /// Transfer
                    SABGREQ_0 = 0x0,
                    /// Stop
                    SABGREQ_1 = 0x1,
                },
                /// Continue Request
                CREQ: enum(u1) {
                    /// No effect
                    CREQ_0 = 0x0,
                    /// Restart
                    CREQ_1 = 0x1,
                },
                /// Read Wait Control
                RWCTL: enum(u1) {
                    /// Disable Read Wait Control, and stop SD Clock at block gap when SABGREQ bit is set
                    RWCTL_0 = 0x0,
                    /// Enable Read Wait Control, and assert Read Wait without stopping SD Clock at block gap when SABGREQ bit is set
                    RWCTL_1 = 0x1,
                },
                /// Interrupt At Block Gap
                IABG: enum(u1) {
                    /// Disabled
                    IABG_0 = 0x0,
                    /// Enabled
                    IABG_1 = 0x1,
                },
                /// RD_DONE_NO_8CLK
                RD_DONE_NO_8CLK: u1,
                reserved24: u3 = 0,
                /// Wakeup Event Enable On Card Interrupt
                WECINT: enum(u1) {
                    /// Disable
                    WECINT_0 = 0x0,
                    /// Enable
                    WECINT_1 = 0x1,
                },
                /// Wakeup Event Enable On SD Card Insertion
                WECINS: enum(u1) {
                    /// Disable
                    WECINS_0 = 0x0,
                    /// Enable
                    WECINS_1 = 0x1,
                },
                /// Wakeup Event Enable On SD Card Removal
                WECRM: enum(u1) {
                    /// Disable
                    WECRM_0 = 0x0,
                    /// Enable
                    WECRM_1 = 0x1,
                },
                reserved30: u3 = 0,
                /// NON_EXACT_BLK_RD
                NON_EXACT_BLK_RD: enum(u1) {
                    /// The block read is exact block read. Host driver doesn't need to issue abort command to terminate this multi-block read.
                    NON_EXACT_BLK_RD_0 = 0x0,
                    /// The block read is non-exact block read. Host driver needs to issue abort command to terminate this multi-block read.
                    NON_EXACT_BLK_RD_1 = 0x1,
                },
                padding: u1 = 0,
            }),
            /// System Control
            SYS_CTRL: mmio.Mmio(packed struct(u32) {
                reserved4: u4 = 0,
                /// Divisor
                DVS: enum(u4) {
                    /// Divide-by-1
                    DVS_0 = 0x0,
                    /// Divide-by-2
                    DVS_1 = 0x1,
                    /// Divide-by-15
                    DVS_14 = 0xe,
                    /// Divide-by-16
                    DVS_15 = 0xf,
                    _,
                },
                /// SDCLK Frequency Select
                SDCLKFS: u8,
                /// Data Timeout Counter Value
                DTOCV: enum(u4) {
                    /// SDCLK x 2 14
                    DTOCV_0 = 0x0,
                    /// SDCLK x 2 15
                    DTOCV_1 = 0x1,
                    /// SDCLK x 2 27
                    DTOCV_13 = 0xd,
                    /// SDCLK x 2 28
                    DTOCV_14 = 0xe,
                    /// SDCLK x 2 29
                    DTOCV_15 = 0xf,
                    _,
                },
                reserved23: u3 = 0,
                /// IPP_RST_N
                IPP_RST_N: u1,
                /// Software Reset For ALL
                RSTA: enum(u1) {
                    /// No Reset
                    RSTA_0 = 0x0,
                    /// Reset
                    RSTA_1 = 0x1,
                },
                /// Software Reset For CMD Line
                RSTC: enum(u1) {
                    /// No Reset
                    RSTC_0 = 0x0,
                    /// Reset
                    RSTC_1 = 0x1,
                },
                /// Software Reset For DATA Line
                RSTD: enum(u1) {
                    /// No Reset
                    RSTD_0 = 0x0,
                    /// Reset
                    RSTD_1 = 0x1,
                },
                /// Initialization Active
                INITA: u1,
                /// Reset Tuning
                RSTT: u1,
                padding: u3 = 0,
            }),
            /// Interrupt Status
            INT_STATUS: mmio.Mmio(packed struct(u32) {
                /// Command Complete
                CC: enum(u1) {
                    /// Command not complete
                    CC_0 = 0x0,
                    /// Command complete
                    CC_1 = 0x1,
                },
                /// Transfer Complete
                TC: enum(u1) {
                    /// Transfer not complete
                    TC_0 = 0x0,
                    /// Transfer complete
                    TC_1 = 0x1,
                },
                /// Block Gap Event
                BGE: enum(u1) {
                    /// No block gap event
                    BGE_0 = 0x0,
                    /// Transaction stopped at block gap
                    BGE_1 = 0x1,
                },
                /// DMA Interrupt
                DINT: enum(u1) {
                    /// No DMA Interrupt
                    DINT_0 = 0x0,
                    /// DMA Interrupt is generated
                    DINT_1 = 0x1,
                },
                /// Buffer Write Ready
                BWR: enum(u1) {
                    /// Not ready to write buffer
                    BWR_0 = 0x0,
                    /// Ready to write buffer:
                    BWR_1 = 0x1,
                },
                /// Buffer Read Ready
                BRR: enum(u1) {
                    /// Not ready to read buffer
                    BRR_0 = 0x0,
                    /// Ready to read buffer
                    BRR_1 = 0x1,
                },
                /// Card Insertion
                CINS: enum(u1) {
                    /// Card state unstable or removed
                    CINS_0 = 0x0,
                    /// Card inserted
                    CINS_1 = 0x1,
                },
                /// Card Removal
                CRM: enum(u1) {
                    /// Card state unstable or inserted
                    CRM_0 = 0x0,
                    /// Card removed
                    CRM_1 = 0x1,
                },
                /// Card Interrupt
                CINT: enum(u1) {
                    /// No Card Interrupt
                    CINT_0 = 0x0,
                    /// Generate Card Interrupt
                    CINT_1 = 0x1,
                },
                reserved12: u3 = 0,
                /// Re-Tuning Event: (only for SD3.0 SDR104 mode and EMMC HS200 mode)
                RTE: enum(u1) {
                    /// Re-Tuning is not required
                    RTE_0 = 0x0,
                    /// Re-Tuning should be performed
                    RTE_1 = 0x1,
                },
                reserved14: u1 = 0,
                /// Tuning Pass:(only for SD3.0 SDR104 mode and EMMC HS200 mode)
                TP: u1,
                reserved16: u1 = 0,
                /// Command Timeout Error
                CTOE: enum(u1) {
                    /// No Error
                    CTOE_0 = 0x0,
                    /// Time out
                    CTOE_1 = 0x1,
                },
                /// Command CRC Error
                CCE: enum(u1) {
                    /// No Error
                    CCE_0 = 0x0,
                    /// CRC Error Generated.
                    CCE_1 = 0x1,
                },
                /// Command End Bit Error
                CEBE: enum(u1) {
                    /// No Error
                    CEBE_0 = 0x0,
                    /// End Bit Error Generated
                    CEBE_1 = 0x1,
                },
                /// Command Index Error
                CIE: enum(u1) {
                    /// No Error
                    CIE_0 = 0x0,
                    /// Error
                    CIE_1 = 0x1,
                },
                /// Data Timeout Error
                DTOE: enum(u1) {
                    /// No Error
                    DTOE_0 = 0x0,
                    /// Time out
                    DTOE_1 = 0x1,
                },
                /// Data CRC Error
                DCE: enum(u1) {
                    /// No Error
                    DCE_0 = 0x0,
                    /// Error
                    DCE_1 = 0x1,
                },
                /// Data End Bit Error
                DEBE: enum(u1) {
                    /// No Error
                    DEBE_0 = 0x0,
                    /// Error
                    DEBE_1 = 0x1,
                },
                reserved24: u1 = 0,
                /// Auto CMD12 Error
                AC12E: enum(u1) {
                    /// No Error
                    AC12E_0 = 0x0,
                    /// Error
                    AC12E_1 = 0x1,
                },
                reserved26: u1 = 0,
                /// Tuning Error: (only for SD3.0 SDR104 mode and EMMC HS200 mode)
                TNE: u1,
                reserved28: u1 = 0,
                /// DMA Error
                DMAE: enum(u1) {
                    /// No Error
                    DMAE_0 = 0x0,
                    /// Error
                    DMAE_1 = 0x1,
                },
                padding: u3 = 0,
            }),
            /// Interrupt Status Enable
            INT_STATUS_EN: mmio.Mmio(packed struct(u32) {
                /// Command Complete Status Enable
                CCSEN: enum(u1) {
                    /// Masked
                    CCSEN_0 = 0x0,
                    /// Enabled
                    CCSEN_1 = 0x1,
                },
                /// Transfer Complete Status Enable
                TCSEN: enum(u1) {
                    /// Masked
                    TCSEN_0 = 0x0,
                    /// Enabled
                    TCSEN_1 = 0x1,
                },
                /// Block Gap Event Status Enable
                BGESEN: enum(u1) {
                    /// Masked
                    BGESEN_0 = 0x0,
                    /// Enabled
                    BGESEN_1 = 0x1,
                },
                /// DMA Interrupt Status Enable
                DINTSEN: enum(u1) {
                    /// Masked
                    DINTSEN_0 = 0x0,
                    /// Enabled
                    DINTSEN_1 = 0x1,
                },
                /// Buffer Write Ready Status Enable
                BWRSEN: enum(u1) {
                    /// Masked
                    BWRSEN_0 = 0x0,
                    /// Enabled
                    BWRSEN_1 = 0x1,
                },
                /// Buffer Read Ready Status Enable
                BRRSEN: enum(u1) {
                    /// Masked
                    BRRSEN_0 = 0x0,
                    /// Enabled
                    BRRSEN_1 = 0x1,
                },
                /// Card Insertion Status Enable
                CINSSEN: enum(u1) {
                    /// Masked
                    CINSSEN_0 = 0x0,
                    /// Enabled
                    CINSSEN_1 = 0x1,
                },
                /// Card Removal Status Enable
                CRMSEN: enum(u1) {
                    /// Masked
                    CRMSEN_0 = 0x0,
                    /// Enabled
                    CRMSEN_1 = 0x1,
                },
                /// Card Interrupt Status Enable
                CINTSEN: enum(u1) {
                    /// Masked
                    CINTSEN_0 = 0x0,
                    /// Enabled
                    CINTSEN_1 = 0x1,
                },
                reserved12: u3 = 0,
                /// Re-Tuning Event Status Enable
                RTESEN: enum(u1) {
                    /// Masked
                    RTESEN_0 = 0x0,
                    /// Enabled
                    RTESEN_1 = 0x1,
                },
                reserved14: u1 = 0,
                /// Tuning Pass Status Enable
                TPSEN: enum(u1) {
                    /// Masked
                    TPSEN_0 = 0x0,
                    /// Enabled
                    TPSEN_1 = 0x1,
                },
                reserved16: u1 = 0,
                /// Command Timeout Error Status Enable
                CTOESEN: enum(u1) {
                    /// Masked
                    CTOESEN_0 = 0x0,
                    /// Enabled
                    CTOESEN_1 = 0x1,
                },
                /// Command CRC Error Status Enable
                CCESEN: enum(u1) {
                    /// Masked
                    CCESEN_0 = 0x0,
                    /// Enabled
                    CCESEN_1 = 0x1,
                },
                /// Command End Bit Error Status Enable
                CEBESEN: enum(u1) {
                    /// Masked
                    CEBESEN_0 = 0x0,
                    /// Enabled
                    CEBESEN_1 = 0x1,
                },
                /// Command Index Error Status Enable
                CIESEN: enum(u1) {
                    /// Masked
                    CIESEN_0 = 0x0,
                    /// Enabled
                    CIESEN_1 = 0x1,
                },
                /// Data Timeout Error Status Enable
                DTOESEN: enum(u1) {
                    /// Masked
                    DTOESEN_0 = 0x0,
                    /// Enabled
                    DTOESEN_1 = 0x1,
                },
                /// Data CRC Error Status Enable
                DCESEN: enum(u1) {
                    /// Masked
                    DCESEN_0 = 0x0,
                    /// Enabled
                    DCESEN_1 = 0x1,
                },
                /// Data End Bit Error Status Enable
                DEBESEN: enum(u1) {
                    /// Masked
                    DEBESEN_0 = 0x0,
                    /// Enabled
                    DEBESEN_1 = 0x1,
                },
                reserved24: u1 = 0,
                /// Auto CMD12 Error Status Enable
                AC12ESEN: enum(u1) {
                    /// Masked
                    AC12ESEN_0 = 0x0,
                    /// Enabled
                    AC12ESEN_1 = 0x1,
                },
                reserved26: u1 = 0,
                /// Tuning Error Status Enable
                TNESEN: enum(u1) {
                    /// Masked
                    TNESEN_0 = 0x0,
                    /// Enabled
                    TNESEN_1 = 0x1,
                },
                reserved28: u1 = 0,
                /// DMA Error Status Enable
                DMAESEN: enum(u1) {
                    /// Masked
                    DMAESEN_0 = 0x0,
                    /// Enabled
                    DMAESEN_1 = 0x1,
                },
                padding: u3 = 0,
            }),
            /// Interrupt Signal Enable
            INT_SIGNAL_EN: mmio.Mmio(packed struct(u32) {
                /// Command Complete Interrupt Enable
                CCIEN: enum(u1) {
                    /// Masked
                    CCIEN_0 = 0x0,
                    /// Enabled
                    CCIEN_1 = 0x1,
                },
                /// Transfer Complete Interrupt Enable
                TCIEN: enum(u1) {
                    /// Masked
                    TCIEN_0 = 0x0,
                    /// Enabled
                    TCIEN_1 = 0x1,
                },
                /// Block Gap Event Interrupt Enable
                BGEIEN: enum(u1) {
                    /// Masked
                    BGEIEN_0 = 0x0,
                    /// Enabled
                    BGEIEN_1 = 0x1,
                },
                /// DMA Interrupt Enable
                DINTIEN: enum(u1) {
                    /// Masked
                    DINTIEN_0 = 0x0,
                    /// Enabled
                    DINTIEN_1 = 0x1,
                },
                /// Buffer Write Ready Interrupt Enable
                BWRIEN: enum(u1) {
                    /// Masked
                    BWRIEN_0 = 0x0,
                    /// Enabled
                    BWRIEN_1 = 0x1,
                },
                /// Buffer Read Ready Interrupt Enable
                BRRIEN: enum(u1) {
                    /// Masked
                    BRRIEN_0 = 0x0,
                    /// Enabled
                    BRRIEN_1 = 0x1,
                },
                /// Card Insertion Interrupt Enable
                CINSIEN: enum(u1) {
                    /// Masked
                    CINSIEN_0 = 0x0,
                    /// Enabled
                    CINSIEN_1 = 0x1,
                },
                /// Card Removal Interrupt Enable
                CRMIEN: enum(u1) {
                    /// Masked
                    CRMIEN_0 = 0x0,
                    /// Enabled
                    CRMIEN_1 = 0x1,
                },
                /// Card Interrupt Interrupt Enable
                CINTIEN: enum(u1) {
                    /// Masked
                    CINTIEN_0 = 0x0,
                    /// Enabled
                    CINTIEN_1 = 0x1,
                },
                reserved12: u3 = 0,
                /// Re-Tuning Event Interrupt Enable
                RTEIEN: enum(u1) {
                    /// Masked
                    RTEIEN_0 = 0x0,
                    /// Enabled
                    RTEIEN_1 = 0x1,
                },
                reserved14: u1 = 0,
                /// Tuning Pass Interrupt Enable
                TPIEN: enum(u1) {
                    /// Masked
                    TPIEN_0 = 0x0,
                    /// Enabled
                    TPIEN_1 = 0x1,
                },
                reserved16: u1 = 0,
                /// Command Timeout Error Interrupt Enable
                CTOEIEN: enum(u1) {
                    /// Masked
                    CTOEIEN_0 = 0x0,
                    /// Enabled
                    CTOEIEN_1 = 0x1,
                },
                /// Command CRC Error Interrupt Enable
                CCEIEN: enum(u1) {
                    /// Masked
                    CCEIEN_0 = 0x0,
                    /// Enabled
                    CCEIEN_1 = 0x1,
                },
                /// Command End Bit Error Interrupt Enable
                CEBEIEN: enum(u1) {
                    /// Masked
                    CEBEIEN_0 = 0x0,
                    /// Enabled
                    CEBEIEN_1 = 0x1,
                },
                /// Command Index Error Interrupt Enable
                CIEIEN: enum(u1) {
                    /// Masked
                    CIEIEN_0 = 0x0,
                    /// Enabled
                    CIEIEN_1 = 0x1,
                },
                /// Data Timeout Error Interrupt Enable
                DTOEIEN: enum(u1) {
                    /// Masked
                    DTOEIEN_0 = 0x0,
                    /// Enabled
                    DTOEIEN_1 = 0x1,
                },
                /// Data CRC Error Interrupt Enable
                DCEIEN: enum(u1) {
                    /// Masked
                    DCEIEN_0 = 0x0,
                    /// Enabled
                    DCEIEN_1 = 0x1,
                },
                /// Data End Bit Error Interrupt Enable
                DEBEIEN: enum(u1) {
                    /// Masked
                    DEBEIEN_0 = 0x0,
                    /// Enabled
                    DEBEIEN_1 = 0x1,
                },
                reserved24: u1 = 0,
                /// Auto CMD12 Error Interrupt Enable
                AC12EIEN: enum(u1) {
                    /// Masked
                    AC12EIEN_0 = 0x0,
                    /// Enabled
                    AC12EIEN_1 = 0x1,
                },
                reserved26: u1 = 0,
                /// Tuning Error Interrupt Enable
                TNEIEN: enum(u1) {
                    /// Masked
                    TNEIEN_0 = 0x0,
                    /// Enabled
                    TNEIEN_1 = 0x1,
                },
                reserved28: u1 = 0,
                /// DMA Error Interrupt Enable
                DMAEIEN: enum(u1) {
                    /// Masked
                    DMAEIEN_0 = 0x0,
                    /// Enable
                    DMAEIEN_1 = 0x1,
                },
                padding: u3 = 0,
            }),
            /// Auto CMD12 Error Status
            AUTOCMD12_ERR_STATUS: mmio.Mmio(packed struct(u32) {
                /// Auto CMD12 Not Executed
                AC12NE: enum(u1) {
                    /// Executed
                    AC12NE_0 = 0x0,
                    /// Not executed
                    AC12NE_1 = 0x1,
                },
                /// Auto CMD12 / 23 Timeout Error
                AC12TOE: enum(u1) {
                    /// No error
                    AC12TOE_0 = 0x0,
                    /// Time out
                    AC12TOE_1 = 0x1,
                },
                /// Auto CMD12 / 23 End Bit Error
                AC12EBE: enum(u1) {
                    /// No error
                    AC12EBE_0 = 0x0,
                    /// End Bit Error Generated
                    AC12EBE_1 = 0x1,
                },
                /// Auto CMD12 / 23 CRC Error
                AC12CE: enum(u1) {
                    /// No CRC error
                    AC12CE_0 = 0x0,
                    /// CRC Error Met in Auto CMD12/23 Response
                    AC12CE_1 = 0x1,
                },
                /// Auto CMD12 / 23 Index Error
                AC12IE: enum(u1) {
                    /// No error
                    AC12IE_0 = 0x0,
                    /// Error, the CMD index in response is not CMD12/23
                    AC12IE_1 = 0x1,
                },
                reserved7: u2 = 0,
                /// Command Not Issued By Auto CMD12 Error
                CNIBAC12E: enum(u1) {
                    /// No error
                    CNIBAC12E_0 = 0x0,
                    /// Not Issued
                    CNIBAC12E_1 = 0x1,
                },
                reserved22: u14 = 0,
                /// Execute Tuning
                EXECUTE_TUNING: u1,
                /// Sample Clock Select
                SMP_CLK_SEL: enum(u1) {
                    /// Fixed clock is used to sample data
                    SMP_CLK_SEL_0 = 0x0,
                    /// Tuned clock is used to sample data
                    SMP_CLK_SEL_1 = 0x1,
                },
                padding: u8 = 0,
            }),
            /// Host Controller Capabilities
            HOST_CTRL_CAP: mmio.Mmio(packed struct(u32) {
                /// SDR50 support
                SDR50_SUPPORT: u1,
                /// SDR104 support
                SDR104_SUPPORT: u1,
                /// DDR50 support
                DDR50_SUPPORT: u1,
                reserved8: u5 = 0,
                /// Time Counter for Retuning
                TIME_COUNT_RETUNING: u4,
                reserved13: u1 = 0,
                /// Use Tuning for SDR50
                USE_TUNING_SDR50: enum(u1) {
                    /// SDR does not require tuning
                    USE_TUNING_SDR50_0 = 0x0,
                    /// SDR50 requires tuning
                    USE_TUNING_SDR50_1 = 0x1,
                },
                /// Retuning Mode
                RETUNING_MODE: enum(u2) {
                    /// Mode 1
                    RETUNING_MODE_0 = 0x0,
                    /// Mode 2
                    RETUNING_MODE_1 = 0x1,
                    /// Mode 3
                    RETUNING_MODE_2 = 0x2,
                    _,
                },
                /// Max Block Length
                MBL: enum(u3) {
                    /// 512 bytes
                    MBL_0 = 0x0,
                    /// 1024 bytes
                    MBL_1 = 0x1,
                    /// 2048 bytes
                    MBL_2 = 0x2,
                    /// 4096 bytes
                    MBL_3 = 0x3,
                    _,
                },
                reserved20: u1 = 0,
                /// ADMA Support
                ADMAS: enum(u1) {
                    /// Advanced DMA Not supported
                    ADMAS_0 = 0x0,
                    /// Advanced DMA Supported
                    ADMAS_1 = 0x1,
                },
                /// High Speed Support
                HSS: enum(u1) {
                    /// High Speed Not Supported
                    HSS_0 = 0x0,
                    /// High Speed Supported
                    HSS_1 = 0x1,
                },
                /// DMA Support
                DMAS: enum(u1) {
                    /// DMA not supported
                    DMAS_0 = 0x0,
                    /// DMA Supported
                    DMAS_1 = 0x1,
                },
                /// Suspend / Resume Support
                SRS: enum(u1) {
                    /// Not supported
                    SRS_0 = 0x0,
                    /// Supported
                    SRS_1 = 0x1,
                },
                /// Voltage Support 3.3V
                VS33: enum(u1) {
                    /// 3.3V not supported
                    VS33_0 = 0x0,
                    /// 3.3V supported
                    VS33_1 = 0x1,
                },
                /// Voltage Support 3.0 V
                VS30: enum(u1) {
                    /// 3.0V not supported
                    VS30_0 = 0x0,
                    /// 3.0V supported
                    VS30_1 = 0x1,
                },
                /// Voltage Support 1.8 V
                VS18: enum(u1) {
                    /// 1.8V not supported
                    VS18_0 = 0x0,
                    /// 1.8V supported
                    VS18_1 = 0x1,
                },
                padding: u5 = 0,
            }),
            /// Watermark Level
            WTMK_LVL: mmio.Mmio(packed struct(u32) {
                /// Read Watermark Level
                RD_WML: u8,
                /// Read Burst Length Due to system restriction, the actual burst length may not exceed 16.
                RD_BRST_LEN: u5,
                reserved16: u3 = 0,
                /// Write Watermark Level
                WR_WML: u8,
                /// Write Burst Length Due to system restriction, the actual burst length may not exceed 16.
                WR_BRST_LEN: u5,
                padding: u3 = 0,
            }),
            /// Mixer Control
            MIX_CTRL: mmio.Mmio(packed struct(u32) {
                /// DMA Enable
                DMAEN: enum(u1) {
                    /// Disable
                    DMAEN_0 = 0x0,
                    /// Enable
                    DMAEN_1 = 0x1,
                },
                /// Block Count Enable
                BCEN: enum(u1) {
                    /// Disable
                    BCEN_0 = 0x0,
                    /// Enable
                    BCEN_1 = 0x1,
                },
                /// Auto CMD12 Enable
                AC12EN: enum(u1) {
                    /// Disable
                    AC12EN_0 = 0x0,
                    /// Enable
                    AC12EN_1 = 0x1,
                },
                /// Dual Data Rate mode selection
                DDR_EN: u1,
                /// Data Transfer Direction Select
                DTDSEL: enum(u1) {
                    /// Write (Host to Card)
                    DTDSEL_0 = 0x0,
                    /// Read (Card to Host)
                    DTDSEL_1 = 0x1,
                },
                /// Multi / Single Block Select
                MSBSEL: enum(u1) {
                    /// Single Block
                    MSBSEL_0 = 0x0,
                    /// Multiple Blocks
                    MSBSEL_1 = 0x1,
                },
                /// NIBBLE_POS
                NIBBLE_POS: u1,
                /// Auto CMD23 Enable
                AC23EN: u1,
                reserved22: u14 = 0,
                /// Execute Tuning: (Only used for SD3.0, SDR104 mode and EMMC HS200 mode)
                EXE_TUNE: enum(u1) {
                    /// Not Tuned or Tuning Completed
                    EXE_TUNE_0 = 0x0,
                    /// Execute Tuning
                    EXE_TUNE_1 = 0x1,
                },
                /// SMP_CLK_SEL
                SMP_CLK_SEL: enum(u1) {
                    /// Fixed clock is used to sample data / cmd
                    SMP_CLK_SEL_0 = 0x0,
                    /// Tuned clock is used to sample data / cmd
                    SMP_CLK_SEL_1 = 0x1,
                },
                /// Auto Tuning Enable (Only used for SD3.0, SDR104 mode and and EMMC HS200 mode)
                AUTO_TUNE_EN: enum(u1) {
                    /// Disable auto tuning
                    AUTO_TUNE_EN_0 = 0x0,
                    /// Enable auto tuning
                    AUTO_TUNE_EN_1 = 0x1,
                },
                /// Feedback Clock Source Selection (Only used for SD3.0, SDR104 mode and EMMC HS200 mode)
                FBCLK_SEL: enum(u1) {
                    /// Feedback clock comes from the loopback CLK
                    FBCLK_SEL_0 = 0x0,
                    /// Feedback clock comes from the ipp_card_clk_out
                    FBCLK_SEL_1 = 0x1,
                },
                padding: u6 = 0,
            }),
            reserved80: [4]u8,
            /// Force Event
            FORCE_EVENT: mmio.Mmio(packed struct(u32) {
                /// Force Event Auto Command 12 Not Executed
                FEVTAC12NE: u1,
                /// Force Event Auto Command 12 Time Out Error
                FEVTAC12TOE: u1,
                /// Force Event Auto Command 12 CRC Error
                FEVTAC12CE: u1,
                /// Force Event Auto Command 12 End Bit Error
                FEVTAC12EBE: u1,
                /// Force Event Auto Command 12 Index Error
                FEVTAC12IE: u1,
                reserved7: u2 = 0,
                /// Force Event Command Not Executed By Auto Command 12 Error
                FEVTCNIBAC12E: u1,
                reserved16: u8 = 0,
                /// Force Event Command Time Out Error
                FEVTCTOE: u1,
                /// Force Event Command CRC Error
                FEVTCCE: u1,
                /// Force Event Command End Bit Error
                FEVTCEBE: u1,
                /// Force Event Command Index Error
                FEVTCIE: u1,
                /// Force Event Data Time Out Error
                FEVTDTOE: u1,
                /// Force Event Data CRC Error
                FEVTDCE: u1,
                /// Force Event Data End Bit Error
                FEVTDEBE: u1,
                reserved24: u1 = 0,
                /// Force Event Auto Command 12 Error
                FEVTAC12E: u1,
                reserved26: u1 = 0,
                /// Force Tuning Error
                FEVTTNE: u1,
                reserved28: u1 = 0,
                /// Force Event DMA Error
                FEVTDMAE: u1,
                reserved31: u2 = 0,
                /// Force Event Card Interrupt
                FEVTCINT: u1,
            }),
            /// ADMA Error Status Register
            ADMA_ERR_STATUS: mmio.Mmio(packed struct(u32) {
                /// ADMA Error State (when ADMA Error is occurred)
                ADMAES: u2,
                /// ADMA Length Mismatch Error
                ADMALME: enum(u1) {
                    /// No Error
                    ADMALME_0 = 0x0,
                    /// Error
                    ADMALME_1 = 0x1,
                },
                /// ADMA Descriptor Error
                ADMADCE: enum(u1) {
                    /// No Error
                    ADMADCE_0 = 0x0,
                    /// Error
                    ADMADCE_1 = 0x1,
                },
                padding: u28 = 0,
            }),
            /// ADMA System Address
            ADMA_SYS_ADDR: mmio.Mmio(packed struct(u32) {
                reserved2: u2 = 0,
                /// ADMA System Address
                ADS_ADDR: u30,
            }),
            reserved96: [4]u8,
            /// DLL (Delay Line) Control
            DLL_CTRL: mmio.Mmio(packed struct(u32) {
                /// DLL_CTRL_ENABLE
                DLL_CTRL_ENABLE: u1,
                /// DLL_CTRL_RESET
                DLL_CTRL_RESET: u1,
                /// DLL_CTRL_SLV_FORCE_UPD
                DLL_CTRL_SLV_FORCE_UPD: u1,
                /// DLL_CTRL_SLV_DLY_TARGET0
                DLL_CTRL_SLV_DLY_TARGET0: u4,
                /// DLL_CTRL_GATE_UPDATE
                DLL_CTRL_GATE_UPDATE: u1,
                /// DLL_CTRL_SLV_OVERRIDE
                DLL_CTRL_SLV_OVERRIDE: u1,
                /// DLL_CTRL_SLV_OVERRIDE_VAL
                DLL_CTRL_SLV_OVERRIDE_VAL: u7,
                /// DLL_CTRL_SLV_DLY_TARGET1
                DLL_CTRL_SLV_DLY_TARGET1: u3,
                reserved20: u1 = 0,
                /// DLL_CTRL_SLV_UPDATE_INT
                DLL_CTRL_SLV_UPDATE_INT: u8,
                /// DLL_CTRL_REF_UPDATE_INT
                DLL_CTRL_REF_UPDATE_INT: u4,
            }),
            /// DLL Status
            DLL_STATUS: mmio.Mmio(packed struct(u32) {
                /// DLL_STS_SLV_LOCK
                DLL_STS_SLV_LOCK: u1,
                /// DLL_STS_REF_LOCK
                DLL_STS_REF_LOCK: u1,
                /// DLL_STS_SLV_SEL
                DLL_STS_SLV_SEL: u7,
                /// DLL_STS_REF_SEL
                DLL_STS_REF_SEL: u7,
                padding: u16 = 0,
            }),
            /// CLK Tuning Control and Status
            CLK_TUNE_CTRL_STATUS: mmio.Mmio(packed struct(u32) {
                /// DLY_CELL_SET_POST
                DLY_CELL_SET_POST: u4,
                /// DLY_CELL_SET_OUT
                DLY_CELL_SET_OUT: u4,
                /// DLY_CELL_SET_PRE
                DLY_CELL_SET_PRE: u7,
                /// NXT_ERR
                NXT_ERR: u1,
                /// TAP_SEL_POST
                TAP_SEL_POST: u4,
                /// TAP_SEL_OUT
                TAP_SEL_OUT: u4,
                /// TAP_SEL_PRE
                TAP_SEL_PRE: u7,
                /// PRE_ERR
                PRE_ERR: u1,
            }),
            reserved192: [84]u8,
            /// Vendor Specific Register
            VEND_SPEC: mmio.Mmio(packed struct(u32) {
                reserved1: u1 = 0,
                /// Voltage Selection
                VSELECT: enum(u1) {
                    /// Change the voltage to high voltage range, around 3.0 V
                    VSELECT_0 = 0x0,
                    /// Change the voltage to low voltage range, around 1.8 V
                    VSELECT_1 = 0x1,
                },
                /// Conflict check enable.
                CONFLICT_CHK_EN: enum(u1) {
                    /// Conflict check disable
                    CONFLICT_CHK_EN_0 = 0x0,
                    /// Conflict check enable
                    CONFLICT_CHK_EN_1 = 0x1,
                },
                /// AC12_WR_CHKBUSY_EN
                AC12_WR_CHKBUSY_EN: enum(u1) {
                    /// Do not check busy after auto CMD12 for write data packet
                    AC12_WR_CHKBUSY_EN_0 = 0x0,
                    /// Check busy after auto CMD12 for write data packet
                    AC12_WR_CHKBUSY_EN_1 = 0x1,
                },
                reserved8: u4 = 0,
                /// FRC_SDCLK_ON
                FRC_SDCLK_ON: enum(u1) {
                    /// CLK active or inactive is fully controlled by the hardware.
                    FRC_SDCLK_ON_0 = 0x0,
                    /// Force CLK active.
                    FRC_SDCLK_ON_1 = 0x1,
                },
                reserved15: u6 = 0,
                /// CRC Check Disable
                CRC_CHK_DIS: enum(u1) {
                    /// Check CRC16 for every read data packet and check CRC bits for every write data packet
                    CRC_CHK_DIS_0 = 0x0,
                    /// Ignore CRC16 check for every read data packet and ignore CRC bits check for every write data packet
                    CRC_CHK_DIS_1 = 0x1,
                },
                reserved31: u15 = 0,
                /// CMD_BYTE_EN
                CMD_BYTE_EN: enum(u1) {
                    /// Disable
                    CMD_BYTE_EN_0 = 0x0,
                    /// Enable
                    CMD_BYTE_EN_1 = 0x1,
                },
            }),
            /// MMC Boot Register
            MMC_BOOT: mmio.Mmio(packed struct(u32) {
                /// DTOCV_ACK
                DTOCV_ACK: enum(u4) {
                    /// SDCLK x 2^14
                    DTOCV_ACK_0 = 0x0,
                    /// SDCLK x 2^15
                    DTOCV_ACK_1 = 0x1,
                    /// SDCLK x 2^16
                    DTOCV_ACK_2 = 0x2,
                    /// SDCLK x 2^17
                    DTOCV_ACK_3 = 0x3,
                    /// SDCLK x 2^18
                    DTOCV_ACK_4 = 0x4,
                    /// SDCLK x 2^19
                    DTOCV_ACK_5 = 0x5,
                    /// SDCLK x 2^20
                    DTOCV_ACK_6 = 0x6,
                    /// SDCLK x 2^21
                    DTOCV_ACK_7 = 0x7,
                    /// SDCLK x 2^28
                    DTOCV_ACK_14 = 0xe,
                    /// SDCLK x 2^29
                    DTOCV_ACK_15 = 0xf,
                    _,
                },
                /// BOOT_ACK
                BOOT_ACK: enum(u1) {
                    /// No ack
                    BOOT_ACK_0 = 0x0,
                    /// Ack
                    BOOT_ACK_1 = 0x1,
                },
                /// BOOT_MODE
                BOOT_MODE: enum(u1) {
                    /// Normal boot
                    BOOT_MODE_0 = 0x0,
                    /// Alternative boot
                    BOOT_MODE_1 = 0x1,
                },
                /// BOOT_EN
                BOOT_EN: enum(u1) {
                    /// Fast boot disable
                    BOOT_EN_0 = 0x0,
                    /// Fast boot enable
                    BOOT_EN_1 = 0x1,
                },
                /// AUTO_SABG_EN
                AUTO_SABG_EN: u1,
                /// Disable Time Out
                DISABLE_TIME_OUT: enum(u1) {
                    /// Enable time out
                    DISABLE_TIME_OUT_0 = 0x0,
                    /// Disable time out
                    DISABLE_TIME_OUT_1 = 0x1,
                },
                reserved16: u7 = 0,
                /// BOOT_BLK_CNT
                BOOT_BLK_CNT: u16,
            }),
            /// Vendor Specific 2 Register
            VEND_SPEC2: mmio.Mmio(packed struct(u32) {
                reserved3: u3 = 0,
                /// Card Interrupt Detection Test
                CARD_INT_D3_TEST: enum(u1) {
                    /// Check the card interrupt only when DATA3 is high.
                    CARD_INT_D3_TEST_0 = 0x0,
                    /// Check the card interrupt by ignoring the status of DATA3.
                    CARD_INT_D3_TEST_1 = 0x1,
                },
                /// TUNING_8bit_EN
                TUNING_8bit_EN: u1,
                /// TUNING_1bit_EN
                TUNING_1bit_EN: u1,
                /// TUNING_CMD_EN
                TUNING_CMD_EN: enum(u1) {
                    /// Auto tuning circuit does not check the CMD line.
                    TUNING_CMD_EN_0 = 0x0,
                    /// Auto tuning circuit checks the CMD line.
                    TUNING_CMD_EN_1 = 0x1,
                },
                reserved12: u5 = 0,
                /// Argument2 register enable for ACMD23
                ACMD23_ARGU2_EN: enum(u1) {
                    /// Disable
                    ACMD23_ARGU2_EN_0 = 0x0,
                    /// Argument2 register enable for ACMD23 sharing with SDMA system address register. Default is enable.
                    ACMD23_ARGU2_EN_1 = 0x1,
                },
                /// debug for part dll
                PART_DLL_DEBUG: u1,
                /// BUS reset
                BUS_RST: u1,
                padding: u17 = 0,
            }),
            /// Tuning Control Register
            TUNING_CTRL: mmio.Mmio(packed struct(u32) {
                /// TUNING_START_TAP
                TUNING_START_TAP: u8,
                /// TUNING_COUNTER
                TUNING_COUNTER: u8,
                /// TUNING_STEP
                TUNING_STEP: u3,
                reserved20: u1 = 0,
                /// TUNING_WINDOW
                TUNING_WINDOW: u3,
                reserved24: u1 = 0,
                /// STD_TUNING_EN
                STD_TUNING_EN: u1,
                padding: u7 = 0,
            }),
        };

        /// WDOG
        pub const WDOG1 = extern struct {
            /// Watchdog Control Register
            WCR: mmio.Mmio(packed struct(u16) {
                /// WDZST
                WDZST: enum(u1) {
                    /// Continue timer operation (Default).
                    WDZST_0 = 0x0,
                    /// Suspend the watchdog timer.
                    WDZST_1 = 0x1,
                },
                /// WDBG
                WDBG: enum(u1) {
                    /// Continue WDOG timer operation (Default).
                    WDBG_0 = 0x0,
                    /// Suspend the watchdog timer.
                    WDBG_1 = 0x1,
                },
                /// WDE
                WDE: enum(u1) {
                    /// Disable the Watchdog (Default).
                    WDE_0 = 0x0,
                    /// Enable the Watchdog.
                    WDE_1 = 0x1,
                },
                /// WDT
                WDT: enum(u1) {
                    /// No effect on WDOG_B (Default).
                    WDT_0 = 0x0,
                    /// Assert WDOG_B upon a Watchdog Time-out event.
                    WDT_1 = 0x1,
                },
                /// SRS
                SRS: enum(u1) {
                    /// Assert system reset signal.
                    SRS_0 = 0x0,
                    /// No effect on the system (Default).
                    SRS_1 = 0x1,
                },
                /// WDA
                WDA: enum(u1) {
                    /// Assert WDOG_B output.
                    WDA_0 = 0x0,
                    /// No effect on system (Default).
                    WDA_1 = 0x1,
                },
                /// software reset extension, an option way to generate software reset
                SRE: enum(u1) {
                    /// using original way to generate software reset (default)
                    SRE_0 = 0x0,
                    /// using new way to generate software reset.
                    SRE_1 = 0x1,
                },
                /// WDW
                WDW: enum(u1) {
                    /// Continue WDOG timer operation (Default).
                    WDW_0 = 0x0,
                    /// Suspend WDOG timer operation.
                    WDW_1 = 0x1,
                },
                /// WT
                WT: enum(u8) {
                    /// - 0.5 Seconds (Default).
                    WT_0 = 0x0,
                    /// - 1.0 Seconds.
                    WT_1 = 0x1,
                    /// - 1.5 Seconds.
                    WT_2 = 0x2,
                    /// - 2.0 Seconds.
                    WT_3 = 0x3,
                    /// - 128 Seconds.
                    WT_255 = 0xff,
                    _,
                },
            }),
            /// Watchdog Service Register
            WSR: mmio.Mmio(packed struct(u16) {
                /// WSR
                WSR: enum(u16) {
                    /// Write to the Watchdog Service Register (WDOG_WSR).
                    WSR_21845 = 0x5555,
                    /// Write to the Watchdog Service Register (WDOG_WSR).
                    WSR_43690 = 0xaaaa,
                    _,
                },
            }),
            /// Watchdog Reset Status Register
            WRSR: mmio.Mmio(packed struct(u16) {
                /// SFTW
                SFTW: enum(u1) {
                    /// Reset is not the result of a software reset.
                    SFTW_0 = 0x0,
                    /// Reset is the result of a software reset.
                    SFTW_1 = 0x1,
                },
                /// TOUT
                TOUT: enum(u1) {
                    /// Reset is not the result of a WDOG timeout.
                    TOUT_0 = 0x0,
                    /// Reset is the result of a WDOG timeout.
                    TOUT_1 = 0x1,
                },
                reserved4: u2 = 0,
                /// POR
                POR: enum(u1) {
                    /// Reset is not the result of a power on reset.
                    POR_0 = 0x0,
                    /// Reset is the result of a power on reset.
                    POR_1 = 0x1,
                },
                padding: u11 = 0,
            }),
            /// Watchdog Interrupt Control Register
            WICR: mmio.Mmio(packed struct(u16) {
                /// WICT
                WICT: enum(u8) {
                    /// WICT[7:0] = Time duration between interrupt and time-out is 0 seconds.
                    WICT_0 = 0x0,
                    /// WICT[7:0] = Time duration between interrupt and time-out is 0.5 seconds.
                    WICT_1 = 0x1,
                    /// WICT[7:0] = Time duration between interrupt and time-out is 2 seconds (Default).
                    WICT_4 = 0x4,
                    /// WICT[7:0] = Time duration between interrupt and time-out is 127.5 seconds.
                    WICT_255 = 0xff,
                    _,
                },
                reserved14: u6 = 0,
                /// WTIS
                WTIS: enum(u1) {
                    /// No interrupt has occurred (Default).
                    WTIS_0 = 0x0,
                    /// Interrupt has occurred
                    WTIS_1 = 0x1,
                },
                /// WIE
                WIE: enum(u1) {
                    /// Disable Interrupt (Default).
                    WIE_0 = 0x0,
                    /// Enable Interrupt.
                    WIE_1 = 0x1,
                },
            }),
            /// Watchdog Miscellaneous Control Register
            WMCR: mmio.Mmio(packed struct(u16) {
                /// PDE
                PDE: enum(u1) {
                    /// Power Down Counter of WDOG is disabled.
                    PDE_0 = 0x0,
                    /// Power Down Counter of WDOG is enabled (Default).
                    PDE_1 = 0x1,
                },
                padding: u15 = 0,
            }),
        };

        /// Crossbar Switch
        pub const XBARA1 = extern struct {
            /// Crossbar A Select Register 0
            SEL0: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT0 (refer to Functional Description section for input/output assignment)
                SEL0: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT1 (refer to Functional Description section for input/output assignment)
                SEL1: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 1
            SEL1: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT2 (refer to Functional Description section for input/output assignment)
                SEL2: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT3 (refer to Functional Description section for input/output assignment)
                SEL3: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 2
            SEL2: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT4 (refer to Functional Description section for input/output assignment)
                SEL4: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT5 (refer to Functional Description section for input/output assignment)
                SEL5: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 3
            SEL3: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT6 (refer to Functional Description section for input/output assignment)
                SEL6: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT7 (refer to Functional Description section for input/output assignment)
                SEL7: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 4
            SEL4: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT8 (refer to Functional Description section for input/output assignment)
                SEL8: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT9 (refer to Functional Description section for input/output assignment)
                SEL9: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 5
            SEL5: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT10 (refer to Functional Description section for input/output assignment)
                SEL10: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT11 (refer to Functional Description section for input/output assignment)
                SEL11: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 6
            SEL6: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT12 (refer to Functional Description section for input/output assignment)
                SEL12: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT13 (refer to Functional Description section for input/output assignment)
                SEL13: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 7
            SEL7: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT14 (refer to Functional Description section for input/output assignment)
                SEL14: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT15 (refer to Functional Description section for input/output assignment)
                SEL15: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 8
            SEL8: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT16 (refer to Functional Description section for input/output assignment)
                SEL16: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT17 (refer to Functional Description section for input/output assignment)
                SEL17: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 9
            SEL9: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT18 (refer to Functional Description section for input/output assignment)
                SEL18: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT19 (refer to Functional Description section for input/output assignment)
                SEL19: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 10
            SEL10: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT20 (refer to Functional Description section for input/output assignment)
                SEL20: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT21 (refer to Functional Description section for input/output assignment)
                SEL21: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 11
            SEL11: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT22 (refer to Functional Description section for input/output assignment)
                SEL22: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT23 (refer to Functional Description section for input/output assignment)
                SEL23: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 12
            SEL12: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT24 (refer to Functional Description section for input/output assignment)
                SEL24: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT25 (refer to Functional Description section for input/output assignment)
                SEL25: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 13
            SEL13: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT26 (refer to Functional Description section for input/output assignment)
                SEL26: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT27 (refer to Functional Description section for input/output assignment)
                SEL27: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 14
            SEL14: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT28 (refer to Functional Description section for input/output assignment)
                SEL28: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT29 (refer to Functional Description section for input/output assignment)
                SEL29: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 15
            SEL15: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT30 (refer to Functional Description section for input/output assignment)
                SEL30: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT31 (refer to Functional Description section for input/output assignment)
                SEL31: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 16
            SEL16: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT32 (refer to Functional Description section for input/output assignment)
                SEL32: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT33 (refer to Functional Description section for input/output assignment)
                SEL33: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 17
            SEL17: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT34 (refer to Functional Description section for input/output assignment)
                SEL34: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT35 (refer to Functional Description section for input/output assignment)
                SEL35: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 18
            SEL18: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT36 (refer to Functional Description section for input/output assignment)
                SEL36: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT37 (refer to Functional Description section for input/output assignment)
                SEL37: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 19
            SEL19: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT38 (refer to Functional Description section for input/output assignment)
                SEL38: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT39 (refer to Functional Description section for input/output assignment)
                SEL39: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 20
            SEL20: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT40 (refer to Functional Description section for input/output assignment)
                SEL40: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT41 (refer to Functional Description section for input/output assignment)
                SEL41: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 21
            SEL21: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT42 (refer to Functional Description section for input/output assignment)
                SEL42: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT43 (refer to Functional Description section for input/output assignment)
                SEL43: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 22
            SEL22: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT44 (refer to Functional Description section for input/output assignment)
                SEL44: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT45 (refer to Functional Description section for input/output assignment)
                SEL45: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 23
            SEL23: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT46 (refer to Functional Description section for input/output assignment)
                SEL46: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT47 (refer to Functional Description section for input/output assignment)
                SEL47: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 24
            SEL24: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT48 (refer to Functional Description section for input/output assignment)
                SEL48: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT49 (refer to Functional Description section for input/output assignment)
                SEL49: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 25
            SEL25: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT50 (refer to Functional Description section for input/output assignment)
                SEL50: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT51 (refer to Functional Description section for input/output assignment)
                SEL51: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 26
            SEL26: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT52 (refer to Functional Description section for input/output assignment)
                SEL52: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT53 (refer to Functional Description section for input/output assignment)
                SEL53: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 27
            SEL27: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT54 (refer to Functional Description section for input/output assignment)
                SEL54: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT55 (refer to Functional Description section for input/output assignment)
                SEL55: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 28
            SEL28: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT56 (refer to Functional Description section for input/output assignment)
                SEL56: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT57 (refer to Functional Description section for input/output assignment)
                SEL57: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 29
            SEL29: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT58 (refer to Functional Description section for input/output assignment)
                SEL58: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT59 (refer to Functional Description section for input/output assignment)
                SEL59: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 30
            SEL30: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT60 (refer to Functional Description section for input/output assignment)
                SEL60: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT61 (refer to Functional Description section for input/output assignment)
                SEL61: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 31
            SEL31: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT62 (refer to Functional Description section for input/output assignment)
                SEL62: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT63 (refer to Functional Description section for input/output assignment)
                SEL63: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 32
            SEL32: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT64 (refer to Functional Description section for input/output assignment)
                SEL64: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT65 (refer to Functional Description section for input/output assignment)
                SEL65: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 33
            SEL33: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT66 (refer to Functional Description section for input/output assignment)
                SEL66: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT67 (refer to Functional Description section for input/output assignment)
                SEL67: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 34
            SEL34: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT68 (refer to Functional Description section for input/output assignment)
                SEL68: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT69 (refer to Functional Description section for input/output assignment)
                SEL69: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 35
            SEL35: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT70 (refer to Functional Description section for input/output assignment)
                SEL70: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT71 (refer to Functional Description section for input/output assignment)
                SEL71: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 36
            SEL36: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT72 (refer to Functional Description section for input/output assignment)
                SEL72: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT73 (refer to Functional Description section for input/output assignment)
                SEL73: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 37
            SEL37: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT74 (refer to Functional Description section for input/output assignment)
                SEL74: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT75 (refer to Functional Description section for input/output assignment)
                SEL75: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 38
            SEL38: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT76 (refer to Functional Description section for input/output assignment)
                SEL76: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT77 (refer to Functional Description section for input/output assignment)
                SEL77: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 39
            SEL39: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT78 (refer to Functional Description section for input/output assignment)
                SEL78: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT79 (refer to Functional Description section for input/output assignment)
                SEL79: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 40
            SEL40: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT80 (refer to Functional Description section for input/output assignment)
                SEL80: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT81 (refer to Functional Description section for input/output assignment)
                SEL81: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 41
            SEL41: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT82 (refer to Functional Description section for input/output assignment)
                SEL82: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT83 (refer to Functional Description section for input/output assignment)
                SEL83: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 42
            SEL42: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT84 (refer to Functional Description section for input/output assignment)
                SEL84: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT85 (refer to Functional Description section for input/output assignment)
                SEL85: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 43
            SEL43: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT86 (refer to Functional Description section for input/output assignment)
                SEL86: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT87 (refer to Functional Description section for input/output assignment)
                SEL87: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 44
            SEL44: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT88 (refer to Functional Description section for input/output assignment)
                SEL88: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT89 (refer to Functional Description section for input/output assignment)
                SEL89: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 45
            SEL45: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT90 (refer to Functional Description section for input/output assignment)
                SEL90: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT91 (refer to Functional Description section for input/output assignment)
                SEL91: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 46
            SEL46: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT92 (refer to Functional Description section for input/output assignment)
                SEL92: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT93 (refer to Functional Description section for input/output assignment)
                SEL93: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 47
            SEL47: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT94 (refer to Functional Description section for input/output assignment)
                SEL94: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT95 (refer to Functional Description section for input/output assignment)
                SEL95: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 48
            SEL48: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT96 (refer to Functional Description section for input/output assignment)
                SEL96: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT97 (refer to Functional Description section for input/output assignment)
                SEL97: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 49
            SEL49: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT98 (refer to Functional Description section for input/output assignment)
                SEL98: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT99 (refer to Functional Description section for input/output assignment)
                SEL99: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 50
            SEL50: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT100 (refer to Functional Description section for input/output assignment)
                SEL100: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT101 (refer to Functional Description section for input/output assignment)
                SEL101: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 51
            SEL51: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT102 (refer to Functional Description section for input/output assignment)
                SEL102: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT103 (refer to Functional Description section for input/output assignment)
                SEL103: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 52
            SEL52: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT104 (refer to Functional Description section for input/output assignment)
                SEL104: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT105 (refer to Functional Description section for input/output assignment)
                SEL105: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 53
            SEL53: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT106 (refer to Functional Description section for input/output assignment)
                SEL106: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT107 (refer to Functional Description section for input/output assignment)
                SEL107: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 54
            SEL54: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT108 (refer to Functional Description section for input/output assignment)
                SEL108: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT109 (refer to Functional Description section for input/output assignment)
                SEL109: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 55
            SEL55: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT110 (refer to Functional Description section for input/output assignment)
                SEL110: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT111 (refer to Functional Description section for input/output assignment)
                SEL111: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 56
            SEL56: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT112 (refer to Functional Description section for input/output assignment)
                SEL112: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT113 (refer to Functional Description section for input/output assignment)
                SEL113: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 57
            SEL57: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT114 (refer to Functional Description section for input/output assignment)
                SEL114: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT115 (refer to Functional Description section for input/output assignment)
                SEL115: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 58
            SEL58: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT116 (refer to Functional Description section for input/output assignment)
                SEL116: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT117 (refer to Functional Description section for input/output assignment)
                SEL117: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 59
            SEL59: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT118 (refer to Functional Description section for input/output assignment)
                SEL118: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT119 (refer to Functional Description section for input/output assignment)
                SEL119: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 60
            SEL60: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT120 (refer to Functional Description section for input/output assignment)
                SEL120: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT121 (refer to Functional Description section for input/output assignment)
                SEL121: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 61
            SEL61: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT122 (refer to Functional Description section for input/output assignment)
                SEL122: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT123 (refer to Functional Description section for input/output assignment)
                SEL123: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 62
            SEL62: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT124 (refer to Functional Description section for input/output assignment)
                SEL124: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT125 (refer to Functional Description section for input/output assignment)
                SEL125: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 63
            SEL63: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT126 (refer to Functional Description section for input/output assignment)
                SEL126: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT127 (refer to Functional Description section for input/output assignment)
                SEL127: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 64
            SEL64: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT128 (refer to Functional Description section for input/output assignment)
                SEL128: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT129 (refer to Functional Description section for input/output assignment)
                SEL129: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Select Register 65
            SEL65: mmio.Mmio(packed struct(u16) {
                /// Input (XBARA_INn) to be muxed to XBARA_OUT130 (refer to Functional Description section for input/output assignment)
                SEL130: u7,
                reserved8: u1 = 0,
                /// Input (XBARA_INn) to be muxed to XBARA_OUT131 (refer to Functional Description section for input/output assignment)
                SEL131: u7,
                padding: u1 = 0,
            }),
            /// Crossbar A Control Register 0
            CTRL0: mmio.Mmio(packed struct(u16) {
                /// DMA Enable for XBAR_OUT0
                DEN0: enum(u1) {
                    /// DMA disabled
                    DEN0_0 = 0x0,
                    /// DMA enabled
                    DEN0_1 = 0x1,
                },
                /// Interrupt Enable for XBAR_OUT0
                IEN0: enum(u1) {
                    /// Interrupt disabled
                    IEN0_0 = 0x0,
                    /// Interrupt enabled
                    IEN0_1 = 0x1,
                },
                /// Active edge for edge detection on XBAR_OUT0
                EDGE0: enum(u2) {
                    /// STS0 never asserts
                    EDGE0_0 = 0x0,
                    /// STS0 asserts on rising edges of XBAR_OUT0
                    EDGE0_1 = 0x1,
                    /// STS0 asserts on falling edges of XBAR_OUT0
                    EDGE0_2 = 0x2,
                    /// STS0 asserts on rising and falling edges of XBAR_OUT0
                    EDGE0_3 = 0x3,
                },
                /// Edge detection status for XBAR_OUT0
                STS0: enum(u1) {
                    /// Active edge not yet detected on XBAR_OUT0
                    STS0_0 = 0x0,
                    /// Active edge detected on XBAR_OUT0
                    STS0_1 = 0x1,
                },
                reserved8: u3 = 0,
                /// DMA Enable for XBAR_OUT1
                DEN1: enum(u1) {
                    /// DMA disabled
                    DEN1_0 = 0x0,
                    /// DMA enabled
                    DEN1_1 = 0x1,
                },
                /// Interrupt Enable for XBAR_OUT1
                IEN1: enum(u1) {
                    /// Interrupt disabled
                    IEN1_0 = 0x0,
                    /// Interrupt enabled
                    IEN1_1 = 0x1,
                },
                /// Active edge for edge detection on XBAR_OUT1
                EDGE1: enum(u2) {
                    /// STS1 never asserts
                    EDGE1_0 = 0x0,
                    /// STS1 asserts on rising edges of XBAR_OUT1
                    EDGE1_1 = 0x1,
                    /// STS1 asserts on falling edges of XBAR_OUT1
                    EDGE1_2 = 0x2,
                    /// STS1 asserts on rising and falling edges of XBAR_OUT1
                    EDGE1_3 = 0x3,
                },
                /// Edge detection status for XBAR_OUT1
                STS1: enum(u1) {
                    /// Active edge not yet detected on XBAR_OUT1
                    STS1_0 = 0x0,
                    /// Active edge detected on XBAR_OUT1
                    STS1_1 = 0x1,
                },
                padding: u3 = 0,
            }),
            /// Crossbar A Control Register 1
            CTRL1: mmio.Mmio(packed struct(u16) {
                /// DMA Enable for XBAR_OUT2
                DEN2: enum(u1) {
                    /// DMA disabled
                    DEN2_0 = 0x0,
                    /// DMA enabled
                    DEN2_1 = 0x1,
                },
                /// Interrupt Enable for XBAR_OUT2
                IEN2: enum(u1) {
                    /// Interrupt disabled
                    IEN2_0 = 0x0,
                    /// Interrupt enabled
                    IEN2_1 = 0x1,
                },
                /// Active edge for edge detection on XBAR_OUT2
                EDGE2: enum(u2) {
                    /// STS2 never asserts
                    EDGE2_0 = 0x0,
                    /// STS2 asserts on rising edges of XBAR_OUT2
                    EDGE2_1 = 0x1,
                    /// STS2 asserts on falling edges of XBAR_OUT2
                    EDGE2_2 = 0x2,
                    /// STS2 asserts on rising and falling edges of XBAR_OUT2
                    EDGE2_3 = 0x3,
                },
                /// Edge detection status for XBAR_OUT2
                STS2: enum(u1) {
                    /// Active edge not yet detected on XBAR_OUT2
                    STS2_0 = 0x0,
                    /// Active edge detected on XBAR_OUT2
                    STS2_1 = 0x1,
                },
                reserved8: u3 = 0,
                /// DMA Enable for XBAR_OUT3
                DEN3: enum(u1) {
                    /// DMA disabled
                    DEN3_0 = 0x0,
                    /// DMA enabled
                    DEN3_1 = 0x1,
                },
                /// Interrupt Enable for XBAR_OUT3
                IEN3: enum(u1) {
                    /// Interrupt disabled
                    IEN3_0 = 0x0,
                    /// Interrupt enabled
                    IEN3_1 = 0x1,
                },
                /// Active edge for edge detection on XBAR_OUT3
                EDGE3: enum(u2) {
                    /// STS3 never asserts
                    EDGE3_0 = 0x0,
                    /// STS3 asserts on rising edges of XBAR_OUT3
                    EDGE3_1 = 0x1,
                    /// STS3 asserts on falling edges of XBAR_OUT3
                    EDGE3_2 = 0x2,
                    /// STS3 asserts on rising and falling edges of XBAR_OUT3
                    EDGE3_3 = 0x3,
                },
                /// Edge detection status for XBAR_OUT3
                STS3: enum(u1) {
                    /// Active edge not yet detected on XBAR_OUT3
                    STS3_0 = 0x0,
                    /// Active edge detected on XBAR_OUT3
                    STS3_1 = 0x1,
                },
                padding: u3 = 0,
            }),
        };

        /// Crossbar Switch
        pub const XBARB2 = extern struct {
            /// Crossbar B Select Register 0
            SEL0: mmio.Mmio(packed struct(u16) {
                /// Input (XBARB_INn) to be muxed to XBARB_OUT0 (refer to Functional Description section for input/output assignment)
                SEL0: u6,
                reserved8: u2 = 0,
                /// Input (XBARB_INn) to be muxed to XBARB_OUT1 (refer to Functional Description section for input/output assignment)
                SEL1: u6,
                padding: u2 = 0,
            }),
            /// Crossbar B Select Register 1
            SEL1: mmio.Mmio(packed struct(u16) {
                /// Input (XBARB_INn) to be muxed to XBARB_OUT2 (refer to Functional Description section for input/output assignment)
                SEL2: u6,
                reserved8: u2 = 0,
                /// Input (XBARB_INn) to be muxed to XBARB_OUT3 (refer to Functional Description section for input/output assignment)
                SEL3: u6,
                padding: u2 = 0,
            }),
            /// Crossbar B Select Register 2
            SEL2: mmio.Mmio(packed struct(u16) {
                /// Input (XBARB_INn) to be muxed to XBARB_OUT4 (refer to Functional Description section for input/output assignment)
                SEL4: u6,
                reserved8: u2 = 0,
                /// Input (XBARB_INn) to be muxed to XBARB_OUT5 (refer to Functional Description section for input/output assignment)
                SEL5: u6,
                padding: u2 = 0,
            }),
            /// Crossbar B Select Register 3
            SEL3: mmio.Mmio(packed struct(u16) {
                /// Input (XBARB_INn) to be muxed to XBARB_OUT6 (refer to Functional Description section for input/output assignment)
                SEL6: u6,
                reserved8: u2 = 0,
                /// Input (XBARB_INn) to be muxed to XBARB_OUT7 (refer to Functional Description section for input/output assignment)
                SEL7: u6,
                padding: u2 = 0,
            }),
            /// Crossbar B Select Register 4
            SEL4: mmio.Mmio(packed struct(u16) {
                /// Input (XBARB_INn) to be muxed to XBARB_OUT8 (refer to Functional Description section for input/output assignment)
                SEL8: u6,
                reserved8: u2 = 0,
                /// Input (XBARB_INn) to be muxed to XBARB_OUT9 (refer to Functional Description section for input/output assignment)
                SEL9: u6,
                padding: u2 = 0,
            }),
            /// Crossbar B Select Register 5
            SEL5: mmio.Mmio(packed struct(u16) {
                /// Input (XBARB_INn) to be muxed to XBARB_OUT10 (refer to Functional Description section for input/output assignment)
                SEL10: u6,
                reserved8: u2 = 0,
                /// Input (XBARB_INn) to be muxed to XBARB_OUT11 (refer to Functional Description section for input/output assignment)
                SEL11: u6,
                padding: u2 = 0,
            }),
            /// Crossbar B Select Register 6
            SEL6: mmio.Mmio(packed struct(u16) {
                /// Input (XBARB_INn) to be muxed to XBARB_OUT12 (refer to Functional Description section for input/output assignment)
                SEL12: u6,
                reserved8: u2 = 0,
                /// Input (XBARB_INn) to be muxed to XBARB_OUT13 (refer to Functional Description section for input/output assignment)
                SEL13: u6,
                padding: u2 = 0,
            }),
            /// Crossbar B Select Register 7
            SEL7: mmio.Mmio(packed struct(u16) {
                /// Input (XBARB_INn) to be muxed to XBARB_OUT14 (refer to Functional Description section for input/output assignment)
                SEL14: u6,
                reserved8: u2 = 0,
                /// Input (XBARB_INn) to be muxed to XBARB_OUT15 (refer to Functional Description section for input/output assignment)
                SEL15: u6,
                padding: u2 = 0,
            }),
        };

        /// XTALOSC24M
        pub const XTALOSC24M = extern struct {
            reserved336: [336]u8,
            /// Miscellaneous Register 0
            MISC0: mmio.Mmio(packed struct(u32) {
                /// Control bit to power-down the analog bandgap reference circuitry
                REFTOP_PWD: u1,
                reserved3: u2 = 0,
                /// Control bit to disable the self-bias circuit in the analog bandgap
                REFTOP_SELFBIASOFF: enum(u1) {
                    /// Uses coarse bias currents for startup
                    REFTOP_SELFBIASOFF_0 = 0x0,
                    /// Uses bandgap-based bias currents for best performance.
                    REFTOP_SELFBIASOFF_1 = 0x1,
                },
                /// Not related to oscillator.
                REFTOP_VBGADJ: enum(u3) {
                    /// Nominal VBG
                    REFTOP_VBGADJ_0 = 0x0,
                    /// VBG+0.78%
                    REFTOP_VBGADJ_1 = 0x1,
                    /// VBG+1.56%
                    REFTOP_VBGADJ_2 = 0x2,
                    /// VBG+2.34%
                    REFTOP_VBGADJ_3 = 0x3,
                    /// VBG-0.78%
                    REFTOP_VBGADJ_4 = 0x4,
                    /// VBG-1.56%
                    REFTOP_VBGADJ_5 = 0x5,
                    /// VBG-2.34%
                    REFTOP_VBGADJ_6 = 0x6,
                    /// VBG-3.12%
                    REFTOP_VBGADJ_7 = 0x7,
                },
                /// Status bit that signals the analog bandgap voltage is up and stable
                REFTOP_VBGUP: u1,
                reserved10: u2 = 0,
                /// Configure the analog behavior in stop mode.Not related to oscillator.
                STOP_MODE_CONFIG: enum(u2) {
                    /// All analog except rtc powered down on stop mode assertion. XtalOsc=on, RCOsc=off;
                    STOP_MODE_CONFIG_0 = 0x0,
                    /// Certain analog functions such as certain regulators left up. XtalOsc=on, RCOsc=off;
                    STOP_MODE_CONFIG_1 = 0x1,
                    /// XtalOsc=off, RCOsc=on, Old BG=on, New BG=off.
                    STOP_MODE_CONFIG_2 = 0x2,
                    /// XtalOsc=off, RCOsc=on, Old BG=off, New BG=on.
                    STOP_MODE_CONFIG_3 = 0x3,
                },
                /// This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
                DISCON_HIGH_SNVS: enum(u1) {
                    /// Turn on the switch
                    DISCON_HIGH_SNVS_0 = 0x0,
                    /// Turn off the switch
                    DISCON_HIGH_SNVS_1 = 0x1,
                },
                /// This field determines the bias current in the 24MHz oscillator
                OSC_I: enum(u2) {
                    /// Nominal
                    NOMINAL = 0x0,
                    /// Decrease current by 12.5%
                    MINUS_12_5_PERCENT = 0x1,
                    /// Decrease current by 25.0%
                    MINUS_25_PERCENT = 0x2,
                    /// Decrease current by 37.5%
                    MINUS_37_5_PERCENT = 0x3,
                },
                /// Status bit that signals that the output of the 24-MHz crystal oscillator is stable
                OSC_XTALOK: u1,
                /// This bit enables the detector that signals when the 24MHz crystal oscillator is stable.
                OSC_XTALOK_EN: u1,
                reserved25: u8 = 0,
                /// This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
                CLKGATE_CTRL: enum(u1) {
                    /// Allow the logic to automatically gate the clock when the XTAL is powered down.
                    ALLOW_AUTO_GATE = 0x0,
                    /// Prevent the logic from ever gating off the clock.
                    NO_AUTO_GATE = 0x1,
                },
                /// This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
                CLKGATE_DELAY: enum(u3) {
                    /// 0.5ms
                    CLKGATE_DELAY_0 = 0x0,
                    /// 1.0ms
                    CLKGATE_DELAY_1 = 0x1,
                    /// 2.0ms
                    CLKGATE_DELAY_2 = 0x2,
                    /// 3.0ms
                    CLKGATE_DELAY_3 = 0x3,
                    /// 4.0ms
                    CLKGATE_DELAY_4 = 0x4,
                    /// 5.0ms
                    CLKGATE_DELAY_5 = 0x5,
                    /// 6.0ms
                    CLKGATE_DELAY_6 = 0x6,
                    /// 7.0ms
                    CLKGATE_DELAY_7 = 0x7,
                },
                /// This field indicates which chip source is being used for the rtc clock.
                RTC_XTAL_SOURCE: enum(u1) {
                    /// Internal ring oscillator
                    RTC_XTAL_SOURCE_0 = 0x0,
                    /// RTC_XTAL
                    RTC_XTAL_SOURCE_1 = 0x1,
                },
                /// This field powers down the 24M crystal oscillator if set true.
                XTAL_24M_PWD: u1,
                /// Predivider for the source clock of the PLL's. Not related to oscillator.
                VID_PLL_PREDIV: enum(u1) {
                    /// Divide by 1
                    VID_PLL_PREDIV_0 = 0x0,
                    /// Divide by 2
                    VID_PLL_PREDIV_1 = 0x1,
                },
            }),
            /// Miscellaneous Register 0
            MISC0_SET: mmio.Mmio(packed struct(u32) {
                /// Control bit to power-down the analog bandgap reference circuitry
                REFTOP_PWD: u1,
                reserved3: u2 = 0,
                /// Control bit to disable the self-bias circuit in the analog bandgap
                REFTOP_SELFBIASOFF: enum(u1) {
                    /// Uses coarse bias currents for startup
                    REFTOP_SELFBIASOFF_0 = 0x0,
                    /// Uses bandgap-based bias currents for best performance.
                    REFTOP_SELFBIASOFF_1 = 0x1,
                },
                /// Not related to oscillator.
                REFTOP_VBGADJ: enum(u3) {
                    /// Nominal VBG
                    REFTOP_VBGADJ_0 = 0x0,
                    /// VBG+0.78%
                    REFTOP_VBGADJ_1 = 0x1,
                    /// VBG+1.56%
                    REFTOP_VBGADJ_2 = 0x2,
                    /// VBG+2.34%
                    REFTOP_VBGADJ_3 = 0x3,
                    /// VBG-0.78%
                    REFTOP_VBGADJ_4 = 0x4,
                    /// VBG-1.56%
                    REFTOP_VBGADJ_5 = 0x5,
                    /// VBG-2.34%
                    REFTOP_VBGADJ_6 = 0x6,
                    /// VBG-3.12%
                    REFTOP_VBGADJ_7 = 0x7,
                },
                /// Status bit that signals the analog bandgap voltage is up and stable
                REFTOP_VBGUP: u1,
                reserved10: u2 = 0,
                /// Configure the analog behavior in stop mode.Not related to oscillator.
                STOP_MODE_CONFIG: enum(u2) {
                    /// All analog except rtc powered down on stop mode assertion. XtalOsc=on, RCOsc=off;
                    STOP_MODE_CONFIG_0 = 0x0,
                    /// Certain analog functions such as certain regulators left up. XtalOsc=on, RCOsc=off;
                    STOP_MODE_CONFIG_1 = 0x1,
                    /// XtalOsc=off, RCOsc=on, Old BG=on, New BG=off.
                    STOP_MODE_CONFIG_2 = 0x2,
                    /// XtalOsc=off, RCOsc=on, Old BG=off, New BG=on.
                    STOP_MODE_CONFIG_3 = 0x3,
                },
                /// This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
                DISCON_HIGH_SNVS: enum(u1) {
                    /// Turn on the switch
                    DISCON_HIGH_SNVS_0 = 0x0,
                    /// Turn off the switch
                    DISCON_HIGH_SNVS_1 = 0x1,
                },
                /// This field determines the bias current in the 24MHz oscillator
                OSC_I: enum(u2) {
                    /// Nominal
                    NOMINAL = 0x0,
                    /// Decrease current by 12.5%
                    MINUS_12_5_PERCENT = 0x1,
                    /// Decrease current by 25.0%
                    MINUS_25_PERCENT = 0x2,
                    /// Decrease current by 37.5%
                    MINUS_37_5_PERCENT = 0x3,
                },
                /// Status bit that signals that the output of the 24-MHz crystal oscillator is stable
                OSC_XTALOK: u1,
                /// This bit enables the detector that signals when the 24MHz crystal oscillator is stable.
                OSC_XTALOK_EN: u1,
                reserved25: u8 = 0,
                /// This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
                CLKGATE_CTRL: enum(u1) {
                    /// Allow the logic to automatically gate the clock when the XTAL is powered down.
                    ALLOW_AUTO_GATE = 0x0,
                    /// Prevent the logic from ever gating off the clock.
                    NO_AUTO_GATE = 0x1,
                },
                /// This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
                CLKGATE_DELAY: enum(u3) {
                    /// 0.5ms
                    CLKGATE_DELAY_0 = 0x0,
                    /// 1.0ms
                    CLKGATE_DELAY_1 = 0x1,
                    /// 2.0ms
                    CLKGATE_DELAY_2 = 0x2,
                    /// 3.0ms
                    CLKGATE_DELAY_3 = 0x3,
                    /// 4.0ms
                    CLKGATE_DELAY_4 = 0x4,
                    /// 5.0ms
                    CLKGATE_DELAY_5 = 0x5,
                    /// 6.0ms
                    CLKGATE_DELAY_6 = 0x6,
                    /// 7.0ms
                    CLKGATE_DELAY_7 = 0x7,
                },
                /// This field indicates which chip source is being used for the rtc clock.
                RTC_XTAL_SOURCE: enum(u1) {
                    /// Internal ring oscillator
                    RTC_XTAL_SOURCE_0 = 0x0,
                    /// RTC_XTAL
                    RTC_XTAL_SOURCE_1 = 0x1,
                },
                /// This field powers down the 24M crystal oscillator if set true.
                XTAL_24M_PWD: u1,
                /// Predivider for the source clock of the PLL's. Not related to oscillator.
                VID_PLL_PREDIV: enum(u1) {
                    /// Divide by 1
                    VID_PLL_PREDIV_0 = 0x0,
                    /// Divide by 2
                    VID_PLL_PREDIV_1 = 0x1,
                },
            }),
            /// Miscellaneous Register 0
            MISC0_CLR: mmio.Mmio(packed struct(u32) {
                /// Control bit to power-down the analog bandgap reference circuitry
                REFTOP_PWD: u1,
                reserved3: u2 = 0,
                /// Control bit to disable the self-bias circuit in the analog bandgap
                REFTOP_SELFBIASOFF: enum(u1) {
                    /// Uses coarse bias currents for startup
                    REFTOP_SELFBIASOFF_0 = 0x0,
                    /// Uses bandgap-based bias currents for best performance.
                    REFTOP_SELFBIASOFF_1 = 0x1,
                },
                /// Not related to oscillator.
                REFTOP_VBGADJ: enum(u3) {
                    /// Nominal VBG
                    REFTOP_VBGADJ_0 = 0x0,
                    /// VBG+0.78%
                    REFTOP_VBGADJ_1 = 0x1,
                    /// VBG+1.56%
                    REFTOP_VBGADJ_2 = 0x2,
                    /// VBG+2.34%
                    REFTOP_VBGADJ_3 = 0x3,
                    /// VBG-0.78%
                    REFTOP_VBGADJ_4 = 0x4,
                    /// VBG-1.56%
                    REFTOP_VBGADJ_5 = 0x5,
                    /// VBG-2.34%
                    REFTOP_VBGADJ_6 = 0x6,
                    /// VBG-3.12%
                    REFTOP_VBGADJ_7 = 0x7,
                },
                /// Status bit that signals the analog bandgap voltage is up and stable
                REFTOP_VBGUP: u1,
                reserved10: u2 = 0,
                /// Configure the analog behavior in stop mode.Not related to oscillator.
                STOP_MODE_CONFIG: enum(u2) {
                    /// All analog except rtc powered down on stop mode assertion. XtalOsc=on, RCOsc=off;
                    STOP_MODE_CONFIG_0 = 0x0,
                    /// Certain analog functions such as certain regulators left up. XtalOsc=on, RCOsc=off;
                    STOP_MODE_CONFIG_1 = 0x1,
                    /// XtalOsc=off, RCOsc=on, Old BG=on, New BG=off.
                    STOP_MODE_CONFIG_2 = 0x2,
                    /// XtalOsc=off, RCOsc=on, Old BG=off, New BG=on.
                    STOP_MODE_CONFIG_3 = 0x3,
                },
                /// This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
                DISCON_HIGH_SNVS: enum(u1) {
                    /// Turn on the switch
                    DISCON_HIGH_SNVS_0 = 0x0,
                    /// Turn off the switch
                    DISCON_HIGH_SNVS_1 = 0x1,
                },
                /// This field determines the bias current in the 24MHz oscillator
                OSC_I: enum(u2) {
                    /// Nominal
                    NOMINAL = 0x0,
                    /// Decrease current by 12.5%
                    MINUS_12_5_PERCENT = 0x1,
                    /// Decrease current by 25.0%
                    MINUS_25_PERCENT = 0x2,
                    /// Decrease current by 37.5%
                    MINUS_37_5_PERCENT = 0x3,
                },
                /// Status bit that signals that the output of the 24-MHz crystal oscillator is stable
                OSC_XTALOK: u1,
                /// This bit enables the detector that signals when the 24MHz crystal oscillator is stable.
                OSC_XTALOK_EN: u1,
                reserved25: u8 = 0,
                /// This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
                CLKGATE_CTRL: enum(u1) {
                    /// Allow the logic to automatically gate the clock when the XTAL is powered down.
                    ALLOW_AUTO_GATE = 0x0,
                    /// Prevent the logic from ever gating off the clock.
                    NO_AUTO_GATE = 0x1,
                },
                /// This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
                CLKGATE_DELAY: enum(u3) {
                    /// 0.5ms
                    CLKGATE_DELAY_0 = 0x0,
                    /// 1.0ms
                    CLKGATE_DELAY_1 = 0x1,
                    /// 2.0ms
                    CLKGATE_DELAY_2 = 0x2,
                    /// 3.0ms
                    CLKGATE_DELAY_3 = 0x3,
                    /// 4.0ms
                    CLKGATE_DELAY_4 = 0x4,
                    /// 5.0ms
                    CLKGATE_DELAY_5 = 0x5,
                    /// 6.0ms
                    CLKGATE_DELAY_6 = 0x6,
                    /// 7.0ms
                    CLKGATE_DELAY_7 = 0x7,
                },
                /// This field indicates which chip source is being used for the rtc clock.
                RTC_XTAL_SOURCE: enum(u1) {
                    /// Internal ring oscillator
                    RTC_XTAL_SOURCE_0 = 0x0,
                    /// RTC_XTAL
                    RTC_XTAL_SOURCE_1 = 0x1,
                },
                /// This field powers down the 24M crystal oscillator if set true.
                XTAL_24M_PWD: u1,
                /// Predivider for the source clock of the PLL's. Not related to oscillator.
                VID_PLL_PREDIV: enum(u1) {
                    /// Divide by 1
                    VID_PLL_PREDIV_0 = 0x0,
                    /// Divide by 2
                    VID_PLL_PREDIV_1 = 0x1,
                },
            }),
            /// Miscellaneous Register 0
            MISC0_TOG: mmio.Mmio(packed struct(u32) {
                /// Control bit to power-down the analog bandgap reference circuitry
                REFTOP_PWD: u1,
                reserved3: u2 = 0,
                /// Control bit to disable the self-bias circuit in the analog bandgap
                REFTOP_SELFBIASOFF: enum(u1) {
                    /// Uses coarse bias currents for startup
                    REFTOP_SELFBIASOFF_0 = 0x0,
                    /// Uses bandgap-based bias currents for best performance.
                    REFTOP_SELFBIASOFF_1 = 0x1,
                },
                /// Not related to oscillator.
                REFTOP_VBGADJ: enum(u3) {
                    /// Nominal VBG
                    REFTOP_VBGADJ_0 = 0x0,
                    /// VBG+0.78%
                    REFTOP_VBGADJ_1 = 0x1,
                    /// VBG+1.56%
                    REFTOP_VBGADJ_2 = 0x2,
                    /// VBG+2.34%
                    REFTOP_VBGADJ_3 = 0x3,
                    /// VBG-0.78%
                    REFTOP_VBGADJ_4 = 0x4,
                    /// VBG-1.56%
                    REFTOP_VBGADJ_5 = 0x5,
                    /// VBG-2.34%
                    REFTOP_VBGADJ_6 = 0x6,
                    /// VBG-3.12%
                    REFTOP_VBGADJ_7 = 0x7,
                },
                /// Status bit that signals the analog bandgap voltage is up and stable
                REFTOP_VBGUP: u1,
                reserved10: u2 = 0,
                /// Configure the analog behavior in stop mode.Not related to oscillator.
                STOP_MODE_CONFIG: enum(u2) {
                    /// All analog except rtc powered down on stop mode assertion. XtalOsc=on, RCOsc=off;
                    STOP_MODE_CONFIG_0 = 0x0,
                    /// Certain analog functions such as certain regulators left up. XtalOsc=on, RCOsc=off;
                    STOP_MODE_CONFIG_1 = 0x1,
                    /// XtalOsc=off, RCOsc=on, Old BG=on, New BG=off.
                    STOP_MODE_CONFIG_2 = 0x2,
                    /// XtalOsc=off, RCOsc=on, Old BG=off, New BG=on.
                    STOP_MODE_CONFIG_3 = 0x3,
                },
                /// This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.
                DISCON_HIGH_SNVS: enum(u1) {
                    /// Turn on the switch
                    DISCON_HIGH_SNVS_0 = 0x0,
                    /// Turn off the switch
                    DISCON_HIGH_SNVS_1 = 0x1,
                },
                /// This field determines the bias current in the 24MHz oscillator
                OSC_I: enum(u2) {
                    /// Nominal
                    NOMINAL = 0x0,
                    /// Decrease current by 12.5%
                    MINUS_12_5_PERCENT = 0x1,
                    /// Decrease current by 25.0%
                    MINUS_25_PERCENT = 0x2,
                    /// Decrease current by 37.5%
                    MINUS_37_5_PERCENT = 0x3,
                },
                /// Status bit that signals that the output of the 24-MHz crystal oscillator is stable
                OSC_XTALOK: u1,
                /// This bit enables the detector that signals when the 24MHz crystal oscillator is stable.
                OSC_XTALOK_EN: u1,
                reserved25: u8 = 0,
                /// This bit allows disabling the clock gate (always ungated) for the xtal 24MHz clock that clocks the digital logic in the analog block
                CLKGATE_CTRL: enum(u1) {
                    /// Allow the logic to automatically gate the clock when the XTAL is powered down.
                    ALLOW_AUTO_GATE = 0x0,
                    /// Prevent the logic from ever gating off the clock.
                    NO_AUTO_GATE = 0x1,
                },
                /// This field specifies the delay between powering up the XTAL 24MHz clock and releasing the clock to the digital logic inside the analog block
                CLKGATE_DELAY: enum(u3) {
                    /// 0.5ms
                    CLKGATE_DELAY_0 = 0x0,
                    /// 1.0ms
                    CLKGATE_DELAY_1 = 0x1,
                    /// 2.0ms
                    CLKGATE_DELAY_2 = 0x2,
                    /// 3.0ms
                    CLKGATE_DELAY_3 = 0x3,
                    /// 4.0ms
                    CLKGATE_DELAY_4 = 0x4,
                    /// 5.0ms
                    CLKGATE_DELAY_5 = 0x5,
                    /// 6.0ms
                    CLKGATE_DELAY_6 = 0x6,
                    /// 7.0ms
                    CLKGATE_DELAY_7 = 0x7,
                },
                /// This field indicates which chip source is being used for the rtc clock.
                RTC_XTAL_SOURCE: enum(u1) {
                    /// Internal ring oscillator
                    RTC_XTAL_SOURCE_0 = 0x0,
                    /// RTC_XTAL
                    RTC_XTAL_SOURCE_1 = 0x1,
                },
                /// This field powers down the 24M crystal oscillator if set true.
                XTAL_24M_PWD: u1,
                /// Predivider for the source clock of the PLL's. Not related to oscillator.
                VID_PLL_PREDIV: enum(u1) {
                    /// Divide by 1
                    VID_PLL_PREDIV_0 = 0x0,
                    /// Divide by 2
                    VID_PLL_PREDIV_1 = 0x1,
                },
            }),
            reserved624: [272]u8,
            /// XTAL OSC (LP) Control Register
            LOWPWR_CTRL: mmio.Mmio(packed struct(u32) {
                /// RC Osc. enable control.
                RC_OSC_EN: enum(u1) {
                    /// Use XTAL OSC to source the 24MHz clock
                    RC_OSC_EN_0 = 0x0,
                    /// Use RC OSC
                    RC_OSC_EN_1 = 0x1,
                },
                reserved4: u3 = 0,
                /// Select the source for the 24MHz clock.
                OSC_SEL: enum(u1) {
                    /// XTAL OSC
                    OSC_SEL_0 = 0x0,
                    /// RC OSC
                    OSC_SEL_1 = 0x1,
                },
                /// Bandgap select. Not related to oscillator.
                LPBG_SEL: enum(u1) {
                    /// Normal power bandgap
                    LPBG_SEL_0 = 0x0,
                    /// Low power bandgap
                    LPBG_SEL_1 = 0x1,
                },
                /// Low power bandgap test bit. Not related to oscillator.
                LPBG_TEST: u1,
                /// Low power reftop ibias disable. Not related to oscillator.
                REFTOP_IBIAS_OFF: u1,
                /// L1 power gate control. Used as software override. Not related to oscillator.
                L1_PWRGATE: u1,
                /// L2 power gate control. Used as software override. Not related to oscillator.
                L2_PWRGATE: u1,
                /// CPU power gate control. Used as software override. Test purpose only Not related to oscillator.
                CPU_PWRGATE: u1,
                /// Display logic power gate control. Used as software override. Not related to oscillator.
                DISPLAY_PWRGATE: u1,
                reserved13: u1 = 0,
                /// For debug purposes only
                RCOSC_CG_OVERRIDE: u1,
                /// Specifies the time delay between when the 24MHz xtal is powered up until it is stable and ready to use
                XTALOSC_PWRUP_DELAY: enum(u2) {
                    /// 0.25ms
                    XTALOSC_PWRUP_DELAY_0 = 0x0,
                    /// 0.5ms
                    XTALOSC_PWRUP_DELAY_1 = 0x1,
                    /// 1ms
                    XTALOSC_PWRUP_DELAY_2 = 0x2,
                    /// 2ms
                    XTALOSC_PWRUP_DELAY_3 = 0x3,
                },
                /// Status of the 24MHz xtal oscillator.
                XTALOSC_PWRUP_STAT: enum(u1) {
                    /// Not stable
                    XTALOSC_PWRUP_STAT_0 = 0x0,
                    /// Stable and ready to use
                    XTALOSC_PWRUP_STAT_1 = 0x1,
                },
                /// Display power gate control. Used as software mask. Set to zero to force ungated.
                MIX_PWRGATE: u1,
                /// GPU power gate control. Used as software mask. Set to zero to force ungated.
                GPU_PWRGATE: u1,
                padding: u13 = 0,
            }),
            /// XTAL OSC (LP) Control Register
            LOWPWR_CTRL_SET: mmio.Mmio(packed struct(u32) {
                /// RC Osc. enable control.
                RC_OSC_EN: enum(u1) {
                    /// Use XTAL OSC to source the 24MHz clock
                    RC_OSC_EN_0 = 0x0,
                    /// Use RC OSC
                    RC_OSC_EN_1 = 0x1,
                },
                reserved4: u3 = 0,
                /// Select the source for the 24MHz clock.
                OSC_SEL: enum(u1) {
                    /// XTAL OSC
                    OSC_SEL_0 = 0x0,
                    /// RC OSC
                    OSC_SEL_1 = 0x1,
                },
                /// Bandgap select. Not related to oscillator.
                LPBG_SEL: enum(u1) {
                    /// Normal power bandgap
                    LPBG_SEL_0 = 0x0,
                    /// Low power bandgap
                    LPBG_SEL_1 = 0x1,
                },
                /// Low power bandgap test bit. Not related to oscillator.
                LPBG_TEST: u1,
                /// Low power reftop ibias disable. Not related to oscillator.
                REFTOP_IBIAS_OFF: u1,
                /// L1 power gate control. Used as software override. Not related to oscillator.
                L1_PWRGATE: u1,
                /// L2 power gate control. Used as software override. Not related to oscillator.
                L2_PWRGATE: u1,
                /// CPU power gate control. Used as software override. Test purpose only Not related to oscillator.
                CPU_PWRGATE: u1,
                /// Display logic power gate control. Used as software override. Not related to oscillator.
                DISPLAY_PWRGATE: u1,
                reserved13: u1 = 0,
                /// For debug purposes only
                RCOSC_CG_OVERRIDE: u1,
                /// Specifies the time delay between when the 24MHz xtal is powered up until it is stable and ready to use
                XTALOSC_PWRUP_DELAY: enum(u2) {
                    /// 0.25ms
                    XTALOSC_PWRUP_DELAY_0 = 0x0,
                    /// 0.5ms
                    XTALOSC_PWRUP_DELAY_1 = 0x1,
                    /// 1ms
                    XTALOSC_PWRUP_DELAY_2 = 0x2,
                    /// 2ms
                    XTALOSC_PWRUP_DELAY_3 = 0x3,
                },
                /// Status of the 24MHz xtal oscillator.
                XTALOSC_PWRUP_STAT: enum(u1) {
                    /// Not stable
                    XTALOSC_PWRUP_STAT_0 = 0x0,
                    /// Stable and ready to use
                    XTALOSC_PWRUP_STAT_1 = 0x1,
                },
                /// Display power gate control. Used as software mask. Set to zero to force ungated.
                MIX_PWRGATE: u1,
                /// GPU power gate control. Used as software mask. Set to zero to force ungated.
                GPU_PWRGATE: u1,
                padding: u13 = 0,
            }),
            /// XTAL OSC (LP) Control Register
            LOWPWR_CTRL_CLR: mmio.Mmio(packed struct(u32) {
                /// RC Osc. enable control.
                RC_OSC_EN: enum(u1) {
                    /// Use XTAL OSC to source the 24MHz clock
                    RC_OSC_EN_0 = 0x0,
                    /// Use RC OSC
                    RC_OSC_EN_1 = 0x1,
                },
                reserved4: u3 = 0,
                /// Select the source for the 24MHz clock.
                OSC_SEL: enum(u1) {
                    /// XTAL OSC
                    OSC_SEL_0 = 0x0,
                    /// RC OSC
                    OSC_SEL_1 = 0x1,
                },
                /// Bandgap select. Not related to oscillator.
                LPBG_SEL: enum(u1) {
                    /// Normal power bandgap
                    LPBG_SEL_0 = 0x0,
                    /// Low power bandgap
                    LPBG_SEL_1 = 0x1,
                },
                /// Low power bandgap test bit. Not related to oscillator.
                LPBG_TEST: u1,
                /// Low power reftop ibias disable. Not related to oscillator.
                REFTOP_IBIAS_OFF: u1,
                /// L1 power gate control. Used as software override. Not related to oscillator.
                L1_PWRGATE: u1,
                /// L2 power gate control. Used as software override. Not related to oscillator.
                L2_PWRGATE: u1,
                /// CPU power gate control. Used as software override. Test purpose only Not related to oscillator.
                CPU_PWRGATE: u1,
                /// Display logic power gate control. Used as software override. Not related to oscillator.
                DISPLAY_PWRGATE: u1,
                reserved13: u1 = 0,
                /// For debug purposes only
                RCOSC_CG_OVERRIDE: u1,
                /// Specifies the time delay between when the 24MHz xtal is powered up until it is stable and ready to use
                XTALOSC_PWRUP_DELAY: enum(u2) {
                    /// 0.25ms
                    XTALOSC_PWRUP_DELAY_0 = 0x0,
                    /// 0.5ms
                    XTALOSC_PWRUP_DELAY_1 = 0x1,
                    /// 1ms
                    XTALOSC_PWRUP_DELAY_2 = 0x2,
                    /// 2ms
                    XTALOSC_PWRUP_DELAY_3 = 0x3,
                },
                /// Status of the 24MHz xtal oscillator.
                XTALOSC_PWRUP_STAT: enum(u1) {
                    /// Not stable
                    XTALOSC_PWRUP_STAT_0 = 0x0,
                    /// Stable and ready to use
                    XTALOSC_PWRUP_STAT_1 = 0x1,
                },
                /// Display power gate control. Used as software mask. Set to zero to force ungated.
                MIX_PWRGATE: u1,
                /// GPU power gate control. Used as software mask. Set to zero to force ungated.
                GPU_PWRGATE: u1,
                padding: u13 = 0,
            }),
            /// XTAL OSC (LP) Control Register
            LOWPWR_CTRL_TOG: mmio.Mmio(packed struct(u32) {
                /// RC Osc. enable control.
                RC_OSC_EN: enum(u1) {
                    /// Use XTAL OSC to source the 24MHz clock
                    RC_OSC_EN_0 = 0x0,
                    /// Use RC OSC
                    RC_OSC_EN_1 = 0x1,
                },
                reserved4: u3 = 0,
                /// Select the source for the 24MHz clock.
                OSC_SEL: enum(u1) {
                    /// XTAL OSC
                    OSC_SEL_0 = 0x0,
                    /// RC OSC
                    OSC_SEL_1 = 0x1,
                },
                /// Bandgap select. Not related to oscillator.
                LPBG_SEL: enum(u1) {
                    /// Normal power bandgap
                    LPBG_SEL_0 = 0x0,
                    /// Low power bandgap
                    LPBG_SEL_1 = 0x1,
                },
                /// Low power bandgap test bit. Not related to oscillator.
                LPBG_TEST: u1,
                /// Low power reftop ibias disable. Not related to oscillator.
                REFTOP_IBIAS_OFF: u1,
                /// L1 power gate control. Used as software override. Not related to oscillator.
                L1_PWRGATE: u1,
                /// L2 power gate control. Used as software override. Not related to oscillator.
                L2_PWRGATE: u1,
                /// CPU power gate control. Used as software override. Test purpose only Not related to oscillator.
                CPU_PWRGATE: u1,
                /// Display logic power gate control. Used as software override. Not related to oscillator.
                DISPLAY_PWRGATE: u1,
                reserved13: u1 = 0,
                /// For debug purposes only
                RCOSC_CG_OVERRIDE: u1,
                /// Specifies the time delay between when the 24MHz xtal is powered up until it is stable and ready to use
                XTALOSC_PWRUP_DELAY: enum(u2) {
                    /// 0.25ms
                    XTALOSC_PWRUP_DELAY_0 = 0x0,
                    /// 0.5ms
                    XTALOSC_PWRUP_DELAY_1 = 0x1,
                    /// 1ms
                    XTALOSC_PWRUP_DELAY_2 = 0x2,
                    /// 2ms
                    XTALOSC_PWRUP_DELAY_3 = 0x3,
                },
                /// Status of the 24MHz xtal oscillator.
                XTALOSC_PWRUP_STAT: enum(u1) {
                    /// Not stable
                    XTALOSC_PWRUP_STAT_0 = 0x0,
                    /// Stable and ready to use
                    XTALOSC_PWRUP_STAT_1 = 0x1,
                },
                /// Display power gate control. Used as software mask. Set to zero to force ungated.
                MIX_PWRGATE: u1,
                /// GPU power gate control. Used as software mask. Set to zero to force ungated.
                GPU_PWRGATE: u1,
                padding: u13 = 0,
            }),
            reserved672: [32]u8,
            /// XTAL OSC Configuration 0 Register
            OSC_CONFIG0: mmio.Mmio(packed struct(u32) {
                /// Start/stop bit for the RC tuning calculation logic. If stopped the tuning logic is reset.
                START: u1,
                /// Enables the tuning logic to calculate new RC tuning values
                ENABLE: u1,
                /// Bypasses any calculated RC tuning value and uses the programmed register value.
                BYPASS: u1,
                /// Invert the stepping of the calculated RC tuning value.
                INVERT: u1,
                /// RC osc. tuning values.
                RC_OSC_PROG: u8,
                /// Positive hysteresis value
                HYST_PLUS: u4,
                /// Negative hysteresis value
                HYST_MINUS: u4,
                reserved24: u4 = 0,
                /// The current tuning value in use.
                RC_OSC_PROG_CUR: u8,
            }),
            /// XTAL OSC Configuration 0 Register
            OSC_CONFIG0_SET: mmio.Mmio(packed struct(u32) {
                /// Start/stop bit for the RC tuning calculation logic. If stopped the tuning logic is reset.
                START: u1,
                /// Enables the tuning logic to calculate new RC tuning values
                ENABLE: u1,
                /// Bypasses any calculated RC tuning value and uses the programmed register value.
                BYPASS: u1,
                /// Invert the stepping of the calculated RC tuning value.
                INVERT: u1,
                /// RC osc. tuning values.
                RC_OSC_PROG: u8,
                /// Positive hysteresis value
                HYST_PLUS: u4,
                /// Negative hysteresis value
                HYST_MINUS: u4,
                reserved24: u4 = 0,
                /// The current tuning value in use.
                RC_OSC_PROG_CUR: u8,
            }),
            /// XTAL OSC Configuration 0 Register
            OSC_CONFIG0_CLR: mmio.Mmio(packed struct(u32) {
                /// Start/stop bit for the RC tuning calculation logic. If stopped the tuning logic is reset.
                START: u1,
                /// Enables the tuning logic to calculate new RC tuning values
                ENABLE: u1,
                /// Bypasses any calculated RC tuning value and uses the programmed register value.
                BYPASS: u1,
                /// Invert the stepping of the calculated RC tuning value.
                INVERT: u1,
                /// RC osc. tuning values.
                RC_OSC_PROG: u8,
                /// Positive hysteresis value
                HYST_PLUS: u4,
                /// Negative hysteresis value
                HYST_MINUS: u4,
                reserved24: u4 = 0,
                /// The current tuning value in use.
                RC_OSC_PROG_CUR: u8,
            }),
            /// XTAL OSC Configuration 0 Register
            OSC_CONFIG0_TOG: mmio.Mmio(packed struct(u32) {
                /// Start/stop bit for the RC tuning calculation logic. If stopped the tuning logic is reset.
                START: u1,
                /// Enables the tuning logic to calculate new RC tuning values
                ENABLE: u1,
                /// Bypasses any calculated RC tuning value and uses the programmed register value.
                BYPASS: u1,
                /// Invert the stepping of the calculated RC tuning value.
                INVERT: u1,
                /// RC osc. tuning values.
                RC_OSC_PROG: u8,
                /// Positive hysteresis value
                HYST_PLUS: u4,
                /// Negative hysteresis value
                HYST_MINUS: u4,
                reserved24: u4 = 0,
                /// The current tuning value in use.
                RC_OSC_PROG_CUR: u8,
            }),
            /// XTAL OSC Configuration 1 Register
            OSC_CONFIG1: mmio.Mmio(packed struct(u32) {
                /// The target count used to tune the RC OSC frequency
                COUNT_RC_TRG: u12,
                reserved20: u8 = 0,
                /// The current tuning value in use.
                COUNT_RC_CUR: u12,
            }),
            /// XTAL OSC Configuration 1 Register
            OSC_CONFIG1_SET: mmio.Mmio(packed struct(u32) {
                /// The target count used to tune the RC OSC frequency
                COUNT_RC_TRG: u12,
                reserved20: u8 = 0,
                /// The current tuning value in use.
                COUNT_RC_CUR: u12,
            }),
            /// XTAL OSC Configuration 1 Register
            OSC_CONFIG1_CLR: mmio.Mmio(packed struct(u32) {
                /// The target count used to tune the RC OSC frequency
                COUNT_RC_TRG: u12,
                reserved20: u8 = 0,
                /// The current tuning value in use.
                COUNT_RC_CUR: u12,
            }),
            /// XTAL OSC Configuration 1 Register
            OSC_CONFIG1_TOG: mmio.Mmio(packed struct(u32) {
                /// The target count used to tune the RC OSC frequency
                COUNT_RC_TRG: u12,
                reserved20: u8 = 0,
                /// The current tuning value in use.
                COUNT_RC_CUR: u12,
            }),
            /// XTAL OSC Configuration 2 Register
            OSC_CONFIG2: mmio.Mmio(packed struct(u32) {
                /// The target count used to tune the 1MHz clock frequency
                COUNT_1M_TRG: u12,
                reserved16: u4 = 0,
                /// Enable the 1MHz clock output. 0 - disabled; 1 - enabled.
                ENABLE_1M: u1,
                /// Mux the corrected or uncorrected 1MHz clock to the output
                MUX_1M: u1,
                reserved31: u13 = 0,
                /// Flag indicates that the count_1m count wasn't reached within 1 32kHz period
                CLK_1M_ERR_FL: u1,
            }),
            /// XTAL OSC Configuration 2 Register
            OSC_CONFIG2_SET: mmio.Mmio(packed struct(u32) {
                /// The target count used to tune the 1MHz clock frequency
                COUNT_1M_TRG: u12,
                reserved16: u4 = 0,
                /// Enable the 1MHz clock output. 0 - disabled; 1 - enabled.
                ENABLE_1M: u1,
                /// Mux the corrected or uncorrected 1MHz clock to the output
                MUX_1M: u1,
                reserved31: u13 = 0,
                /// Flag indicates that the count_1m count wasn't reached within 1 32kHz period
                CLK_1M_ERR_FL: u1,
            }),
            /// XTAL OSC Configuration 2 Register
            OSC_CONFIG2_CLR: mmio.Mmio(packed struct(u32) {
                /// The target count used to tune the 1MHz clock frequency
                COUNT_1M_TRG: u12,
                reserved16: u4 = 0,
                /// Enable the 1MHz clock output. 0 - disabled; 1 - enabled.
                ENABLE_1M: u1,
                /// Mux the corrected or uncorrected 1MHz clock to the output
                MUX_1M: u1,
                reserved31: u13 = 0,
                /// Flag indicates that the count_1m count wasn't reached within 1 32kHz period
                CLK_1M_ERR_FL: u1,
            }),
            /// XTAL OSC Configuration 2 Register
            OSC_CONFIG2_TOG: mmio.Mmio(packed struct(u32) {
                /// The target count used to tune the 1MHz clock frequency
                COUNT_1M_TRG: u12,
                reserved16: u4 = 0,
                /// Enable the 1MHz clock output. 0 - disabled; 1 - enabled.
                ENABLE_1M: u1,
                /// Mux the corrected or uncorrected 1MHz clock to the output
                MUX_1M: u1,
                reserved31: u13 = 0,
                /// Flag indicates that the count_1m count wasn't reached within 1 32kHz period
                CLK_1M_ERR_FL: u1,
            }),
        };
    };
};
